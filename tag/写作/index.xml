<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>写作 | 30年磨一剑</title>
    <link>https://jueqingsizhe66.github.io/tag/%E5%86%99%E4%BD%9C/</link>
      <atom:link href="https://jueqingsizhe66.github.io/tag/%E5%86%99%E4%BD%9C/index.xml" rel="self" type="application/rss+xml" />
    <description>写作</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><copyright>©2022</copyright><lastBuildDate>Wed, 28 Sep 2016 23:21:06 +0800</lastBuildDate>
    <image>
      <url>https://jueqingsizhe66.github.io/images/icon_hua2ec155b4296a9c9791d015323e16eb5_11927_512x512_fill_lanczos_center_3.png</url>
      <title>写作</title>
      <link>https://jueqingsizhe66.github.io/tag/%E5%86%99%E4%BD%9C/</link>
    </image>
    
    <item>
      <title>Jump Out of Ontology</title>
      <link>https://jueqingsizhe66.github.io/blog/2016/09/28/jump-out-of-ontology/</link>
      <pubDate>Wed, 28 Sep 2016 23:21:06 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/blog/2016/09/28/jump-out-of-ontology/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Tool&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;工具&lt;/a&gt;(进一步可以参考&lt;a href=&#34;https://zhidao.baidu.com/share/4ee9bd642cdd8cc40d654d3e6096b35d.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;The design of everyday things&lt;/a&gt;)之内，讲究的是如何设计这个东西(制作者角度)，可能更多讲的是设计的东西，而不是完成的功能，更多用于写技术路线
&lt;img src=&#34;https://jueqingsizhe66.github.io/images/ontology/inner.png&#34; alt=&#34;inner1&#34;&gt;&lt;/p&gt;
&lt;p&gt;工具之外，讲究的是从工具的外头看这个东西（眼睛放在工具外面,使用者角度），从工具外看黑夹子的工具，看他在不同的工况下能够实现什么功能？ 所以更多用于写软件说明书。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://jueqingsizhe66.github.io/images/ontology/outer.png&#34; alt=&#34;outer&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Language&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;语言&lt;/a&gt;之内和语言之外（站在一个本不存在逻辑体之外）&lt;/p&gt;
&lt;p&gt;语言之内 说的是语言如何创造出来，如何写一个解释器，怎么设计这门语言，添加那些语言特性&lt;a href=&#34;http://jueqingsizhe66.github.io/blog/2016/02/27/the-fourth-interpreter-about-the-traceproc/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;(参考EOPL语言特性)&lt;/a&gt;，语言的语法怎么样等等&lt;/p&gt;
&lt;p&gt;语言之外是指运用这门语言 我能够解决某个工况问题，某个实际问题，某个数值问题，&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Problem_solving&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;问题&lt;/a&gt;之内是指解决这个问题，问题之外是指解决了这个问题之后还可以解决其他什么问题。&lt;/p&gt;
&lt;p&gt;内是指内部链接，外是指外部链接&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Domain&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;领域&lt;/a&gt;之内和领域之外， 领域之内是指从专业的角度进行介绍，领域之外是平民（不懂专业知识）的角度进行解释。&lt;/p&gt;
&lt;p&gt;工具、语言、问题、领域等都可以归结为本体&lt;a href=&#34;https://en.wikipedia.org/wiki/Ontology&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ontology&lt;/a&gt;论的&lt;a href=&#34;https://en.wikipedia.org/wiki/Knowledge&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;知识&lt;/a&gt;(进一步参考&lt;a href=&#34;https://en.wikipedia.org/wiki/Knowledge_Graph&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;knowledge_graph&lt;/a&gt;以及 &lt;a href=&#34;https://en.wikipedia.org/wiki/Knowledge_representation_and_reasoning&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;knowledge-presentation and reasoning&lt;/a&gt;)。
&lt;a href=&#34;https://en.wikipedia.org/wiki/Ontology_%28information_science%29&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Ontology (information science)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://jueqingsizhe66.github.io/images/ontology/ontology.jpg&#34; alt=&#34;ontology&#34;&gt;&lt;/p&gt;
&lt;p&gt;其中，亚里斯多德指出本体论&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;what it is (its &amp;lsquo;whatness&amp;rsquo;, quidditas or essence)&lt;/li&gt;
&lt;li&gt;how it is (its &amp;lsquo;howness&amp;rsquo; or qualitativeness)&lt;/li&gt;
&lt;li&gt;how much it is (quantitativeness)&lt;/li&gt;
&lt;li&gt;where it is, its relatedness to other beings&lt;a href=&#34;http://jueqingsizhe66.github.io/blog/2016/02/27/the-fourth-interpreter-about-the-traceproc/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;3&lt;/a&gt; &amp;ndash;组合，环境下的行为&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;whatness指的是individuals from class(这边是指类 不是指&lt;a href=&#34;http://jueqingsizhe66.github.io/blog/2016/09/28/machine-learning-some-search-record/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;贝叶斯概率&lt;/a&gt;中的class-predictor键值对，其中class指目标值，而predictor是指属性值，或者叫做表征值,比如表征天气情况：晴天 下雨天 多云)
也就是说whatness解决的是存在的&lt;a href=&#34;https://en.wikipedia.org/wiki/Reason&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;原因&lt;/a&gt;(whyness).&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;经常我们会这样描述&lt;code&gt;What is A&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;明确主谓宾(忌讳缺乏主谓宾)

A是一种***技术，解决了***问题，帮助我们实现了***，帮助我们简化了
****。第一***，第二****，第三***；
首先****，其次***,最后***,

总的来说，A****

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也就是我们需要&lt;a href=&#34;https://en.wikipedia.org/wiki/Statement_%28logic%29&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;说明&lt;/a&gt;(&lt;a href=&#34;https://en.wikipedia.org/wiki/Declarative_programming&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;声明式语言&lt;/a&gt;)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;确保主谓宾&lt;/li&gt;
&lt;li&gt;说明它的功能，解决了什么问题(现实都是问题驱动 problem-driven),好处是什么？&lt;/li&gt;
&lt;li&gt;可能的话在细化分析，第一，第二，第三，首先，其次等.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;任何一项技术的学习其实都有一个思路，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;这门技术是什么？&lt;/li&gt;
&lt;li&gt;怎么使用这门技术？&lt;/li&gt;
&lt;li&gt;使用过程中需要注意些什么？&lt;/li&gt;
&lt;li&gt;这门技术和其他的优缺点？&lt;/li&gt;
&lt;li&gt;这门技术的主要场所是在哪里？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最好能够熟练地自己提问自己上面的5个问题。并反复运用说明方式组织好自己的逻辑语言。这大概是whatness该注意的大部分内容。&lt;/p&gt;
&lt;p&gt;howness是从定性的角度分析该存在体，而howmuchness则是从定量的角度对存在体进行分析。&lt;/p&gt;
&lt;p&gt;由于存在体有很多个，于是需要确定他们的存在关系，于是选用了whereness(也就是空间维度，每加一层维度都可以确定一个y=ax+b的关系，可以参考&lt;a href=&#34;https://en.wikipedia.org/wiki/Support_vector_machine&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SVM&lt;/a&gt;,
所有的算法问题都最终可以归结为&lt;a href=&#34;https://en.wikipedia.org/wiki/Reduction_%28mathematics%29&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;降阶&lt;/a&gt;和&lt;a href=&#34;https://en.wikipedia.org/wiki/Mathematical_optimization&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;优化&lt;/a&gt;（优化只是一种思想）问题，而&lt;a href=&#34;https://en.wikipedia.org/wiki/Least_squares&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;最小二乘法&lt;/a&gt;却是贯穿始终，最小二乘法进一步其实original from y=ax+b)&lt;/p&gt;
&lt;p&gt;关于最小二乘法的总结如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://jueqingsizhe66.github.io/images/ontology/leastSquare1.jpg&#34; alt=&#34;leastsquare1&#34;&gt;
&lt;img src=&#34;https://jueqingsizhe66.github.io/images/ontology/leastSquare2.jpg&#34; alt=&#34;leastsquare2&#34;&gt;
&lt;img src=&#34;https://jueqingsizhe66.github.io/images/ontology/leastSquare3.jpg&#34; alt=&#34;leastsquare3&#34;&gt;
&lt;img src=&#34;https://jueqingsizhe66.github.io/images/ontology/leastSquare4.jpg&#34; alt=&#34;leastsquare4&#34;&gt;&lt;/p&gt;
&lt;p&gt;最小二乘法另外一些描述&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/emanlee/archive/2011/08/03/2125712.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;最小二乘法 least square method &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://mathworld.wolfram.com/LeastSquaresFitting.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;least_squares fitting&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://jean-pierre.moreau.pagesperso-orange.fr/f_lstsqr.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;最小二乘法fortran实现 from 熊叉叉&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/monoSLAM/p/5252917.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;最小二乘法介绍&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;紧接着whereness，我觉得还需要引入一个时间维度也就是whenness，我觉得他很重要，因为机器学习的很多算法都是需要通过时间不断的训练，需要明确whenness,
现实当中约会、上课、上班、吃饭、睡觉等都有一个whenness，我们都生活在时间的单项维度当中，放眼在&lt;a href=&#34;https://en.wikipedia.org/wiki/History&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;历史&lt;/a&gt;的时间尺度来说，我们一个人真的是微不足道，而放眼到我们自己的局部时间尺度来说，我们却需要细细的
品味时光的间隙，体味其中的变化，记录可能需要表征的一类变化量，进一步可能会影响到其他的量的变化（所以任何东西是不是都有着&lt;a href=&#34;https://en.wikipedia.org/wiki/Causality&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;因果论&lt;/a&gt;,也就是说在历史的长河中，我们是渺小的一粒沙子，跌跌撞撞的前行。&lt;/p&gt;
&lt;p&gt;某某美国总统&lt;a href=&#34;https://en.wikipedia.org/wiki/Franklin_D._Roosevelt&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;罗斯福&lt;/a&gt;曾说:&amp;ldquo;Joint and separate ,which is the problem&amp;rdquo;. 本体论就是用于解决个体之间的分类和具体关系。&lt;/p&gt;
&lt;p&gt;所以最终，本体之外和本体之内？&lt;/p&gt;
&lt;p&gt;那是你对自己的定位(在历史长河微不足道，在局部时间，精打细算。秉着科学的精神，踏实生活；挣点小钱，养家糊口; 钱不多，只求闲的时候可以写写岁月中的一些趣事)和取舍(保留需要的东西，舍弃糟粕), 以及你对&lt;a href=&#34;https://en.wikipedia.org/wiki/World&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;世界&lt;/a&gt;或者&lt;a href=&#34;https://en.wikipedia.org/wiki/Cosmos&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;宇宙&lt;/a&gt;的定位(要不然，不想了，想点当下)。&lt;/p&gt;
&lt;h2 id=&#34;appendix&#34;&gt;Appendix&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-gnuplot&#34;&gt;//fdp -Tpdf ontology.dot -o ontology.pdf 

digraph G{
    ontology[label=&amp;quot;Ontology&amp;quot;, shape=box,style=rounded] ;   

    node[style=&amp;quot;rounded,filled&amp;quot;,fillcolor=chartreuse];

    whatness[label=&amp;quot;whatness&amp;quot;];
    howness[label=&amp;quot;howness&amp;quot;];
    howmuchness[label=&amp;quot;howmuchness&amp;quot;];
    whereness[label=&amp;quot;whereness&amp;quot;];
    whenness[label=&amp;quot;whenness&amp;quot;];

    ontology{ whatness howness howmuchness whereness whenness};
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&#34;http://jueqingsizhe66.github.io/blog/2016/09/28/graphviz-notebook/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;graphviz reference&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>能真正教会你编程能力的是重写</title>
      <link>https://jueqingsizhe66.github.io/blog/2016/04/15/neng-zhen-zheng-jiao-hui-ni-bian-cheng-neng-li-de-shi-zhong-xie/</link>
      <pubDate>Fri, 15 Apr 2016 21:50:10 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/blog/2016/04/15/neng-zhen-zheng-jiao-hui-ni-bian-cheng-neng-li-de-shi-zhong-xie/</guid>
      <description>&lt;p&gt;写了很多的matlab，感觉就那样！
编了那么多数值fortran代码，也不见自己编程有多厉害！
练了那么多的java项目，也感觉自己的技术还不见飞涨！
用c语言摸索了好几年，也没见得有太深的见地！&lt;/p&gt;
&lt;p&gt;真正决定你对程序的深入理解，需要你去认识&lt;a href=&#34;http://www.eopl3.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;EOPL&lt;/a&gt;或者&lt;a href=&#34;https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-4.html#%25_toc_start&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SICP&lt;/a&gt;，亦或者更简单的&lt;a href=&#34;http://www.ccs.neu.edu/home/matthias/BTLS/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;TLS&lt;/a&gt;.
他们也许不能教你们做大的项目，却真切教会你编写程序，思考程序。&lt;/p&gt;
&lt;p&gt;回想起之前写的java项目，反反复复就为了构造一门解释器语言，用来输送数据到数据库进行操作，不断
在中间进行验证，保证传递数据的有效性，为了搭上这样的一个平台，反复重构了代码，采用了新技术，
不断采用接口来抽象，割分具体的关系，防止数据的污染。&lt;/p&gt;
&lt;p&gt;而这样做是为何？ 我之前没理解，后来做了一阶段程序语言设计方面的工作，写了多个解释器之后，我才发现总是基于
存在（任意）某一变量某一程序供你使用，你的目的就是使用这个程序或者变量来实现他的能力！然而为了懒惰，
你创建了很多工具（其实，应该是重构，重写）来不断让你的写的东西少点，同时能够达到更多的功能。&lt;/p&gt;
&lt;p&gt;这过程不好经历，也不好做，很多人也很少做，有些人不需要做，更多人没想做。大部分的企业级程序也不会教你去实现这一过程，
也不会跟你从程序理论去介绍。架空程序理论，完成一系列的工程项目成为了很多人编程的主要目的。减少深入思考的时间，
追逐敏捷性编程方式，忽略了闲暇的编程时间，一味着实现需求，个人感觉不是一个好的归宿、目的、追求，但却是一种好的生活手段、工作方式、效率实现。&lt;/p&gt;
&lt;p&gt;编程在我眼里是慢工出细活，所谓的快速开发的提出，我就不好奇，因为我不合适它。真正能够进一步提供自己对于写过程序理解，应该要自己能够写出一个解释器解释你写的程序，这个可以体现在&lt;a href=&#34;http://www.ccs.neu.edu/home/matthias/BTLS/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;TLS&lt;/a&gt;,  &lt;a href=&#34;http://www.ccs.neu.edu/home/matthias/BTSS/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;TSS&lt;/a&gt;  &lt;a href=&#34;http://www.eopl3.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;EOPL&lt;/a&gt;,  &lt;a href=&#34;https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-4.html#%25_toc_start&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SICP&lt;/a&gt;等。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;let解释器&lt;/li&gt;
&lt;li&gt;letrec解释器&lt;/li&gt;
&lt;li&gt;proc解释器&lt;/li&gt;
&lt;li&gt;state解释器&lt;/li&gt;
&lt;li&gt;cps解释器&lt;/li&gt;
&lt;li&gt;type解释器&lt;/li&gt;
&lt;li&gt;oo解释器&lt;/li&gt;
&lt;li&gt;typeoo解释器&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>基于现实，抽象现实，模拟现实</title>
      <link>https://jueqingsizhe66.github.io/blog/2015/10/05/ji-yu-xian-shi-chou-xiang-xian-shi-mo-ni-xian-shi/</link>
      <pubDate>Mon, 05 Oct 2015 10:04:47 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/blog/2015/10/05/ji-yu-xian-shi-chou-xiang-xian-shi-mo-ni-xian-shi/</guid>
      <description>&lt;p&gt;信息与知识的不同在于，信息是暂时不被理解的知识，而当它被理解，并被组织，他也就成了知识。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;你的课题是什么&#34;&gt;你的课题是什么？&lt;/h2&gt;
&lt;p&gt;不再是老师布置的题目，而是基于现实，充分调研，提取你需要的信息，
进行分布式抽象，合理分类，构建知识系统，从而模拟你所expected的现实，
来论证理论……&lt;/p&gt;
&lt;p&gt;知识的存在就因为被interpreted or made sense,namely some what happened
have been interpreted and compared ,finnalys tored into your knowledge
system in the memory(in your head not in the world),更进一步可以阅读
《The Design of Everyday Things》.&lt;/p&gt;
&lt;h2 id=&#34;获取知识的途径&#34;&gt;获取知识的途径？&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;A goal &amp;ndash;&amp;gt;    Your expected things.What do you want?&lt;/li&gt;
&lt;li&gt;B plan &amp;ndash;&amp;gt;    what&amp;rsquo;s your actions to get what you want&lt;/li&gt;
&lt;li&gt;C specify  &amp;ndash;&amp;gt; what action can I do now? Design a conceptual model&lt;/li&gt;
&lt;li&gt;D perform  &amp;ndash;&amp;gt; How do I do it! Get affordance to execute the action&lt;/li&gt;
&lt;li&gt;E perceive &amp;ndash;&amp;gt; What happened after you done the action?&lt;/li&gt;
&lt;li&gt;F interpret &amp;ndash;&amp;gt; explain what happened?&lt;/li&gt;
&lt;li&gt;G compare   &amp;ndash;&amp;gt; it is okay? is it what you want? compare with what you want?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;BCD&lt;/code&gt; is called the stage of execute while &lt;code&gt;EFG&lt;/code&gt; is called the stage of evaluation. Also ,you can call &lt;code&gt;BCD&lt;/code&gt; stage as FeedForward which aid in understanding the process of what can you do.And &lt;code&gt;EFG&lt;/code&gt; stage can be also looked at as FeedBack stage which aid in understanding the process of what happened.&lt;/p&gt;
&lt;p&gt;In the stage of perceive, you can use some signifiers such as light,colors etc in order to communicate with people sucessfully.
In the stage of interpret, it means mapping the knowledge.&lt;/p&gt;
&lt;h2 id=&#34;大量文章的阅读方法&#34;&gt;大量文章的阅读方法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;前言（引言）的第三段讲述作者为什么要进行这项工作、依据、方法（可能一些结果）&lt;/li&gt;
&lt;li&gt;文章中的图表（提出的表征方法和性能变化）&amp;ndash;技术手段&amp;ndash;研究路线&lt;/li&gt;
&lt;li&gt;结论（这些表征方法是否实现了既定的目标以及是否还需要优化（产物的性能怎么样？模拟的精度？未发现的自然现象？）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;摘要的阅读方法&#34;&gt;摘要的阅读方法&lt;/h2&gt;
&lt;p&gt;一般分为三句话。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一句话对应引言第一段。比如说某个东西多NB。&lt;/li&gt;
&lt;li&gt;第二句化对应引言第二段。这个NB东西的工作机理激发了我们设计新的方案的灵感&lt;/li&gt;
&lt;li&gt;第三句话对应Here we report。。回答四个问题&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;我们到底做了什么？&lt;/li&gt;
&lt;li&gt;怎么做的?&lt;/li&gt;
&lt;li&gt;为什么能做到？&lt;/li&gt;
&lt;li&gt;结果怎么样？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;想把一个研究工作讲成一个好故事，最关键式该工作取得好的结果。上述过程也满足
SQCA原则，SQCA（situations&amp;mdash;conflict&amp;ndash;Questions&amp;mdash;Answers),很多人针对situations和conflicts基本上都不按章出牌。&lt;/p&gt;
&lt;p&gt;这些都是前人的一些经验，加油你的topic。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
