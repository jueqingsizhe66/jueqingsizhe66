<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>fortran | 30å¹´ç£¨ä¸€å‰‘</title>
    <link>https://jueqingsizhe66.github.io/tag/fortran/</link>
      <atom:link href="https://jueqingsizhe66.github.io/tag/fortran/index.xml" rel="self" type="application/rss+xml" />
    <description>fortran</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><copyright>Â©2021</copyright><lastBuildDate>Wed, 08 Feb 2017 17:29:29 +0800</lastBuildDate>
    <image>
      <url>https://jueqingsizhe66.github.io/images/icon_hua2ec155b4296a9c9791d015323e16eb5_11927_512x512_fill_lanczos_center_2.png</url>
      <title>fortran</title>
      <link>https://jueqingsizhe66.github.io/tag/fortran/</link>
    </image>
    
    <item>
      <title>fortranè¯»å–csvæ–‡ä»¶</title>
      <link>https://jueqingsizhe66.github.io/blog/2017/02/08/fortrandu-qu-csvwen-jian/</link>
      <pubDate>Wed, 08 Feb 2017 17:29:29 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/blog/2017/02/08/fortrandu-qu-csvwen-jian/</guid>
      <description>&lt;p&gt;æœ¬æ–‡åªæ˜¯ç®€å•å¯¹ä¸€ä¸ªæ–‡ä»¶è¯»å–æ¨¡å—DFile_modçš„ä¸€ä¸ªè¿ç”¨ï¼Œå¹¶è¯»å–é€—å·åˆ†éš”çš„csvæ–‡ä»¶ã€‚&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://jueqingsizhe66.github.io/images/fortrandebug/csv/csv1.png&#34; alt=&#34;csvread&#34;&gt;&lt;/p&gt;
&lt;p&gt;FileMod.f90:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-fortran&#34;&gt;Module DFile_Mod
  Implicit None
  !!**************************************
  !*  è¯†åˆ«æ–‡ä»¶çš„ç©ºæ ¼å’Œé€—å·ä½œä¸ºåˆ†éš”ç¬¦
  !!*************************************** 
contains 

subroutine binaryStreamType
implicit none
integer :: File_Unit
integer :: File_UnitOutput
   !!**************************************
    !* DFile_Mod å˜é‡å®šä¹‰  100%
    !!*************************************** 
    Character(len=512) :: cLine
    integer :: nRow, nCol
    character(len=20) :: name=&amp;quot;yezhaoliang&amp;quot;,addr=&amp;quot;zhangzhou&amp;quot; 
    INTEGER :: I
type :: data_head
integer(kind=2) :: column
end type 

type(data_head) :: FileHead
!real,allocatable :: g(:,:)
real,allocatable :: firstColumn(:)
real,allocatable :: secondColumn(:)
real,allocatable :: thirdColumn(:)

 Open( NewUnit=File_Unit , File = &#39;./data/myfile.csv&#39; )
 Open( NewUnit=File_UnitOutput , File = &#39;./data/myfile12.csv&#39; )

  nRow = GetFileN( File_Unit )
  write( * , * ) &#39;æ–‡ä»¶å…±&#39;,nRow,&#39;è¡Œï¼&#39;
  read(File_Unit,*) FileHead
  write(*,*) &#39;m=&#39;,FileHead%column

  allocate(firstColumn(nRow-1))
  allocate(secondColumn(nRow-1))
  allocate(thirdColumn(nRow-1))
  
  !! æµæ–¹å¼è¯»å–
!  READ(File_Unit) g

250 format(3f10.4)  
251 format(I4,I4,f10.4)  
252 format (f10.4,A,f10.4,A,f10.4)
253 format (I4,A,I4,A,f10.4)
Do i = 1,nRow-1
    read(File_Unit,251) firstColumn(i),secondColumn(i),thirdColumn(i)
 end Do
  DO i = 1 ,nRow-1
   !write(*,&#39;(f10.4,A,f10.4,A,f10.4)&#39;)  firstColumn(i),&#39;,&#39;,secondColumn(i),&#39;,&#39;,thirdColumn(i)
   write(File_UnitOutput,253)  firstColumn(i)*2,&#39;,--&#39;,secondColumn(i)*2,&#39;,--&#39;,thirdColumn(i)
  end do

deallocate(firstColumn)
deallocate(secondColumn)
deallocate(thirdColumn)
close(File_Unit)
close(File_UnitOutput)

  !Do i = 1, nRow
  !  Do j = 1, FileHead%column
  !
  !  end do
  !end do
  
end subroutine binaryStreamType


subroutine testType
implicit none
integer :: File_Unit
integer :: File_UnitOutput
   !!**************************************
    !* DFile_Mod å˜é‡å®šä¹‰  100%
    !!*************************************** 
    Character(len=512) :: cLine
    integer :: nRow, nCol
    character(len=20) :: name=&amp;quot;yezhaoliang&amp;quot;,addr=&amp;quot;zhangzhou&amp;quot; 
    INTEGER :: I
type :: data_head
integer(kind=2) :: column
end type 

type(data_head) :: FileHead
!real,allocatable :: g(:,:)
real,allocatable :: firstColumn(:)
real,allocatable :: secondColumn(:)
real,allocatable :: thirdColumn(:)

 Open( NewUnit=File_Unit , File = &#39;./data/A001.csv&#39; )
 Open( NewUnit=File_UnitOutput , File = &#39;./data/A0012.csv&#39; )

  nRow = GetFileN( File_Unit )
  write( * , * ) &#39;æ–‡ä»¶å…±&#39;,nRow,&#39;è¡Œï¼&#39;
  read(File_Unit,*) FileHead
  write(*,*) &#39;m=&#39;,FileHead%column

  allocate(firstColumn(nRow-1))
  allocate(secondColumn(nRow-1))
  allocate(thirdColumn(nRow-1))
  
  !! æµæ–¹å¼è¯»å–
!  READ(File_Unit) g

250 format(3f10.4)  
251 format(I4,I4,f10.4)  
252 format (f10.4,A,f10.4,A,f10.4)
253 format (I4,A,I4,A,f10.4)
Do i = 1,nRow-1
    read(File_Unit,251) firstColumn(i),secondColumn(i),thirdColumn(i)
 end Do
  DO i = 1 ,nRow-1
   !write(*,&#39;(f10.4,A,f10.4,A,f10.4)&#39;)  firstColumn(i),&#39;,&#39;,secondColumn(i),&#39;,&#39;,thirdColumn(i)
   write(File_UnitOutput,253)  firstColumn(i)*2,&#39;,--&#39;,secondColumn(i)*2,&#39;,--&#39;,thirdColumn(i)
  end do

deallocate(firstColumn)
deallocate(secondColumn)
deallocate(thirdColumn)
close(File_Unit)
close(File_UnitOutput)

  !Do i = 1, nRow
  !  Do j = 1, FileHead%column
  !
  !  end do
  !end do
  
end subroutine testType


  Integer Function GetDataN( cStr )
    Character( Len = * ) , Intent( IN ) :: cStr
    Integer :: i
    Logical :: bIsSeparator , bIsQuote
    GetDataN = 0
    bIsSeparator = .TRUE.
    bIsQuote = .FALSE.
    Do i = 1 , Len_Trim( cStr )
      Select Case( cStr(i:i) )
      Case( &#39;&amp;quot;&#39; , &amp;quot;&#39;&amp;quot; ) !// å¦‚æœé‡åˆ°å¼•å·
        If ( .Not.bIsQuote ) GetDataN = GetDataN + 1  !//å¦‚æœä¸åœ¨å¼•å·ä¸­ï¼Œåˆ™å¢åŠ ä¸€ä¸ªæ•°æ®
        bIsQuote = .Not.bIsQuote !// å¼•å·ç»“æŸæˆ–å¼€å§‹
        bIsSeparator = .FALSE.
      Case( &amp;quot; &amp;quot; , &amp;quot;,&amp;quot; , char(9) ) !// å¦‚æœé‡åˆ°åˆ†éš”ç¬¦
        If ( .Not.bIsQuote ) then  !// åˆ†éš”ç¬¦å¦‚æœä¸åœ¨å¼•å·ä¸­
          bIsSeparator = .TRUE.
        End If
      Case Default      
        If ( bIsSeparator ) then
          GetDataN = GetDataN + 1
        End If
        bIsSeparator = .FALSE.
      End Select
    End Do
  End Function GetDataN
  
  Function f_numbervars(vars) result(numvars)
    character(len=*), intent(in) :: vars
    integer :: numvars
    character(len=len(vars)) :: tmpvars
    character(len=256) :: tmpvar
    tmpvars = trim(adjustl(vars))
    numvars = 0
    do while (len_trim(tmpvars) &amp;gt; 0)
      read(tmpvars, *) tmpvar
      numvars = numvars + 1
      tmpvars = tmpvars(index(tmpvars, trim(tmpvar))+len_trim(tmpvar):)
    end do
  End Function f_numbervars
  
  Integer Function GetFileN( iFileUnit )
  !// æ­¤å‡½æ•°åº”åœ¨æ‰“å¼€æ–‡ä»¶åç«‹å³è°ƒç”¨ã€‚è°ƒç”¨åè¯»å–ä½ç½®è¿”å›æ–‡ä»¶èµ·å§‹ä½ç½®
    Implicit None
    Integer , Intent( IN ) :: iFileUnit
    character( Len = 1 ) :: cDummy
    integer :: ierr
    GetFileN = 0
    Rewind( iFileUnit )
    Do
      Read( iFileUnit , * , ioStat = ierr ) cDummy
      If( ierr /= 0 ) Exit
      GetFileN = GetFileN + 1
    End Do
    Rewind( iFileUnit )
  End Function GetFileN 

End Module DFile_Mod


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ä¸»å‡½æ•°main.f90:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-fortran&#34;&gt;program Main

use DFile_Mod
Implicit none

   INTEGER :: I
   !!**************************************
    !* DFile_Mod å˜é‡å®šä¹‰  100%
    !!*************************************** 
    !Character(len=512) :: cLine
    !integer :: nRow, nCol
    !character(len=20) :: name=&amp;quot;yezhaoliang&amp;quot;,addr=&amp;quot;zhangzhou&amp;quot; 
    !**************************************
    !*  æµ‹è¯•DFile_Mod   100%
    !*************************************** 
    
 !Open( 53 , File = &#39;./data/in.txt&#39; )
  !Open( 53 , File = &#39;./data/myfile.csv&#39; )
  !
  !nRow = GetFileN( 53 )
  !write( * , * ) &#39;æ–‡ä»¶å…±&#39;,nRow,&#39;è¡Œï¼&#39;
  !Do i = 1 , nRow
  !  read( 53 , &#39;(a512)&#39; ) cLine
  !  nCol = GetDataN( cLine )
  !  !nCol = f_numbervars( cLine )
  !  write( * , * ) i,&#39;è¡Œæœ‰&#39;,nCol,&#39;ä¸ªæ•°æ®&#39;
  !End Do
  call binaryStreamType

  Close( 53 )
  end program Main

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;é…ç½®æ–‡ä»¶in.txt:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1 2 3 , fsd
4 5 6 7 : asd
8 9 10 11 12
13 f sadf ! gad
14 15

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;è½½å…¥visual studioåŸºæœ¬ä¸Šå°±èƒ½è¿è¡Œã€‚&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>fortranå®«æ®¿</title>
      <link>https://jueqingsizhe66.github.io/blog/2015/08/09/fortrangong-dian/</link>
      <pubDate>Sun, 09 Aug 2015 15:06:38 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/blog/2015/08/09/fortrangong-dian/</guid>
      <description>&lt;p&gt;ä»»ä½•è¯­è¨€åº”è¯¥éƒ½å¯ä»¥æœ‰ç±»ä¼¼å®«æ®¿çš„æƒ³æ³•ï¼Œåœ¨çºµæ¨ªäº¤é”™çš„è¡—é“ä¸­ï¼Œèƒ½è¿‡æ‰¾åˆ°è¿›å£å’Œå‡ºå£ï¼Œ
å¹¶å¯ä»¥ä½¿ç”¨å¾ˆå¤šæ¡é“è·¯å®Œæˆä½ æƒ³å»çš„åœ°æ–¹ï¼Œè€Œä¸æ˜¯æ‹˜æ³¥äºä¸€æ¡é“è·¯ã€‚Fortranä¹Ÿæ˜¯å¦‚æ­¤ã€‚
è¯ç”Ÿäº1951å¹´å·¦å³çš„ç¬¬ä¸€ä¸ªé¢å‘å¯¹è±¡çš„é«˜çº§è¯­è¨€Fortran è¯­è¨€ï¼Œä¹Ÿå·²ç»65å²å·¦å³äº†ï¼Œå®ƒä»¥å…¶
å¿«é€Ÿæœ‰æ•ˆçš„ç§‘å­¦æ•°å€¼è®¡ç®—ï¼Œä¸€ç›´è¿ç”¨äºç§‘å­¦ç ”ç©¶é¢†åŸŸä¸­ã€‚
æµ…æ˜¾é’ˆå¯¹fortrançš„ç†è§£&amp;mdash;-å®«æ®¿å¼çš„ä»‹ç».&lt;/p&gt;
&lt;h2 id=&#34;å®«æ®¿&#34;&gt;å®«æ®¿&lt;/h2&gt;
&lt;p&gt;å®«æ®¿è•´å«ç€çºµæ¨ªäº¤é”™ï¼Œé˜¡é™Œäº¤é€šï¼Œä½†æ˜¯ç¡®å®é›¶è½æœ‰åºï¼Œå¤åˆè§„å¾‹ã€‚é€šè¿‡å®«æ®¿ç¾¤æ¥è®¤è¯†è¿™é—¨ç§‘å­¦è¯­è¨€ã€‚&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://jueqingsizhe66.github.io/images/fortran/palace.jpg&#34; alt=&#34;å®«æ®¿&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;fortran&#34;&gt;fortran&lt;/h2&gt;
&lt;p&gt;fortranåŒ…å«ä»¥ä¸‹ä¸»è¦å‡ ä¸ªéƒ¨åˆ†&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;#3.1&#34;&gt;è¿›å£(åˆå§‹åŒ–)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3.2&#34;&gt;æ•°ç»„&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3.3&#34;&gt;è¿‡ç¨‹å®šä¹‰(å­ç¨‹åºå’Œå‡½æ•°)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3.4&#34;&gt;æ¨¡å—&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3.5&#34;&gt;å‡ºå£&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3.6&#34;&gt;æ–‡ä»¶ç»„åˆ&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;3.1&#34;&gt; è¿›å£&lt;/h3&gt;
&lt;p&gt;ç¨‹åºåœ¨å¼€å§‹è®¾è®¡çš„æ—¶å€™ï¼Œéœ€è¦å˜é‡åˆå§‹åŒ–ï¼Œä¹Ÿå°±æ˜¯è¿›è¡Œè¿›å£çš„å¸ƒç½®ã€‚&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://jueqingsizhe66.github.io/images/fortran/wumen.jpg&#34; alt=&#34;input&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;3.2&#34;&gt; æ•°ç»„arrays and allocatable &lt;/h3&gt;
&lt;p&gt;æœ‰æ—¶å€™æˆ‘ä»¬å‘ç°ä¸€æ¡è¡—åˆ°åº”è¯¥ç›¸åŒçš„æ ·å¼ï¼Œäºæ˜¯æˆ‘ä»¬é‡‡ç”¨æ•°ç»„æŠŠå…·æœ‰ç›¸åŒçš„
æ•°æ®å½¢æˆæ”¾è¿›ä¸€ä¸ªä¸€ä¸ªçš„æˆ¿å±‹ã€‚&lt;img src=&#34;https://jueqingsizhe66.github.io/images/fortran/wumen.jpg&#34; alt=&#34;arrays&#34;&gt;
fortrançš„dimensionæ˜¯ç›¸å½“å¸¸è§çš„å½¢å¼ï¼Œå› ä¸ºä»–å°±æ˜¯æ•°ç»„çš„ä½“ç°ã€‚
ä¸€èˆ¬æˆ¿å±‹çš„å»ºé€ éƒ½æ˜¯éœ€è¦allocatableçš„å±æ€§ï¼Œä¹Ÿå°±æ˜¯æ”¿åºœæŒ‡å®šçš„å¯ç”¨åœ°ï¼Œåˆ©ç”¨allocateå»ºæˆ¿ï¼Œä½¿ç”¨å®Œï¼ŒåºŸå¼ƒäº†ï¼Œå°±deallocateã€‚&lt;img src=&#34;https://jueqingsizhe66.github.io/images/fortran/zhengdi.jpg&#34; alt=&#34;zhengdi&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;3.3&#34;&gt;subroutine and function&lt;/h3&gt;
&lt;p&gt;æˆ¿å±‹ä¸€å¤šæˆ‘ä»¬å‘ç°æ²¡æ³•ç®¡ç†ï¼Œäºæ˜¯æˆ‘ä»¬å°±æŠŠå¾ˆå¤šçš„æˆ¿å±‹æ”¾åœ¨å¯¹åº”çš„è¡—é“ä¸­å»,ä¹Ÿå°±æ˜¯
subroutineæˆ–è€…functionå½“ä¸­ã€‚&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://jueqingsizhe66.github.io/images/fortran/street.png&#34; alt=&#34;è¡—é“&#34;&gt;&lt;/p&gt;
&lt;p&gt;å¦å¤–æœ‰æ—¶å€™æœ‰ä¸€äº›å·²ç»åœ¨å¤–å»ºçš„subroutineå’Œfunctionä¸€å®šå¾—æŠŠä»–ä»¬çš„å¤´å’Œå‚æ•°ç±»å‹å’Œendéƒ¨åˆ†æäº¤åˆ°programï¼ˆæ”¿åºœï¼‰å½“ä¸­çš„INTERFACEå½“ä¸­ï¼Œè¿™æ ·æ‰èƒ½ç¡®å®šè¿™å—åœ°çš„åˆæ³•æ€§ç­‰ã€‚
è¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆfortranä¸­æœ‰æ—¶ä¼šæœ‰é¢å¤–çš„å­ç¨‹åºçš„å®šä¹‰ï¼ˆå’Œä¸»æ–‡ä»¶ä¸åœ¨åŒä¸€ä¸ªæ–‡ä»¶å¤¹å½“ä¸­ï¼‰ï¼Œä¸ºäº†è®©ä¸»æ–‡ä»¶èƒ½å¤Ÿè¯†åˆ«ï¼Œä½¿ç”¨INTERFACEæŠŠå®ƒåµŒå…¥è¿›æ¥(åæ¥å¼•å…¥moduleå‡å°‘äº†interfaceçš„ä½œç”¨)ã€‚&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://jueqingsizhe66.github.io/images/fortran/zhai.jpg&#34; alt=&#34;interface&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;3.4&#34;&gt; å‡çº§ç‰ˆçš„module&lt;/h3&gt;
&lt;p&gt;ä¸ºäº†ç®¡ç†å’Œç»´æŠ¤æˆ¿é—´(arrays)å’Œè¡—é“(subs)ï¼Œäºæ˜¯æˆ‘ä»¬æŠŠä»–ä»¬æ”¾åœ¨ä¸€ä¸ªä¸€ä¸ªåŒºåŸŸå½“ä¸­ã€‚&lt;img src=&#34;https://jueqingsizhe66.github.io/images/fortran/module.png&#34; alt=&#34;module&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;3.5&#34;&gt; å‡ºå£ &lt;/h3&gt;
   å½“æˆ‘ä»¬ç»•è¿‡äº†æ•´ä¸ªå®«æ®¿åï¼Œè¿˜éœ€è¦å¸ƒç½®ä¸€ä¸ªæˆ–å¤šä¸ªçš„å‡ºå£ã€‚ ![output][5]
&lt;h3 id=&#34;3.6&#34;&gt; ç„¶è€Œæˆ‘ä»¬å‘ç°æˆ‘ä»¬éœ€è¦æ›´å¤§çš„è¿›å£è¯´æ˜&lt;/h3&gt;
&lt;p&gt;æœ‰æ—¶å€™æˆ‘ä»¬è¿›ä¸€æ­¥ç»„è£…å¤šä¸ªè¾“å…¥æ–‡ä»¶ï¼Œè€Œä¸ºäº†æ–¹ä¾¿ï¼Œæˆ‘ä»¬æŠŠä»–ä»¬ç»„è£…æˆä¸€ä¸ªæ›´å¤§çš„è¿›å£è£…ç½®ï¼Œæ”¾ç½®åœ¨æœ€å‰é¢ã€‚&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://jueqingsizhe66.github.io/images/fortran/square.jpg&#34; alt=&#34;square&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;åç»­&#34;&gt;åç»­&lt;/h2&gt;
&lt;p&gt;æ— è®ºæ¨¡å—åŒ–ï¼Œè¿˜æ˜¯å‡½æ•°åŒ–ï¼Œäº¦æˆ–è€…æ¨¡å¼åŒ–ï¼Œéƒ½æ˜¯åŸºäºåŸå…ˆå¤§çš„è¿‡ç¨‹å¼å˜æˆçš„æ”¹æˆï¼Œ
åªä¸è¿‡æ˜¯ä¸ºäº†å‡å°‘å†—ä½™ã€é‡å¤ï¼ŒåŒæ—¶ç®€åŒ–å’Œæ–¹ä¾¿é˜…è¯»ï¼Œå¦å¤–è¿˜æœ‰å°±æ˜¯æ–¹ä¾¿æ‹“å±•ã€‚
&lt;em&gt;ä»ç°åœ¨å¼€å§‹å¯ä»¥å»ºç«‹ä½ è‡ªå·±çš„fortranlibrary modal&lt;/em&gt; (&lt;font color=&#34;red&#34;&gt;ä¸€ä¸ªä¸é”™çš„å»ºè®®&lt;/font&gt;)&lt;/p&gt;
&lt;p&gt;fortran2003å‡ºæ¥äº†ä¸ªtypeè¿™ä¸ªæ•°æ®ç»“æ„çš„åˆ›å»ºï¼Œæ–¹ä¾¿çš„æŠŠå¤šä¸ªå˜é‡æˆ–è€…æ•°ç»„ç»„åˆæˆä¸ºä¸€ç§æ•°æ®ç±»å‹ï¼Œè¿™å°±æœ‰ç‚¹åƒ3Dæ‰“å°çš„åŠŸèƒ½ï¼š&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  type creat_a
    real :: a
    integer :: b
    real,allocatable :: c(:)
  end type creat_a
  
  type(creat_a) :: creat_b,creat_c
  
  creat_b%a = 1.0
  creat_b%b = 2
  allocate (creat_b%c(3))
  creat_b%c = 6.0
  
  creat_c = creat_b
  creat_c%b = 8

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;typeçš„ä½œç”¨ç±»ä¼¼Hashkellçš„dataçš„ä½œç”¨ï¼Œæ²¡æœ‰è¡Œä¸ºåªæœ‰æ•°æ®ç±»å‹ã€‚
å…ˆå¼€ä¸ªå¤´â€¦â€¦&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Incompact3dçš„MakefileåŠDNSç®—æ³•</title>
      <link>https://jueqingsizhe66.github.io/blog/2015/06/22/incompact3dde-makefileji-dnssuan-fa/</link>
      <pubDate>Mon, 22 Jun 2015 16:52:20 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/blog/2015/06/22/incompact3dde-makefileji-dnssuan-fa/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://code.google.com/p/incompact3d&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Incompact3d&lt;/a&gt;æ˜¯ä¸€ä¸ªå¼€æºçš„åŸºäºfortranè¯­è¨€ç¼–å†™çš„DNSæ±‚è§£å™¨ï¼Œä¹Ÿæ˜¯æˆ‘ç ”ç©¶ç”ŸæœŸé—´ä½¿ç”¨çš„å¼€æºæºä»£ç ã€‚
Incompact3dæ•´ä½“æ¡†æ¶çš„ä»‹ç»å¯ä»¥å‚è€ƒè½¯ä»¶çš„&lt;a href=&#34;https://code.google.com/p/incompact3d/downloads/detail?name=user_guide_incompact3d_V1-1.pdf&amp;amp;can=2&amp;amp;q=&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;user-guide&lt;/a&gt;å’Œæ–‡çŒ®&lt;a href=&#34;http://www.imperial.ac.uk/media/imperial-college/research-centres-and-groups/turbulence-mixing-and-flow-control-group/2009_LAIZET_JCP.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;High-order-compact schemes for incompressible flows: a simple and effcient method with the quasi-spectral accuary&lt;/a&gt;,è¿˜å¯ä»¥æœç´¢&lt;a href=&#34;http://www.imperial.ac.uk/tmfc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;sylvain Laziet&lt;/a&gt; ç›¸å…³çš„æ–‡ç«  ï¼Œåªä¸è¿‡ä»–å¹¶ä¸æ˜¯æˆç†Ÿçš„è½¯ä»¶ï¼Œå¾ˆå¤šçš„ç¼–è¯‘å’Œåå¤„ç†éƒ½å¯èƒ½å‡ºç°é—®é¢˜ï¼Œä¸‹é¢æ˜¯æˆ‘ä½¿ç”¨è¿‡ç¨‹é‡åˆ°çš„ä¸€äº›é—®é¢˜ã€‚
å½“ç„¶ä¸»è¦è¿‡ç¨‹æ˜¯ï¼Œé€šè¿‡makefileç¼–è¯‘ï¼Œç„¶åè¿è¡Œincompact3dï¼Œæœ€åå¤„ç†è®¡ç®—ç»“æœã€‚&lt;/p&gt;
&lt;p&gt;#1 å¦‚ä½•æ¨¡æ‹Ÿï¼Ÿ&lt;/p&gt;
&lt;p&gt;ä»¥å‘¨æœŸæ€§æ§½é“æµåŠ¨(å½“ç„¶æˆ‘ä¹Ÿå°±ä¼šè¿™ä¹ˆä¸€ç§ï¼Œå…¶ä»–éƒ½åªæ˜¯èµ°äº†ä¸€å°åŠï¼‰ä¸ºä¾‹ã€‚&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;é¦–å…ˆæ˜¯å¾—åˆ°(ä¸å¾—ä¸è¯´ï¼Œæˆ‘ä¹Ÿæœ‰ç‚¹å¿˜è®°)ä¸€ä¸ªå®Œå…¨å‘å±•çš„æ—‹è½¬æ§½é“æµåŠ¨(æ³¨æ„æ—‹è½¬æºé¡¹çš„æ·»åŠ ) (ä¸€èˆ¬è®¾ç½®20000æ­¥å¯ä»¥äº†ï¼Œåªè¦æ”¶æ•›å³å¯ å¤§æ¦‚ä¸€å¤©)&lt;/li&gt;
&lt;li&gt;ç„¶åæ˜¯è·å¾—å®Œå…¨å‘å±•æ§½é“æµåŠ¨(ä¹Ÿå°±æ˜¯ä¸åŠ ä¸Šæ—‹è½¬æºé¡¹)(ä¼°è®¡å¾—ä¸‰ä¸‡æ­¥ä»¥ä¸Š å¤§æ¦‚ä¸€å¤©)&lt;/li&gt;
&lt;li&gt;æœ€åæ˜¯è·å¾—ç»Ÿè®¡çš„å®Œå…¨å‘å±•æ§½é“æµåŠ¨.å› ä¸ºDNSè·å¾—çš„ç»“æœæ˜¯éå®šå¸¸çš„ï¼Œæ‰€ä»¥ä½ å¾—è¿›è¡Œæ—¶å‡å¤„ç†(å½“ç„¶æ—¶å‡ç¨‹åºå¾—æ‰“å¼€æ—¶å‡ç»Ÿè®¡é¡¹ umeanç­‰)(æˆ‘ç»Ÿè®¡äº†20ä¸‡æ­¥ï¼Œå¤§æ¦‚èŠ±äº†4å¤©æ—¶é—´ã€‚)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;æ­¥éª¤å°±æ˜¯è¿™æ ·,å¤§æ¦‚ä¸€ä¸ªè¾ƒå°çš„æµç¨‹éœ€è¦ä¸€å‘¨å·¦å³ã€‚&lt;/p&gt;
&lt;p&gt;Incompact3dæ¯”è¾ƒç‰¹æ®Šçš„æ˜¯æ”¶æ•›æ€§åˆ¤å®šé—®é¢˜ï¼Œä¸Šé¢çš„å‡ ä¸ªè¿‡ç¨‹éƒ½éœ€è¦ä½¿ç”¨å®æ—¶&lt;a href=&#34;http://jueqingsizhe66.github.io/blog/2015/05/31/u-plus-y-plus/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ç›‘æ§å°ç¨‹åº&lt;/a&gt;
æ¥è§‚çœ‹é€Ÿåº¦æ•£åº¦å’Œè´¨é‡æµé‡(è´¨é‡æµé‡æ˜¯å‘¨æœŸæ€§æ§½é“æµåŠ¨æ‰€ç‰¹æœ‰çš„ï¼Œæ‰€ä»¥æœ€å¥½è¿›è¡Œå®æ—¶æ˜¾ç¤º)çš„æ”¶æ•›æƒ…å†µ.å¦å¤–ä½ å¯ä»¥é€šè¿‡pythonçš„ä¸€ä¸ªå°è„šæœ¬
æ¥è·å¾—å®æ—¶æ˜¾ç¤ºçš„å›¾ç‰‡ï¼Œè¿™æ ·å°±èƒ½çœ‹åˆ°ç¨‹åºæ¨¡æ‹Ÿå¾—æ€ä¹ˆæ ·äº†ï¼Œå…·ä½“æŸ¥çœ‹&lt;a href=&#34;http://jueqingsizhe66.github.io/blog/2015/06/11/ji-yu-pythonde-ju-yu-wang-wen-jian-gong-xiang-ruan-jian-simplehttpserverwithupload/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;pythonå±€åŸŸç½‘ä¸Šä¼ å’Œä¸‹è½½&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;#2 åå¤„ç†æ–¹æ³•
å‚è€ƒæˆ‘çš„&lt;a href=&#34;http://jueqingsizhe66.github.io/blog/2015/06/22/incompact3dru-he-tong-guo-jie-guo-chu-li-chu-ji-xian&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;pathlineå¤„ç†æ–¹æ³•&lt;/a&gt;
ä¸€å®šè¦æ³¨æ„(real 8) å¦åˆ™å¾—åˆ°çš„ç»“æœè‚¯å®šæ˜¯é”™è¯¯çš„ï¼Œè¿™ä¹Ÿæ˜¯å›°æ‰°æˆ‘å‡ æ˜ŸæœŸçš„é—®é¢˜ã€‚&lt;/p&gt;
&lt;p&gt;#3 å…³äºMakefileç¼–è¯‘&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;#=======================================================================
# Makefile for Imcompact3D
#=======================================================================

# Choose pre-processing options
#   -DSHM	   - enable shared-memory implementation
#   -DDOUBLE_PREC  - use double-precision
OPTIONS = -DDOUBLE_PREC

# Choose an FFT engine, available options are:
#   essl       - IBM Blue Gene ESSL Library
#   fftw3      - FFTW version 3.x
#   generic    - A general FFT algorithm (no 3rd-party library needed)
#FFT= essl # I ignore
FFT = generic

# Paths to FFTW 3
FFTW3_PATH=   # full path of FFTW installation if using fftw3 engine above
FFTW3_INCLUDE = -I$(FFTW3_PATH)/include
FFTW3_LIB = -L$(FFTW3_PATH)/lib -lfftw3 -lfftw3f

# Paths to ESSL
ESSL_PATH=/bgsys/drivers/ppcfloor/comm/xl
ESSL_INCLUDE =
ESSL_LIB = -L$(ESSL_PATH)/lib -L/opt/ibmmath/lib64 -lesslbg

# Specify Fortran and C compiler names and flags here
# Normally, use MPI wrappers rather than compilers themselves 
# Supply a Fortran pre-processing flag together with optimisation level flags
# Some examples are given below:

#FC =  
#OPTFC = 
#CC = 
#CFLAGS = 

# PGI
#FC = ftn
#OPTFC = -fast -O3 -Mpreprocess
#CC = cc
#CFLAGS = -O3

# PathScale
#FC = ftn
#OPTFC = -Ofast -cpp
#CC = cc
#CFLAGS = -O3

# GNU é€‰ç”¨mpif90è¿›è¡Œç¼–è¯‘
FC = mpif90
OPTFC = -O0 -g  -fdefault-real-8 -fdefault-double-8 -funroll-loops -ftree-vectorize -fcray-pointer -cpp
CC = mpicc
CFLAGS = -O0
PLATFORM=gnu

#Blue Gene/Q : EDF R&amp;amp;D
#PREP=/bgsys/drivers/ppcfloor/comm/xl/bin/
#FC = $(PREP)mpixlf95_r
#OPTFC= -O3 -qsuffix=cpp=f90 -qinitauto -qautodbl=dbl4
##OPT_LK= -O3 -qinitauto -qautodbl=dbl4
#CFLAGS= -O3 -qinitauto -qautodbl=dbl4
#CC=$(PREP)mpixlc_r
#PLATFORM=bgq_xlf

# Cray
#FC = ftn
#OPTFC = -e Fm
#CC = cc
#CFLAGS = 

#-----------------------------------------------------------------------
# Normally no need to change anything below

# include PATH 
ifeq ($(FFT),generic)
  INC=
else ifeq ($(FFT),fftw3)
  INC=$(FFTW3_INCLUDE)
else ifeq ($(FFT),essl)
  INC=$(ESSL_INCLUDE)
endif

# library path
ifeq ($(FFT),generic)
   LIBFFT=
else ifeq ($(FFT),fftw3)
   LIBFFT=$(FFTW3_LIB)
else ifeq ($(FFT),essl)
   LIBFFT=$(ESSL_LIB)
endif

# List of source files
# æ³¨æ„è¿™è¾¹ç¼–è¯‘çš„æ¨¡å—ï¼Œä¸€èˆ¬æ˜¯éœ€è¦çš„modç”Ÿæˆæ”¾åœ¨å‰é¢é¦–å…ˆç¼–è¯‘ï¼Œå¦‚æœä¸æ”¾å‰é¢ä¼šæŠ¥é”™ï¼Œè§£å†³åŠæ³• å°±æ˜¯æ–‡ä»¶åæ”¾åœ¨å‰é¢å³å¯,å…·ä½“å¯ä»¥æŸ¥çœ‹å…³äºMakefile Fortran
SRC = decomp_2d.f90 glassman.f90 fft_$(FFT).f90 module_param.f90 io.f90 variables.f90 poisson.f90 schemes.f90 implicit.f90 convdiff.f90 user_module.f90 incompact3d.f90 navier.f90 derive.f90 parameters.f90 tools.f90 visu.f90

#-----------------------------------------------------------------------
# Normally no need to change anything below

ifneq (,$(findstring DSHM,$(OPTIONS)))
SRC := FreeIPC.f90 $(SRC)  
OBJ =	$(SRC:.f90=.o) alloc_shm.o FreeIPC_c.o
else
OBJ =	$(SRC:.f90=.o)
endif	

OPTION=$(OPTIONS)
from:=-D
to:=-WF,-D
TMP=$(subst $(from),$(to),$(OPTIONS))
ifeq ($(PLATFORM),bgp_xlf)
   OPTION=$(TMP)
endif
ifeq ($(PLATFORM),bgq_xlf)
   OPTION=$(TMP)
endif

all: incompact3d

alloc_shm.o: alloc_shm.c
	$(CC) $(CFLAGS) -c $&amp;lt;

FreeIPC_c.o: FreeIPC_c.c
	$(CC) $(CFLAGS) -c $&amp;lt;

incompact3d : $(OBJ)
	$(FC) -O0 -g -o $@ $(OBJ) $(LIBFFT)

%.o : %.f90
	$(FC) $(OPTFC) $(OPTION) $(INC) -c $&amp;lt;

.PHONY: clean 
clean:
	rm -f *~ *.o *.mod incompact3d

.PHONY: realclean
realclean: clean
	rm -f *~ \#*\#
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;è¿è¡Œæ–¹å¼:
æˆ‘çš„ç”µè„‘åˆšå¥½æ˜¯8çº¿ç¨‹ï¼Œå°±ç”¨8çº¿ç¨‹è¿è¡Œï¼Œä½ ä¹Ÿå¯ä»¥é€‰ç”¨4æˆ–è€…æ›´å¤š.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;mpirun -np 8  incompact3d  &amp;gt; tail.out &amp;amp;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;#4 The Algorithm of the DNS in Incompact3d&lt;/p&gt;
&lt;p&gt;Incompact3dçš„æ‰§è¡Œæµç¨‹åŸºæœ¬ä¸Šæ˜¯ä¸‹é¢å‡ ä¸ª(å½“ç„¶å¾—ä»”ç»†é˜…è¯»ï¼Œå¹¶åå¤æ¯”å¯¹).æˆ‘å†™å¾—è¿™æ®µè‹±æ–‡å¤§ä½“èƒ½å¤Ÿå¯¹å¾—ä¸Š.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;1. Initial the velocity field with noise(init subroutine).
2. Start the iterative process by guessing the pressure field. First we use convdiff subroutine take convection and diffusion of the flow into consideration.And then use pre_correc subroutine to correction the velocity value with the specified boundary condition.
3. Use the values of u,v,and w to get the initialize of the pp3 in the spectral space from subroutine divergence(â€¦pp3,1â€¦)(first sign to turbulent spot).Then we use poisson solver decomp_2d_poisson_stag to get the value of the pp3 in the spectral space.
4. Since they were obtained from the guessed values of u,v,w,the values pp3,when substituted into the divergence equation,will not necessarily satisfy that that equation.Hence ,using the gradp subroutine,get the pressure gradients in the physics space,then using corgp subroutine ,get the velocity correction by the pressure gradient in the physics space.Use subroutine divergence(â€¦dv3,2â€¦) to do another monitor for turbulent spot(second sign to turbulent spot) .At the end of the current step, we go to step2 again until the simulation have been fully developed.
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Incompact3då¦‚ä½•é€šè¿‡ç»“æœå¤„ç†å‡ºè¿¹çº¿</title>
      <link>https://jueqingsizhe66.github.io/blog/2015/06/22/incompact3dru-he-tong-guo-jie-guo-chu-li-chu-ji-xian/</link>
      <pubDate>Mon, 22 Jun 2015 16:20:48 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/blog/2015/06/22/incompact3dru-he-tong-guo-jie-guo-chu-li-chu-ji-xian/</guid>
      <description>&lt;p&gt;Incompact3Dè·å¾—çš„æ•°æ®éƒ½æ˜¯äºŒè¿›åˆ¶çš„æ•°æ®æ–‡ä»¶ï¼Œä¸ºäº†è·å¾—å†…éƒ¨çš„æ–‡ä»¶
éœ€è¦è¿›ä¸€æ­¥é€šè¿‡ç¼–ç¨‹è·å¾—ï¼Œä¸‹é¢æ˜¯ä¸€ä¸ªè·å¾—pathlineçš„æºä»£ç ã€‚&lt;/p&gt;
&lt;p&gt;è¯´æ˜ï¼š&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;é€šè¿‡ module.f90æ–‡ä»¶è¯»å– nx ny nzçš„å€¼&lt;/li&gt;
&lt;li&gt;æŠŠä¸‹é¢çš„æºä»£ç ç¼–è¯‘å¹¶æ”¾åœ¨ux uy uzæ‰€åœ¨çš„æ–‡ä»¶å¤¹å½“ä¸­&lt;/li&gt;
&lt;li&gt;è¿›ä¸€æ­¥çš„ç›¸å…³ä¿¡æ¯ï¼Œå¯ä»¥å‚è€ƒæ³¨é‡Šã€‚&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-fortran&#34;&gt;PROGRAM b
IMPLICIT NONE
Integer,parameter :: nx=128,ny=129,nz=84 
INTEGER :: I,J,K,COUNT,LN=128,COL=129,VOL=84
REAL(8),DIMENSION(nx,ny,nz) :: ux,uy,uz
CHARACTER(len=12)::NAME1=&amp;quot;Incompact3d&amp;quot;,NAME2=&amp;quot;ux&amp;quot;,NAME3=&amp;quot;uy&amp;quot;,NAME4=&amp;quot;uz&amp;quot;
character(len=15) :: temp,temp1,temp2,temp3
CHARACTER(len=20) :: CFILEux
integer :: num

real,dimension(nx):: y1
real,dimension(ny):: y2
real,dimension(nz):: y3

!generation of the mesh
do i=1,nx
   y1(i)=(i-1)*0.098174770425 !0.8 is DX ! incompact3d.prmçš„é…ç½®é•¿åº¦é™¤ä»¥ç½‘æ ¼å°ºåº¦å³å¯ã€‚
enddo


do j=1,ny
   y2(j)=(j-1)*0.015503875968992248 !0.8 is DY
enddo


do k=1,nz
   y3(k)=(k-1)*0.04986655005702381!0.8 is DZ
enddo


! ä¸‹é¢åªæ˜¯å¯¹äºè¯»å–æ–‡ä»¶è¿›è¡Œçš„ä¸€ä¸ªåå¤„ç†ï¼Œåªæ˜¯ä¸ºäº†æ–¹ä¾¿æ‰¹å¤„ç†è€Œå·²
22 format(I1)
23 format(I2)
DO num=1,30
    if(num .lt. 10) then
        write(temp,22) num
        temp1 =trim(NAME2)//trim(&#39;00&#39;)//trim(temp)
        temp2 =trim(NAME3)//trim(&#39;00&#39;)//trim(temp)
        temp3 =trim(NAME4)//trim(&#39;00&#39;)//trim(temp)
    else 
        write(temp,23) num
        temp1 =trim(NAME2)//trim(&#39;0&#39;)//trim(temp)
        temp2 =trim(NAME3)//trim(&#39;0&#39;)//trim(temp)
        temp3 =trim(NAME4)//trim(&#39;0&#39;)//trim(temp)
    end if
    
! äº§ç”Ÿå®é™…çš„æ–‡ä»¶å
CFILEux=trim(&#39;./pathchange/&#39;)//trim(temp1)//&#39;.dat&#39;
!read the ux è¯»å–ux00*çš„æ•°æ®
OPEN(10,FILE=temp1,FORM=&#39;UNFORMATTED&#39;,&amp;amp;
ACCESS=&#39;DIRECT&#39;, RECL=8, STATUS=&#39;OLD&#39;)

! read the uy
OPEN(11,FILE=temp2,FORM=&#39;UNFORMATTED&#39;,&amp;amp;
ACCESS=&#39;DIRECT&#39;, RECL=8, STATUS=&#39;OLD&#39;)
!read the uz
OPEN(12,FILE=temp3,FORM=&#39;UNFORMATTED&#39;,&amp;amp;
ACCESS=&#39;DIRECT&#39;, RECL=8, STATUS=&#39;OLD&#39;)

! æ–°å»ºä¸€ä¸ªç»“æœæ–‡ä»¶ï¼Œå¹¶æ·»åŠ ä¸Štecplotçš„æ•°æ®å¤´

OPEN(20,FILE=CFILEux,FORM=&#39;FORMATTED&#39;)
WRITE (20,&#39;(A6,A12)&#39;)               &#39;TITLE=&#39;,TRIM(ADJUSTL(NAME1))
 WRITE (20,&#39;(A36)&#39;)    &#39;VARIABLES=&amp;quot;X&amp;quot;,&amp;quot;Y&amp;quot;,&amp;quot;Z&amp;quot;,&amp;quot;VX&amp;quot;,&amp;quot;VY&amp;quot;,&amp;quot;VZ&amp;quot;&#39;
      WRITE (20,&#39;(A7,I4,A1,A2,I4,A1,A2,I4,A1,A7)&#39;) &#39;ZONE I=&#39;,LN,&#39;,&#39;,&#39;J=&#39;,COL,&#39;,&#39;,&#39;K=&#39;,VOL,&#39;,&#39;,&#39;F=POINT&#39;

COUNT = 1
DO K=1,nz
    DO J=1,ny
        DO I=1,nx
            READ(10,REC=COUNT) ux(I,J,K)
            READ(11,REC=COUNT) uy(I,J,K)
            READ(12,REC=COUNT) uz(I,J,K)
        !    WRITE(20,30) I,J,K,ux(I,J,K),uy(I,J,K),uz(I,J,K)
             WRITE(20,30) y1(i),y2(j),y3(k),ux(I,J,K),uy(I,J,K),uz(I,J,K)
            30 format(I3,1X,I3,1X,I3,1X,E11.4,1x,E11.4,1x,E11.4)
            COUNT = COUNT + 1
        ENDDO
    ENDDO
ENDDO
ENDDO
CLOSE(10)
CLOSE(11)
CLOSE(10)
CLOSE(20)
END PROGRAM b
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>ç§¯ç´¯å’Œé‡å†™å¯¹äºç¨‹åºå‘˜å¾ˆé‡è¦</title>
      <link>https://jueqingsizhe66.github.io/blog/2015/06/22/ji-lei-he-zhong-xie-dui-yu-cheng-xu-yuan-hen-zhong-yao/</link>
      <pubDate>Mon, 22 Jun 2015 15:35:19 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/blog/2015/06/22/ji-lei-he-zhong-xie-dui-yu-cheng-xu-yuan-hen-zhong-yao/</guid>
      <description>&lt;p&gt;ç§¯ç´¯ï¼Œä½ æ‰èƒ½åšç§¯è€Œè–„å‘ã€‚
é‡å†™ï¼Œä½ æ‰èƒ½è¿›ä¸€æ­¥è®¤è¯†ä½ çš„ç§¯ç´¯.
é‡å†™æœ‰æ—¶å€™ä¼šå¸¦æ¥å¯¹äºçŸ¥è¯†çš„è¿›ä¸€æ­¥æ·±å…¥çš„ç†è§£.&lt;/p&gt;
&lt;p&gt;ä»Šå¤©å¬äº†&lt;a href=&#34;http://www.fcode.cn&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Fcode&lt;/a&gt;çš„ä¸€ä¸ªè§†é¢‘è®²åº§ï¼Œä¸€ä¸ªç«‹å¿—äºå¼€æºçš„éè¥åˆ©å°å›¢é˜Ÿï¼Œè¿˜æœ‰ä¸€ä¸ªä¸“é—¨çš„Fortran Coderçš„qqç¾¤ã€‚å¬å®Œæ„Ÿè§‰ï¼Œè‡ªå·±çœŸçš„å¾ˆæœ‰ç¼ºç‚¹ï¼Œä¹‹å‰ä¸Šè¿‡ä¸€ä¸ªjavaåŸ¹è®­ç­ï¼Œå…¶å®å¥—è·¯éƒ½ä¸€æ ·ï¼Œå†™ä»£ç ï¼Œé‡å¤å†™ï¼Œç›´åˆ°ä½ ç¡è§‰é†’æ¥è¿˜èƒ½å†™ï¼Œå–äº†åŠæ–¤52åº¦äºŒé”…å¤´è¿˜èƒ½å†™ã€‚&lt;/p&gt;
&lt;p&gt;å¹¶ä¸”éœ€è¦åœ¨ä¸€å®šçš„æ—¶é—´å†…å›é¡¾ï¼Œé‡å†™ä¹‹å‰ä½ å†™è¿‡çš„ä¸œè¥¿ï¼Œè™½ç„¶å¬èµ·æ¥å¾ˆç®€å•ï¼Œå¯æ˜¯æˆ‘ç»å¸¸ä¹Ÿæ˜¯å¿˜è®°äº†è¿™ä¸ªè¯¥åšçš„å·¥ä½œã€‚&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ç§¯ç´¯&lt;/li&gt;
&lt;li&gt;é‡å†™&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;è¿™ä¸¤é¡¹å¯¹äºå­¦ä¹ ä»»ä½•ä¸€ä¸ªç§‘ç›®éƒ½è‡³å…³é‡è¦å’Œå¿…ä¸å¯å°‘ã€‚æ­¦åŠŸå†é«˜,ä¹Ÿè¦ç»ƒæ“ã€‚&lt;/p&gt;
&lt;p&gt;fortranæ˜¯ç®€å•ï¼Œè€Œä¸”æ˜¯åŸºäºè§£å†³æ•°å­¦ã€ç‰©ç†é—®é¢˜,æ“…é•¿ç§‘å­¦è®¡ç®—ï¼Œè€Œä¸æ˜¯åˆ©ç”¨å®ƒåšä¸€ä¸ªæ¼‚äº®çš„ç•Œé¢ã€‚åŸºæœ¬ä¸Šfortrançš„å¾ˆå¤šç®—æ³•éƒ½å¯ä»¥é€šè¿‡ç½‘ç»œèµ„æºæœç´¢å¾—åˆ°ï¼Œå¹¶è¿›è¡Œé€‚å½“ä¿®æ”¹ï¼Œè¿™ä¹Ÿéœ€è¦ä½ å»ç§¯ç´¯ã€‚ä½†æ˜¯fortranç»™ä½ æ€ç»´å±‚æ¬¡çš„æ”¹é€ ä¸æ˜¯ç‰¹åˆ«æ˜æ˜¾ï¼Œæ‰€ä»¥ä»è¿™ä¸ªè§’åº¦æ¥è¯´ï¼Œæˆ‘å¹¶ä¸è§‰å¾—ä»–æ˜¯ä¸€é—¨å¥½çš„è¯­è¨€ï¼Œä½†æ˜¯ä»–çš„è®¡ç®—èƒ½åŠ›è¿˜çœŸçš„ä¸é”™ï¼Œç‰¹åˆ«æ˜¯çŸ©é˜µè®¡ç®—èƒ½åŠ›ã€‚ä¹Ÿè®¸æˆ‘ä¹Ÿè¯¥ç»å¸¸æ•´ç†fortranç›¸å…³çš„ç¼–ç¨‹çŸ¥è¯†ã€‚&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Ubuntu gtk-fortran</title>
      <link>https://jueqingsizhe66.github.io/blog/2015/05/19/ubuntu-gtk-fortran/</link>
      <pubDate>Tue, 19 May 2015 17:03:25 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/blog/2015/05/19/ubuntu-gtk-fortran/</guid>
      <description>&lt;p&gt;Fortranï¼šä¸€é—¨å¤è€çš„&lt;a href=&#34;http://micro.ustc.edu.cn/Fortran/ZJDing/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;è®¡ç®—æœºæ•°å€¼ç§‘å­¦è®¡ç®—è¯­è¨€&lt;/a&gt;,1950.&lt;/p&gt;
&lt;p&gt;Fortrançš„å¼ºé¡¹å°±æ˜¯æ•°å€¼è®¡ç®—ï¼Œå›¾å½¢ç¼–ç¨‹æ˜¯ä¸€ä¸ªé¸¡è‚‹æ‰€åœ¨ï¼Œä½†æ˜¯æœ‰æ—¶å€™åˆéœ€è¦åšä¸€äº›å›¾å½¢çš„å±•ç¤ºï¼Œå€ŸåŠ©äº&lt;a href=&#34;http://www.gtk.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GTK+ project&lt;/a&gt;å¯ä»¥æ–¹ä¾¿æˆ‘ä»¬è¾¾åˆ°ç›®çš„.&lt;/p&gt;
&lt;p&gt;GTKæ˜¯cè¯­è¨€ç¼–å†™çš„æºç¨‹åºï¼Œè¿ç”¨åˆ°fortranéœ€è¦ç›¸åº”çš„åº“è½¬æ¢,åœ¨githubä¸Šæ‰¾åˆ°ä¸€ä¸ª&lt;a href=&#34;https://github.com/jueqingsizhe66/gtk-fortran&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;gtk-fortranåº“&lt;/a&gt;.ä¸‹é¢æ˜¯ubuntuä¸Šé¢çš„æ­å»ºè¿‡ç¨‹(windows æœªå®ç°,å¯ä»¥å‚è€ƒ gtk+makefile)&lt;/p&gt;
&lt;h2 id=&#34;ubuntu-æ­å»º&#34;&gt;Ubuntu æ­å»º&lt;/h2&gt;
&lt;h3 id=&#34;ç¯å¢ƒæ­å»º&#34;&gt;ç¯å¢ƒæ­å»º&lt;/h3&gt;
&lt;p&gt;GTK3+æ˜¯è·¨å¹³å°çš„ï¼Œæ—¢å¯ä»¥åœ¨windowsä¸Šä½¿ç”¨ï¼Œä¹Ÿå¯ä»¥åœ¨linuxä¸Šä½¿ç”¨
ä¸‹é¢çš„ä»£ç å¯ä»¥ç›´æ¥æ‰“åŒ…è¿›ä¸€ä¸ªgtk.shæ–‡ä»¶ï¼Œç›´æ¥è¿è¡Œsh gtk.shè¿›è¡Œå®‰è£…&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#1 åˆšè£…å¥½çš„Ubuntuç³»ç»Ÿä¸­å·²ç»æœ‰GCCäº†ï¼Œä½†æ˜¯è¿™ä¸ªGCCå‡ ä¹ä»€ä¹ˆæ–‡ä»¶éƒ½ä¸èƒ½ç¼–è¯‘ï¼Œå› ä¸ºç¼ºå°‘ä¸€äº›å¿…é¡»çš„å¤´æ–‡ä»¶ï¼Œæ‰€ä»¥è¦å®‰è£…build-essentialè¿™ä¸ªè½¯ä»¶åŒ…
sudo apt-get install build-essential
#2 å®‰è£…GTK/GNOMEå¼€å‘ç¯å¢ƒ  éœ€è¦ä¸‹è½½ä¸€ç³»åˆ—çš„å®‰è£…åŒ…ï¼Œæ—¶é—´æ¯”è¾ƒé•¿
sudo apt-get install gnome-devel gnome-devel-docs 
#3 ç”¨äºåœ¨ç¼–è¯‘GTKç¨‹åºæ—¶è‡ªåŠ¨æ‰¾å‡ºå¤´æ–‡ä»¶åŠåº“æ–‡ä»¶ä½ç½®ã€€ã€€
sudo apt-get install pkg-config
#4å®‰è£… devhelp GTKæ–‡æ¡£æŸ¥çœ‹ç¨‹åº 
sudo apt-get install devhelp
#5å®‰è£… gtk/glib çš„APIå‚è€ƒæ‰‹å†ŒåŠå…¶å®ƒå¸®åŠ©æ–‡æ¡£ 
sudo apt-get install libglib2.0-doc libgtk2.0-doc
#6  å®‰è£…åŸºäºGTKçš„ç•Œé¢GTKæ˜¯å¼€å‘Gnomeçª—å£çš„c/c++è¯­è¨€å›¾å½¢åº“
sudo apt-get install glade libglade2-dev
##æˆ–è€…sudo apt-get install glade-gnome glade-common glade-doc 
#7å®‰è£…gtk3.0 æˆ–è€… å°†gtk+3.0æ‰€éœ€çš„æ‰€æœ‰æ–‡ä»¶ç»Ÿé€šä¸‹è½½å®‰è£…å®Œæ¯• (å®‰è£…æ—¶é—´è¾ƒé•¿)
sudo apt-get install libgtk3*

## æŸ¥çœ‹ä¿¡æ¯
# æŸ¥çœ‹ 2.x ç‰ˆæœ¬ 
#pkg-config --modversion gtk+-3.0 
# æŸ¥çœ‹pkg-configçš„ç‰ˆæœ¬
#$pkg-config -version 
#æŸ¥çœ‹æ˜¯å¦å®‰è£…äº†gtk 
#pkg-config --list-all | grep gtk 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;è¿™ä¸ªæµç¨‹åšå®Œäº†ï¼Œå°±å¯ä»¥è¿›è¡Œgtkæµ‹è¯•,å½“ç„¶ä»…ä»…æ˜¯cè¯­è¨€çš„æµ‹è¯•&lt;/p&gt;
&lt;h3 id=&#34;æµ‹è¯•æ–‡ä»¶&#34;&gt;æµ‹è¯•æ–‡ä»¶&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;//Helloworld.c

#include &amp;lt;gtk/gtk.h&amp;gt;  

int main(int argc,char *argv[])  
{  
    GtkWidget    *window;  
    GtkWidget    *label;  

    gtk_init(&amp;amp;argc,&amp;amp;argv);  

    /* create the main, top level, window */  
    window = gtk_window_new(GTK_WINDOW_TOPLEVEL);  

    /* give it the title */  
    gtk_window_set_title(GTK_WINDOW(window),&amp;quot;Hello World&amp;quot;);  

    /* connect the destroy signal of the window to gtk_main_quit 
     * when the window is about to be destroyed we get a notification and 
     * stop the main GTK+ loop 
     */  
    g_signal_connect(window,&amp;quot;destroy&amp;quot;,G_CALLBACK(gtk_main_quit),NULL);  

    /* create the &amp;quot;Hello, World&amp;quot; label */  
    label = gtk_label_new(&amp;quot;GTKå¯ä»¥è¿è¡Œäº†ï¼&amp;quot;);  

    /* and insert it into the main window */  
    gtk_container_add(GTK_CONTAINER(window),label);  

    /* make sure that everything, window and label, are visible */  
    gtk_widget_show_all(window);  

    /* start the main loop, and let it rest until the application is closed */  
    gtk_main();  

    return 0;  
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;ç¼–è¯‘&#34;&gt;ç¼–è¯‘&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;gcc -o Helloworld Helloworld.c `pkg-config --cflags --libs gtk+-3.0`
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;è¿è¡Œ&#34;&gt;è¿è¡Œ&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;./Helloworld

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;å¦‚æœä½ å¾—åˆ°ä¸€ä¸ªå°çª—å£&amp;quot;GTKå¯ä»¥è¿è¡Œäº†&amp;quot; è¯æ˜ä½ çš„gtkç¯å¢ƒæ˜¯æ­£ç¡®çš„ã€‚&lt;/p&gt;
&lt;p&gt;ç„¶åæˆ‘ä»¬å¼€å§‹è¿›ä¸€æ­¥é…ç½®gtk-fortran&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;ä¸‹è½½
&lt;a href=&#34;https://github.com/jueqingsizhe66/gtk-fortran&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/jueqingsizhe66/gtk-fortran&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;ç¼–è¯‘&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;mkdir build
cd build

åœ¨gtk-fortranç›®å½•ä¸‹ï¼š/home/happycamp-of-fortran/gtk-fortran/build
cmake ..
make 
make install

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ä¼šå¾—åˆ°å¦‚ä¸‹ç»“æœ:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;Install the project...
-- Install configuration: &amp;quot;release&amp;quot;
-- Installing: /usr/local/lib/libgtk-2-fortran.a
-- Installing: /usr/local/lib/libgtk-2-fortran.so.0.1
-- Installing: /usr/local/lib/libgtk-2-fortran.so
-- Installing: /usr/local/include/gtk-2-fortran/atk.mod
-- Installing: /usr/local/include/gtk-2-fortran/cairo.mod
-- Installing: /usr/local/include/gtk-2-fortran/gdk.mod
-- Installing: /usr/local/include/gtk-2-fortran/gdk_pixbuf.mod
-- Installing: /usr/local/include/gtk-2-fortran/g.mod
-- Installing: /usr/local/include/gtk-2-fortran/gtk.mod
-- Installing: /usr/local/include/gtk-2-fortran/gtk_hl.mod
-- Installing: /usr/local/include/gtk-2-fortran/gtk_hl_container.mod
-- Installing: /usr/local/include/gtk-2-fortran/gtk_hl_button.mod
-- Installing: /usr/local/include/gtk-2-fortran/gtk_hl_entry.mod
-- Installing: /usr/local/include/gtk-2-fortran/gtk_hl_tree.mod
-- Installing: /usr/local/include/gtk-2-fortran/gtk_hl_menu.mod
-- Installing: /usr/local/include/gtk-2-fortran/gtk_hl_combobox.mod
-- Installing: /usr/local/include/gtk-2-fortran/gtk_hl_spin_slider.mod
-- Installing: /usr/local/include/gtk-2-fortran/gtk_hl_chooser.mod
-- Installing: /usr/local/include/gtk-2-fortran/gtk_hl_dialog.mod
-- Installing: /usr/local/include/gtk-2-fortran/gtk_hl_progress.mod
-- Installing: /usr/local/include/gtk-2-fortran/gtk_hl_accelerator.mod
-- Installing: /usr/local/include/gtk-2-fortran/gtk_hl_infobar.mod
-- Installing: /usr/local/include/gtk-2-fortran/gtk_hl_assistant.mod
-- Installing: /usr/local/include/gtk-2-fortran/gtk_hl_misc.mod
-- Installing: /usr/local/include/gtk-2-fortran/gtk_draw_hl.mod
-- Installing: /usr/local/include/gtk-2-fortran/gdk_pixbuf_hl.mod
-- Installing: /usr/local/include/gtk-2-fortran/gtk_sup.mod
-- Installing: /usr/local/include/gtk-2-fortran/pango.mod
-- Installing: /usr/local/include/gtk-2-fortran/gdk_events.mod
-- Installing: /usr/local/include/gtk-2-fortran/gtk_os_dependent.mod
-- Installing: /usr/local/bin/gtk-2-fortran-modscan
-- Installing: /usr/local/share/gtk-fortran/gtk-2-fortran-index.csv
-- Installing: /usr/local/share/gtk-fortran/gtk-2-enumerators.lis
-- Installing: /usr/local/lib/pkgconfig/gtk-2-fortran.pc
-- Installing: /usr/local/share/man/man1/gtk-2-fortran-modscan.1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3: æµ‹è¯•è½¯ä»¶
ç„¶åä½ å°±ä¼šå‘ç°
cd åˆ° /home/happycamp-of-fortran/gtk-fortran/examples
ç„¶å&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;root at javazhao-N53SM [19:27:20Ã¤ï¿½ï¿½åˆ] in /home/happycamp-of-fortran/gtk-fortran/examples on git:master?
$ gfortran gtkhello2.f90 -o gtkhello2 `pkg-config --cflags --libs gtk-2-fortran` 

å°±å¯ä»¥äº†. ä¸€å®šè®°ä½åŠ å…¥çš„æ˜¯gtk-2-fortran è¿™ä¸ªåº“ã€‚è€Œä¸æ˜¯gtk+-2.0æˆ–è€…gtk+-3.0,è¿™ä¸¤ä¸ªåº“æ˜¯é’ˆå¯¹cè¯­è¨€çš„ã€‚
$ ./gtkhello2 


&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>makefileç¼–è¯‘fortrançš„module</title>
      <link>https://jueqingsizhe66.github.io/blog/2014/05/14/makefilebian-yi-fortrande-module/</link>
      <pubDate>Wed, 14 May 2014 13:09:20 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/blog/2014/05/14/makefilebian-yi-fortrande-module/</guid>
      <description>&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;FC = gfortran
FFLAGS = -g -Wall -O3 --free-form
modFFLAGS =  --free-form

OPTFC = -O3 -funroll-loops -ftree-vectorize -fcray-pointer -cpp
#src = $(wildcard *.f90)
src = secdmo.f90 record.f90
obj = $(src:.f90=.o )
secd : $(obj)
    $(FC) $(FFLAGS) -o $@ $^

%.o : %.f90
    $(FC) $(modFFLAGS) $(OPTFC) -c $&amp;lt;

#secdmo.mod : secdmo.f
#	$(FC) $(modFFLAGS) @ $&amp;lt;

.phony: clean

clean:
    rm -rf secd secdmo.mod funct.plo accu* fort* ./errdi* *.o

&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>poisson</title>
      <link>https://jueqingsizhe66.github.io/blog/2014/05/14/poisson/</link>
      <pubDate>Wed, 14 May 2014 02:09:00 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/blog/2014/05/14/poisson/</guid>
      <description>&lt;pre&gt;&lt;code class=&#34;language-fortran&#34;&gt;
module decomp_2d_poisson

  use decomp_2d
  use decomp_2d_fft

  use param
  use variables

  implicit none

  private        ! Make everything private unless declared public

!  real(mytype), private, parameter :: PI = 3.14159265358979323846_mytype
!                                   This 0.0_mytype!!!!!!!!!!!!!1111

#ifdef DOUBLE_PREC
  real(mytype), parameter :: epsilon = 1.e-16
#else
  real(mytype), parameter :: epsilon = 1.e-8
#endif

  ! boundary conditions
  integer, save :: bcx, bcy, bcz

  ! decomposition object for physical space
  TYPE(DECOMP_INFO), save :: ph
 
  ! decomposition object for spectral space
  TYPE(DECOMP_INFO), save :: sp

  ! store sine/cosine factors
  real(mytype), save, allocatable, dimension(:) :: az,bz
  real(mytype), save, allocatable, dimension(:) :: ay,by
  real(mytype), save, allocatable, dimension(:) :: ax,bx

  ! wave numbers
  complex(mytype), save, allocatable, dimension(:,:,:) :: kxyz
  !wave numbers for stretching in a pentadiagonal matrice
  complex(mytype), save, allocatable, dimension(:,:,:,:) :: a,a2,a3
  ! work arrays,
  ! naming convention: cw (complex); rw (real);
  !                    1 = X-pencil; 2 = Y-pencil; 3 = Z-pencil
  real(mytype), allocatable, dimension(:,:,:) :: rw1,rw1b,rw2,rw2b,rw3
  complex(mytype), allocatable, dimension(:,:,:) :: cw1,cw1b,cw2,cw22,cw2b,cw2c

  ! underlying FFT library only needs to be initialised once
  logical, save :: fft_initialised = .false.

  public :: decomp_2d_poisson_stg, decomp_2d_poisson_init, &amp;amp;
       decomp_2d_poisson_finalize

  ! For staggered mesh where main variables are defined in the centre of
  ! control volumes while boundary conditions are defined on interfaces
  interface decomp_2d_poisson_stg
     module procedure poisson
  end interface
contains



  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  ! Initialise Poisson solver for given boundary conditions
  !                               given
  !                               given
  !   just for init
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine decomp_2d_poisson_init(bcx1, bcy1, bcz1)

    implicit none

    integer, intent(IN) :: bcx1, bcy1, bcz1
    integer :: nx, ny, nz, i

    bcx = bcx1
    bcy = bcy1
    bcz = bcz1

    nx = nx_global
    ny = ny_global
    nz = nz_global

    ! pressure-grid having 1 fewer point for non-periodic directions
    if (bcx==1) nx=nx-1
    if (bcy==1) ny=ny-1
    if (bcz==1) nz=nz-1

    allocate(ax(nx),bx(nx))
    allocate(ay(ny),by(ny))
    allocate(az(nz),bz(nz))
    call abxyz(ax,ay,az,bx,by,bz,nx,ny,nz,bcx,bcy,bcz)
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!Initialise the ax bx
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!Initialise the ay by
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!Initialise the az bz
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1


    call decomp_info_init(nx, ny, nz, ph)
    call decomp_info_init(nx, ny, nz/2+1, sp)

    ! allocate work space
    if (bcx==0 .and. bcy==0 .and. bcz==0) then
       allocate(cw1(sp%xst(1):sp%xen(1),sp%xst(2):sp%xen(2), &amp;amp;
            sp%xst(3):sp%xen(3)))
       allocate(kxyz(sp%xst(1):sp%xen(1),sp%xst(2):sp%xen(2), &amp;amp;
            sp%xst(3):sp%xen(3)))
       allocate(a(sp%yst(1):sp%yen(1),ny/2,sp%yst(3):sp%yen(3),5))
       allocate(a2(sp%yst(1):sp%yen(1),ny/2,sp%yst(3):sp%yen(3),5))
       allocate(a3(sp%yst(1):sp%yen(1),ny,sp%yst(3):sp%yen(3),5))
       ! (000)  ^c  ^kxyz ^a
    else if (bcx==1 .and. bcy==0 .and. bcz==0) then
       allocate(cw1(sp%xst(1):sp%xen(1),sp%xst(2):sp%xen(2), &amp;amp;
                 sp%xst(3):sp%xen(3)))
       allocate(cw1b(sp%xst(1):sp%xen(1),sp%xst(2):sp%xen(2), &amp;amp;
                 sp%xst(3):sp%xen(3)))
       allocate(rw1(ph%xst(1):ph%xen(1),ph%xst(2):ph%xen(2), &amp;amp;
            ph%xst(3):ph%xen(3)))
       allocate(rw1b(ph%xst(1):ph%xen(1),ph%xst(2):ph%xen(2), &amp;amp;
            ph%xst(3):ph%xen(3)))
       allocate(rw2(ph%yst(1):ph%yen(1),ph%yst(2):ph%yen(2), &amp;amp;
            ph%yst(3):ph%yen(3)))
       allocate(kxyz(sp%xst(1):sp%xen(1),sp%xst(2):sp%xen(2), &amp;amp;
            sp%xst(3):sp%xen(3)))
       allocate(a(sp%yst(1):sp%yen(1),ny/2,sp%yst(3):sp%yen(3),5))
       allocate(a2(sp%yst(1):sp%yen(1),ny/2,sp%yst(3):sp%yen(3),5))
       allocate(a3(sp%yst(1):sp%yen(1),ny,sp%yst(3):sp%yen(3),5))
       !(100)      consist :: cw1 cw1b   rw1   rw1b   rw2    ^a
    else if (bcx==0 .and. bcy==1 .and. bcz==0) then
       allocate(rw2(ph%yst(1):ph%yen(1),ph%yst(2):ph%yen(2), &amp;amp;
            ph%yst(3):ph%yen(3)))
       allocate(rw2b(ph%yst(1):ph%yen(1),ph%yst(2):ph%yen(2), &amp;amp;
            ph%yst(3):ph%yen(3)))
       allocate(cw1(sp%xst(1):sp%xen(1),sp%xst(2):sp%xen(2), &amp;amp;
                 sp%xst(3):sp%xen(3)))
       allocate(cw2(sp%yst(1):sp%yen(1),sp%yst(2):sp%yen(2), &amp;amp;
                 sp%yst(3):sp%yen(3)))
       allocate(cw22(sp%yst(1):sp%yen(1),sp%yst(2):sp%yen(2), &amp;amp;
            sp%yst(3):sp%yen(3)))
       allocate(cw2b(sp%yst(1):sp%yen(1),sp%yst(2):sp%yen(2), &amp;amp;
                 sp%yst(3):sp%yen(3)))
       allocate(cw2c(sp%yst(1):sp%yen(1),sp%yst(2):sp%yen(2), &amp;amp;
                 sp%yst(3):sp%yen(3)))
       allocate(kxyz(sp%yst(1):sp%yen(1),sp%yst(2):sp%yen(2), &amp;amp;
            sp%yst(3):sp%yen(3)))
       allocate(a(sp%yst(1):sp%yen(1),ny/2,sp%yst(3):sp%yen(3),5))
       allocate(a2(sp%yst(1):sp%yen(1),ny/2,sp%yst(3):sp%yen(3),5))
       allocate(a3(sp%yst(1):sp%yen(1),ny,sp%yst(3):sp%yen(3),5))
       !(010)  rw2 rw2b cw2 cw22 cw2b cw2c kxyz  ^a
    else if (bcx==1 .and. bcy==1) then
       allocate(cw1(sp%xst(1):sp%xen(1),sp%xst(2):sp%xen(2), &amp;amp;
                 sp%xst(3):sp%xen(3)))
       allocate(cw1b(sp%xst(1):sp%xen(1),sp%xst(2):sp%xen(2), &amp;amp;
                 sp%xst(3):sp%xen(3)))
       allocate(cw2(sp%yst(1):sp%yen(1),sp%yst(2):sp%yen(2), &amp;amp;
                 sp%yst(3):sp%yen(3)))
       allocate(cw22(sp%yst(1):sp%yen(1),sp%yst(2):sp%yen(2), &amp;amp;
            sp%yst(3):sp%yen(3)))
       allocate(cw2b(sp%yst(1):sp%yen(1),sp%yst(2):sp%yen(2), &amp;amp;
                 sp%yst(3):sp%yen(3)))
       allocate(cw2c(sp%yst(1):sp%yen(1),sp%yst(2):sp%yen(2), &amp;amp;
                 sp%yst(3):sp%yen(3)))
       allocate(rw1(ph%xst(1):ph%xen(1),ph%xst(2):ph%xen(2), &amp;amp;
            ph%xst(3):ph%xen(3)))
       allocate(rw1b(ph%xst(1):ph%xen(1),ph%xst(2):ph%xen(2), &amp;amp;
            ph%xst(3):ph%xen(3)))
       allocate(rw2(ph%yst(1):ph%yen(1),ph%yst(2):ph%yen(2), &amp;amp;
            ph%yst(3):ph%yen(3)))
       allocate(rw2b(ph%yst(1):ph%yen(1),ph%yst(2):ph%yen(2), &amp;amp;
            ph%yst(3):ph%yen(3)))
        !(11*) cw1 cw1b cw2 cw2b  cw2c  rw1 rw1b rw2b
       if (bcz==1) then  
          allocate(rw3(ph%zsz(1),ph%zsz(2),ph%zsz(3)))
       end if
       allocate(kxyz(sp%xst(1):sp%xen(1),sp%xst(2):sp%xen(2), &amp;amp;
            sp%xst(3):sp%xen(3)))    
       allocate(a(sp%yst(1):sp%yen(1),ny/2,sp%yst(3):sp%yen(3),5))
       allocate(a2(sp%yst(1):sp%yen(1),ny/2,sp%yst(3):sp%yen(3),5))
       allocate(a3(sp%yst(1):sp%yen(1),nym,sp%yst(3):sp%yen(3),5))      
       !(111) rw3  kxyz  ^a
    end if

    call waves()

    return
  end subroutine decomp_2d_poisson_init


  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  ! Release memory used by Poisson solver
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine decomp_2d_poisson_finalize

    implicit none

    deallocate(ax,bx,ay,by,az,bz)

    call decomp_info_finalize(ph)
    call decomp_info_finalize(sp)

    call decomp_2d_fft_finalize
    fft_initialised = .false.

    deallocate(kxyz)

    if (bcx==0 .and. bcy==0 .and. bcz==0) then
       deallocate(cw1)
       ! (000) cw1
    else if (bcx==1 .and. bcy==0 .and. bcz==0) then
       deallocate(cw1,cw1b,rw1,rw1b,rw2)
       ! (100)   cw1 cw1b rw1 rw1b rw2
    else if (bcx==0 .and. bcy==1 .and. bcz==0) then
       deallocate(cw1,cw2,cw2b,rw2,rw2b)
       ! (010)   cw1 cw2  cw2b  rw2 rw2b
    else if (bcx==1 .and. bcy==1) then
       deallocate(cw1,cw1b,cw2,cw2b,rw1,rw1b,rw2,rw2b)
       ! (11*)   cw1,cw1b,cw2,cw2b,rw1,rw1b,rw2,rw2b
       if (bcz==1) then
          deallocate(rw3)
        !(111)    rw3
       end if
    end if

    return
  end subroutine decomp_2d_poisson_finalize


  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  ! Top level wrapper
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine poisson(rhs, bcx, bcy, bcz)

    implicit none

    real(mytype), dimension(:,:,:), intent(INOUT) :: rhs
    integer, intent(IN) :: bcx, bcy, bcz  ! boundary conditions
    integer :: i

    if (bcx==0 .and. bcy==0 .and. bcz==0) then
       call poisson_000(rhs)
    else if (bcx==1 .and. bcy==0 .and. bcz==0) then
       call poisson_100(rhs)
    else if (bcx==0 .and. bcy==1 .and. bcz==0) then
       call poisson_010(rhs)
    else if (bcx==1 .and. bcy==1) then   ! 110 &amp;amp; 111
       call poisson_11x(rhs, bcz)
    else
       stop &#39;boundary condition not supported&#39;
    end if

    return
  end subroutine poisson


  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  ! Solving 3D Poisson equation with periodic B.C in all 3 dimensions
  !                                                      3
  !                                                      3
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine poisson_000(rhs)

    use derivX
    use derivY
    use derivZ

    ! right-hand-side of Poisson as input
    ! solution of Poisson as output
    real(mytype), dimension(:,:,:), intent(INOUT) :: rhs

    integer, dimension(3) :: fft_start, fft_end, fft_size

    complex(mytype) :: xyzk

    complex(mytype) :: ytt,xtt,ztt,yt1,xt1,yt2,xt2
    complex(mytype) :: xtt1,ytt1,ztt1,zt1,zt2


    real(mytype) :: tmp1, tmp2,x ,y, z
    
    integer :: nx,ny,nz, i,j,k

    nx = nx_global
    ny = ny_global
    nz = nz_global

    if (.not. fft_initialised) then
       call decomp_2d_fft_init(PHYSICAL_IN_Z)
       fft_initialised = .true.
    end if

    ! compute r2c transform   r2c:real to complex by zhaoliang
    ! cw1 is 3dim data structrue
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !!!!! only fft to transform the real data to complex data while (100) twice
    !!!!! one is tranform and then fft  (you can see poisson100
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    call decomp_2d_fft_3d(rhs,cw1)
    

    ! normalisation
    !  why this below is called normalisation ??????  just divide 3dim grid number
    cw1 = cw1 / real(nx, kind=mytype) /real(ny, kind=mytype) &amp;amp;
         / real(nz, kind=mytype)

    do k = sp%xst(3),sp%xen(3)
       do j = sp%xst(2),sp%xen(2)
          do i = sp%xst(1),sp%xen(1)

             ! post-processing in spectral space

             !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
             !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
             !!!!!!!!!!!!!!!!!post-processing in 3-direction can be
             !!!!!!!!!!!!!!!!! set in the same cycle,because they are
             !!!!!!!!!!!!!!!!!! similar
             !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
             !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

             ! POST PROCESSING IN Z
             tmp1 = real(cw1(i,j,k), kind=mytype)   !  get the real number of cw1
             tmp2 = aimag(cw1(i,j,k))               !  get the imagenumber of cw1
             cw1(i,j,k) = cmplx(tmp1*bz(k)+tmp2*az(k), &amp;amp;
                  tmp2*bz(k)-tmp1*az(k), kind=mytype)   ! modify the cw1 in the spectral space Z
                                                    !  bz  az
                                                    !  by  ay
                                                    !  bx  ax

             ! POST PROCESSING IN Y
             tmp1 = real(cw1(i,j,k), kind=mytype)
             tmp2 = aimag(cw1(i,j,k))
             cw1(i,j,k) = cmplx(tmp1*by(j)+tmp2*ay(j), &amp;amp;
                  tmp2*by(j)-tmp1*ay(j), kind=mytype)
             if (j.gt.(ny/2+1)) cw1(i,j,k)=-cw1(i,j,k)   ! why should be axisymmetry!

             ! POST PROCESSING IN X
             tmp1 = real(cw1(i,j,k), kind=mytype)
             tmp2 = aimag(cw1(i,j,k))
             cw1(i,j,k) = cmplx(tmp1*bx(i)+tmp2*ax(i), &amp;amp;
                  tmp2*bx(i)-tmp1*ax(i), kind=mytype)
             if (i.gt.(nx/2+1)) cw1(i,j,k)=-cw1(i,j,k)

             !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
             !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
             !!!!!!!!!!!!!!! Solve Poisson
             !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
             !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

             tmp1=real(kxyz(i,j,k), kind=mytype)
             tmp2=aimag(kxyz(i,j,k))
             ! CANNOT DO A DIVISION BY ZERO
             !  Yes ! division  by zero is impossible!!!-----------------------------------&amp;lt;
             if ((tmp1.lt.epsilon).or.(tmp2.lt.epsilon)) then   !epsilon?  what does it mean?
                cw1(i,j,k)=0._mytype
!                print *,&#39;DIV 0&#39;,i,j,k,epsilon
             else
                cw1(i,j,k)=cmplx( real(cw1(i,j,k), kind=mytype) / (-tmp1), &amp;amp;
                     aimag(cw1(i,j,k))/(-tmp2), kind=mytype)
             end if

           !Print result in spectal space after Poisson
      !     if (abs(out(i,j,k)) &amp;gt; 1.0e-4) then
      !        write(*,*) &#39;AFTER&#39;,i,j,k,out(i,j,k),xyzk
      !     end if


             !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
             !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
             ! post-processing backward
             !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
             !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
             
             ! POST PROCESSING IN Z
             tmp1 = real(cw1(i,j,k), kind=mytype)
             tmp2 = aimag(cw1(i,j,k))
             cw1(i,j,k) = cmplx(tmp1*bz(k)-tmp2*az(k), &amp;amp;
                  -tmp2*bz(k)-tmp1*az(k), kind=mytype)
              !                                          bz    az
              !                                          by    ay
              !                                          bx    ax

             ! POST PROCESSING IN Y
             tmp1 = real(cw1(i,j,k), kind=mytype)
             tmp2 = aimag(cw1(i,j,k))
             cw1(i,j,k) = cmplx(tmp1*by(j)+tmp2*ay(j), &amp;amp;
                  tmp2*by(j)-tmp1*ay(j), kind=mytype)
             if (j.gt.(ny/2+1)) cw1(i,j,k)=-cw1(i,j,k)

             ! POST PROCESSING IN X
             tmp1 = real(cw1(i,j,k), kind=mytype)
             tmp2 = aimag(cw1(i,j,k))
             cw1(i,j,k) = cmplx(tmp1*bx(i)+tmp2*ax(i), &amp;amp;
                  -tmp2*bx(i)+tmp1*ax(i), kind=mytype)
             if (i.gt.(nx/2+1)) cw1(i,j,k)=-cw1(i,j,k)

          end do
       end do
    end do
             
    ! compute c2r transform
    call decomp_2d_fft_3d(cw1,rhs)    !  from complex  to real!
    
 !   call decomp_2d_fft_finalize

    return
  end subroutine poisson_000


  subroutine poisson_100(rhs)
      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      !!!! get the rhs and then modify rhs ,at last return the rhs
      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


    implicit none

    real(mytype), dimension(:,:,:), intent(INOUT) :: rhs

    complex(mytype) :: xyzk
    real(mytype) :: tmp1, tmp2, tmp3, tmp4
    real(mytype) :: xx1,xx2,xx3,xx4,xx5,xx6,xx7,xx8
    
    integer :: nx,ny,nz, i,j,k, itmp
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !!!!  8 transform   from x --&amp;gt;y --&amp;gt;z then z--&amp;gt; y ---&amp;gt;x at the beginning
    !!!!!!!!!!!!!!!!!!from x --&amp;gt;y --&amp;gt;z then z--&amp;gt; y ---&amp;gt;x at the endding
    !!!!!  (100 add 8 more transform than 000) while 000 is 0 transform
    !!!!!  so rhs is in the z pencil ,no there are not z pencil at all!
    !!!!!   the program is  2-dim pm*pn decomp !  so only  xpencil and y pencil
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

                   !!!!!!!!!!!!!!twice real to complex
                     !!!!!!!!!!! 1: transform rhs-rw2-rw1
                     !!!!!!!!!!! 2: fft       rhs-----rw1
                   !!!!!!!!!!!!!!twice complex to real
                     !!!!!!!!!!! 1: transfrom rw1-rw2--rhs
                     !!!!!!!!!!! 2: fft       rw1------rhs
                   !!!!!!!!!!!!! post-processing operations is under the complex condition
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !!!!!!!!!!!!   input real rhs(:.:,:) in the z pencil
    !!!!!!!!!!!!   2+2 transform    |destination: modify the rhs
    !!!!!!!!!!!!   1 normalisation
    !!!!!!!!!!!!   1 FFT forward
    !!!!!!!!!!!!   3 post-processing   z--&amp;gt;y---&amp;gt;x  direction not pencil
    !!!!!!!!!!!!   1 poisson solver
    !!!!!!!!!!!!   3 post-processing backward  x---&amp;gt;y----&amp;gt;z  direction
    !!!!!!!!!!!!   1 FFT backward
    !!!!!!!!!!!!   2+2 transform    |destination: modify the rhs
    !!!!!!!!!!!!   output real rhs(:,:,:)  in the z pencil
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

100 format(1x,a8,3I4,2F12.6)

    nx = nx_global - 1
    ny = ny_global
    nz = nz_global

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1
    ! rhs is in Z-pencil(wrong!There isn&#39;t Z pencil)(wrong
      !again, there is Z pencil))but requires global operations in X
    ! why should do the transpose!!!!!!!!!!!!!!
       ! why in the poisson_000 is not needed!???????????????
    !   two steps to change from z to x
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1

    call transpose_z_to_y(rhs,rw2,ph)  ! z pencil in y pencil but in the physical space
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!rw2 is the complex 3-dim data the same as rw1
    call transpose_y_to_x(rw2,rw1,ph)
    do k=ph%xst(3),ph%xen(3)
       do j=ph%xst(2),ph%xen(2)
          do i=1,nx/2
              !!! rw1  rw1b   1 means  x pencil   
              !!! rw2  rw2b   2 means  y pencil
             rw1b(i,j,k)=rw1(2*(i-1)+1,j,k)  ! the odd terms  is for the half before
          enddo
          do i=nx/2+1,nx
             rw1b(i,j,k)=rw1(2*nx-2*i+2,j,k)  ! the reverse terms is for the half after
          enddo
       enddo
    end do

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!11
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!11
    !!!!3 layers data
    !!!! rw1b is the top lay data  xpencil     physical space
    !!!! rw2  is in the middle lay data   y pencil   physical space
    !!!! rw1 rhs  is in the outer lay data    z pencil  spectral space
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!11
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!11

    call transpose_x_to_y(rw1b,rw2,ph)    ! let x pencil rw1b to y pencil
    call transpose_y_to_z(rw2,rhs,ph)     ! let y pencil rw2 to  z pencil&#39;s rhs
    !!!!!!!!!!!!first time get what we want

    if (.not. fft_initialised) then
       call decomp_2d_fft_init(PHYSICAL_IN_Z,nx,ny,nz)
       fft_initialised = .true.
    end if

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    ! compute r2c transform
    !           why should force the before pre-posting   ------------------------------&amp;lt;&amp;lt;&amp;lt;&amp;lt;
    !!!!!!!!!the most key operation :::: the fft operator: decomp_2d_fft_3d
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    call decomp_2d_fft_3d(rhs,cw1)  !  from real to complex!  and begin poission solver

    
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! in the z pencil we did the fft transform
        !!!!!!!!!!!!!!!!!! so cw1 is 3d complex data ,yeah (:,:,:)
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!



    ! normalisation
    cw1 = cw1 / real(nx, kind=mytype) /real(ny, kind=mytype) &amp;amp;
         / real(nz, kind=mytype)
#ifdef DEBUG
    do k = sp%xst(3),sp%xen(3)
       do j = sp%xst(2),sp%xen(2)
          do i = sp%xst(1),sp%xen(1)
             if (abs(cw1(i,j,k)) &amp;gt; 1.0e-4) then
                write(*,100) &#39;START&#39;,i,j,k,cw1(i,j,k)
             end if
          end do
       end do
    end do
#endif

    ! post-processing in spectral space

    ! POST PROCESSING IN Z
    do k = sp%xst(3),sp%xen(3)
       do j = sp%xst(2),sp%xen(2)
          do i = sp%xst(1),sp%xen(1)
             tmp1 = real(cw1(i,j,k), kind=mytype)
             tmp2 = aimag(cw1(i,j,k))
             cw1(i,j,k) = cmplx(tmp1*bz(k)+tmp2*az(k), &amp;amp;
                  tmp2*bz(k)-tmp1*az(k), kind=mytype)
#ifdef DEBUG
             if (abs(cw1(i,j,k)) &amp;gt; 1.0e-4) &amp;amp;
                  write(*,100) &#39;after z&#39;,i,j,k,cw1(i,j,k)
#endif
          end do
       end do
    end do

    ! POST PROCESSING IN Y
    do k = sp%xst(3),sp%xen(3)
       do j = sp%xst(2),sp%xen(2)
          do i = sp%xst(1),sp%xen(1)
             tmp1 = real(cw1(i,j,k), kind=mytype)
             tmp2 = aimag(cw1(i,j,k))
             cw1(i,j,k) = cmplx(tmp1*by(j)+tmp2*ay(j), &amp;amp;
                  tmp2*by(j)-tmp1*ay(j), kind=mytype)
             if (j.gt.(ny/2+1)) cw1(i,j,k)=-cw1(i,j,k)
#ifdef DEBUG
             if (abs(cw1(i,j,k)) &amp;gt; 1.0e-4) &amp;amp;
                  write(*,100) &#39;after y&#39;,i,j,k,cw1(i,j,k)
#endif
          end do
       end do
    end do

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!because (100)
                   !!!!!!!!!!!!!!!!!!!!!so the post processing in x is different
                   !!!!!!!!!!!!!!!!!!!!!from the  y and z
    ! POST PROCESSING IN X
    do k = sp%xst(3),sp%xen(3)
       do j = sp%xst(2),sp%xen(2)
          cw1b(1,j,k)=cw1(1,j,k)
          do i = 2,nx
             tmp1 = real(cw1(i,j,k), kind=mytype)
             tmp2 = aimag(cw1(i,j,k))
             tmp3 = real(cw1(nx-i+2,j,k), kind=mytype) !!! the 2~nx
             tmp4 = aimag(cw1(nx-i+2,j,k))    !!!!!!!!!!!!     2~nx
             xx1=tmp1*bx(i)/2._mytype
             xx2=tmp1*ax(i)/2._mytype
             xx3=tmp2*bx(i)/2._mytype
             xx4=tmp2*ax(i)/2._mytype
             xx5=tmp3*bx(i)/2._mytype
             xx6=tmp3*ax(i)/2._mytype
             xx7=tmp4*bx(i)/2._mytype
             xx8=tmp4*ax(i)/2._mytype
             cw1b(i,j,k) = cmplx(xx1+xx4+xx5-xx8,-xx2+xx3+xx6+xx7, &amp;amp;
                  kind=mytype)  
          end do
       end do
    end do
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !  While  you set the -Debug in the compile period
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

#ifdef DEBUG
    do k = sp%xst(3),sp%xen(3)
       do j = sp%xst(2),sp%xen(2)
          do i = sp%xst(1),sp%xen(1)
             if (abs(cw1b(i,j,k)) &amp;gt; 1.0e-4) then
                write(*,100) &#39;after x&#39;,i,j,k,cw1b(i,j,k)
             end if
          end do
       end do
    end do
#endif
!!!!!!!!!!!!!!!!!!!!!from now on, the cw1b in x,y,z direction(not pencil)
!!!!!!!!!!!!!!!!!!!!is calculated ,so now you can calculate cw1b in the
!!!!!!!!!!!!!!!!!!!!!!! poisson condition ,yes poisson solver

    ! Solve Poisson
    do k = sp%xst(3),sp%xen(3)
       do j = sp%xst(2),sp%xen(2)
          do i = sp%xst(1),sp%xen(1)
             !tmp1=real(zk2(k)+yk2(j)+xk2(i), kind=mytype)
             !tmp2=aimag(zk2(k)+yk2(j)+xk2(i))
             tmp1=real(kxyz(i,j,k), kind=mytype)
             tmp2=aimag(kxyz(i,j,k))
             !xyzk=cmplx(tmp1,tmp2, kind=mytype)
             ! CANNOT DO A DIVISION BY ZERO
! yes
             if ((abs(tmp1).lt.epsilon).and.(abs(tmp2).lt.epsilon)) then    
                cw1b(i,j,k)=cmplx(0._mytype,0._mytype, kind=mytype)
             end if
             if ((abs(tmp1).lt.epsilon).and.(abs(tmp2).ge.epsilon)) then
                cw1b(i,j,k)=cmplx(0._mytype, &amp;amp;
                     aimag(cw1b(i,j,k))/(-tmp2), kind=mytype)
             end if
             if ((abs(tmp1).ge.epsilon).and.(abs(tmp2).lt.epsilon)) then    
                cw1b(i,j,k)=cmplx( real(cw1b(i,j,k), kind=mytype) &amp;amp;
                     /(-tmp1), 0._mytype, kind=mytype)
             end if
             !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
             !!!!!!!!!!!!!!!!!!the most dayly processing
             !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
             if ((abs(tmp1).ge.epsilon).and.(abs(tmp2).ge.epsilon)) then
                cw1b(i,j,k)=cmplx( real(cw1b(i,j,k), kind=mytype) &amp;amp;
                     /(-tmp1), &amp;amp;
                     aimag(cw1b(i,j,k))/(-tmp2), kind=mytype)
             end if
#ifdef DEBUG
             if (abs(cw1b(i,j,k)) &amp;gt; 1.0e-4) &amp;amp;
                  write(*,100) &#39;AFTER&#39;,i,j,k,cw1b(i,j,k)
#endif
          end do
       end do
    end do
    
    ! post-processing backward

!!!!!!!!!!!!!!!!!!!!!!  You know cw1b is the cw1&#39;s another form in the spectral
!!!!!!!!!!!!!!!!!!!!!! space ,so you need to change the spetral space to physical
!!!!!!!!!!!!!!!!!!!!!!! space again ,yes get the cw1
!!!!!!!!!!!!!!!!!!!!!!!! from now on ,you will found that the calculate of poisson
!!!!!!!!!!!!!!!!!!!!!!!! equation is in the spectral space ,from the fft,then 3 post
!!!!!!!!!!!!!!!!!!!!!!!!!! processing in x,y,z 3 directions, then calculate the  poisson
!!!!!!!!!!!!!!!!!!!!!!!!!! equation. OK,then you start next!
    ! POST PROCESSING IN X
    do k = sp%xst(3),sp%xen(3)
       do j = sp%xst(2),sp%xen(2)
          cw1(1,j,k)=cw1b(1,j,k)
          do i = 2,nx
             tmp1 = real(cw1b(i,j,k), kind=mytype)
             tmp2 = aimag(cw1b(i,j,k))
             tmp3 = real(cw1b(nx-i+2,j,k), kind=mytype)
             tmp4 = aimag(cw1b(nx-i+2,j,k))
             xx1=tmp1*bx(i)
             xx2=tmp1*ax(i)
             xx3=tmp2*bx(i)
             xx4=tmp2*ax(i)
             xx5=tmp3*bx(i)
             xx6=tmp3*ax(i)
             xx7=tmp4*bx(i)
             xx8=tmp4*ax(i)
             cw1(i,j,k) = cmplx(xx1-xx4+xx6+xx7,-(-xx2-xx3+xx5-xx8), &amp;amp;
                  kind=mytype)        
              !!!!!the buterfly algorithm!!!!!!!!!!!!!!!!!!!!!!!
          end do
       end do
    end do
    !!!!!!!!!!!!!!!!!!!!!!!from now on x direction ,the spectral data has been transform to
    !!!!!!!!!!!!!!!!!!!!!!!! physical space, but still the complex
#ifdef DEBUG
    do k = sp%xst(3),sp%xen(3)
       do j = sp%xst(2),sp%xen(2)
          do i = sp%xst(1),sp%xen(1)
             if (abs(cw1(i,j,k)) &amp;gt; 1.0e-4) then
                write(*,100) &#39;AFTER X&#39;,i,j,k,cw1(i,j,k)
             end if
          end do
       end do
    end do
#endif

    ! POST PROCESSING IN Y
    do k = sp%xst(3),sp%xen(3)
       do j = sp%xst(2),sp%xen(2)
          do i = sp%xst(1),sp%xen(1)
             tmp1 = real(cw1(i,j,k), kind=mytype)
             tmp2 = aimag(cw1(i,j,k))
             cw1(i,j,k) = cmplx(tmp1*by(j)-tmp2*ay(j), &amp;amp;
                  tmp2*by(j)+tmp1*ay(j), kind=mytype)
             if (j.gt.(ny/2+1)) cw1(i,j,k)=-cw1(i,j,k)
#ifdef DEBUG
             if (abs(cw1(i,j,k)) &amp;gt; 1.0e-4) &amp;amp;
                  write(*,100) &#39;AFTER Y&#39;,i,j,k,cw1(i,j,k)
#endif
          end do
       end do
    end do

                                    !!!!!!!!!!!!!!!!!!!!!! by  ay
                                    !!!!!!!!!!!!!!!!!!!!!! bz  az
    ! POST PROCESSING IN Z
    do k = sp%xst(3),sp%xen(3)
       do j = sp%xst(2),sp%xen(2)
          do i = sp%xst(1),sp%xen(1)
             tmp1 = real(cw1(i,j,k), kind=mytype)
             tmp2 = aimag(cw1(i,j,k))
             cw1(i,j,k) = cmplx(tmp1*bz(k)-tmp2*az(k), &amp;amp;
                  tmp2*bz(k)+tmp1*az(k), kind=mytype)
#ifdef DEBUG
             if (abs(cw1(i,j,k)) &amp;gt; 1.0e-4) &amp;amp;
                  write(*,100) &#39;END&#39;,i,j,k,cw1(i,j,k)
#endif
          end do
       end do
    end do

    ! compute c2r transform
    call decomp_2d_fft_3d(cw1,rhs)

    ! rhs is in Z-pencil but requires global operations in X
    call transpose_z_to_y(rhs,rw2,ph)
    call transpose_y_to_x(rw2,rw1,ph)
    do k=ph%xst(3),ph%xen(3)
       do j=ph%xst(2),ph%xen(2)
          do i=1,nx/2
             rw1b(2*i-1,j,k)=rw1(i,j,k)   ! the odd terms is setted!
          enddo
          do i=1,nx/2
             rw1b(2*i,j,k)=rw1(nx-i+1,j,k)  ! the even terms is setted
          enddo
       enddo
    end do
    call transpose_x_to_y(rw1b,rw2,ph)
    call transpose_y_to_z(rw2,rhs,ph)
!!!!!!!!!!!!!the finally outcome rhs
    
  !  call decomp_2d_fft_finalize

    return
  end subroutine poisson_100

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!Neumann!!!!!!!!!!!!!!!!!!!!!!!!!!!111
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  ! Solving 3D Poisson equation: Neumann in Y; periodic in X &amp;amp; Z
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine poisson_010(rhs)

    implicit none

    real(mytype), dimension(:,:,:), intent(INOUT) :: rhs

    complex(mytype) :: xyzk
    real(mytype) :: tmp1, tmp2, tmp3, tmp4
    real(mytype) :: xx1,xx2,xx3,xx4,xx5,xx6,xx7,xx8

    integer :: nx,ny,nz, i,j,k

100 format(1x,a8,3I4,2F12.6)

    nx = nx_global
    ny = ny_global - 1  ! (010)  so have fewer1 ny!
    nz = nz_global

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!so if (11*)  you need to ?what pencil??????
    !!!!??
    ! rhs is in Z-pencil but requires global operations in Y  because(010)

                   !!!!!!!!!!!!!!twice real to complex
                     !!!!!!!!!!! 1: transform rhs-rw2-rw1
                     !!!!!!!!!!! 2: fft       rhs-----rw1
                   !!!!!!!!!!!!!!twice complex to real
                     !!!!!!!!!!! 1: transfrom rw1-rw2--rhs
                     !!!!!!!!!!! 2: fft       rw1------rhs
                   !!!!!!!!!!!!! post-processing operations is under the complex condition
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !!!!!!!!!!!!   input real rhs(:.:,:) in the z pencil
    !!!!!!!!!!!!   1+1 transform  z-&amp;gt;y y-&amp;gt;z  |destination: modify the rhs  because z-y=1  rather than z-x=2
    !!!!!!!!!!!!   1 normalisation
    !!!!!!!!!!!!   1 FFT forward
    !!!!!!!!!!!!   2 post-processing   z--&amp;gt;x  direction not pencil
    !!!!!!!!!!!!   1 transform z-y
    !!!!!!!!!!!!   1 post-processing   y
    !!!!!!!!!!!!   1 poisson solver
    !!!!!!!!!!!!   1 matrice_refinement
    !!!!!!!!!!!!   3 inversion5_v1  inversion5_v2
    !!!!!!!!!!!!   1 post-processing backward  Y
    !!!!!!!!!!!!   1 transform y-z
    !!!!!!!!!!!!   2 post-processing backward  x----&amp;gt;z  direction
    !!!!!!!!!!!!   1 FFT backward
    !!!!!!!!!!!!   1+1 transform    |destination: modify the rhs
    !!!!!!!!!!!!   output real rhs(:,:,:)  in the z pencil
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                   !!!!!!!!!!!!!!!!!!so the key factor  a  a2  a3    ax bx
                   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ay by
                   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! az bz

    call transpose_z_to_y(rhs,rw2,ph)
    do k=ph%yst(3),ph%yen(3)
       do i=ph%yst(1),ph%yen(1)
          do j=1,ny/2
             rw2b(i,j,k)=rw2(i,2*(j-1)+1,k)
          enddo
          do j=ny/2+1,ny
             rw2b(i,j,k)=rw2(i,2*ny-2*j+2,k)
          enddo
       enddo
    end do
    call transpose_y_to_z(rw2b,rhs,ph)

    if (.not. fft_initialised) then
       call decomp_2d_fft_init(PHYSICAL_IN_Z,nx,ny,nz)
       fft_initialised = .true.
    end if
    ! compute r2c transform
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    call decomp_2d_fft_3d(rhs,cw1)
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    ! normalisation
    cw1 = cw1 / real(nx, kind=mytype) /real(ny, kind=mytype) &amp;amp;
         / real(nz, kind=mytype)
#ifdef DEBUG
    do k = sp%xst(3),sp%xen(3)
       do j = sp%xst(2),sp%xen(2)
          do i = sp%xst(1),sp%xen(1)
             if (abs(cw1(i,j,k)) &amp;gt; 1.0e-4) then
                write(*,100) &#39;START&#39;,i,j,k,cw1(i,j,k)
             end if
          end do
       end do
    end do
#endif

    ! post-processing in spectral space

    ! POST PROCESSING IN Z
    do k = sp%xst(3),sp%xen(3)
       do j = sp%xst(2),sp%xen(2)
          do i = sp%xst(1),sp%xen(1)
             tmp1 = real(cw1(i,j,k), kind=mytype)
             tmp2 = aimag(cw1(i,j,k))
             cw1(i,j,k) = cmplx(tmp1*bz(k)+tmp2*az(k), &amp;amp;
                  tmp2*bz(k)-tmp1*az(k), kind=mytype)
#ifdef DEBUG
             if (abs(cw1(i,j,k)) &amp;gt; 1.0e-4) &amp;amp;
                  write(*,100) &#39;after z&#39;,i,j,k,cw1(i,j,k)
#endif
          end do
       end do
    end do

    ! POST PROCESSING IN X
    do k = sp%xst(3),sp%xen(3)
       do j = sp%xst(2),sp%xen(2)
          do i = sp%xst(1),sp%xen(1)
             tmp1 = real(cw1(i,j,k), kind=mytype)
             tmp2 = aimag(cw1(i,j,k))
             cw1(i,j,k) = cmplx(tmp1*bx(i)+tmp2*ax(i), &amp;amp;
                  tmp2*bx(i)-tmp1*ax(i), kind=mytype)
             if (i.gt.(nx/2+1)) cw1(i,j,k)=-cw1(i,j,k)
#ifdef DEBUG
             if (abs(cw1(i,j,k)) &amp;gt; 1.0e-4) &amp;amp;
                  write(*,100) &#39;after x&#39;,i,j,k,cw1(i,j,k)
#endif
          end do
       end do
    end do
    
    ! POST PROCESSING IN Y
    ! NEED TO BE IN Y PENCILS!!!!!!!!!!!!!!!
    !!!!!!!!!!!!!!!!!!!!!sp!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    call transpose_x_to_y(cw1,cw2,sp)

    !!!!!!!!!!!!!!!!!!!!!sp!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    do k = sp%yst(3), sp%yen(3)
       do i = sp%yst(1), sp%yen(1)
          cw2b(i,1,k)=cw2(i,1,k)
          do j = 2,ny      
             tmp1 = real(cw2(i,j,k), kind=mytype)
             tmp2 = aimag(cw2(i,j,k))
             tmp3 = real(cw2(i,ny-j+2,k), kind=mytype)
             tmp4 = aimag(cw2(i,ny-j+2,k))
             xx1=tmp1*by(j)/2._mytype
             xx2=tmp1*ay(j)/2._mytype
             xx3=tmp2*by(j)/2._mytype
             xx4=tmp2*ay(j)/2._mytype
             xx5=tmp3*by(j)/2._mytype
             xx6=tmp3*ay(j)/2._mytype
             xx7=tmp4*by(j)/2._mytype
             xx8=tmp4*ay(j)/2._mytype
             cw2b(i,j,k) = cmplx(xx1+xx4+xx5-xx8,-xx2+xx3+xx6+xx7, &amp;amp;
                  kind=mytype)
          end do
       end do
    end do
#ifdef DEBUG
    do k = sp%yst(3), sp%yen(3)
       do j = sp%yst(2), sp%yen(2)
          do i = sp%yst(1), sp%yen(1)
             if (abs(cw2b(i,j,k)) &amp;gt; 1.0e-4) then
                write(*,100) &#39;after y&#39;,i,j,k,cw2b(i,j,k)
                print *,kxyz(i,j,k)
             end if
          end do
       end do
    end do
#endif

    if (istret==0) then

    ! Solve Poisson
    ! doing wave number division in Y-pencil
    do k = sp%yst(3), sp%yen(3)
       do j = sp%yst(2), sp%yen(2)
          do i = sp%yst(1), sp%yen(1)
             !tmp1=real(zk2(k)+yk2(j)+xk2(i), kind=mytype)
             !tmp2=aimag(zk2(k)+yk2(j)+xk2(i))
             tmp1=real(kxyz(i,j,k), kind=mytype)
             tmp2=aimag(kxyz(i,j,k))
             !xyzk=cmplx(tmp1,tmp2, kind=mytype)
             !CANNOT DO A DIVISION BY ZERO
             if ((abs(tmp1).lt.epsilon).and.(abs(tmp2).lt.epsilon)) then    
                cw2b(i,j,k)=cmplx(0._mytype,0._mytype, kind=mytype)
             end if
             if ((abs(tmp1).lt.epsilon).and.(abs(tmp2).ge.epsilon)) then
                cw2b(i,j,k)=cmplx(0._mytype, &amp;amp;
                     aimag(cw2b(i,j,k))/(-tmp2), kind=mytype)
             end if
             if ((abs(tmp1).ge.epsilon).and.(abs(tmp2).lt.epsilon)) then    
                cw2b(i,j,k)=cmplx( real(cw2b(i,j,k), kind=mytype) &amp;amp;
                     /(-tmp1), 0._mytype, kind=mytype)
             end if
             if ((abs(tmp1).ge.epsilon).and.(abs(tmp2).ge.epsilon)) then
                cw2b(i,j,k)=cmplx( real(cw2b(i,j,k), kind=mytype) &amp;amp;
                     /(-tmp1), &amp;amp;
                     aimag(cw2b(i,j,k))/(-tmp2), kind=mytype)
             end if
          end do
       end do
    end do

    else
       
        !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
       call matrice_refinement()
        !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!       do k = sp%yst(3), sp%yen(3)
!          do j = 1,ny/2
!             do i = sp%yst(1), sp%yen(1)
!                print *,i,j,k,a(i,j,k,3)
!!                if (nrank.le.1) print *,i,j,k,a(i,j,k,3)
!!                if (nrank.gt.1) print *,i+4,j,k,a(i,j,k,3)
!             enddo
!          enddo
!       enddo
     


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!istret  !=3
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
       if (istret.ne.3) then
          cw2(:,:,:)=0.;cw2c(:,:,:)=0.
          do k = sp%yst(3), sp%yen(3)
          do j = 1,ny/2
          do i = sp%yst(1), sp%yen(1)
             cw2(i,j,k)=cw2b(i,2*j-1,k)
             cw2c(i,j,k)=cw2b(i,2*j,k)
          enddo
          enddo
          enddo

 !   do k = sp%yst(3), sp%yen(3)
 !      do j = 1,ny/2
 !         do i = sp%yst(1), sp%yen(1)
 !            if (abs(cw2(i,j,k)) &amp;gt; 1.0e-4) then
 !               write(*,*) &#39;before IN&#39;,i,j,k,cw2(i,j,k)!*2.
 !!            end if
  !        end do
  !     end do
  !  end do
          
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!for the strech  grid!!!!!!!!!!!!!!!!!!!!!!!
         call inversion5_v1(a,cw2,sp)
         call inversion5_v1(a2,cw2c,sp)

!         cw2(1,1,1)=cw2(1,1,1)*0.5
         
 
!   do k = sp%yst(3), sp%yen(3)
!       do j = 1,ny/2
!          do i = sp%yst(1), sp%yen(1)
!             if (abs(cw2c(i,j,k)) &amp;gt; 1.0e-4) then
!                write(*,*) &#39;after IN&#39;,i,j,k,cw2c(i,j,k)!*2.
!             end if
!          end do
!       end do
!    end do

          cw2b(:,:,:)=0.
          do k=sp%yst(3), sp%yen(3)
          do j=1,ny-1,2
          do i=sp%yst(1), sp%yen(1)
             cw2b(i,j,k)=cw2(i,(j+1)/2,k)
          enddo
          enddo
          do j=2,ny,2
          do i=sp%yst(1), sp%yen(1)
             cw2b(i,j,k)=cw2c(i,j/2,k)
          enddo
          enddo
          enddo
          !do k=sp%yst(3), sp%yen(3)
          !do i=sp%yst(1), sp%yen(1)
          !   if ((xkx(i)==0).and.(zkz(k)==0)) then
          !   !   cw2b(i,1,1)=0.
          !   !   cw2b(i,ny,1)=0.
          !   endif
          !enddo
          !enddo
       else
          do k = sp%yst(3), sp%yen(3)
          do j = 1,ny
          do i = sp%yst(1), sp%yen(1)
             cw2(i,j,k)=cw2b(i,j,k)
          enddo
          enddo
          enddo
          call inversion5_v2(a3,cw2,sp)
          do k = sp%yst(3), sp%yen(3)
          do j = 1,ny
          do i = sp%yst(1), sp%yen(1)
             cw2b(i,j,k)=cw2(i,j,k)
          enddo
          enddo
          enddo
       endif

    endif

!    print *,nrank, sp%yst(3),sp%yen(3),sp%yst(1),sp%yen(1)

!we are in Y pencil
    do k = sp%yst(3), sp%yen(3)  
    do i = sp%yst(1), sp%yen(1)
       if ((i==nx/2+1).and.(k==nz/2+1)) then
          cw2b(i,:,k)=0.
       endif
    enddo
    enddo
#ifdef DEBUG
    do k = sp%yst(3), sp%yen(3)
       do j = sp%yst(2), sp%yen(2)
          do i = sp%yst(1), sp%yen(1)
             if (abs(cw2b(i,j,k)) &amp;gt; 1.0e-4) then
                write(*,100) &#39;AFTER&#39;,i,j,k,cw2b(i,j,k)
                print *,kxyz(i,j,k)
             end if
          end do
       end do
    end do
#endif

    ! post-processing backward

    ! POST PROCESSING IN Y
    do k = sp%yst(3), sp%yen(3)
       do i = sp%yst(1), sp%yen(1)
          cw2(i,1,k)=cw2b(i,1,k)
          do j = 2,ny
             tmp1 = real(cw2b(i,j,k), kind=mytype)
             tmp2 = aimag(cw2b(i,j,k))
             tmp3 = real(cw2b(i,ny-j+2,k), kind=mytype)
             tmp4 = aimag(cw2b(i,ny-j+2,k))
             xx1=tmp1*by(j)
             xx2=tmp1*ay(j)
             xx3=tmp2*by(j)
             xx4=tmp2*ay(j)
             xx5=tmp3*by(j)
             xx6=tmp3*ay(j)
             xx7=tmp4*by(j)
             xx8=tmp4*ay(j)
             cw2(i,j,k) = cmplx(xx1-xx4+xx6+xx7,-(-xx2-xx3+xx5-xx8), &amp;amp;
                  kind=mytype)
          end do
       end do
    end do
           
    ! Back to X-pencil
    call transpose_y_to_x(cw2,cw1,sp)
#ifdef DEBUG
    do k = sp%xst(3),sp%xen(3)
       do j = sp%xst(2),sp%xen(2)
          do i = sp%xst(1),sp%xen(1)
             if (abs(cw1(i,j,k)) &amp;gt; 1.0e-4) then
                write(*,100) &#39;AFTER Y&#39;,i,j,k,cw1(i,j,k)
             end if
          end do
       end do
    end do
#endif
    
    ! POST PROCESSING IN X
    do k = sp%xst(3),sp%xen(3)
       do j = sp%xst(2),sp%xen(2)
          do i = sp%xst(1),sp%xen(1)
             tmp1 = real(cw1(i,j,k), kind=mytype)
             tmp2 = aimag(cw1(i,j,k))
             cw1(i,j,k) = cmplx(tmp1*bx(i)-tmp2*ax(i), &amp;amp;
                  tmp2*bx(i)+tmp1*ax(i), kind=mytype)
             if (i.gt.(nx/2+1)) cw1(i,j,k)=-cw1(i,j,k)
#ifdef DEBUG
             if (abs(cw1(i,j,k)) &amp;gt; 1.0e-4) &amp;amp;
                  write(*,100) &#39;AFTER X&#39;,i,j,k,cw1(i,j,k)
#endif
          end do
       end do
    end do

    ! POST PROCESSING IN Z
    do k = sp%xst(3),sp%xen(3)
       do j = sp%xst(2),sp%xen(2)
          do i = sp%xst(1),sp%xen(1)
             tmp1 = real(cw1(i,j,k), kind=mytype)
             tmp2 = aimag(cw1(i,j,k))
             cw1(i,j,k) = cmplx(tmp1*bz(k)-tmp2*az(k), &amp;amp;
                  tmp2*bz(k)+tmp1*az(k), kind=mytype)
#ifdef DEBUG
             if (abs(cw1(i,j,k)) &amp;gt; 1.0e-4) &amp;amp;
                  write(*,100) &#39;END&#39;,i,j,k,cw1(i,j,k)
#endif
          end do
       end do
    end do

    ! compute c2r transform, back to physical space

    call decomp_2d_fft_3d(cw1,rhs)

    ! rhs is in Z-pencil but requires global operations in Y
    call transpose_z_to_y(rhs,rw2,ph)
    do k=ph%yst(3),ph%yen(3)
       do i=ph%yst(1),ph%yen(1)
          do j=1,ny/2
             rw2b(i,2*j-1,k)=rw2(i,j,k)
          enddo
          do j=1,ny/2
             rw2b(i,2*j,k)=rw2(i,ny-j+1,k)
          enddo
       enddo
    end do
    call transpose_y_to_z(rw2b,rhs,ph)

  !  call decomp_2d_fft_finalize

    return
  end subroutine poisson_010

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!!!!!!!!!!!!!!!!!!!!!!!Neumann!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!11x!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!!!!!!!!!!!Neumann Neumann Neumann!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!!!!!!!!!!!Neumann Neumann periodic!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  ! Solving 3D Poisson equation: Neumann in X, Y; Neumann/periodic in Z
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine poisson_11x(rhs, nclz1)




                   !!!!!!!!!!!!!!twice real to complex
                     !!!!!!!!!!! 1: transform rhs-rw2-rw1
                     !!!!!!!!!!! 2: fft       rhs-----rw1
                   !!!!!!!!!!!!!!twice complex to real
                     !!!!!!!!!!! 1: transfrom rw1-rw2--rhs
                     !!!!!!!!!!! 2: fft       rw1------rhs
                   !!!!!!!!!!!!! post-processing operations is under the complex condition
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !!!!!!!!!!!!   input real rhs(:.:,:) in the z pencil
    !!!!!!!!!!!!   2+2 transform    z--y  y-&amp;gt;x   x-y y-z|destination: modify the rhs
    !!!!!!!!!!!!   1 normalisation
    !!!!!!!!!!!!   1 FFT forward
    !!!!!!!!!!!!   1 post-processing  z
    !!!!!!!!!!!!   1 transpose  x--y
    !!!!!!!!!!!!   1 post-processing  y
    !!!!!!!!!!!!   1 transpose  y--x
    !!!!!!!!!!!!   1 post-processing  x (because  he thinks he is in X pencil, Zhaoliang said no)
    !!!!!!!!!!!!   1 poisson solver
    !!!!!!!!!!!!   1 matrice_refinemento
    !!!!!!!!!!!!   1 transpse   x--y  (for strecting  because strecthing is in the y direction)
    !!!!!!!!!!!!   1 inversion5_v1
    !!!!!!!!!!!!   1 transpose  y---x
    !!!!!!!!!!!!  
    !!!!!!!!!!!!   1 post-processing x
    !!!!!!!!!!!!   1 transpose  x-y
    !!!!!!!!!!!!   1 post-processing y
    !!!!!!!!!!!!   1 transpose  y-x
    !!!!!!!!!!!!   1 post-processing z
    !!!!!!!!!!!!!
    !!!!!!!!!!!!   1 FFT backward
    !!!!!!!!!!!!   2+2 transform    |destination: modify the rhs
    !!!!!!!!!!!!   output real rhs(:,:,:)  in the z pencil
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!



    implicit none

    integer, intent(IN) :: nclz1    
    real(mytype), dimension(:,:,:), intent(INOUT) :: rhs

    complex(mytype) :: xyzk
    real(mytype) :: tmp1, tmp2, tmp3, tmp4
    real(mytype) :: xx1,xx2,xx3,xx4,xx5,xx6,xx7,xx8

    integer :: nx,ny,nz, i,j,k

100 format(1x,a8,3I4,2F12.6)

    nx = nx_global - 1   ! becasuse (110)
    ny = ny_global - 1

    if (nclz1==1) then     !!!!!the free-slip boundary condition
       nz = nz_global - 1
    else if (nclz1==0) then
       nz = nz_global
    end if
   
    if (nclz1==1) then  
       do j=1,ph%zsz(2)
          do i=1,ph%zsz(1)
             do k=1,nz/2
                rw3(i,j,k)=rhs(i,j,2*(k-1)+1)
             end do
             do k=nz/2+1,nz
                rw3(i,j,k)=rhs(i,j,2*nz-2*k+2)
             end do
          end do
       end do
       call transpose_z_to_y(rw3,rw2,ph)
    else if (nclz1==0) then     
       call transpose_z_to_y(rhs,rw2,ph)
    end if
    

    do k=ph%yst(3),ph%yen(3)
       do i=ph%yst(1),ph%yen(1)
          do j=1,ny/2
             rw2b(i,j,k)=rw2(i,2*(j-1)+1,k)
          end do
          do j=ny/2+1,ny
             rw2b(i,j,k)=rw2(i,2*ny-2*j+2,k)
          end do
       end do
    end do

    ! the global operations in X
    call transpose_y_to_x(rw2b,rw1,ph)

    do k=ph%xst(3),ph%xen(3)
       do j=ph%xst(2),ph%xen(2)
          do i=1,nx/2
             rw1b(i,j,k)=rw1(2*(i-1)+1,j,k)
          end do
          do i=nx/2+1,nx
             rw1b(i,j,k)=rw1(2*nx-2*i+2,j,k)
          end do
       end do
    end do

    ! back to Z-pencil
    call transpose_x_to_y(rw1b,rw2,ph)
    call transpose_y_to_z(rw2,rhs,ph)

    if (.not. fft_initialised) then
       call decomp_2d_fft_init(PHYSICAL_IN_Z,nx,ny,nz)
       fft_initialised = .true.
    end if

    ! compute r2c transform

    call decomp_2d_fft_3d(rhs,cw1)



    ! normalisation
    cw1 = cw1 / real(nx, kind=mytype) /real(ny, kind=mytype) &amp;amp;
         / real(nz, kind=mytype)
#ifdef DEBUG
    do k = sp%xst(3),sp%xen(3)
       do j = sp%xst(2),sp%xen(2)
          do i = sp%xst(1),sp%xen(1)
             if (abs(cw1(i,j,k)) &amp;gt; 1.0e-4) then
                write(*,100) &#39;START&#39;,i,j,k,cw1(i,j,k)
             end if
          end do
       end do
    end do
#endif

    ! post-processing in spectral space

    ! POST PROCESSING IN Z
    do k = sp%xst(3),sp%xen(3)
       do j = sp%xst(2),sp%xen(2)
          do i = sp%xst(1),sp%xen(1)
             tmp1 = real(cw1(i,j,k), kind=mytype)
             tmp2 = aimag(cw1(i,j,k))
             cw1(i,j,k) = cmplx(tmp1*bz(k)+tmp2*az(k), &amp;amp;
                  tmp2*bz(k)-tmp1*az(k), kind=mytype)
#ifdef DEBUG
             if (abs(cw1(i,j,k)) &amp;gt; 1.0e-4) &amp;amp;
                  write(*,100) &#39;after z&#39;,i,j,k,cw1(i,j,k)
#endif
          end do
       end do
    end do


    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !!!!!!!!!!!!!!!!!!!!while  1  should be in the corresponding pencils
    !!!!!!!!!!!!!!!!!!!!!!!!!!!characteristic 2 : there sholud be tmp1*2*3*4
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    ! POST PROCESSING IN Y
    ! WE HAVE TO BE IN Y PENCILS



    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !!!!!!!!!!!!!!No  we should be the z pencil!  
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    !!!!!!!!!!!!!!!!!!!there is something wrong in the source code!!!!!!!!!
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!But now we are in the z pencil not in
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  the x pencil!
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!so,it should be
    !!!!!!!!!!!!!!!!!call transpose_z_to_y rather than transpose_x_to_y
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    call transpose_x_to_y(cw1,cw2,sp)
    do k = sp%yst(3), sp%yen(3)
       do i = sp%yst(1), sp%yen(1)
          cw2b(i,1,k)=cw2(i,1,k)
          do j = 2,ny
             tmp1 = real(cw2(i,j,k), kind=mytype)
             tmp2 = aimag(cw2(i,j,k))
             tmp3 = real(cw2(i,ny-j+2,k), kind=mytype)
             tmp4 = aimag(cw2(i,ny-j+2,k))
             xx1=tmp1*by(j)/2._mytype
             xx2=tmp1*ay(j)/2._mytype
             xx3=tmp2*by(j)/2._mytype
             xx4=tmp2*ay(j)/2._mytype
             xx5=tmp3*by(j)/2._mytype
             xx6=tmp3*ay(j)/2._mytype
             xx7=tmp4*by(j)/2._mytype
             xx8=tmp4*ay(j)/2._mytype
             cw2b(i,j,k) = cmplx(xx1+xx4+xx5-xx8,-xx2+xx3+xx6+xx7, &amp;amp;
                  kind=mytype)  
          end do
       end do
    end do
    
    ! back to X-pencil
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!the same wrong ,now you should
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!go back to the z pencil rather than the x pencil
    call transpose_y_to_x(cw2b,cw1,sp)
#ifdef DEBUG
    do k = sp%xst(3),sp%xen(3)
       do j = sp%xst(2),sp%xen(2)
          do i = sp%xst(1),sp%xen(1)
             if (abs(cw1(i,j,k)) &amp;gt; 1.0e-4) then
                write(*,100) &#39;after y&#39;,i,j,k,cw1(i,j,k)
             end if
          end do
       end do
    end do
#endif
    
    ! POST PROCESSING IN X
    do k = sp%xst(3),sp%xen(3)
       do j = sp%xst(2),sp%xen(2)
          cw1b(1,j,k)=cw1(1,j,k)
          do i = 2,nx
             tmp1 = real(cw1(i,j,k), kind=mytype)
             tmp2 = aimag(cw1(i,j,k))
             tmp3 = real(cw1(nx-i+2,j,k), kind=mytype)
             tmp4 = aimag(cw1(nx-i+2,j,k))
             xx1=tmp1*bx(i)/2._mytype
             xx2=tmp1*ax(i)/2._mytype
             xx3=tmp2*bx(i)/2._mytype
             xx4=tmp2*ax(i)/2._mytype
             xx5=tmp3*bx(i)/2._mytype
             xx6=tmp3*ax(i)/2._mytype
             xx7=tmp4*bx(i)/2._mytype
             xx8=tmp4*ax(i)/2._mytype
             cw1b(i,j,k) = cmplx(xx1+xx4+xx5-xx8,-xx2+xx3+xx6+xx7, &amp;amp;
                  kind=mytype)  
          end do
       end do
    end do
    
#ifdef DEBUG
    do k = sp%xst(3),sp%xen(3)
       do j = sp%xst(2),sp%xen(2)
          do i = sp%xst(1),sp%xen(1)
             if (abs(cw1b(i,j,k)) &amp;gt; 1.0e-4) then
                write(*,*) &#39;BEFORE&#39;,i,j,k,cw1b(i,j,k)
             end if
          end do
       end do
    end do
#endif

    if (istret==0) then

    ! Solve Poisson
    do k = sp%xst(3),sp%xen(3)
       do j = sp%xst(2),sp%xen(2)
          do i = sp%xst(1),sp%xen(1)
             !tmp1=real(zk2(k)+yk2(j)+xk2(i), kind=mytype)
             !tmp2=aimag(zk2(k)+yk2(j)+xk2(i))
             tmp1=real(kxyz(i,j,k), kind=mytype)
             tmp2=aimag(kxyz(i,j,k))
             !xyzk=cmplx(tmp1,tmp2, kind=mytype)
             !CANNOT DO A DIVISION BY ZERO
             if ((abs(tmp1).lt.epsilon).and.(abs(tmp2).lt.epsilon)) then    
                cw1b(i,j,k)=cmplx(0._mytype,0._mytype, kind=mytype)
             end if
             if ((abs(tmp1).lt.epsilon).and.(abs(tmp2).ge.epsilon)) then
                cw1b(i,j,k)=cmplx(0._mytype, &amp;amp;
                     aimag(cw1b(i,j,k))/(-tmp2), kind=mytype)
             end if
             if ((abs(tmp1).ge.epsilon).and.(abs(tmp2).lt.epsilon)) then    
                cw1b(i,j,k)=cmplx( real(cw1b(i,j,k), kind=mytype) &amp;amp;
                     /(-tmp1), 0._mytype, kind=mytype)
             end if
             if ((abs(tmp1).ge.epsilon).and.(abs(tmp2).ge.epsilon)) then
                cw1b(i,j,k)=cmplx( real(cw1b(i,j,k), kind=mytype) &amp;amp;
                     /(-tmp1), &amp;amp;
                     aimag(cw1b(i,j,k))/(-tmp2), kind=mytype)
             end if
          end do
       end do
    end do

    else
       call matrice_refinement()
       !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!11so       we  should  z-&amp;gt;y pencil but not  x-&amp;gt;ypencil
! the stretching is only working in Y pencils

!!!!!!!!!!!!!!!why the default the pencil is  x pencil rather than z pencil!!!
       call transpose_x_to_y(cw1b,cw2b,sp)
       !we are now in Y pencil
       
       if (istret.ne.3) then
          cw2(:,:,:)=0.;cw2c(:,:,:)=0.
          do k = sp%yst(3), sp%yen(3)
          do j = 1,ny/2
          do i = sp%yst(1), sp%yen(1)
             cw2(i,j,k)=cw2b(i,2*j-1,k)
             cw2c(i,j,k)=cw2b(i,2*j,k)
          enddo
          enddo
          enddo
          call inversion5_v1(a,cw2,sp)
          call inversion5_v1(a2,cw2c,sp)

          cw2b(:,:,:)=0.
          do k=sp%yst(3), sp%yen(3)
          do j=1,ny-1,2
          do i=sp%yst(1), sp%yen(1)
             cw2b(i,j,k)=cw2(i,(j+1)/2,k)
          enddo
          enddo
          do j=2,ny,2
          do i=sp%yst(1), sp%yen(1)
             cw2b(i,j,k)=cw2c(i,j/2,k)
          enddo
          enddo
          enddo
       else
          cw2(:,:,:)=0.
          do k = sp%yst(3), sp%yen(3)
          do j = sp%yst(2), sp%yen(2)
          do i = sp%yst(1), sp%yen(1)
             cw2(i,j,k)=cw2b(i,j,k)
          enddo
          enddo
          enddo

          call inversion5_v2(a3,cw2,sp)

          do k = sp%yst(3), sp%yen(3)
          do j = sp%yst(2), sp%yen(2)
          do i = sp%yst(1), sp%yen(1)
             cw2b(i,j,k)=cw2(i,j,k)
          enddo
          enddo
          enddo
       endif
!we have to go back in X pencils
       call transpose_y_to_x(cw2b,cw1b,sp)
    endif

#ifdef DEBUG
    do k = sp%xst(3),sp%xen(3)
       do j = sp%xst(2),sp%xen(2)
          do i = sp%xst(1),sp%xen(1)
             if (abs(cw1b(i,j,k)) &amp;gt; 1.0e-6) then
                write(*,*) &#39;AFTER&#39;,i,j,k,cw1b(i,j,k)
             end if
          end do
       end do
    end do
#endif
!stop
    ! post-processing backward
    
    do k = sp%xst(3),sp%xen(3)
       do j = sp%xst(2),sp%xen(2)
          cw1(1,j,k)=cw1b(1,j,k)
          do i = 2,nx
             tmp1 = real(cw1b(i,j,k), kind=mytype)
             tmp2 = aimag(cw1b(i,j,k))
             tmp3 = real(cw1b(nx-i+2,j,k), kind=mytype)
             tmp4 = aimag(cw1b(nx-i+2,j,k))
             xx1=tmp1*bx(i)
             xx2=tmp1*ax(i)
             xx3=tmp2*bx(i)
             xx4=tmp2*ax(i)
             xx5=tmp3*bx(i)
             xx6=tmp3*ax(i)
             xx7=tmp4*bx(i)
             xx8=tmp4*ax(i)
             cw1(i,j,k) = cmplx(xx1-xx4+xx6+xx7,-(-xx2-xx3+xx5-xx8), &amp;amp;
                  kind=mytype)        
          end do
       end do
    end do
#ifdef DEBUG
    do k = sp%xst(3),sp%xen(3)
       do j = sp%xst(2),sp%xen(2)
          do i = sp%xst(1),sp%xen(1)
             if (abs(cw1(i,j,k)) &amp;gt; 1.0e-4) then
                write(*,100) &#39;AFTER X&#39;,i,j,k,cw1(i,j,k)
             end if
          end do
       end do
    end do
#endif

    ! POST PROCESSING IN Y
    ! NEED to be in Y-pencil
    call transpose_x_to_y(cw1,cw2,sp)
    do k = sp%yst(3), sp%yen(3)
       do i = sp%yst(1), sp%yen(1)
          cw2b(i,1,k)=cw2(i,1,k)
          do j = 2,ny
             tmp1 = real(cw2(i,j,k), kind=mytype)
             tmp2 = aimag(cw2(i,j,k))
             tmp3 = real(cw2(i,ny-j+2,k), kind=mytype)
             tmp4 = aimag(cw2(i,ny-j+2,k))
             xx1=tmp1*by(j)
             xx2=tmp1*ay(j)
             xx3=tmp2*by(j)
             xx4=tmp2*ay(j)
             xx5=tmp3*by(j)
             xx6=tmp3*ay(j)
             xx7=tmp4*by(j)
             xx8=tmp4*ay(j)
             cw2b(i,j,k) = cmplx(xx1-xx4+xx6+xx7,-(-xx2-xx3+xx5-xx8), &amp;amp;
                  kind=mytype)        
          end do
       end do
    end do
#ifdef DEBUG
    do k = sp%yst(3), sp%yen(3)
       do j = sp%yst(2), sp%yen(2)
          do i = sp%yst(1), sp%yen(1)
             if (abs(cw2b(i,j,k)) &amp;gt; 1.0e-4) then
                write(*,100) &#39;AFTER Y&#39;,i,j,k,cw2b(i,j,k)
             end if
          end do
       end do
    end do
#endif
    ! back to X-pencil
    call transpose_y_to_x(cw2b,cw1,sp)
    
    ! POST PROCESSING IN Z
    do k = sp%xst(3),sp%xen(3)
       do j = sp%xst(2),sp%xen(2)
          do i = sp%xst(1),sp%xen(1)
             tmp1 = real(cw1(i,j,k), kind=mytype)
             tmp2 = aimag(cw1(i,j,k))
             cw1(i,j,k) = cmplx(tmp1*bz(k)-tmp2*az(k), &amp;amp;
                  tmp2*bz(k)+tmp1*az(k), kind=mytype)
#ifdef DEBUG
             if (abs(cw1(i,j,k)) &amp;gt; 1.0e-4) &amp;amp;
                  write(*,100) &#39;END&#39;,i,j,k,cw1(i,j,k)
#endif
          end do
       end do
    end do

    ! compute c2r transform, back to physical space
    call decomp_2d_fft_3d(cw1,rhs)

    if (nclz1==1) then
       do j=1,ph%zsz(2)
          do i=1,ph%zsz(1)
             do k=1,nz/2
                rw3(i,j,2*k-1)=rhs(i,j,k)
             end do
             do k=1,nz/2
                rw3(i,j,2*k)=rhs(i,j,nz-k+1)
             end do
          end do
       end do
       call transpose_z_to_y(rw3,rw2,ph)
    else if (nclz1==0) then
       call transpose_z_to_y(rhs,rw2,ph)   
    end if
    
    do k=ph%yst(3),ph%yen(3)
       do i=ph%yst(1),ph%yen(1)
          do j=1,ny/2
             rw2b(i,2*j-1,k)=rw2(i,j,k)
          end do
          do j=1,ny/2
             rw2b(i,2*j,k)=rw2(i,ny-j+1,k)
          end do
       enddo
    end do
    call transpose_y_to_x(rw2b,rw1,ph)
    do k=ph%xst(3),ph%xen(3)
       do j=ph%xst(2),ph%xen(2)
          do i=1,nx/2
             rw1b(2*i-1,j,k)=rw1(i,j,k)
          enddo
          do i=1,nx/2
             rw1b(2*i,j,k)=rw1(nx-i+1,j,k)
          enddo
       enddo
    end do
    call transpose_x_to_y(rw1b,rw2,ph)
    call transpose_y_to_z(rw2,rhs,ph)

  !  call decomp_2d_fft_finalize

   

    return
  end subroutine poisson_11x


 
  subroutine abxyz(ax,ay,az,bx,by,bz,nx,ny,nz,bcx,bcy,bcz)
    
    use param

    implicit none

    integer, intent(IN) :: nx,ny,nz
    integer, intent(IN) :: bcx,bcy,bcz
    real(mytype), dimension(:), intent(OUT) :: ax,bx
    real(mytype), dimension(:), intent(OUT) :: ay,by
    real(mytype), dimension(:), intent(OUT) :: az,bz

    integer :: i,j,k

    if (bcx==0) then
       do i=1,nx
           !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
           !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
           !!!!!!!!!!!!!! generate the x direction coeficiency!!!!!!!!!!!
           !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
           !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
          ax(i) = sin(real(i-1, kind=mytype)*PI/real(nx, kind=mytype))
          bx(i) = cos(real(i-1, kind=mytype)*PI/real(nx, kind=mytype))
       end do
    else if (bcx==1) then
       do i=1,nx
           !!!!!!!!!!!!!!!!!!!!!!!!!one and a half of PI
          ax(i) = sin(real(i-1, kind=mytype)*PI/2.0_mytype/ &amp;amp;
               real(nx, kind=mytype))
          bx(i) = cos(real(i-1, kind=mytype)*PI/2.0_mytype/ &amp;amp;
               real(nx, kind=mytype))
       end do
    end if

    if (bcy==0) then
       do j=1,ny
          ay(j) = sin(real(j-1, kind=mytype)*PI/real(ny, kind=mytype))
          by(j) = cos(real(j-1, kind=mytype)*PI/real(ny, kind=mytype))
       end do
    else if (bcy==1) then
       do j=1,ny
          ay(j) = sin(real(j-1, kind=mytype)*PI/2.0_mytype/ &amp;amp;
               real(ny, kind=mytype))
          by(j) = cos(real(j-1, kind=mytype)*PI/2.0_mytype/ &amp;amp;
               real(ny, kind=mytype))
       end do
    end if

    if (bcz==0) then
       do k=1,nz
          az(k) = sin(real(k-1, kind=mytype)*PI/real(nz, kind=mytype))
          bz(k) = cos(real(k-1, kind=mytype)*PI/real(nz, kind=mytype))
       end do
    else if (bcz==1) then
       do k=1,nz
          az(k) = sin(real(k-1, kind=mytype)*PI/2.0_mytype/ &amp;amp;
               real(nz, kind=mytype))
          bz(k) = cos(real(k-1, kind=mytype)*PI/2.0_mytype/ &amp;amp;
               real(nz, kind=mytype))
       end do
    end if

    return
  end subroutine abxyz

! ***********************************************************
!
subroutine waves ()
!
!***********************************************************

USE derivX
USE derivY
USE derivZ
USE param
USE decomp_2d
USE variables
use decomp_2d_fft

implicit none

integer :: i,j,k
real(mytype) :: w,wp,w1,w1p
complex(mytype) :: xyzk
complex(mytype) :: ytt,xtt,ztt,yt1,xt1,yt2,xt2
complex(mytype) :: xtt1,ytt1,ztt1,zt1,zt2,tmp1,tmp2,tmp3
complex(mytype) :: tmp4,tmp5,tmp6

xkx(:)=0. ; xk2(:)=0. ; yky(:)=0. ; yk2(:)=0.
zkz(:)=0. ; zk2(:)=0.

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!WAVE NUMBER IN X
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
if (nclx==0) then
   do i=1,nx/2+1
      w=2.*pi*(i-1)/nx
      wp=acix6*2.*dx*sin(w/2.)+(bcix6*2.*dx)*sin(3./2.*w)
      wp=wp/(1.+2.*alcaix6*cos(w))
      xkx(i)=cmplx(nx*wp/xlx,nx*wp/xlx, kind=mytype)
      exs(i)=cmplx(nx*w/xlx,nx*w/xlx, kind=mytype)
      xk2(i)=cmplx((nx*wp/xlx)**2,(nx*wp/xlx)**2, kind=mytype)
   enddo
   do i=nx/2+2,nx
      xkx(i)=xkx(nx-i+2)
      exs(i)=exs(nx-i+2)
      xk2(i)=xk2(nx-i+2)
   enddo
else
   do i=1,nx
      w=2.*pi*0.5*(i-1)/nxm
      wp=acix6*2.*dx*sin(w/2.)+(bcix6*2.*dx)*sin(3./2.*w)
      wp=wp/(1.+2.*alcaix6*cos(w))
      xkx(i)=cmplx(nxm*wp/xlx,nxm*wp/xlx, kind=mytype)
      exs(i)=cmplx(nxm*w/xlx,nxm*w/xlx, kind=mytype)
      xk2(i)=cmplx((nxm*wp/xlx)**2,(nxm*wp/xlx)**2, kind=mytype)
   enddo
   xkx(1)=0.
   exs(1)=0.
   xk2(1)=0.
endif

!WAVE NUMBER IN Y
if (ncly==0) then
   do j=1,ny/2+1
      w=2.*pi*(j-1)/ny
      wp=aciy6*2.*dy*sin(w/2.)+(bciy6*2.*dy)*sin(3./2.*w)
      wp=wp/(1.+2.*alcaiy6*cos(w))
      if (istret==0) yky(j)=cmplx(ny*wp/yly,ny*wp/yly, kind=mytype)
      if (istret.ne.0) yky(j)=cmplx(ny*wp,ny*wp, kind=mytype)
      eys(j)=cmplx(ny*w/yly,ny*w/yly, kind=mytype)
      yk2(j)=cmplx((ny*wp/yly)**2,(ny*wp/yly)**2, kind=mytype)
   enddo
   do j=ny/2+2,ny
      yky(j)=yky(ny-j+2)
      eys(j)=eys(ny-j+2)
      yk2(j)=yk2(ny-j+2)
   enddo
else
   do j=1,ny
      w=2.*pi*0.5*(j-1)/nym
      wp=aciy6*2.*dy*sin(w/2.)+(bciy6*2.*dy)*sin(3./2.*w)
      wp=wp/(1.+2.*alcaiy6*cos(w))
      if (istret==0) yky(j)=cmplx(nym*wp/yly,nym*wp/yly, kind=mytype)
      if (istret.ne.0) yky(j)=cmplx(nym*wp,nym*wp, kind=mytype)
      eys(j)=cmplx(nym*w/yly,nym*w/yly, kind=mytype)
      yk2(j)=cmplx((nym*wp/yly)**2,(nym*wp/yly)**2, kind=mytype)
   enddo
   yky(1)=0.
   eys(1)=0.
   yk2(1)=0.
endif

!WAVE NUMBER IN Z
if (nclz==0) then
   do k=1,nz/2+1
      w=2.*pi*(k-1)/nz
      wp=aciz6*2.*dz*sin(w/2.)+(bciz6*2.*dz)*sin(3./2.*w)
      wp=wp/(1.+2.*alcaiz6*cos(w))
      zkz(k)=cmplx(nz*wp/zlz,nz*wp/zlz, kind=mytype)
      ezs(k)=cmplx(nz*w/zlz,nz*w/zlz, kind=mytype)
      zk2(k)=cmplx((nz*wp/zlz)**2,(nz*wp/zlz)**2, kind=mytype)
   enddo
else
   do k=1,nz/2+1
      w=2.*pi*0.5*(k-1)/nzm
      w1=2.*pi*0.5*(nzm-k+1)/nzm
      wp=aciz6*2.*dz*sin(w/2.)+(bciz6*2.*dz)*sin(3./2.*w)
      wp=wp/(1.+2.*alcaiz6*cos(w))
      w1p=aciz6*2.*dz*sin(w1/2.)+(bciz6*2.*dz)*sin(3./2.*w1)
      w1p=w1p/(1.+2.*alcaiz6*cos(w1))     
      zkz(k)=cmplx(nzm*wp/zlz,-nzm*w1p/zlz, kind=mytype)
      ezs(k)=cmplx(nzm*w/zlz,nzm*w1/zlz, kind=mytype)
      zk2(k)=cmplx((nzm*wp/zlz)**2,(nzm*w1p/zlz)**2, kind=mytype)
   enddo
endif
!
!if (nrank==0) then
!   do i=1,nx
!      print *,i,ezs(i)
!   enddo
!endif
!stop

if ((nclx==0).and.(nclz==0).and.((ncly==1).or.(ncly==2))) then
do k = sp%yst(3), sp%yen(3)
do j = sp%yst(2), sp%yen(2)
do i = sp%yst(1), sp%yen(1)
   xtt=cmplx((bicix6*2.*cos(real(exs(i))*3.*dx/2.)+&amp;amp;
        cicix6*2.*cos(real(exs(i), kind=mytype)*5.*dx/2.)),&amp;amp;
        (bicix6*2.*cos(real(exs(i), kind=mytype)*3.*dx/2.)+&amp;amp;
        cicix6*2.*cos(real(exs(i), kind=mytype)*5.*dx/2.)), kind=mytype)
   ytt=cmplx((biciy6*2.*cos(real(eys(j), kind=mytype)*3.*dy/2.)+&amp;amp;
        ciciy6*2.*cos(real(eys(j), kind=mytype)*5.*dy/2.)),&amp;amp;
        (biciy6*2.*cos(real(eys(j), kind=mytype)*3.*dy/2.)+&amp;amp;
        ciciy6*2.*cos(real(eys(j), kind=mytype)*5.*dy/2.)), kind=mytype)
   ztt=cmplx((biciz6*2.*cos(real(ezs(k), kind=mytype)*3.*dz/2.)+&amp;amp;
        ciciz6*2.*cos(real(ezs(k), kind=mytype)*5.*dz/2.)),&amp;amp;
        (biciz6*2.*cos(real(ezs(k), kind=mytype)*3.*dz/2.)+&amp;amp;
        ciciz6*2.*cos(real(ezs(k), kind=mytype)*5.*dz/2.)), kind=mytype)
   xtt1=cmplx((aicix6*2.*cos(real(exs(i), kind=mytype)*dx/2.)),&amp;amp;
        (aicix6*2.*cos(real(exs(i), kind=mytype)*dx/2.)), kind=mytype)
   ytt1=cmplx((aiciy6*2.*cos(real(eys(j), kind=mytype)*dy/2.)),&amp;amp;
        (aiciy6*2.*cos(real(eys(j), kind=mytype)*dy/2.)), kind=mytype)
   ztt1=cmplx((aiciz6*2.*cos(real(ezs(k), kind=mytype)*dz/2.)),&amp;amp;
        (aiciz6*2.*cos(real(ezs(k), kind=mytype)*dz/2.)), kind=mytype)
   xt1=cmplx((1.+2.*ailcaix6*cos(real(exs(i), kind=mytype)*dx)),&amp;amp;
        (1.+2.*ailcaix6*cos(real(exs(i), kind=mytype)*dx)), kind=mytype)
   yt1=cmplx((1.+2.*ailcaiy6*cos(real(eys(j), kind=mytype)*dy)),&amp;amp;
        (1.+2.*ailcaiy6*cos(real(eys(j), kind=mytype)*dy)), kind=mytype)
   zt1=cmplx((1.+2.*ailcaiz6*cos(real(ezs(k), kind=mytype)*dz)),&amp;amp;
        (1.+2.*ailcaiz6*cos(real(ezs(k), kind=mytype)*dz)), kind=mytype)
   xt2=xk2(i)*((((ytt1+ytt)/yt1)*((ztt1+ztt)/zt1))**2)
   yt2=yk2(j)*((((xtt1+xtt)/xt1)*((ztt1+ztt)/zt1))**2)
   zt2=zk2(k)*((((xtt1+xtt)/xt1)*((ytt1+ytt)/yt1))**2)
   xyzk=xt2+yt2+zt2
   kxyz(i,j,k)=xyzk
!   print *,i,j,k, kxyz(i,j,k)
enddo
enddo
enddo
else
   if (nclz==0) then
      do k = sp%xst(3),sp%xen(3)
      do j = sp%xst(2),sp%xen(2)
      do i = sp%xst(1),sp%xen(1)
         xtt=cmplx((bicix6*2.*cos(real(exs(i), kind=mytype)*3.*dx/2.)+&amp;amp;
              cicix6*2.*cos(real(exs(i), kind=mytype)*5.*dx/2.)),&amp;amp;
              (bicix6*2.*cos(real(exs(i), kind=mytype)*3.*dx/2.)+&amp;amp;
              cicix6*2.*cos(real(exs(i), kind=mytype)*5.*dx/2.)), kind=mytype)
         ytt=cmplx((biciy6*2.*cos(real(eys(j), kind=mytype)*3.*dy/2.)+&amp;amp;
              ciciy6*2.*cos(real(eys(j), kind=mytype)*5.*dy/2.)),&amp;amp;
              (biciy6*2.*cos(real(eys(j), kind=mytype)*3.*dy/2.)+&amp;amp;
              ciciy6*2.*cos(real(eys(j), kind=mytype)*5.*dy/2.)), kind=mytype)
         ztt=cmplx((biciz6*2.*cos(real(ezs(k), kind=mytype)*3.*dz/2.)+&amp;amp;
              ciciz6*2.*cos(real(ezs(k), kind=mytype)*5.*dz/2.)),&amp;amp;
              (biciz6*2.*cos(real(ezs(k), kind=mytype)*3.*dz/2.)+&amp;amp;
              ciciz6*2.*cos(real(ezs(k), kind=mytype)*5.*dz/2.)), kind=mytype)
         xtt1=cmplx((aicix6*2.*cos(real(exs(i), kind=mytype)*dx/2.)),&amp;amp;
              (aicix6*2.*cos(real(exs(i), kind=mytype)*dx/2.)), kind=mytype)
         ytt1=cmplx((aiciy6*2.*cos(real(eys(j), kind=mytype)*dy/2.)),&amp;amp;
              (aiciy6*2.*cos(real(eys(j), kind=mytype)*dy/2.)), kind=mytype)
         ztt1=cmplx((aiciz6*2.*cos(real(ezs(k), kind=mytype)*dz/2.)),&amp;amp;
              (aiciz6*2.*cos(real(ezs(k), kind=mytype)*dz/2.)), kind=mytype)
         xt1=cmplx((1.+2.*ailcaix6*cos(real(exs(i), kind=mytype)*dx)),&amp;amp;
              (1.+2.*ailcaix6*cos(real(exs(i))*dx)), kind=mytype)
         yt1=cmplx((1.+2.*ailcaiy6*cos(real(eys(j), kind=mytype)*dy)),&amp;amp;
              (1.+2.*ailcaiy6*cos(real(eys(j), kind=mytype)*dy)), kind=mytype)
         zt1=cmplx((1.+2.*ailcaiz6*cos(real(ezs(k), kind=mytype)*dz)),&amp;amp;
              (1.+2.*ailcaiz6*cos(real(ezs(k), kind=mytype)*dz)), kind=mytype)
         xt2=xk2(i)*((((ytt1+ytt)/yt1)*((ztt1+ztt)/zt1))**2)
         yt2=yk2(j)*((((xtt1+xtt)/xt1)*((ztt1+ztt)/zt1))**2)
         zt2=zk2(k)*((((xtt1+xtt)/xt1)*((ytt1+ytt)/yt1))**2)
         xyzk=xt2+yt2+zt2
         kxyz(i,j,k)=xyzk
!   print *,i,j,k, kxyz(i,j,k)
      enddo
      enddo
      enddo
   else
      do k = sp%xst(3),sp%xen(3)
      do j = sp%xst(2),sp%xen(2)
      do i = sp%xst(1),sp%xen(1)  
         xtt=cmplx((bicix6*2.*cos(real(exs(i), kind=mytype)*3.*dx/2.)+&amp;amp;
              cicix6*2.*cos(real(exs(i), kind=mytype)*5.*dx/2.)),&amp;amp;
              (bicix6*2.*cos(real(exs(i), kind=mytype)*3.*dx/2.)+&amp;amp;
              cicix6*2.*cos(real(exs(i), kind=mytype)*5.*dx/2.)), kind=mytype)
         ytt=cmplx((biciy6*2.*cos(real(eys(j), kind=mytype)*3.*dy/2.)+&amp;amp;
              ciciy6*2.*cos(real(eys(j), kind=mytype)*5.*dy/2.)),&amp;amp;
              (biciy6*2.*cos(real(eys(j), kind=mytype)*3.*dy/2.)+&amp;amp;
              ciciy6*2.*cos(real(eys(j), kind=mytype)*5.*dy/2.)), kind=mytype)
         !
         ztt=cmplx((biciz6*2.*cos(real(ezs(k), kind=mytype)*3.*dz/2.)+&amp;amp;
              ciciz6*2.*cos(real(ezs(k), kind=mytype)*5.*dz/2.)),&amp;amp;
              (biciz6*2.*cos(aimag(ezs(k))*3.*dz/2.)+&amp;amp;
              ciciz6*2.*cos(aimag(ezs(k))*5.*dz/2.)), kind=mytype)
         !
         xtt1=cmplx((aicix6*2.*cos(real(exs(i), kind=mytype)*dx/2.)),&amp;amp;
              (aicix6*2.*cos(real(exs(i), kind=mytype)*dx/2.)), kind=mytype)
         ytt1=cmplx((aiciy6*2.*cos(real(eys(j), kind=mytype)*dy/2.)),&amp;amp;
              (aiciy6*2.*cos(real(eys(j), kind=mytype)*dy/2.)), kind=mytype)
         !
         ztt1=cmplx((aiciz6*2.*cos(real(ezs(k), kind=mytype)*dz/2.)),&amp;amp;
              (aiciz6*2.*cos(aimag(ezs(k))*dz/2.)), kind=mytype)
         !
         xt1=cmplx((1.+2.*ailcaix6*cos(real(exs(i), kind=mytype)*dx)),&amp;amp;
              (1.+2.*ailcaix6*cos(real(exs(i), kind=mytype)*dx)), kind=mytype)
         yt1=cmplx((1.+2.*ailcaiy6*cos(real(eys(j), kind=mytype)*dy)),&amp;amp;
              (1.+2.*ailcaiy6*cos(real(eys(j), kind=mytype)*dy)), kind=mytype)
         zt1=cmplx((1.+2.*ailcaiz6*cos(real(ezs(k), kind=mytype)*dz)),&amp;amp;
              (1.+2.*ailcaiz6*cos(aimag(ezs(k))*dz)), kind=mytype)
         
         tmp1=cmplx(real(ztt1+ztt, kind=mytype)/real(zt1, kind=mytype),&amp;amp;
              aimag(ztt1+ztt)/aimag(zt1), kind=mytype)
         tmp2=cmplx(real(ytt1+ytt, kind=mytype)/real(yt1, kind=mytype),&amp;amp;
              real(ytt1+ytt, kind=mytype)/real(yt1, kind=mytype), kind=mytype)
         tmp3=cmplx(real(xtt1+xtt, kind=mytype)/real(xt1, kind=mytype),&amp;amp;
              real(xtt1+xtt, kind=mytype)/real(xt1, kind=mytype), kind=mytype)
         
         tmp4=cmplx((real(tmp1, kind=mytype)*real(tmp2, kind=mytype))**2,(aimag(tmp1)*aimag(tmp2))**2, kind=mytype)
         tmp5=cmplx((real(tmp1, kind=mytype)*real(tmp3, kind=mytype))**2,(aimag(tmp1)*aimag(tmp3))**2, kind=mytype)
         tmp6=cmplx((real(tmp3, kind=mytype)*real(tmp2, kind=mytype))**2,(aimag(tmp3)*aimag(tmp2))**2, kind=mytype)
         
         tmp1=cmplx(real(tmp4, kind=mytype)*real(xk2(i), kind=mytype),aimag(tmp4)*aimag(xk2(i)), kind=mytype)
         tmp2=cmplx(real(tmp5, kind=mytype)*real(yk2(j), kind=mytype),aimag(tmp5)*aimag(yk2(j)), kind=mytype)
         tmp3=cmplx(real(tmp6, kind=mytype)*real(zk2(k), kind=mytype),aimag(tmp6)*aimag(zk2(k)), kind=mytype)

         xyzk=tmp1+tmp2+tmp3
         kxyz(i,j,k)=xyzk
!         print *,i,j,k,zt1,yt1
      enddo
      enddo
      enddo
   endif
endif


!          do k=1,1!nz
!          do j=1,ny
!          do i=1,1!!nx
!             print *,j,a(i,j,k,3),kxyz(i,j,k)
!          enddo
!          enddo
!          enddo

end subroutine waves

!**************************************************************************
!
subroutine matrice_refinement()
!
!**************************************************************************

USE decomp_2d
USE variables
USE param
USE var
USE MPI
USE derivX
USE derivY
USE derivZ

implicit none

integer :: i,j,k

complex(mytype),dimension(sp%yst(1):sp%yen(1)) :: transx
complex(mytype),dimension(sp%yst(2):sp%yen(2)) :: transy
complex(mytype),dimension(sp%yst(3):sp%yen(3)) :: transz
real(mytype) :: xa0,xa1
complex(mytype) :: ytt,xtt,ztt,yt1,xt1,yt2,xt2
complex(mytype) :: xtt1,ytt1,ztt1,zt1,zt2,tmp1,tmp2,tmp3

do i = sp%yst(1),sp%yen(1)
   xtt=cmplx((bicix6*2.*cos(real(exs(i), kind=mytype)*3.*dx/2.)+&amp;amp;
        cicix6*2.*cos(real(exs(i), kind=mytype)*5.*dx/2.)),&amp;amp;
        (bicix6*2.*cos(real(exs(i), kind=mytype)*3.*dx/2.)+&amp;amp;
        cicix6*2.*cos(real(exs(i), kind=mytype)*5.*dx/2.)), kind=mytype)
   xtt1=cmplx((aicix6*2.*cos(real(exs(i), kind=mytype)*dx/2.)),&amp;amp;
        (aicix6*2.*cos(real(exs(i), kind=mytype)*dx/2.)), kind=mytype)
   xt1=cmplx((1.+2.*ailcaix6*cos(real(exs(i), kind=mytype)*dx)),&amp;amp;
        (1.+2.*ailcaix6*cos(real(exs(i), kind=mytype)*dx)), kind=mytype)
   transx(i)=cmplx(real(xtt1+xtt, kind=mytype)/real(xt1, kind=mytype),&amp;amp;
        real(xtt1+xtt, kind=mytype)/real(xt1, kind=mytype), kind=mytype)!(xtt+xtt)/xt1
enddo
do j = sp%yst(2),sp%yen(2)
   ytt=cmplx((biciy6*2.*cos(real(eys(j), kind=mytype)*3.*dy/2.)+&amp;amp;
        ciciy6*2.*cos(real(eys(j), kind=mytype)*5.*dy/2.)),&amp;amp;
        (biciy6*2.*cos(real(eys(j), kind=mytype)*3.*dy/2.)+&amp;amp;
        ciciy6*2.*cos(real(eys(j), kind=mytype)*5.*dy/2.)), kind=mytype)
   ytt1=cmplx((aiciy6*2.*cos(real(eys(j), kind=mytype)*dy/2.)),&amp;amp;
        (aiciy6*2.*cos(real(eys(j), kind=mytype)*dy/2.)), kind=mytype)
   yt1=cmplx((1.+2.*ailcaiy6*cos(real(eys(j), kind=mytype)*dy)),&amp;amp;
        (1.+2.*ailcaiy6*cos(real(eys(j), kind=mytype)*dy)), kind=mytype)
   transy(j)=cmplx(real(ytt1+ytt, kind=mytype)/real(yt1, kind=mytype),&amp;amp;
        real(ytt1+ytt, kind=mytype)/real(yt1, kind=mytype), kind=mytype)!(ytt+ytt)/yt1
enddo
if (nclz==0) then
   do k = sp%yst(3),sp%yen(3)
      ztt=cmplx((biciz6*2.*cos(real(ezs(k), kind=mytype)*3.*dz/2.)+&amp;amp;
           ciciz6*2.*cos(real(ezs(k), kind=mytype)*5.*dz/2.)),&amp;amp;
           (biciz6*2.*cos(real(ezs(k), kind=mytype)*3.*dz/2.)+&amp;amp;
           ciciz6*2.*cos(real(ezs(k), kind=mytype)*5.*dz/2.)), kind=mytype)
      ztt1=cmplx((aiciz6*2.*cos(real(ezs(k), kind=mytype)*dz/2.)),&amp;amp;
           (aiciz6*2.*cos(real(ezs(k), kind=mytype)*dz/2.)), kind=mytype)
      zt1=cmplx((1.+2.*ailcaiz6*cos(real(ezs(k), kind=mytype)*dz)),&amp;amp;
           (1.+2.*ailcaiz6*cos(real(ezs(k), kind=mytype)*dz)), kind=mytype)
      transz(k)=cmplx(real(ztt1+ztt, kind=mytype)/real(zt1, kind=mytype),&amp;amp;
           aimag(ztt1+ztt)/aimag(zt1), kind=mytype)!(ztt+ztt)/zt1
   enddo
else
   do k = sp%yst(3),sp%yen(3)
      ztt=cmplx((biciz6*2.*cos(real(ezs(k), kind=mytype)*3.*dz/2.)+&amp;amp;
           ciciz6*2.*cos(real(ezs(k), kind=mytype)*5.*dz/2.)),&amp;amp;
           (biciz6*2.*cos(aimag(ezs(k))*3.*dz/2.)+&amp;amp;
           ciciz6*2.*cos(aimag(ezs(k))*5.*dz/2.)), kind=mytype)
      ztt1=cmplx((aiciz6*2.*cos(real(ezs(k), kind=mytype)*dz/2.)),&amp;amp;
           (aiciz6*2.*cos(aimag(ezs(k))*dz/2.)), kind=mytype)
      zt1=cmplx((1.+2.*ailcaiz6*cos(real(ezs(k), kind=mytype)*dz)),&amp;amp;
           (1.+2.*ailcaiz6*cos(aimag(ezs(k))*dz)), kind=mytype)
      transz(k)=cmplx(real(ztt1+ztt, kind=mytype)/real(zt1, kind=mytype),&amp;amp;
           aimag(ztt1+ztt)/aimag(zt1), kind=mytype)!(ztt+ztt)/zt1
   enddo
endif

if ((istret==1).or.(istret==2)) then

 
   xa0=alpha/pi+1./2./beta/pi
   if (istret==1) xa1=1./4./beta/pi
   if (istret==2) xa1=-1./4./beta/pi
!
!construction of the pentadiagonal matrice
!
   do k=sp%yst(3),sp%yen(3)
   do j=1,ny/2
   do i=sp%yst(1),sp%yen(1)
      cw22(i,j,k)=cmplx(real(yky(2*j-1), kind=mytype)*real(transx(i), kind=mytype)*real(transz(k), kind=mytype),&amp;amp;
           aimag(yky(2*j-1))*aimag(transx(i))*aimag(transz(k)), kind=mytype)
      cw2(i,j,k)=cmplx(real(yky(2*j), kind=mytype)*real(transx(i), kind=mytype)*real(transz(k), kind=mytype),&amp;amp;
           aimag(yky(2*j))*aimag(transx(i))*aimag(transz(k)), kind=mytype)
   enddo
   enddo
   enddo


   

!main diagonal
   do k=sp%yst(3),sp%yen(3)
   do j=2,ny/2-1
   do i=sp%yst(1),sp%yen(1)
      a(i,j,k,3)=cmplx(-(real(xk2(i), kind=mytype)*real(transy(2*j-1), kind=mytype)*real(transy(2*j-1), kind=mytype)&amp;amp;
           *real(transz(k), kind=mytype)*real(transz(k), kind=mytype))&amp;amp;
           -(real(zk2(k), kind=mytype)*real(transy(2*j-1), kind=mytype)*real(transy(2*j-1), kind=mytype)*&amp;amp;
           real(transx(i), kind=mytype)*real(transx(i), kind=mytype))&amp;amp;
           -real(cw22(i,j,k), kind=mytype)*real(cw22(i,j,k), kind=mytype)*xa0*xa0-&amp;amp;
           xa1*xa1*(real(cw22(i,j,k), kind=mytype)*real(cw22(i,j-1,k), kind=mytype)+real(cw22(i,j,k), kind=mytype)*&amp;amp;
           real(cw22(i,j+1,k), kind=mytype)),&amp;amp;
           -(aimag(xk2(i))*aimag(transy(2*j-1))*aimag(transy(2*j-1))*aimag(transz(k))*aimag(transz(k)))&amp;amp;
           -(aimag(zk2(k))*aimag(transy(2*j-1))*aimag(transy(2*j-1))*aimag(transx(i))*aimag(transx(i)))&amp;amp;
           -aimag(cw22(i,j,k))*aimag(cw22(i,j,k))*xa0*xa0-&amp;amp;
           xa1*xa1*(aimag(cw22(i,j,k))*aimag(cw22(i,j-1,k))+aimag(cw22(i,j,k))*aimag(cw22(i,j+1,k))), kind=mytype)
      a2(i,j,k,3)=cmplx(-(real(xk2(i), kind=mytype)*real(transy(2*j), kind=mytype)*real(transy(2*j), kind=mytype)*&amp;amp;
           real(transz(k), kind=mytype)*real(transz(k), kind=mytype))&amp;amp;
           -(real(zk2(k), kind=mytype)*real(transy(2*j), kind=mytype)*real(transy(2*j), kind=mytype)*&amp;amp;
           real(transx(i), kind=mytype)*real(transx(i), kind=mytype))&amp;amp;
           -real(cw2(i,j,k), kind=mytype)*real(cw2(i,j,k), kind=mytype)*xa0*xa0-&amp;amp;
           xa1*xa1*(real(cw2(i,j,k), kind=mytype)*real(cw2(i,j-1,k), kind=mytype)+real(cw2(i,j,k), kind=mytype)*&amp;amp;
           real(cw2(i,j+1,k), kind=mytype)),&amp;amp;
           -(aimag(xk2(i))*aimag(transy(2*j))*aimag(transy(2*j))*aimag(transz(k))*aimag(transz(k)))&amp;amp;
           -(aimag(zk2(k))*aimag(transy(2*j))*aimag(transy(2*j))*aimag(transx(i))*aimag(transx(i)))&amp;amp;
           -aimag(cw2(i,j,k))*aimag(cw2(i,j,k))*xa0*xa0-&amp;amp;
           xa1*xa1*(aimag(cw2(i,j,k))*aimag(cw2(i,j-1,k))+aimag(cw2(i,j,k))*aimag(cw2(i,j+1,k))), kind=mytype)
   enddo
   enddo
   do i=sp%yst(1),sp%yen(1)
      a(i,1,k,3)=cmplx(-(real(xk2(i), kind=mytype)*real(transy(1), kind=mytype)*real(transy(1), kind=mytype)*&amp;amp;
           real(transz(k), kind=mytype)*real(transz(k), kind=mytype))&amp;amp;
           -(real(zk2(k), kind=mytype)*real(transy(1), kind=mytype)*real(transy(1), kind=mytype)*&amp;amp;
           real(transx(i), kind=mytype)*real(transx(i), kind=mytype))&amp;amp;
           -real(cw22(i,1,k), kind=mytype)*real(cw22(i,1,k), kind=mytype)*xa0*xa0-xa1*xa1*(real(cw22(i,1,k), kind=mytype)*&amp;amp;
           real(cw22(i,2,k), kind=mytype)),&amp;amp;
           -(aimag(xk2(i))*aimag(transy(1))*aimag(transy(1))*aimag(transz(k))*aimag(transz(k)))&amp;amp;
           -(aimag(zk2(k))*aimag(transy(1))*aimag(transy(1))*aimag(transx(i))*aimag(transx(i)))&amp;amp;
           -aimag(cw22(i,1,k))*aimag(cw22(i,1,k))*xa0*xa0-xa1*xa1*(aimag(cw22(i,1,k))*aimag(cw22(i,2,k))), kind=mytype)
      a(i,ny/2,k,3)=cmplx(-(real(xk2(i), kind=mytype)*real(transy(ny-2), kind=mytype)*real(transy(ny-2), kind=mytype)&amp;amp;
           *real(transz(k), kind=mytype)*real(transz(k), kind=mytype))&amp;amp;
           -(real(zk2(k), kind=mytype)*real(transy(ny-2), kind=mytype)*real(transy(ny-2), kind=mytype)*&amp;amp;
           real(transx(i), kind=mytype)*real(transx(i), kind=mytype))&amp;amp;
           -real(cw22(i,ny/2,k), kind=mytype)*real(cw22(i,ny/2,k), kind=mytype)*xa0*xa0-&amp;amp;
           xa1*xa1*(real(cw22(i,ny/2,k), kind=mytype)*real(cw22(i,ny/2-1,k), kind=mytype)),&amp;amp;
           -(aimag(xk2(i))*aimag(transy(ny-2))*aimag(transy(ny-2))*aimag(transz(k))*aimag(transz(k)))&amp;amp;
           -(aimag(zk2(k))*aimag(transy(ny-2))*aimag(transy(ny-2))*aimag(transx(i))*aimag(transx(i)))&amp;amp;
           -aimag(cw22(i,ny/2,k))*aimag(cw22(i,ny/2,k))*xa0*xa0-&amp;amp;
           xa1*xa1*(aimag(cw22(i,ny/2,k))*aimag(cw22(i,ny/2-1,k))), kind=mytype)
      a2(i,1,k,3)=cmplx(-(real(xk2(i), kind=mytype)*real(transy(2), kind=mytype)*real(transy(2), kind=mytype)*&amp;amp;
           real(transz(k), kind=mytype)*real(transz(k), kind=mytype))&amp;amp;
           -(real(zk2(k), kind=mytype)*real(transy(2), kind=mytype)*real(transy(2), kind=mytype)*&amp;amp;
           real(transx(i), kind=mytype)*real(transx(i), kind=mytype))&amp;amp;
           -real(cw2(i,1,k), kind=mytype)*real(cw2(i,1,k), kind=mytype)*(xa0-xa1)*(xa0+xa1)-xa1*xa1*(real(cw2(i,1,k), kind=mytype)*&amp;amp;
           real(cw2(i,2,k), kind=mytype)),&amp;amp;
           -(aimag(xk2(i))*aimag(transy(2))*aimag(transy(2))*aimag(transz(k))*aimag(transz(k)))&amp;amp;
           -(aimag(zk2(k))*aimag(transy(2))*aimag(transy(2))*aimag(transx(i))*aimag(transx(i)))&amp;amp;
           -aimag(cw2(i,1,k))*aimag(cw2(i,1,k))*(xa0-xa1)*(xa0+xa1)-xa1*xa1*(aimag(cw2(i,1,k))*aimag(cw2(i,2,k))), kind=mytype)
      a2(i,ny/2,k,3)=cmplx(-(real(xk2(i), kind=mytype)*real(transy(ny-1), kind=mytype)*real(transy(ny-1), kind=mytype)*&amp;amp;
           real(transz(k), kind=mytype)*real(transz(k), kind=mytype))&amp;amp;
           -(real(zk2(k), kind=mytype)*real(transy(ny-1), kind=mytype)*real(transy(ny-1), kind=mytype)*&amp;amp;
           real(transx(i), kind=mytype)*real(transx(i), kind=mytype))&amp;amp;
           -real(cw2(i,ny/2,k), kind=mytype)*real(cw2(i,ny/2,k), kind=mytype)*(xa0+xa1)*(xa0+xa1)-&amp;amp;
           xa1*xa1*(real(cw2(i,ny/2,k), kind=mytype)*real(cw2(i,ny/2-1,k), kind=mytype)),&amp;amp;
           -(aimag(xk2(i))*aimag(transy(ny-1))*aimag(transy(ny-1))*aimag(transz(k))*aimag(transz(k)))&amp;amp;
           -(aimag(zk2(k))*aimag(transy(ny-1))*aimag(transy(ny-1))*aimag(transx(i))*aimag(transx(i)))&amp;amp;
           -aimag(cw2(i,ny/2,k))*aimag(cw2(i,ny/2,k))*(xa0+xa1)*(xa0+xa1)-&amp;amp;
           xa1*xa1*(aimag(cw2(i,ny/2,k))*aimag(cw2(i,ny/2-1,k))), kind=mytype)
   enddo
   enddo
   
 

 

!sup diag +1
   do k=sp%yst(3),sp%yen(3)
   do j=2,ny/2-1
   do i=sp%yst(1),sp%yen(1)   
      a(i,j,k,4)=cmplx(xa0*xa1*(real(cw22(i,j,k), kind=mytype)*real(cw22(i,j+1,k), kind=mytype)+real(cw22(i,j+1,k), kind=mytype)*&amp;amp;
           real(cw22(i,j+1,k), kind=mytype)),&amp;amp;
           xa0*xa1*(aimag(cw22(i,j,k))*aimag(cw22(i,j+1,k))+aimag(cw22(i,j+1,k))*aimag(cw22(i,j+1,k))), kind=mytype)
      a2(i,j,k,4)=cmplx(xa0*xa1*(real(cw2(i,j,k), kind=mytype)*real(cw2(i,j+1,k), kind=mytype)+real(cw2(i,j+1,k), kind=mytype)*&amp;amp;
           real(cw2(i,j+1,k), kind=mytype)),&amp;amp;
           xa0*xa1*(aimag(cw2(i,j,k))*aimag(cw2(i,j+1,k))+aimag(cw2(i,j+1,k))*aimag(cw2(i,j+1,k))), kind=mytype)
   enddo
   enddo
   do i=sp%yst(1),sp%yen(1)   
      a(i,1,k,4)=2.*cmplx((xa0*xa1*(real(cw22(i,1,k), kind=mytype)*real(cw22(i,2,k), kind=mytype)+real(cw22(i,2,k), kind=mytype)*&amp;amp;
           real(cw22(i,2,k), kind=mytype))),&amp;amp;
           (xa0*xa1*(aimag(cw22(i,1,k))*aimag(cw22(i,2,k))+aimag(cw22(i,2,k))*aimag(cw22(i,2,k)))), kind=mytype)
      a2(i,1,k,4)=cmplx((xa0-xa1)*xa1*(real(cw2(i,1,k), kind=mytype)*real(cw2(i,2,k), kind=mytype))&amp;amp;
           +xa0*xa1*(real(cw2(i,2,k), kind=mytype)*real(cw2(i,2,k), kind=mytype)),&amp;amp;
           (xa0-xa1)*xa1*(aimag(cw2(i,1,k))*aimag(cw2(i,2,k)))&amp;amp;
           +xa0*xa1*(aimag(cw2(i,2,k))*aimag(cw2(i,2,k))), kind=mytype)
      a2(i,ny/2-1,k,4)=cmplx(xa0*xa1*(real(cw2(i,ny/2-1,k), kind=mytype)*real(cw2(i,ny/2,k), kind=mytype))&amp;amp;
           +(xa0+xa1)*xa1*(real(cw2(i,ny/2,k), kind=mytype)*real(cw2(i,ny/2,k), kind=mytype)),&amp;amp;
           xa0*xa1*(aimag(cw2(i,ny/2-1,k))*aimag(cw2(i,ny/2,k)))&amp;amp;
           +(xa0+xa1)*xa1*(aimag(cw2(i,ny/2,k))*aimag(cw2(i,ny/2,k))), kind=mytype)
      a2(i,ny/2,k,4)=0.
   enddo
   enddo



!sup diag +2
   do k=sp%yst(3),sp%yen(3)
   do i=sp%yst(1),sp%yen(1)   
   do j=1,ny/2-2
      a(i,j,k,5)=cmplx(-real(cw22(i,j+1,k), kind=mytype)*real(cw22(i,j+2,k), kind=mytype)*xa1*xa1,&amp;amp;
           -aimag(cw22(i,j+1,k))*aimag(cw22(i,j+2,k))*xa1*xa1, kind=mytype)
      a2(i,j,k,5)=cmplx(-real(cw2(i,j+1,k), kind=mytype)*real(cw2(i,j+2,k), kind=mytype)*xa1*xa1,&amp;amp;
           -aimag(cw2(i,j+1,k))*aimag(cw2(i,j+2,k))*xa1*xa1, kind=mytype)
   enddo
   a(i,1,k,5)=cmplx(real(a(i,1,k,5), kind=mytype)*2.,aimag(a(i,1,k,5))*2., kind=mytype)
   a(i,ny/2-1,k,5)=0.
   a(i,ny/2,k,5)=0.
   a2(i,ny/2-1,k,5)=0.
   a2(i,ny/2,k,5)=0.
   enddo
   enddo



!inf diag -1
   do k=sp%yst(3),sp%yen(3)
   do i=sp%yst(1),sp%yen(1)   
   do j=2,ny/2
      a(i,j,k,2)=cmplx(xa0*xa1*(real(cw22(i,j,k), kind=mytype)*real(cw22(i,j-1,k), kind=mytype)+real(cw22(i,j-1,k), kind=mytype)*&amp;amp;
           real(cw22(i,j-1,k), kind=mytype)),&amp;amp;
           xa0*xa1*(aimag(cw22(i,j,k))*aimag(cw22(i,j-1,k))+aimag(cw22(i,j-1,k))*aimag(cw22(i,j-1,k))), kind=mytype)
      a2(i,j,k,2)=cmplx(xa0*xa1*(real(cw2(i,j,k), kind=mytype)*real(cw2(i,j-1,k), kind=mytype)+real(cw2(i,j-1,k), kind=mytype)*&amp;amp;
           real(cw2(i,j-1,k), kind=mytype)),&amp;amp;
           xa0*xa1*(aimag(cw2(i,j,k))*aimag(cw2(i,j-1,k))+aimag(cw2(i,j-1,k))*aimag(cw2(i,j-1,k))), kind=mytype)
   enddo
   a(i,1,k,2)=0.
   a2(i,1,k,2)=0.
   a2(i,2,k,2)=cmplx(xa0*xa1*(real(cw2(i,2,k), kind=mytype)*real(cw2(i,1,k), kind=mytype))&amp;amp;
        +(xa0+xa1)*xa1*(real(cw2(i,1,k), kind=mytype)*real(cw2(i,1,k), kind=mytype)),&amp;amp;
        xa0*xa1*(aimag(cw2(i,2,k))*aimag(cw2(i,1,k)))&amp;amp;
        +(xa0+xa1)*xa1*(aimag(cw2(i,1,k))*aimag(cw2(i,1,k))), kind=mytype)
   a2(i,ny/2,k,2)=cmplx((xa0+xa1)*xa1*(real(cw2(i,ny/2,k), kind=mytype)*real(cw2(i,ny/2-1,k), kind=mytype))&amp;amp;
        +xa0*xa1*(real(cw2(i,ny/2-1,k), kind=mytype)*real(cw2(i,ny/2-1,k), kind=mytype)),&amp;amp;
        (xa0+xa1)*xa1*(aimag(cw2(i,ny/2,k))*aimag(cw2(i,ny/2-1,k)))&amp;amp;
        +xa0*xa1*(aimag(cw2(i,ny/2-1,k))*aimag(cw2(i,ny/2-1,k))), kind=mytype)
   enddo
   enddo
!inf diag -2
   do k=sp%yst(3),sp%yen(3)
   do i=sp%yst(1),sp%yen(1)  
   do j=3,ny/2
      a(i,j,k,1)=cmplx(-real(cw22(i,j-1,k), kind=mytype)*real(cw22(i,j-2,k), kind=mytype)*xa1*xa1,&amp;amp;
           -aimag(cw22(i,j-1,k))*aimag(cw22(i,j-2,k))*xa1*xa1, kind=mytype)
      a2(i,j,k,1)=cmplx(-real(cw2(i,j-1,k), kind=mytype)*real(cw2(i,j-2,k), kind=mytype)*xa1*xa1,&amp;amp;
           -aimag(cw2(i,j-1,k))*aimag(cw2(i,j-2,k))*xa1*xa1, kind=mytype)
   enddo
   a(i,1,k,1)=0.
   a(i,2,k,1)=0.
   a2(i,1,k,1)=0.
   a2(i,2,k,1)=0.
   enddo
   enddo
!not to have a singular matrice
   do k=sp%yst(3),sp%yen(3)
   do i=sp%yst(1),sp%yen(1)
      if ((real(xk2(i), kind=mytype)==0.).and.(real(zk2(k), kind=mytype)==0)) then
         a(i,1,k,3)=cmplx(1.,1., kind=mytype)
         a(i,1,k,4)=0.
         a(i,1,k,5)=0.
      endif
   enddo
   enddo

else
   xa0=alpha/pi+1./2./beta/pi
   xa1=-1./4./beta/pi
!
!construction of the pentadiagonal matrice
!   
   do k=sp%yst(3),sp%yen(3)
   do j=1,nym
   do i=sp%yst(1),sp%yen(1)
      cw22(i,j,k)=cmplx(real(yky(j), kind=mytype)*real(transx(i), kind=mytype)*real(transz(k), kind=mytype),&amp;amp;
           aimag(yky(j))*aimag(transx(i))*aimag(transz(k)), kind=mytype)
   enddo
   enddo
   enddo

!main diagonal
   do k=sp%yst(3),sp%yen(3)
   do j=2,nym-1
   do i=sp%yst(1),sp%yen(1)
      a3(i,j,k,3)=cmplx(-(real(xk2(i), kind=mytype)*real(transy(j), kind=mytype)*real(transy(j), kind=mytype)*&amp;amp;
           real(transz(k), kind=mytype)*real(transz(k), kind=mytype))&amp;amp;
           -(real(zk2(k), kind=mytype)*real(transy(j), kind=mytype)*real(transy(j), kind=mytype)*&amp;amp;
           real(transx(i), kind=mytype)*real(transx(i), kind=mytype))&amp;amp;
           -real(cw22(i,j,k), kind=mytype)*real(cw22(i,j,k), kind=mytype)*xa0*xa0-&amp;amp;
           xa1*xa1*(real(cw22(i,j,k), kind=mytype)*real(cw22(i,j-1,k), kind=mytype)+real(cw22(i,j,k), kind=mytype)*&amp;amp;
           real(cw22(i,j+1,k), kind=mytype)),&amp;amp;
           -(aimag(xk2(i))*aimag(transy(j))*aimag(transy(j))*aimag(transz(k))*aimag(transz(k)))&amp;amp;
           -(aimag(zk2(k))*aimag(transy(j))*aimag(transy(j))*aimag(transx(i))*aimag(transx(i)))&amp;amp;
           -aimag(cw22(i,j,k))*aimag(cw22(i,j,k))*xa0*xa0-&amp;amp;
           xa1*xa1*(aimag(cw22(i,j,k))*aimag(cw22(i,j-1,k))+aimag(cw22(i,j,k))*aimag(cw22(i,j+1,k))), kind=mytype)
   enddo
   enddo
   enddo

   do k=sp%yst(3),sp%yen(3)
   do i=sp%yst(1),sp%yen(1)
      a3(i,1,k,3)=cmplx(-(real(xk2(i), kind=mytype)*real(transy(1), kind=mytype)*real(transy(1), kind=mytype)*&amp;amp;
           real(transz(k), kind=mytype)*real(transz(k), kind=mytype))&amp;amp;
           -(real(zk2(k), kind=mytype)*real(transy(1), kind=mytype)*real(transy(1), kind=mytype)*real(transx(i), kind=mytype)*&amp;amp;
           real(transx(i), kind=mytype))&amp;amp;
           -real(cw22(i,1,k), kind=mytype)*real(cw22(i,1,k), kind=mytype)*xa0*xa0-xa1*xa1*(real(cw22(i,1,k), kind=mytype)*&amp;amp;
           real(cw22(i,2,k), kind=mytype)),&amp;amp;
           -(aimag(xk2(i))*aimag(transy(1))*aimag(transy(1))*aimag(transz(k))*aimag(transz(k)))&amp;amp;
           -(aimag(zk2(k))*aimag(transy(1))*aimag(transy(1))*aimag(transx(i))*aimag(transx(i)))&amp;amp;
           -aimag(cw22(i,1,k))*aimag(cw22(i,1,k))*xa0*xa0-xa1*xa1*(aimag(cw22(i,1,k))*aimag(cw22(i,2,k))), kind=mytype)
      a3(i,nym,k,3)=cmplx(-(real(xk2(i), kind=mytype)*real(transy(nym), kind=mytype)*real(transy(nym), kind=mytype)*&amp;amp;
           real(transz(k), kind=mytype)*real(transz(k), kind=mytype))&amp;amp;
           -(real(zk2(k), kind=mytype)*real(transy(nym), kind=mytype)*real(transy(nym), kind=mytype)*real(transx(i), kind=mytype)*&amp;amp;
           real(transx(i), kind=mytype))&amp;amp;
           -real(cw22(i,nym,k), kind=mytype)*real(cw22(i,nym,k), kind=mytype)*xa0*xa0-&amp;amp;
           xa1*xa1*(real(cw22(i,nym,k), kind=mytype)*real(cw22(i,nym-1,k), kind=mytype)),&amp;amp;
           -(aimag(xk2(i))*aimag(transy(nym))*aimag(transy(nym))*aimag(transz(k))*aimag(transz(k)))&amp;amp;
           -(aimag(zk2(k))*aimag(transy(nym))*aimag(transy(nym))*aimag(transx(i))*aimag(transx(i)))&amp;amp;
           -aimag(cw22(i,nym,k))*aimag(cw22(i,nym,k))*xa0*xa0-&amp;amp;
           xa1*xa1*(aimag(cw22(i,nym,k))*aimag(cw22(i,nym-1,k))), kind=mytype)
   enddo
   enddo

   


!sup diag +1
   do k=sp%yst(3),sp%yen(3)
   do i=sp%yst(1),sp%yen(1)
   do j=2,nym-1
      a3(i,j,k,4)=cmplx(xa0*xa1*(real(cw22(i,j,k), kind=mytype)*real(cw22(i,j+1,k), kind=mytype)+real(cw22(i,j+1,k), kind=mytype)*&amp;amp;
           real(cw22(i,j+1,k), kind=mytype)),&amp;amp;
           xa0*xa1*(aimag(cw22(i,j,k))*aimag(cw22(i,j+1,k))+aimag(cw22(i,j+1,k))*aimag(cw22(i,j+1,k))), kind=mytype)
   enddo
   a3(i,1,k,4)=cmplx((xa0*xa1*(real(cw22(i,1,k), kind=mytype)*real(cw22(i,2,k), kind=mytype)+real(cw22(i,2,k), kind=mytype)*&amp;amp;
        real(cw22(i,2,k), kind=mytype))),&amp;amp;
        (xa0*xa1*(aimag(cw22(i,1,k))*aimag(cw22(i,2,k))+aimag(cw22(i,2,k))*aimag(cw22(i,2,k)))), kind=mytype)
   enddo
   enddo
!sup diag +2
   do k=sp%yst(3),sp%yen(3)
   do i=sp%yst(1),sp%yen(1)
   do j=1,nym-2
      a3(i,j,k,5)=cmplx(-real(cw22(i,j+1,k), kind=mytype)*real(cw22(i,j+2,k), kind=mytype)*xa1*xa1,&amp;amp;
           -aimag(cw22(i,j+1,k))*aimag(cw22(i,j+2,k))*xa1*xa1, kind=mytype)
   enddo
   !a3(i,1,k,5)=a3(i,1,k,5)*2.
   !a3(i,1,k,5)=0.
   a3(i,nym-1,k,5)=0.
   a3(i,nym,k,5)=0.
   enddo
   enddo


!inf diag -1
   do k=sp%yst(3),sp%yen(3)
   do i=sp%yst(1),sp%yen(1)
   do j=2,nym
      a3(i,j,k,2)=cmplx(xa0*xa1*(real(cw22(i,j,k), kind=mytype)*real(cw22(i,j-1,k), kind=mytype)+real(cw22(i,j-1,k), kind=mytype)*&amp;amp;
           real(cw22(i,j-1,k), kind=mytype)),&amp;amp;
           xa0*xa1*(aimag(cw22(i,j,k))*aimag(cw22(i,j-1,k))+aimag(cw22(i,j-1,k))*aimag(cw22(i,j-1,k))), kind=mytype)
   enddo
   a3(i,1,k,2)=0.
   enddo
   enddo
!inf diag -2
   do k=sp%yst(3),sp%yen(3)
   do i=sp%yst(1),sp%yen(1)
   do j=3,nym
      a3(i,j,k,1)=cmplx(-real(cw22(i,j-1,k), kind=mytype)*real(cw22(i,j-2,k), kind=mytype)*xa1*xa1,&amp;amp;
           -aimag(cw22(i,j-1,k))*aimag(cw22(i,j-2,k))*xa1*xa1, kind=mytype)
   enddo
   a3(i,1,k,1)=0.
   a3(i,2,k,1)=0.
   enddo
   enddo

!not to have a singular matrice
!   do k=sp%yst(3),sp%yen(3)
!   do i=sp%yst(1),sp%yen(1)
!      if ((xkx(i)==0.).and.(zkz(k)==0)) then
if (nrank==0) then
   a3(1,1,1,3)=cmplx(1.,1., kind=mytype)
   a3(1,1,1,4)=0.
   a3(1,1,1,5)=0.
endif
!      endif
!   enddo
!   enddo
endif


   


return
end subroutine matrice_refinement

end module decomp_2d_poisson
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
  </channel>
</rss>
