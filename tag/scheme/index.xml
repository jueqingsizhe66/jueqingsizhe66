<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>scheme | 突然的~自我~</title>
    <link>https://jueqingsizhe66.github.io/tag/scheme/</link>
      <atom:link href="https://jueqingsizhe66.github.io/tag/scheme/index.xml" rel="self" type="application/rss+xml" />
    <description>scheme</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><copyright>©2023</copyright><lastBuildDate>Wed, 10 May 2023 23:22:19 +0800</lastBuildDate>
    <image>
      <url>https://jueqingsizhe66.github.io/media/icon_hua2ec155b4296a9c9791d015323e16eb5_11927_512x512_fill_lanczos_center_3.png</url>
      <title>scheme</title>
      <link>https://jueqingsizhe66.github.io/tag/scheme/</link>
    </image>
    
    <item>
      <title>What&#39;s the Same</title>
      <link>https://jueqingsizhe66.github.io/post/whats-the-same/</link>
      <pubDate>Wed, 10 May 2023 23:22:19 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/post/whats-the-same/</guid>
      <description>&lt;p&gt;什么是公平？
没有人知道公平是什么，all atoms create equal!&lt;/p&gt;
&lt;h1&gt; eq? &lt;/h1&gt;
比较两个字符是否相等
&lt;h1&gt; = &lt;/h1&gt;
比较两个数字是否相等
&lt;h1&gt; eqan? &lt;/h1&gt;
比较两个字符或者数字是否相等,需要借用`eq?`和`=`
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define eqan?
   ;; only evaluate atoms of number and character
  (lambda (n1 n2)
    (cond
      ((and (number? n1) (number? n2))
       (= n1 n2))
      ((or (number? n1) (number? n2))
       #f)
      (else
       (eq? n1 n2)))))

&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt; eqlist? &lt;/h1&gt;
&lt;p&gt;比较两个list是否相等，需要借用&lt;code&gt;eqan?&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define eqlist?
  ;; only anlysis list argument
  (lambda (l1 l2)
    (letrec ((atom? (lambda (a1)
                      (and (not (pair? a1)) (not (null? a1))))))
      (cond
        ((and (null? l1) (null? l2)) #t)
        ((or (null? l1) (null? l2)) #f)
        ((and (atom? (car l1)) (atom? (car l2)))
         (and (eqan? (car l1) (car l2)) (eqlist? (cdr l1) (cdr l2))))
        ((or (atom? (car l1)) (atom? (car l2))) #f)
        (else
         (and (eqlist? (car l1) (car l2))
              (eqlist? (cdr l1) (cdr l2))))))))


&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt; equal? &lt;/h1&gt;
&lt;p&gt;比较两个字符或者数字或者list是否相等，更加普遍些&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define equal?
  ;; accept s-expressions as arguments( atoms 、lat  and  lists)
  (lambda (s1 s2)
    (letrec ((atom? (lambda (x)
                      (and (not (null? x)) (not (pair? x))))))
      (cond
        ((and (atom? s1) (atom? s2))
         (eqan? s1 s2))
        ((or (atom? s1) (atom? s2))
         #f)
        (else
         (eqlist? s1 s2))))))

&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt; 过去的yzl和现在的yzl是否相同&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define yzl
  (lambda (things)
    (letrec ((atom? (lambda (thing)
                      (and (not (pair? thing)) (not (null? thing))))))
    (cond ((null? things) (quote &#39;nervous))
          ((atom? (car things))
             (cons (quote &#39;done) (yzl (cdr things))))
          (else
            (cons (yzl (car things)) (yzl (cdr things))))))))
;;; (yzl &#39;(get learn study buy travel do wash eat create))
;;; &#39;(&#39;done &#39;done &#39;done &#39;done &#39;done &#39;done &#39;done &#39;done quote nervous)  
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Are we finish?&lt;/li&gt;
&lt;li&gt;Do you have any other questions?&lt;/li&gt;
&lt;li&gt;what&amp;rsquo;s the meaning of that?&lt;/li&gt;
&lt;li&gt;I regret that I cannot recall who remarked the computation is the art of carefully throwing away information, while Computer science deals with information and with complexity: give an overwhelming collection of data, you reduce it to
useable result by discarding most of its content(进行边缘计算，只取回特征值)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;抽象很重要。计算科学面临的最大的问题就是计算复杂度；随着程序变大的，计算复杂度极具增大，abstraction is the primary tool
or technique for managing complexity. 因为An abstraction hides unnecessary detail and allow recurring patterns to be
expressed concisely(递归表达), less is more(少就是多)
我们面临的最大的挑战就是how to convey the necessary details without losing the overall structure(不失全局)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Abstract mean you give sth a name; Abstraction is the most important concept in all of the computer science
Abstraction consists in treating sth complex as if they were simpler, throwing away details.&lt;/li&gt;
&lt;li&gt;Reference means you call sth by name&lt;/li&gt;
&lt;li&gt;While Synthesis means you combine two of the things(Abstract and Reference) From 《scheme and art of programming》(抽象的反义词 合成  抽象为简单、合成为复杂)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Solve problems not only for their solutions but also or an understanding of how the solutions were obtained(也许背后的求解思路更重要)&lt;/p&gt;
&lt;p&gt;The task that confronts you is not only to learn a programming language but to learn to think as a computer scientist and develop an aesthetic about computer programs( make them become elegant&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>From Little Scheme to Season Scheme</title>
      <link>https://jueqingsizhe66.github.io/archives/from-little-scheme-to-season-scheme/</link>
      <pubDate>Fri, 11 Aug 2017 20:13:42 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/archives/from-little-scheme-to-season-scheme/</guid>
      <description>&lt;p&gt;The Little Scheme(TLS) 提出了&lt;code&gt;rember&lt;/code&gt;,&lt;code&gt;multirember&lt;/code&gt;,&lt;code&gt;multirember*&lt;/code&gt;以及&lt;code&gt;multirember&amp;amp;Col collector&lt;/code&gt;等系列函数的定义;&lt;/p&gt;
&lt;p&gt;而在The Season Scheme(TSS) 进一步改进了&lt;code&gt;rember&lt;/code&gt;系列函数， 使用&lt;code&gt;let&lt;/code&gt;、&lt;code&gt;letrec&lt;/code&gt;、&lt;code&gt;letcc&lt;/code&gt;进行改写，并结合&lt;code&gt;leftmost&lt;/code&gt;和&lt;code&gt;deep&lt;/code&gt;函数的想法，又提出了&lt;code&gt;rember&lt;/code&gt;的函数，该函数表示删除最左边的函数。&lt;/p&gt;
&lt;p&gt;在此过程中，剖析每一个简单的函数(并由此带来智趣)， 并进行改进，升级，提炼，从中可以体味到&lt;a href=&#34;http://blog.sina.com.cn/s/blog_bffd70da0101f4sl.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt; 华罗庚老先生 &lt;/a&gt;说的”书越读越薄，并积厚薄书”的感觉,从繁杂中感受直观的本质， 借以理解事物，从另外一个角度看待事物。&lt;/p&gt;
&lt;p&gt;一、The Little Scheme&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;rember&lt;/li&gt;
&lt;li&gt;multirember&lt;/li&gt;
&lt;li&gt;multiremberStar&lt;/li&gt;
&lt;li&gt;multiremberStarCol&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;二、The Season Scheme&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;rember-let&lt;/li&gt;
&lt;li&gt;rember-letrec&lt;/li&gt;
&lt;li&gt;rember-letcc&lt;/li&gt;
&lt;li&gt;rember star&lt;/li&gt;
&lt;li&gt;depthStar improvement&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;一the-little-scheme&#34;&gt;一、The Little Scheme&lt;/h1&gt;
&lt;p&gt;scheme的核心数据结构是List，通过list进行算法的演算，而rember是其中的一种算法，用于去除其中的一个元素。 并在rember的同级函数中，也定义了subst，member，insert left, insert right等。在TLS书中也提出了这些函数的相同之处并最终使用insert-g来统一各个函数，这是不错的思想。&lt;/p&gt;
&lt;h2 id=&#34;11-rember&#34;&gt;1.1 rember&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define rember-f
  (lambda (test?)
          (lambda (a lat)
            (cond
              ((null? lat) &#39;())
              ((test? a (car lat))
               (cdr lat))
              (else
               (cons (car lat)
                     ((multirember-f test?) a (cdr lat))))))))

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Another related procedures:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define insertL
  (lambda (new old lat)
    (cond
      ((null? lat)
       &#39;())
      ((eq? (car lat) old)
       (cons new (cons old (cdr lat))))
      (else
       (cons new (insertL new old (cdr lat)))))))


(define insertLR
  (lambda (new oldL oldR lat)
    (cond
      ((null? lat)
       &#39;())
      ((eq? (car lat) oldL)
       (cons new (cons oldL (cdr lat))))
      ((eq? (car lat) oldR)
       (cons oldR (cons new (cdr lat))))
      (else
       (cons (car lat) (insertLR new oldL oldR (cdr lat)))))))

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;进一步可以参考 &lt;a href=&#34;http://jueqingsizhe66.github.io/blog/2015/05/18/the-little-scheme-and-part-of-tss/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt; TLS and TSS Backup &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;为了更进一步删除一个列表(未嵌套多个list)时候所有的元素(定义为lat version)&lt;/p&gt;
&lt;h2 id=&#34;12-multirember&#34;&gt;1.2 multirember&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define multirember-f
  (lambda (test?)
          (lambda (a lat)
            (cond
              ((null? lat) &#39;())
              ((test? a (car lat))
               ((multirember-f test?) a (cdr lat)))
              (else
               (cons (car lat)
                     ((multirember-f test?) a (cdr lat))))))))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Another related procedures:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define multiinsertLR
  (lambda (new oldL oldR lat)
    (cond
      ((null? lat)
       &#39;())
      ((eq? (car lat) oldL)
       (cons new (cons oldL (multiinsertLR new oldL oldR (cdr lat)))))
      ((eq? (car lat) oldR)
       (cons oldR (cons new (multiinsertLR new oldL oldR (cdr lat)))))
      (else
       (cons (car lat) (multiinsertLR new oldL oldR (cdr lat)))))))


;(insertL &#39;a &#39;b &#39;(a b c (a b c)))
;&#39;(a a b c (a b c))

;(insertLR &#39;water &#39;a &#39;b &#39;(a bc b c d (a c b)))
;&#39;(water a bc b c d (a c b))

 (multiinsertLR &#39;water &#39;a &#39;b &#39;(a b c d a b (a b c d)))
&#39;(water a b water c d water a b water (a b c d))
&amp;gt; (insertLR &#39;water &#39;a &#39;b &#39;(a b c d a b (a b c d)))
&#39;(water a b c d a b (a b c d))

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;13-multirember&#34;&gt;1.3 multirember*&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define multiinsertLR*
  (lambda (new oldL oldR lat)
    (define atom?
      (lambda (x)
        (and  (not (pair? x)) (not (null? x)))))
    (cond
      ((null? lat)
       &#39;())
      ((atom? (car lat))
       (cond 
         ((eq? (car lat) oldL)
          (cons new (cons oldL (multiinsertLR* new oldL oldR (cdr lat)))))
         ((eq? (car lat) oldR)
          (cons oldR (cons new (multiinsertLR* new oldL oldR (cdr lat)))))
         (else
          (cons (car lat) (multiinsertLR* new oldL oldR (cdr lat))))))
      (else
       (cons (multiinsertLR* new oldL oldR (car lat))
             (multiinsertLR* new oldL oldR (cdr lat)))))))


(define evens-only*
  (lambda (l)

    (define atom?
      (lambda (x)
        (and (not (pair? x)) (not (null? x)))))
    (cond
      ((null? l) &#39;())
      ((atom? (car l))
       (cond
         ((even? (car l))
          (cons (car l) (evens-only* (cdr l))))
         (else (evens-only* (cdr l)))))
      (else
       (cons (evens-only* (car l))
             (evens-only* (cdr l)))))))


&amp;gt; (multiinsertLR* &#39;water &#39;a &#39;b &#39;(a b c d a b (a b c d)))
&#39;(water a b water c d water a b water (water a b water c d))
&amp;gt; (multiinsertLR &#39;water &#39;a &#39;b &#39;(a b c d a b (a b c d)))
&#39;(water a b water c d water a b water (a b c d))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Another related procedures:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define multiinsertLR*let
  (lambda (new oldL oldR lat)
    (define atom?
      (lambda (x)
        (and  (not (pair? x)) (not (null? x)))))
    (cond
      ((null? lat)
       &#39;())
      ((atom? (car lat))
        (let ((rest (multiinsertLR* new oldL oldR (cdr lat))))
          (cond 
            ((eq? (car lat) oldL)
             (cons new (cons oldL rest)))
            ((eq? (car lat) oldR)
             (cons oldR (cons new rest)))
            (else
             (cons (car lat) rest)))))
      (else
       (let ((first (multiinsertLR* new oldL oldR (car lat)))
             (rest (multiinsertLR* new oldL oldR (cdr lat))))
       (cons first rest))))))



(define multiinsertLR*letrec
  (lambda (new oldL oldR lat)
    (define atom?
      (lambda (x)
        (and  (not (pair? x)) (not (null? x)))))
    (define mul-help
      (lambda (lat)
        (cond
          ((null? lat)
           &#39;())
          ((atom? (car lat))
           (cond 
             ((eq? (car lat) oldL)
              (cons new (cons oldL (mul-help  (cdr lat)))))
             ((eq? (car lat) oldR)
              (cons oldR (cons new (mul-help  (cdr lat)))))
             (else
              (cons (car lat) (mul-help  (cdr lat))))))
          (else
           (cons (mul-help  (car lat))
                 (mul-help  (cdr lat)))))))
    (mul-help lat)))

&amp;gt; (multiinsertLR*let &#39;water &#39;a &#39;b &#39;(a b c d a b (a b c d)))
&#39;(water a b water c d water a b water (water a b water c d))
&amp;gt; (multiinsertLR* &#39;water &#39;a &#39;b &#39;(a b c d a b (a b c d)))
&#39;(water a b water c d water a b water (water a b water c d))
&amp;gt; (multiinsertLR &#39;water &#39;a &#39;b &#39;(a b c d a b (a b c d)))
&#39;(water a b water c d water a b water (a b c d))

(multiinsertLR*letrec &#39;water &#39;a &#39;b &#39;(a b c d a b (a b c d)))
&#39;(water a b water c d water a b water (water a b water c d))



(define multiinsertLR*letreclet
  (lambda (new oldL oldR lat)
    (define atom?
      (lambda (x)
        (and  (not (pair? x)) (not (null? x)))))
    (define mul-help
      (lambda (lat)
        (cond
          ((null? lat)
           &#39;())
          ((atom? (car lat))
           (let ((rest (mul-help  (cdr lat))))
           (cond 
             ((eq? (car lat) oldL)
              (cons new (cons oldL rest)))
             ((eq? (car lat) oldR)
              (cons oldR (cons new rest)))
             (else
              (cons (car lat) rest)))))
          (else
           (let ((first (mul-help  (car lat)))
                 (rest (mul-help  (cdr lat))))
           (cons first rest))))))
    (mul-help lat)))

(multiinsertLR*letreclet &#39;water &#39;a &#39;b &#39;(a b c d a b (a b c d)))
&#39;(water a b water c d water a b water (water a b water c d))
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;14-multiremberstar-and-collector&#34;&gt;1.4 multiremberstar and collector&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define multirember*co
  (lambda (a lat col)
    (define atom?
      (lambda (x)
        (and (not (pair? x)) (not (null? x)))))
    (cond
      (( null? lat)
       (col (quote ()) (quote ())))
      ((atom? (car lat))
       (cond
         ((eq? ( car lat) a)
         (multirember*co a (cdr lat)
                        (lambda ( newlat seen)
                          (col newlat (cons (car lat)
                                            seen)))))
       (else
        (multirember*co a (cdr lat)
                       (lambda (newlat seen)
                         (col (cons (car lat) newlat) seen))))))
      (else
       (multirember*co a (car lat)
                       (lambda (al as)
                         (multirember*co a (cdr lat)
                                         (lambda (dl ds)
                                           (col (cons al dl)
                                                (cons as ds))))))))))

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Another related procedures:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define col
   (lambda (x y)
      (null? y)))


(define a-friend
   (lambda (x y)
      (length x)))

(define a-friend-y
   (lambda (x y)
      (length y)))


(define a-friend-z
   (lambda (x y)
      (cons x (cons y &#39;()))))

(define a-friend-zp
   (lambda (x y z)
      (cons x (cons y (cons z &#39;())))))

(define evens-only*col
  (lambda (l col)

    (define atom?
      (lambda (x)
        (and (not (pair? x)) (not (null? x)))))
    (cond
      ((null? l) (col &#39;() 1 0))
      ((atom? (car l))
       (cond
         ((even? (car l))
          (evens-only*col (cdr l)
                          (lambda (newlat L R)
                            (col (cons (car l) newlat) (* (car l) L) R))))
         (else (evens-only*col (cdr l) (lambda (newlat L R)
                                      (col newlat L
                                           (+ (car l) R)))))))
      (else
       (evens-only*col (car l)
                       (lambda (al ale ari)
                         (evens-only*col (cdr l)
                                         (lambda (dl dle dri)
                                           (col (cons al dl)
                                                (* ale dle)
                                                (+ ari dri))))))))))


(define multiinsertLRo
  (lambda (new oldL oldR lat col)
    (cond
      ((null? lat) (col &#39;() 0 0))
      ((eq? (car lat) oldL)
       (multiinsertLRo new oldL oldR (cdr lat)
                       (lambda (newlat L R)
                         (col (cons new (cons oldL newlat))
                              (+ L 1) R))))
      ((eq? (car lat) oldR)
       (multiinsertLRo new oldL oldR (cdr lat)
                       (lambda (newlat L R)
                         (col (cons oldR (cons new newlat))
                              L (+ R 1)))))
      (else
       (multiinsertLRo new oldL oldR (cdr lat)
                       (lambda (newlat L R)
                         (col (cons (car lat) newlat)
                              L
                              R)))))))




(define multiinsertLR*o
  (lambda (new oldL oldR lat col)
    (define atom?
      (lambda (x)
        (and (not (pair? x)) (not (null? x)))))
    (cond
      ((null? lat) (col &#39;() 0 0))
      ((atom? (car lat))
       (cond
         ((eq? (car lat) oldL)
          (multiinsertLR*o new oldL oldR (cdr lat)
                          (lambda (newlat L R)
                            (col (cons new (cons oldL newlat))
                                 (+ L 1) R))))
         ((eq? (car lat) oldR)
          (multiinsertLR*o new oldL oldR (cdr lat)
                          (lambda (newlat L R)
                            (col (cons oldR (cons new newlat))
                                 L (+ R 1)))))
         (else
          (multiinsertLR*o new oldL oldR (cdr lat)
                          (lambda (newlat L R)
                            (col (cons (car lat) newlat)
                                 L
                                 R))))))
      (else
       (multiinsertLR*o new oldL oldR (car lat)
                        (lambda (al ale ari)
                          (multiinsertLR*o new oldL oldR (cdr lat)
                                           (lambda (dl dle dri)
                                             (col (cons al dl)
                                                  (+ ale dle)
                                                  (+ ari dri))))))))))

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;二the-season-scheme&#34;&gt;二、The Season Scheme&lt;/h1&gt;
&lt;p&gt;由&lt;code&gt;member&lt;/code&gt;和&lt;code&gt;rember&lt;/code&gt;又可以深入进行剖析，于是引进了&lt;code&gt;member&lt;/code&gt;的升级版本&lt;code&gt;two-in-a-lat&lt;/code&gt;,未包含TSS的最后一个two-in-a-lat的实现，并通过let,letrec,letcc改写TLS中的rember系列函数，在结合leftmost和deep(Later on,deep有两外一层意思就是产生n层的pizza)函数，升级rember到删除最左边的一个元素。&lt;/p&gt;
&lt;p&gt;Member实际上在所有的函数的实现中都有对应的组成，他是一个十分重要的组成部分，包括基于member的union,intersect,intersectall函数的，一个相对基础的函数。
the definition of member&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define member?
  (lambda (a lat)
    (cond
      ((null? lat) #f)
      (else
       (or (eq? a (car lat))
           (member a (cdr lat)))))))

; member-letrec version
(define member?
  (lambda (a l)
    (letrec
      ((yes? (lambda (l)
               (cond
                 ((null? l) #f)
                 ((eq? (car l) a) #t)
                 (else (yes? (cdr l)))))))
      (yes? l))))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在让我们看看two-in-a-lat的引申(通过member)
Two -in -a -lat&lt;/p&gt;
&lt;p&gt;包含two-in-a-lat(用member2代替),并附加sum-of-prefix和scramble函数的实现，目的是说如果你想让函数知道额外的信息，可以通过增加参数的方法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define member-letrec-ju?
  (lambda (a lat)
    (letrec ((yes? (lambda (l)
                    (cond
                      ((null? l) #f)
                      (else
                       (or (eq? a (car l))
                           (yes? a (cdr l))))))))
      (yes? lat))))

(define member2?
  (lambda (preceding lat)
    (cond
      ((null? lat) #f)
      (else (or (eq? preceding (car lat))
                (member2? (car lat) (cdr lat)))))))

;;; (member2? &#39;a &#39;(a b c))  bugs!

(define memberContinue?
  (lambda (lat)
    (define M2?
      (lambda (preceding lat)
        (cond
          ((null? lat) #f)
          (else (or (eq? preceding (car lat))
                    (M2? (car lat) (cdr lat)))))))
    (M2? &#39;() lat)))


(define memberContinueAlter?
  (lambda (lat)
    (letrec ((M2? (lambda (preceding lat)
                    (cond
                      ((null? lat) #f)
                      (else
                       (let ((pre (car lat)))
                         (or (eq? preceding pre)
                                (M2? pre (cdr lat)))))))))
             (M2? &#39;() lat))))


(define sum-of-prefixes
  (lambda (tup)
    (define sum-of-prefixes-b
      (lambda (sonssf tup)     ; sonssf stands for &#39;sum of numbers seen so far&#39;
        (cond
          ((null? tup) &#39;())
          (else (cons (+ sonssf (car tup))
                      (sum-of-prefixes-b
                       (+ sonssf (car tup))
                       (cdr tup)))))))
    (sum-of-prefixes-b 0 tup)))

;  (sum-of-prefixes &#39;(1 2 3 4))
; &#39;(1 3 6 10)


(define sum-of-prefixes1
  (lambda (tup)
    (letrec
      ((S (lambda (sss tup)
            (cond
              ((null? tup) &#39;())
              (else
               (let ((first (car tup)))
                (cons (+ sss first)
                      (S (+ sss first) (cdr tup)))))))))
(S 0 tup))))

(define scramble-b
  (lambda (tup rev-pre)
    (define one?
      (lambda (n)
        (= n  1)))
    (define sub1
      (lambda (n)
        (- n 1)))
    (define pick
      (lambda (n lat)
        (cond
          ((one? n) (car lat))
          (else (pick (sub1 n) (cdr lat))))))
    (cond
      ((null? tup) &#39;())
      (else
       (cons (pick (car tup) (cons (car tup) rev-pre))
             (scramble-b (cdr tup)
                         (cons (car tup) rev-pre)))))))


(define scramble
  (lambda (tup)
    (letrec ((scramble-b
              (lambda (tup rev-pre)
                (define one?
                  (lambda (n)
                    (= n  1)))
                (define sub1
                  (lambda (n)
                    (- n 1)))
                (define pick
                  (lambda (n lat)
                    (cond
                      ((one? n) (car lat))
                      (else (pick (sub1 n) (cdr lat))))))
                (cond
                  ((null? tup) &#39;())
                  (else
                   (let ((first (car tup)))
                     (cons (pick first (cons first rev-pre))
                     (scramble-b (cdr tup)
                                 (cons first rev-pre)))))))))
      (scramble-b tup &#39;()))))




(define scramble2
  (lambda (tup)
    (letrec ((one?
              (lambda (n)
                (= n  1)))
             (sub1
              (lambda (n)
                (- n 1)))
             (pick
              (lambda (n lat)
                (cond
                  ((one? n) (car lat))
                  (else (pick (sub1 n) (cdr lat))))))
             (scramble-b
              (lambda (tup rev-pre)
                (cond
                  ((null? tup) &#39;())
                  (else
                   (let ((first (car tup)))
                     (cons (pick first (cons first rev-pre))
                           (scramble-b (cdr tup)
                                       (cons first rev-pre)))))))))
      (scramble-b tup &#39;()))))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;##2.1 rember-let&lt;/p&gt;
&lt;p&gt;Note: use let to define the repeated expression, so simplify the definition of the procedure.&lt;/p&gt;
&lt;h2 id=&#34;22-rember-letrec&#34;&gt;2.2 rember-letrec&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;;;; see at the TSS
(define rember
  (lambda (a lat)
    (letrec
        ((R (lambda (lat)
              (cond
                ((null? lat) &#39;())
                ((eq? (car lat) a) (cdr lat))
                (else
                 (cons (car lat) (R (cdr lat))))))))
      (R lat))))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果我们想要进一步实现rember-beyond-first(保留删除元素之前的所有元素)和rember-upto-last(只保留删除元素之后的元素)&lt;/p&gt;
&lt;h2 id=&#34;23-rember-letcc&#34;&gt;2.3 rember-letcc&lt;/h2&gt;
&lt;p&gt;Rember-Beyond-first&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;; The rember-beyond-first function rembers everything beyond first match
;
(define rember-beyond-first
  (lambda (a lat)
    (letrec
      ((R (lambda (lat)
            (cond
              ((null? lat) &#39;())
              ((eq? (car lat) a) &#39;())
              (else
                (cons (car lat) (R (cdr lat))))))))
      (R lat))))
	

(rember-beyond-first
  &#39;roots
  &#39;(noodles spaghetti spatzle bean-thread roots potatoes yam others rice))
; ==&amp;gt; &#39;(noodles spaghetti spaghetti bean-thread)

Rember-upto-last


(define-syntax letcc
  (syntax-rules ()
    ((letcc ?k ?body ...)
     (call/cc (lambda (?k) ?body ...)))))
(define rember-upto-last
  (lambda (a lat) ; Look Ma, no cons   
    (letcc skip
      (letrec 
          ((R
            (lambda (l)
              (cond
                ((null? l) (void))
                (else (let ()
                        (R (cdr l))
                        (cond
                          ((eq? a (car l))
                           (skip (cdr l)))
                          (else (void)))))))))
        (R lat)
        lat))))

	

(rember-upto-last
  &#39;roots
  &#39;(noodles spaghetti spatzle bean-thread roots potatoes yam others rice))
; ==&amp;gt; &#39;(potatoes yam others rice)

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;24-remberstar&#34;&gt;2.4 remberstar&lt;/h2&gt;
&lt;p&gt;the definition of leftmost&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define leftmost-fixed-let
  (lambda (l)
    (cond
      ((null? l) &#39;())
      ((atom? (car l)) (car l))
      (else
       (let ((a (leftmost-fixed (car l))))
         (cond
           ((atom? a) a)
           (else (leftmost-fixed (cdr l)))))))))

;(leftmost-fixed-let &#39;((() a b) (c d))) ;; bug fixed
;
;(leftmost-fixed-let &#39;(((y) b) (c d)))   ; &#39;y
;(leftmost-fixed-let &#39;(((y) ()) () (e))) ; &#39;y
;(leftmost-fixed-let &#39;(((() y) ())))     ; &#39;y
;(leftmost-fixed-let &#39;(((()) ()))) ; &#39;()



;;letcc version

(define leftmost-letcc
  (letrec
      ((lm (lambda (l out)
             (cond
               ((null? l) &#39;())
               ((atom? (car l)) (out (car l)))
               (else
                (begin
                  (lm (car l) out)
                  (lm (cdr l) out)))))))
    (lambda (l)
      (call-with-current-continuation
       (lambda (skip)
         (lm l skip))))))
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;the-definition-of-deep&#34;&gt;the definition of deep&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define deep
  (lambda (m)
    (cond
      ((zero? m) &#39;pizza)
      (else (cons (deep (sub1 m)) &#39;())))))


(define toppings 0)
(define deepB
  (lambda (m)
    (cond
      ((zero? m)
       (call-with-current-continuation
        (lambda (jump)
          (set! toppings jump)
          &#39;pizza)))
      (else
       (cons (deepB (sub1 m)) &#39;())))))

(define deep&amp;amp;co
  (lambda (m k)
    (cond
      ((zero? m) (k &#39;pizza))
      (else
       (deep&amp;amp;co (sub1 m)
                (lambda (x) (k (cons x &#39;()))))))))

(deep&amp;amp;co 0 (lambda (x) x))          ; &#39;pizza
(deep&amp;amp;co 6 (lambda (x) x))          ; &#39;((((((pizza))))))
(deep&amp;amp;co 2 (lambda (x) x)) ; &#39;((pizza))


(define deep&amp;amp;coB
  (lambda (m k)
    (cond
      ((zero? m)
       (let ()
         (set! toppings k)
         (k &#39;pizza)))
      (else
       (deep&amp;amp;coB (sub1 m)
                 (lambda (x)
                   (k (cons x &#39;()))))))))

(deep&amp;amp;coB 6 (lambda (x) x))         ; &#39;((((((pizza))))))
(deep&amp;amp;coB 4 (lambda (x) x)) ; &#39;((((pizza))))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来，再看看由leftmost结合rember得到rember star.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;
; The rember1* function removes the leftmost occurrence of a in l
;
(define rember1*
  (lambda (a l)
    (cond
      ((null? l) &#39;())
      ((atom? (car l))
       (cond
         ((eq? (car l) a) (cdr l))
         (else
           (cons (car l) (rember1* a (cdr l))))))
      (else
        (cond
          ((equal? (rember1* a (car l)) (car l)) ; if the list with &#39;a&#39; removed doesn&#39;t change
           (cons (car l) (rember1* a (cdr l))))  ; then recurse
          (else
            (cons (rember1* a (car l)) (cdr l)))))))) ; otherwise remove &#39;a&#39;

	


; Examples of rember1*
;
(rember1*
  &#39;salad
  &#39;((Swedish rye) (French (mustard salad turkey)) salad))
; ==&amp;gt; &#39;((Swedish rye) (French (mustard turkey)) salad)

(rember1*
  &#39;meat
  &#39;((pasta meat) pasta (noodles meat sauce) meat tomatoes))
; ==&amp;gt; &#39;((pasta) pasta (noodles meat sauce) meat tomatoes)

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面是letrec version of rember1&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;
(define rember1*-letrec
  (lambda (a l)
    (letrec
        ((R (lambda (l)
              (cond
                ((null? l) &#39;())
                ((atom? (car l))
                 (let ((first (car l))
                       (second (cdr l)))
                   (cond
                     ((eq? first a) second)
                     (else
                      (cons first (R second))))))
                 (else
                  (let ((first (car l))
                        (second (cdr l)))
                    (cond
                      ((equal? (R first) first) ; if the list with &#39;a&#39; removed doesn&#39;t change
                       (cons first (R second)))  ; then recurse
                      (else
                       (cons (R first) second))))))))) ; otherwise remove &#39;a&#39;
      (R l))))
(rember1*-letrec
  &#39;salad
  &#39;((Swedish rye) (French (mustard salad turkey)) salad))
(rember1*-letrec
  &#39;meat
  &#39;((pasta meat) pasta (noodles meat sauce) meat tomatoes))

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;##the version of letcc&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;; rember1* via letcc
;
(define rember1*-letcc
  (lambda (a l)
    (letrec
        ((rm (lambda (a l oh)
               (cond
                 ((null? l) (oh &#39;no))
                 ((atom? (car l))
                  (if (eq? (car l) a)
                      (cdr l)
                      (cons (car l) (rm a (cdr l) oh))))
                 (else
                  (let ((new-car
                         (call-with-current-continuation
                          (lambda (oh)
                            (rm a (car l) oh)))))
                    (if (atom? new-car)
                        (cons (car l) (rm a (cdr l) oh))
                        (cons new-car (cdr l)))))))))
      (let ((new-l
             (call-with-current-continuation
              (lambda (oh)
                (rm a l oh)))))
        (if (atom? new-l)
            l
            new-l)))))

; Tests of rember1*-letcc
;
(rember1*-letcc
 &#39;salad
 &#39;((Swedish rye) (French (mustard salad turkey)) salad))
; ==&amp;gt; &#39;((Swedish rye) (French (mustard turkey)) salad)

(rember1*-letcc
 &#39;meat
 &#39;((pasta meat) pasta (noodles meat sauce) meat tomatoes))
; ==&amp;gt; &#39;((pasta) pasta (noodles meat sauce) meat tomatoes)

(rember1*-letcc
 &#39;a
 &#39;((foo bar) baz))
; ==&amp;gt; &#39;((foo bar) baz)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;the-definition-of-union&#34;&gt;the definition of union&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define union2
  (lambda (set1 set2)
    (letrec ((member? (lambda (a lat)
                (cond ((null? lat) #f)
                              ((eq? a (car lat)) #t)
                              (else (member? a (cdr lat))))))
             (A (lambda (set1)
                (cond
                  ((null? set1) set2)
                  (else
                   (let ((p1 (A (cdr set1))))
                     (if (member? (car set1) set2)
                         p1
                         (cons (car set1) p1))))))))
      (A set1))))
      (union2 &#39;(a b c) &#39;(c d e f))

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;the-definition-of-intersect&#34;&gt;the definition of intersect&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define intersect
  (lambda (set1 set2)
    (cond
      ((null? set1) &#39;())  ; don&#39;t forget the 1st commandment
      ((member? (car set1) set2)
       (cons (car set1) (intersect (cdr set1) set2)))
      (else
        (intersect (cdr set1) set2)))))
; Examples of intersect
;
;(intersect &#39;(a b x c d) &#39;(q w e x r t y a))     ; &#39;(a x)
;(intersect &#39;(a b x c d) &#39;())                    ; &#39;()
;(intersect &#39;() &#39;())                             ; &#39;()
;(intersect &#39;() &#39;(a b x c d))                    ; &#39;()
;(intersect &#39;(a b x c d) &#39;(a b x c d))           ; &#39;(a b x c d)

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;intersect-letrec-version&#34;&gt;intersect letrec version&lt;/h2&gt;
&lt;p&gt;use letrec to remove arguments that do not change for recursive applications&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define intersect-letrec
  (lambda (set1 set2)
    (letrec
      ((I (lambda (set)
            (cond
              ((null? set) &#39;())
              ((member? (car set) set2)
               (cons (car set) (I (cdr set))))
              (else
                (I (cdr set)))))))
      (I set1))))

; Test of intersect-letrec
;
;(intersect-letrec &#39;(a b x c d) &#39;(q w e x r t y a))     ; &#39;(a x)
;(intersect-letrec &#39;(a b x c d) &#39;())                    ; &#39;()
;(intersect-letrec &#39;() &#39;())                             ; &#39;()
;(intersect-letrec &#39;() &#39;(a b x c d))                    ; &#39;()
;(intersect-letrec &#39;(a b x c d) &#39;(a b x c d))           ; &#39;(a b x c d)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;the-definition-of-intersectall&#34;&gt;the definition of intersectall&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;; The intersectall function finds intersect of a bunch of sets
;
(define intersectall
  (lambda (lset)
    (cond
      ((null? lset) &#39;())
      ((null? (cdr lset)) (car lset))
      (else
        (intersect (car lset)
                   (intersectall (cdr lset)))))))

; Examples of intersectall
;
;(intersectall &#39;((a) (a) (a)))                   ; &#39;(a)
;(intersectall &#39;((a) () (a)))                    ; &#39;()
;(intersectall &#39;())                              ; &#39;()
;(intersectall &#39;((a b c d) (b c d e) (c d e f))) ; &#39;(c d)

; Obeying the 12th commandment
;
(define intersectall-letrec
  (lambda (lset)
    (letrec
      ((A (lambda (lset)
            (cond
              ((null? (cdr lset)) (car lset))
              (else
                (intersect (car lset)
                           (A (cdr lset))))))))
      (cond
        ((null? lset) &#39;())
        (else (A lset))))))

; Tests of intersectall-letrec
;;
;(intersectall-letrec &#39;((a) (a) (a)))                   ; &#39;(a)
;(intersectall-letrec &#39;((a) () (a)))                    ; &#39;()
;(intersectall-letrec &#39;())                              ; &#39;()
;(intersectall-letrec &#39;((a b c d) (b c d e) (c d e f))) ; &#39;(c d)


(define intersectall-ap
  (lambda (lset)
    (call-with-current-continuation
      (lambda (hop)
        (letrec
          ((A (lambda (lset)
                (cond
                  ((null? (car lset)) (hop &#39;()))
                  ((null? (cdr lset)) (car lset))
                  (else
                    (I (car lset)
                       (A (cdr lset)))))))
           (I (lambda (s1 s2)
                (letrec
                  ((J (lambda (s1)
                        (cond
                          ((null? s1) &#39;())
                          ((member? (car s1) s2)
                           (cons (car s1) (J (cdr s1))))
                          (else
                            (J (cdr s1)))))))
                  (cond
                    ((null? s2) (hop &#39;()))
                    (else (J s1)))))))
          (cond
            ((null? lset) &#39;())
            (else (A lset))))))))

; Tests of intersectall-ap
;
;(intersectall-ap &#39;((a) (a) (a)))                   ; &#39;(a)
;(intersectall-ap &#39;((a) () (a)))                    ; &#39;()
;(intersectall-ap &#39;())                              ; &#39;()
;(intersectall-ap &#39;((a b c d) (b c d e) (c d e f))) ; &#39;(c d)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后再透过deep star的写法优化过程来体会TSS的函数精髓。
depthStar improvement&lt;/p&gt;
&lt;p&gt;通过depth进一步阐释letrec的意义（从原始的depth到depth-let 然后depth-let-if，以及更为清晰版本的depth-let-max,然后最后浓缩到最后的6行代码depth-max。
depth&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;; The depth* function finds the max depth of an s-expression

;
(define depth*
  (lambda (l)
    (cond
      ((null? l) 1)
      ((atom? (car l)) (depth* (cdr l)))
      (else
        (cond
          ((&amp;gt; (depth* (cdr l))
              (add1 (depth* (car l))))
           (depth* (cdr l)))
          (else
(add1 (depth* (car l)))))))))


(depth* &#39;((pickled) peppers (peppers pickled)))                          ; 2
(depth* &#39;(margarine ((bitter butter) (makes) (batter (bitter))) butter)) ; 4
(depth* &#39;(c (b (a b) a) a)) ; 3
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;let-version&#34;&gt;let version:&lt;/h2&gt;
&lt;p&gt;depth-let&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define depth*-let
  (lambda (l)
    (cond
      ((null? l) 1)
      ((atom? (car l)) (depth*-let (cdr l)))
      (else
       (let ((rightPart (depth*-let (cdr l)))
             (leftPart (add1 (depth*-let (car l)))))
         (cond
           ((&amp;gt; rightPart
               leftPart)
            rightPart)
           (else
            leftPart)))))))

(depth*-let &#39;((pickled) peppers (peppers pickled)))                          ; 2
(depth*-let &#39;(margarine ((bitter butter) (makes) (batter (bitter))) butter)) ; 4
(depth*-let &#39;(c (b (a b) a) a)) ; 3

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;let-if-version&#34;&gt;let-if version:&lt;/h2&gt;
&lt;p&gt;depth-let-if&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define depth*-let-if
  (lambda (l)
    (cond
      ((null? l) 1)
      ((atom? (car l)) (depth*-let-if (cdr l)))
      (else
       (let ((rightPart (depth*-let-if (cdr l)))
             (leftPart (add1 (depth*-let-if (car l)))))
         (if (&amp;gt; rightPart leftPart)
            rightPart
            leftPart))))))

(depth*-let-if &#39;((pickled) peppers (peppers pickled)))                          ; 2
(depth*-let-if &#39;(margarine ((bitter butter) (makes) (batter (bitter))) butter)) ; 4
(depth*-let-if &#39;(c (b (a b) a) a)) ; 3

depth-let-max version:
depth-let-max
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;define depth*-let-max
  (lambda (l)
    (cond
      ((null? l) 1)
      ((atom? (car l)) (depth*-let-max (cdr l)))
      (else
       (let ((rightPart (depth*-let-max (cdr l)))
             (leftPart (add1 (depth*-let-max (car l)))))
         (max rightPart leftPart))))))

(depth*-let-max &#39;((pickled) peppers (peppers pickled)))                          ; 2
(depth*-let-max &#39;(margarine ((bitter butter) (makes) (batter (bitter))) butter)) ; 4
(depth*-let-max &#39;(c (b (a b) a) a)) ; 3

depth-max version:
depth-max

(define depth*-max
  (lambda (l)
    (cond
      ((null? l) 1)
      ((atom? (car l)) (depth*-max (cdr l)))
      (else
         (max (depth*-max (cdr l)) (add1 (depth*-max (car l))))))))

(depth*-max &#39;((pickled) peppers (peppers pickled)))                          ; 2
(depth*-max &#39;(margarine ((bitter butter) (makes) (batter (bitter))) butter)) ; 4
(depth*-max &#39;(c (b (a b) a) a)) ; 3

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;常用链接&#34;&gt;常用链接，&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://jueqingsizhe66.github.io/blog/2016/02/14/si-ji-mo-si-de-le-yuan-schemers/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt; Scheme清单 &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://groups.google.com/forum/#!forum/racket-users&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt; Google racket User group &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://groups.google.com/forum/#!topic/racket-users/cPuTr8lrXCs&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt; Gossip about the decision tree &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;GreghenderShoot 1970&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/greghendershott&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt; Github Repo &lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/greghendershott/fear-of-macros&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt; Fear of macro &lt;/a&gt; Tell us the history of macro, overcome the fear of macro&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/greghendershott/frog&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt; frog &lt;/a&gt; one static website generator tool&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://www.greghendershott.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt; His Website &lt;/a&gt;
Tonyg&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/tonyg?tab=repositories&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt; Github Repo &lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://tonyg.github.io/racket-bitsyntax/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt; His opensource tools: Bitsyntax &lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&#34;https://botbot.me/freenode/racket/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt; racket freenote robot, Gossip Platform &lt;/a&gt;
Husk scheme&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/justinethier/husk-scheme&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt; husk repo &lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://justinethier.github.io/husk-scheme/manual/getting-started.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt; husk get started &lt;/a&gt;
&lt;a href=&#34;https://github.com/alaricsp/chicken-scheme&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt; chicken scheme &lt;/a&gt;
&lt;a href=&#34;http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-2.html#%25_toc_start&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt; R5RS html file &lt;/a&gt;
root of lisp&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://www.paulgraham.com/rootsoflisp.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt; original site &lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/hlpp/scheme/tree/master/tests&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt; define implement &lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;BTW, one very good vim tips, you can use &lt;a href=&#34;https://github.com/Shougo/vimfiler.vim&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt; Vimfiler &lt;/a&gt;, with shortkey &lt;code&gt;m&lt;/code&gt; and then &lt;code&gt;r&lt;/code&gt; to rename the file in the editor page.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>program-as-data</title>
      <link>https://jueqingsizhe66.github.io/archives/program-as-data/</link>
      <pubDate>Wed, 30 Mar 2016 13:23:21 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/archives/program-as-data/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://www.ccs.neu.edu/home/matthias/HtDP2e/part_three.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;A program is like an essay. The first version is a draft, and drafts demand editing.&lt;/a&gt;
Program is also can be seen as data.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;直觉认识proc,提取body。&lt;/li&gt;
&lt;li&gt;对比识别。&lt;/li&gt;
&lt;li&gt;加壳。&lt;/li&gt;
&lt;li&gt;三行表格，n列迭代。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;
(value-of (proc (var body)) env)
 = (value-of (proc-exp (procedure (var body env)) val) env)

 = (value-of body ([var=val] env))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;函数其实也是expression，它可以被consume也可以被produce.凭着这个脑中的
印象是否可以帮助你继续理解abstration和程序即数据的思想。&lt;/p&gt;
&lt;p&gt;所有的函数和数据犹如花生的壳和仁的关系。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://jueqingsizhe66.github.io/images/lisp/peanut.jpeg&#34; alt=&#34;peanut&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;只有加壳就相当于是创建一层抽象，把类似的东西包裹起来，或者也可以换着一种思路
（每个壳里面都包着类似的花生仁，只不过可能存在些许不同）&lt;/p&gt;
&lt;h3 id=&#34;two-similar-functions&#34;&gt;Two similar functions&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;; Los -&amp;gt; Boolean
; does l contain &amp;quot;dog&amp;quot;
(define (contains-dog? l)
  (cond
    [(empty? l) #false]
    [else
     (or
       (string=? (first l) &amp;quot;dog&amp;quot;)
       (contains-dog?
         (rest l)))]))

	
; Los -&amp;gt; Boolean
; does l contain &amp;quot;cat&amp;quot;
(define (contains-cat? l)
  (cond
    [(empty? l) #false]
    [else
     (or
       (string=? (first l) &amp;quot;cat&amp;quot;)
       (contains-cat?
         (rest l)))]))
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;加壳&#34;&gt;加壳&lt;/h3&gt;
&lt;p&gt;加上一个函数皮，并封上一层。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;; String Los -&amp;gt; Boolean
; determines whether l contains the string s
(define (contains? s l)
  (cond
    [(empty? l) #false]
    [else (or (string=? (first l) s)
              (contains? s (rest l)))]))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后我们就可以类似的改写了&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;; Los -&amp;gt; Boolean
; does l contain &amp;quot;dog&amp;quot;
(define (contains-dog? l)
  (contains? &amp;quot;dog&amp;quot; l))
	
	
; Los -&amp;gt; Boolean
; does l contain &amp;quot;cat&amp;quot;
(define (contains-cat? l)
  (contains? &amp;quot;cat&amp;quot; l))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个典型的过程就是函数抽象。进一步可以参考&lt;a href=&#34;http://www.ccs.neu.edu/home/matthias/HtDP2e/part_three.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;HowToDesginProgram&lt;/a&gt;和&lt;a href=&#34;http://www.ccs.neu.edu/home/matthias/BTLS/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;TheLittleScheme&lt;/a&gt;.
Note: 你需要解析的其实是花生仁，但是你不得不先把壳打开或者通过另外一种方式，比如红外线等技术把它识别出来。&lt;/p&gt;
&lt;p&gt;也就是说进一步归纳的话，你首先得recognise识别出来，然后才能进行解析（提取其中的蛋白质、脂肪、热量等）。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://jueqingsizhe66.github.io/images/lisp/baby.png&#34; alt=&#34;mybaby&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;保护它的壳，给它提供营养，防止它受到感染和伤害。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://pressbin.com/tools/excel_to_html_table/index.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;表格转换链接&lt;/a&gt;.&lt;/p&gt;
&lt;table&gt;
      &lt;tr&gt;
                &lt;td&gt;index&lt;/td&gt;
                &lt;td&gt;0&lt;/td&gt;
                &lt;td&gt;1&lt;/td&gt;
                &lt;td&gt;2&lt;/td&gt;
                &lt;td&gt;…&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
                &lt;td&gt;M&lt;/td&gt;
                &lt;td&gt;a+S&lt;/td&gt;
                &lt;td&gt;a+1*W+S&lt;/td&gt;
                &lt;td&gt;a+2*W+S&lt;/td&gt;
                &lt;td&gt;…&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
                &lt;td&gt;f at M&lt;/td&gt;
                &lt;td&gt;f(a+S)&lt;/td&gt;
                &lt;td&gt;f(a+1*W+S)&lt;/td&gt;
                &lt;td&gt;f(a+2*W+S)&lt;/td&gt;
                &lt;td&gt;…&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
                &lt;td&gt;Area&lt;/td&gt;
                &lt;td&gt;W*f(a+S)&lt;/td&gt;
                &lt;td&gt;W*f(a+1*W+S)&lt;/td&gt;
                &lt;td&gt;W*f(a+2*W+S)&lt;/td&gt;
                &lt;td&gt;…&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
                &lt;td&gt;residual&lt;/td&gt;
                &lt;td&gt;60.00%&lt;/td&gt;
                &lt;td&gt;50.00%&lt;/td&gt;
                &lt;td&gt;40.00%&lt;/td&gt;
                &lt;td&gt;…&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
                &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
&lt;/table&gt;
&lt;p&gt;慢工才能出细活，通过三行表格n列迭代的形式(也可以进一步加大计算量变成n行表格n列迭代)理解递归迭代的过程,在一定的时间，进行一系列的列计算，并让时间推进，直到满足你想要的结果。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>scheme环境的几种表现形式-represtations</title>
      <link>https://jueqingsizhe66.github.io/archives/schemehuan-jing-de-ji-chong-biao-xian-xing-shi-represtations/</link>
      <pubDate>Thu, 03 Mar 2016 02:05:32 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/archives/schemehuan-jing-de-ji-chong-biao-xian-xing-shi-represtations/</guid>
      <description>&lt;p&gt;scheme的解释器的构造，都需要enviroment类型的参与，environment类型的抽象确是影响到语言的具体性能。&lt;/p&gt;
&lt;p&gt;主要有以下四种类型(另一种未实现)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;#1&#34;&gt;环境关联表形式出现(cons cons&amp;hellip;)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2&#34;&gt;环境的列表出现 (list var val env)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3&#34;&gt;环境的过程实现(lambda ()形式)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4&#34;&gt;环境的一种较为特殊的形式成堆变量的实现(list (list var) (list val))&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;1&#34;&gt; 1. 环境关联表形式出现 &lt;/h2&gt;
&lt;p&gt;此时是每一次都把一个键值对存入到环境中，逐次存入的过程(采用 &lt;em&gt;cons cons的形式&lt;/em&gt;)。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;((a . 1) (b . 1)  (c . 1))

empty-env  is &#39;()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;具体实现如下所示&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;
(define empty-env
  (lambda() &#39;()))

(define extend-env
  (lambda (var val env)
    (cons (cons var val)
	  env)))

(define apply-env
  (lambda (env search-var)
    (cond
     ((null? env)
      (report-no-binding-found search-var))
     ((eqv? (caar env) search-var)
      (cdr (car env)))
     (else
      (apply-env (cdr env) search-var)))))

(define report-no-binding-found
  (lambda (search-var)
    (error &#39;apply-env &amp;quot;No binding for: &amp;quot; search-var)))

(define e
  (extend-env &#39;d 6
    (extend-env &#39;y 8
       (extend-env &#39;x 7
	  (extend-env &#39;y 14
	    (empty-env))))))

(equal?? (apply-env e &#39;d) 6)
(equal?? (apply-env e &#39;y) 8)
(equal?? (apply-env e &#39;x) 7)
(equal?? (apply-env e &#39;d) 6)

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一种比较特殊的就是&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt; a=1 b=2  a=3  c=5

 ((a 1 3) (b 2) (c 5))

 empty-env is &#39;()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;针对当前的关联表的一个很小的拓展&lt;/p&gt;
&lt;h3 id=&#34;增加一个has-binding-实现&#34;&gt;增加一个&lt;code&gt;has-binding&lt;/code&gt; 实现&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;
(define has-binding?
  (lambda (env var)
    (cond
     ((null? env) #f)
     ((eqv? (caar env) var) #t)
     (else
      (has-binding? (cdr env) var)))))


(define e
  (extend-env &#39;d 6
     (extend-env &#39;y 8
        (extend-env &#39;x 7
           (extend-env &#39;y 14
              (empty-env))))))

(equal?? (has-binding? e &#39;d) #t)
(equal?? (has-binding? e &#39;y) #t)
(equal?? (has-binding? e &#39;x) #t)
(equal?? (has-binding? e &#39;z) #f)

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;拓展一个列表输入的功能extend-env&#34;&gt;拓展一个列表输入的功能&lt;code&gt;extend-env*&lt;/code&gt;&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define extend-env*
  (lambda (var-list val-list env)
    (if (null? var-list)
	env
	(let ((var (car var-list))
	      (val (car val-list)))
	  (extend-env* (cdr var-list)
		       (cdr val-list)
		       (extend-env var val env))))))

(equal?? (has-binding? (extend-env* &#39;(A) &#39;(1) e) &#39;A) #t)
(equal?? (has-binding? (extend-env* &#39;(A B C) &#39;(1 2 3) e) &#39;C) #t)

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2&#34;&gt; 2.环境的列表出现  &lt;/h2&gt;
&lt;p&gt;此时使用一个标志位&lt;code&gt;extend-env&lt;/code&gt;每一次都把一个键值对存入到list环境中，&lt;font color=&#34;red&#34;&gt;嵌套&lt;/font&gt;存入的过程(采用 &lt;em&gt;cons cons的形式&lt;/em&gt;)。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt; (extend 
   (list &#39;extend-env var exp (extend                        ;;;====其实&#39;extend-env 有点多余
                         (list &#39;extend-env var exp (extend  ;;;====其实&#39;extend-env 有点多余
                                               (empty-env))))))

 (1 (2 (3 6)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;且看具体实现如下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;;; empty-env : () -&amp;gt; Env
(define empty-env
  (lambda () (list &#39;empty-env)))

;; extend-env : Var * Schemeval * Env -&amp;gt; Env
(define extend-env
  (lambda (var val env)
    (list &#39;extend-env var val env)))     ;;;;;;;==================&amp;gt;关键位置

;; apply-env : Env * Var -&amp;gt; Schemeval
(define apply-env-rec
  (lambda (env search-var all)
    (cond
     ((eqv? (car env) &#39;empty-env)
      (report-no-binding-found search-var all))
     ((eqv? (car env) &#39;extend-env)
      (let ((saved-var (cadr env))        ;;;;;;;==================&amp;gt;关键位置  
	    (saved-val (caddr env))           ;;;;;;;==================&amp;gt;关键位置
	    (saved-env (cadddr env)))         ;;;;;;;==================&amp;gt;关键位置
	(if (eqv? search-var saved-var)
	    saved-val
	    (apply-env-rec saved-env search-var all))))  ;;;;;;;==================&amp;gt;不断更新最新的位置look up variable in the saved-env
     (else
      (report-invalid-env env)))))

(define apply-env
  (lambda (env search-var)
    (apply-env-rec env search-var env)))


(define display-env-rec
  (lambda (env)
    (if (eqv? (car env) &#39;extend-env)
	(let ((saved-var (cadr env))
	      (saved-env (cadddr env)))
	  (printf &amp;quot; ~a &amp;quot; saved-var)
	  (display-env-rec saved-env)))))


(define display-env
  (lambda (env)
    (printf &amp;quot;env: &amp;quot;)
    (display-env-rec env)
    (newline)))

(display-env e)

(define report-no-binding-found
  (lambda (search-var all)
    (display-env all)
    (error &#39;apply-env &amp;quot;No binding for&amp;quot; search-var)))

(define report-invalid-env
  (lambda (env)
    (error &#39;apply-env &amp;quot;Bad environment&amp;quot; env)))

(define e
  (extend-env &#39;d 6
      (extend-env &#39;y 8
         (extend-env &#39;x 7
            (extend-env &#39;y 14
                (empty-env))))))

(equal?? (apply-env e &#39;d) 6)
(equal?? (apply-env e &#39;y) 8)
(equal?? (apply-env e &#39;x) 7)


&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3&#34;&gt; 3.环境的过程实现&lt;/h2&gt;
&lt;p&gt;环境的过程实现是比较难理解的，因为该过程更少了递归的逐渐减少的表像，感觉所有都不变。&lt;/p&gt;
&lt;p&gt;具体实现如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;;; data definition:
;; Env = Var -&amp;gt; Schemeval

;; empty-env : () -&amp;gt; Env
(define empty-env
  (lambda ()
    (cons (lambda (search-var)
	    (report-no-binding-found search-var))
	  (lambda ()
	    #t))))


;; extend-env : Var * Schemeval * Env -&amp;gt; Env
(define extend-env
  (lambda (saved-var saved-val saved-env)
    (cons (lambda (search-var)
	    (if (eqv? search-var saved-var)
		saved-val
		(apply-env saved-env search-var)))
	  (lambda ()
	    #f))))

;; apply-env : Env * Var -&amp;gt; Schemeval
(define apply-env
  (lambda (env search-var)
    ((car env) search-var)))

(define empty-env?
  (lambda (env)
    ((cdr env))))

(define report-no-binding-found
  (lambda (search-var)
    (error &#39;apply-env &amp;quot;No binding for ~s&amp;quot; search-var)))

(define report-invalid-env
  (lambda (env)
    (error &#39;apply-env &amp;quot;Bad environment: ~s&amp;quot; env)))

(define e
  (extend-env &#39;d 6
     (extend-env &#39;y 8
        (extend-env &#39;x 7
           (extend-env &#39;y 14
              (empty-env))))))

(equal?? (apply-env e &#39;d) 6)
(equal?? (apply-env e &#39;y) 8)
(equal?? (apply-env e &#39;x) 7)

(equal?? (empty-env? (empty-env)) #t)
(equal?? (empty-env? e) #f)

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4&#34;&gt; 4.环境的一种较为特殊的形式的实现 &lt;/h2&gt;
&lt;p&gt;如果若有的定义扎堆存在呢？也就是把所有变量放在一个列表中，值放在一个列表里面。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt; x=3 y=4 z=5 c=6

 表现为 ((x y z c) (3 4 5 6))

 此时 empty-env is (()  ())
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;
(define empty-env
  (lambda() &#39;()))


(define extend-env
  (lambda (var val env)
    (cons (list
	   (list var) (list val))
          env)))

(define extend-env*
  (lambda (var-list val-list env)
    (if (null? var-list)
	env
	(cons (list var-list val-list)
	      env))))

;; return a pair, for distinguish with val is #f
(define apply-current
  (lambda (vars vals search-var)
    (if (null? vars)
	(cons #f &#39;())
	(if (eqv? (car vars) search-var)
	    (cons #t (car vals))
	    (apply-current (cdr vars) (cdr vals) search-var)))))

(define apply-env
  (lambda (env search-var)
    (if (null? env)
     (report-no-binding-found search-var)
     (let ((val (apply-current (caar env) (cadar env) search-var)))
       (if (car val) (cdr val)
	   (apply-env (cdr env) search-var))))))

(define report-no-binding-found
  (lambda (search-var)
    (error &#39;apply-env &amp;quot;No binding for: &amp;quot; search-var)))


(define has-binding?
  (lambda (env var)
    (if (null? env)
	#f
	(let ((val (apply-current (caar env) (cadar env) var)))
	  (if (car val)
	      #t
	      (has-binding? (cdr env) var))))))


(define e (empty-env))
(equal?? e &#39;())

(define e (extend-env &#39;z 10 e))
(equal?? e &#39;(((z) (10))))

(define e (extend-env* &#39;(a b c d) &#39;(1 2 3 4) e))
(equal?? e &#39;(((a b c d) (1 2 3 4)) ((z) (10))))

(equal?? (apply-env e &#39;z) 10)
(equal?? (apply-env e &#39;d) 4)

(equal?? (has-binding? e &#39;z) #t)
(equal?? (has-binding? e &#39;d) #t)
(equal?? (has-binding? e &#39;m) #f)

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;结论&#34;&gt;结论&lt;/h2&gt;
&lt;p&gt;上述所谈的4种环境的实现，其实也就对应着四种不同的解释器的实现。环境实现的不同，对应者整个解释器的提取过程也就不一样。
整个解释器独立的解释每一个表达式的时候，所采用的方法也就会有所不一样。所以设计一个好的environment，对应的就是设计一个好的
数据结构，用于程序program解析的时候需要使用到的变量或者表达式数据，至关重要！&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>插入排序</title>
      <link>https://jueqingsizhe66.github.io/archives/cha-ru-pai-xu/</link>
      <pubDate>Sun, 28 Feb 2016 16:42:54 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/archives/cha-ru-pai-xu/</guid>
      <description>&lt;p&gt;排序算法是一种比较常见的算法，一般包括冒泡排序，插入排序，快速排序等。
本文主要是关于插入排序。&lt;/p&gt;
&lt;h2 id=&#34;如何把一个数字插入到一个列表中&#34;&gt;如何把一个数字插入到一个列表中&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;;; using insert sort here

(define insert
  (lambda (lst elem)
    (cond ((null? lst) (list elem))
	  ((&amp;lt; elem (car lst))
	   (cons elem lst))
	  (else (cons (car lst)
		      (insert (cdr lst) elem))))))

(define sort-rec
  (lambda (prev now)
    (if (null? now)
	prev
	(sort-rec (insert prev (car now))
		  (cdr now)))))
(define sort
  (lambda (lst)
    (sort-rec &#39;() lst)))


&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;提取出判断条件&#34;&gt;提取出判断条件&lt;/h2&gt;
&lt;p&gt;利用pred代表小于号&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define insert
  (lambda (lst elem pred)
     (cond
        ((null? lst) (list elem))
        ((pred elem (car lst))
          (cons elem lst))
        (else (cons (car lst)
                    (insert (cdr lst) elem pred))))))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(insert &#39;(1 2 3) &#39;4 &amp;lt;)
    (1 2 3 4)
(insert &#39;(1 2 3) &#39;0 &amp;lt;)
    (0 1 2 3)
(insert &#39;(1 3 2) &#39;4 &amp;lt;)
    (1 3 2 4)    ==&amp;gt; 这不是我们想要的
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;分析发现 insert仅仅是在判断满足条件的时候，直接退出，不管后面的大小问题，
&lt;font color=&#34;red&#34;&gt;我们不可以判断该元素之后的所有的字符的情况&lt;/font&gt;。&lt;/p&gt;
&lt;p&gt;然而该程序当作一个最小的模块，也就是加入我逐个提出判断列表，最终实现的是每提取一个元素
都和新构成的排序列表进行判断，那么也就算判断完成。&lt;/p&gt;
&lt;h2 id=&#34;对一个列表进行插入排序&#34;&gt;对一个列表进行插入排序&lt;/h2&gt;
&lt;p&gt;在原先insert的基础上，书写了sort-rec和sort-predicate&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;sort-rec 逐个判断最新的元素和新的临时列表的比较&lt;/li&gt;
&lt;li&gt;sort-predicate 仅仅是选择判断的标准。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define sort-rec
  (lambda (prev now pred)
    (if (null? now)
        prev
        (sort-rec (insert prev (car now) pred)
                  (cdr now)
                  pred))))

(define sort/predicate
   (lambda (pred lst)
      (sort-rec &#39;() lst pred)))

&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;sort-rec的prev在逐渐的变大，而now的部分在不断的变小&lt;/li&gt;
&lt;li&gt;也就是 sort-rec 的第一号位置不断变大，第二号位由于cdr作用不断变小。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(sort/predicate &amp;lt; &#39;(1 6 5 7))

    prev          now
1.  ()         (1 6 5 7)
2.  (1)        (6 5 7)
3.  (1 6)      (5 7)
4.  (1 5 6)    (7)
5.  (1 5 6 7)  ()

计算结束，返回prev的值
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;于是我们就可以获得正确的结果&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(sort/predicate &amp;lt; &#39;(1 6 5 7))
    (1 5 6 7)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;利用内部define和letrec改写程序&#34;&gt;利用内部define和letrec改写程序&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;采用内部的define实现&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以保护函数的实现（只被使用一次）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define sort/predicate1
  (lambda (pred lst)
    (define sort-rec
      (lambda (prev now pred)
        (if (null? now)
           prev
           (sort-rec (insert prev (car now) pred)
                    (cdr now)
                    pred))))
    (define insert
      (lambda (lst elem pred)
        (cond
          ((null? lst) (list elem))
          ((pred elem (car lst))
           (cons elem lst))
          (else (cons (car lst)
                     (insert (cdr lst) elem pred))))))

     (sort-rec &#39;() lst pred)))

      (sort/predicate1 &amp;lt; &#39;(1 6 5 7))
    
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;采用letrec实现sort/predicate,主要是用&lt;code&gt;(letrec (() ...) ...)&lt;/code&gt; 结构&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;
(define sort/predicate2
  (lambda (pred lst)
    (letrec ((sort-rec
              (lambda (prev now pred)
                (if (null? now)
                   prev
                   (sort-rec (insert prev (car now) pred)
                            (cdr now)
                            pred))))
             (insert
              (lambda (lst elem pred)
                (cond
                  ((null? lst) (list elem))
                  ((pred elem (car lst))
                   (cons elem lst))
                  (else (cons (car lst)
                             (insert (cdr lst) elem pred)))))))
      
      (sort-rec &#39;() lst pred))))

(sort/predicate2 &amp;lt; &#39;(1 6 5 7))

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;结论&#34;&gt;结论&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;每隔离一层抽象，相当于增加了一种变化&lt;/li&gt;
&lt;li&gt;了解插入排序的实现过程。&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>The Fifth interpreter with the implementation of letrec(Important)</title>
      <link>https://jueqingsizhe66.github.io/archives/the-fifth-interpreter-with-the-implementation-of-letrec-important/</link>
      <pubDate>Sun, 28 Feb 2016 06:02:57 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/archives/the-fifth-interpreter-with-the-implementation-of-letrec-important/</guid>
      <description>&lt;p&gt;letrec的作用是可以定义内部函数。它的实现类似于let，只不过let实现的主要是局部变量，而他是局部的过程（持保留意见)&lt;/p&gt;
&lt;h2 id=&#34;错误1&#34;&gt;错误1.&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;  (define-datatype environment environment?
    (empty-env)
    (extend-env
     (bvar symbol?)  ;;;这边是一个 所以是symbol?
     (bval expval?)
     (saved-env environment?))
    (extend-env-rec
     (id symbol?)
     (bvar (list-of symbol?)) ;;这边和proc-val的定义发生了冲突  一个是symbol? 另外一个则是(list-of symbol?)
     (body expression?)
     (saved-env environment?)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而在实际的extend-env-rec的实现中，则是调用了proc-val，所以并且传入到proc-val，为了保证一致性&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;;;;;;;;;;;;;;;;; environment constructors and observers ;;;;;;;;;;;;;;;;
(define apply-env
  (lambda (env search-sym)
    (cases environment env
           (empty-env ()
                      (error &#39;apply-env &amp;quot;No binding for ~s&amp;quot; search-sym))
           (extend-env (var val saved-env)
                       (if (eqv? search-sym var)
                           val
                           (apply-env saved-env search-sym)))
           (extend-env-rec (p-name b-var p-body saved-env)
                           (if (eqv? search-sym p-name)
                             ;; (proc-val (procedure b-var p-body env))  ;;;注意这里的变化！
                              (proc-val (procedure b-var p-body env #t)) ;;修改了一个bug 目的是可以追踪的作用
                               (apply-env saved-env search-sym))))))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以需要对应的修改proc-val&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  ;; proc? : SchemeVal -&amp;gt; Bool
  ;; procedure : Var * Exp * Env -&amp;gt; Proc
  (define-datatype proc proc? ;;;注意这边的变化 影响到apply-procedure
    (procedure
     ;(var symbol?)  ;;;为了保证和environment的define-datatype一直改为(list-of symbol?)
     (var (list-of symbol?))
     (body expression?)
     (env environment?)
     (trace boolean?))) ;;;需要考虑#t #f
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;错误2&#34;&gt;错误2.&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; (run &amp;quot;letrec double(x)=+(x,6) in (double 10)&amp;quot;)
enter: (x) = #(struct:num-val 10)
. . cdr: contract violation
  expected: pair?
  given: (num-val 10)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;原因在于原先的call-exp并没有遍历的过程，而新改进的apply-procedure则是需要遍历，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        (call-exp (rator rand)
                 (let ((proc (expval-&amp;gt;proc (value-of rator env)))
                       (arg (value-of rand env))) 
                   (apply-procedure proc arg)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;改进的call-exp&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        (call-exp (rator rands)
                 (let ((proc (expval-&amp;gt;proc (value-of rator env)))
                       (args (map (lambda (x) (value-of x env)) rands)))
                   (apply-procedure proc args)))
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;额外错误&#34;&gt;额外错误&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt; data-structures.scm:7:11: all-defined: not a provide sub-form in: (all-defined)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个错误是因为现在都是在使用&lt;code&gt;(all-defined-out)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;为什么还是会出现如下的错误&#34;&gt;为什么还是会出现如下的错误&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;&amp;gt; (run &amp;quot;letrec double(x)
            = if zero?(x) then 0 else -((double -(x,1)), 2)
       in (double 6)&amp;quot;)
. . extend-env-rec: bad value for bvar field: &#39;(x)
&amp;gt; (run &amp;quot;if zero?(3) then 0 else -(3,2)&amp;quot;) 
(num-val 1)
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>The Fourth Interpreter about the traceproc</title>
      <link>https://jueqingsizhe66.github.io/archives/the-fourth-interpreter-about-the-traceproc/</link>
      <pubDate>Sat, 27 Feb 2016 21:49:18 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/archives/the-fourth-interpreter-about-the-traceproc/</guid>
      <description>&lt;p&gt;程序的过程追踪能力体现着一个独特的优势，本文在&lt;a href=&#34;http://jueqingsizhe66.github.io/blog/2016/02/25/first-interpreter-from-eopl/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;First Interpreter&lt;/a&gt;,&lt;a href=&#34;http://jueqingsizhe66.github.io/blog/2016/02/27/the-second-interpreter-from-one/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Second Interpreter&lt;/a&gt;,&lt;a href=&#34;http://jueqingsizhe66.github.io/blog/2016/02/27/the-third-interpreter-implementing-proc/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Third Interpreter&lt;/a&gt;基础上实现新的解释器功能。&lt;/p&gt;
&lt;p&gt;实现效果:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    enter: x = #(struct:num-val 30)
    exting: result = #(struct:num-val 29)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;font size=&#34;2&#34; color=&#34;red&#34;&gt;老阮不狂谁会得？出门一笑大江横！&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&#34;langscm修改程序追踪部分&#34;&gt;lang.scm修改程序追踪部分&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;      ;;增加了trace-proc
          (expression (&amp;quot;traceproc&amp;quot; &amp;quot;(&amp;quot; identifier &amp;quot;)&amp;quot; expression) traceproc-exp)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;至于proc的语法并不需要做任何的修改。&lt;/p&gt;
&lt;h2 id=&#34;data-structuresscm-进行部分修改&#34;&gt;data-structures.scm 进行部分修改&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;在修改trace-proc实现的情况下还得修改proc?&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;原先的proc?实现&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;  ;; proc? : SchemeVal -&amp;gt; Bool
  ;; procedure : Var * Exp * Env -&amp;gt; Proc
  (define-datatype proc proc?
    (procedure
     (var symbol?)
     (body expression?)
     (env environment?)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;改进后的&lt;code&gt;proc?&lt;/code&gt;实现,注意trace 是&lt;code&gt;boolean?&lt;/code&gt;类型。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;  ;; proc? : SchemeVal -&amp;gt; Bool
  ;; procedure : Var * Exp * Env -&amp;gt; Proc
  (define-datatype proc proc?
    (procedure
     (var symbol?)
     (body expression?)
     (env environment?)
     (trace boolean?)))
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;interpscm-修改程序追踪部分&#34;&gt;interp.scm 修改程序追踪部分&lt;/h2&gt;
&lt;p&gt;由于proc?的类型实现发生了变化，所以需要进行对应的修改apply-procedure和value-of。&lt;/p&gt;
&lt;h3 id=&#34;apply-procedure的修改&#34;&gt;apply-procedure的修改&lt;/h3&gt;
&lt;p&gt;原先的apply-procedure实现：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;
(define apply-procedure
    (lambda (proc1 val)
      (cases proc proc1
        (procedure (var body saved-env)
          (value-of body (extend-env var val saved-env))))))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;改进后的apply-procedure增加了trace?的判断&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;;; apply-procedure : Proc * ExpVal -&amp;gt; ExpVal
  ;; Page: 79
  (define apply-procedure
    (lambda (proc1 val)
      (cases proc proc1
        (procedure (var body saved-env trace?)
                  (if trace? (printf &amp;quot;enter: ~a = ~a\n&amp;quot; var val) &#39;**proc**)
                  (let ((value (value-of body (extend-env var val saved-env))))
                    (if trace? (printf &amp;quot;exting: result = ~a\n&amp;quot; value) &#39;**proc**)
                    value)))))
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;value-of-的修改&#34;&gt;value-of 的修改&lt;/h3&gt;
&lt;p&gt;原先的value-of实现：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;  (proc-exp (var body)
                 (proc-val (procedure var body env)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;新改进的的value-of 实现:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;    (proc-exp (var body)
                 (proc-val (procedure var body env #f)))
    (traceproc-exp (var body)
                  (proc-val (procedure var body env #t)))
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;测试追踪修改的结果&#34;&gt;测试追踪修改的结果&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(run &amp;quot;proc(x) -(x, 1)&amp;quot;)
(run &amp;quot;(proc(x) -(x,1)  30)&amp;quot;)
(run &amp;quot;let f = traceproc (x) -(x,1) in (f 30)&amp;quot;)
(run &amp;quot;(proc(f)(f 30)  proc(x)-(x,1))&amp;quot;)
(run &amp;quot;let x = 3 in -(x,1)&amp;quot;)

    (proc-val (procedure &#39;x (diff-exp (var-exp &#39;x) (const-exp 1)) (list (list &#39;i (num-val 1)) (list &#39;v (num-val 5)) (list &#39;x (num-val 10))) #f))
    (num-val 29)
    enter: x = #(struct:num-val 30)
    exting: result = #(struct:num-val 29)
    (num-val 29)
    (num-val 29)
    (num-val 2)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;&lt;font size=&#34;9&#34; color=&#34;yellow&#34;&gt;老阮不狂谁会得？出门一笑大江横！&lt;/font&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>The third Interpreter implementing Proc</title>
      <link>https://jueqingsizhe66.github.io/archives/the-third-interpreter-implementing-proc/</link>
      <pubDate>Sat, 27 Feb 2016 14:35:50 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/archives/the-third-interpreter-implementing-proc/</guid>
      <description>&lt;p&gt;Scheme解释器的好处是可以不断的拓展自己语言的能力，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过&lt;a href=&#34;http://jueqingsizhe66.github.io/blog/2016/02/25/first-interpreter-from-eopl/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;The First-interpreter-from-eopl&lt;/a&gt;创建了一个较为简单let-language，实现了较为简单的减法运算和let局部变量赋值等功能。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://jueqingsizhe66.github.io/blog/2016/02/27/the-second-interpreter-from-one/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;The Second Interpreter from on&lt;/a&gt;第一次扩展了基础的let-language，实现了四则运算，逻辑判断，列表操作,列表赋值等。&lt;/li&gt;
&lt;li&gt;这个版本的解释器进一步拓展了过程定义和过程调用的功能。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1&#34;&gt;1. proc-language 的实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2&#34;&gt;2. Y-comb 的实现过程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3&#34;&gt;3. 新语言的Y+实现&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id = &#34;1&#34;&gt; 1. proc-language 的实现 &lt;/h2&gt;
&lt;h3 id=&#34;langscm增加了过程定义和调用&#34;&gt;lang.scm增加了过程定义和调用&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;    ;;;new stuff
      (expression
       (&amp;quot;proc&amp;quot; &amp;quot;(&amp;quot; identifier &amp;quot;)&amp;quot; expression)
       proc-exp)
      
      (expression
       (&amp;quot;(&amp;quot; expression expression &amp;quot;)&amp;quot;)
       call-exp)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;interpscm增加了过程定义和调用&#34;&gt;interp.scm增加了过程定义和调用&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;value-of 增加了proc-exp和call-exp的内部语言形式&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;      ;;;新增的proc-exp 和call-exp
        (proc-exp (var body)
                 (proc-val (procedure var body env)))
        
        (call-exp (rator rand)
                 (let ((proc (expval-&amp;gt;proc (value-of rator env)))
                       (arg (value-of rand env)))
                   (apply-procedure proc arg)))
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;apply-procedure 用于proc的实现&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt; ;; proc-exp
 ;; apply-procedure : Proc * ExpVal -&amp;gt; ExpVal
  ;; Page: 79
  (define apply-procedure
    (lambda (proc1 val)
      (cases proc proc1
        (procedure (var body saved-env)
          (value-of body (extend-env var val saved-env))))))
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;data-structuresscm增加了过程定义和调用&#34;&gt;data-structures.scm增加了过程定义和调用&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;在expval中拓展了proc?的判断&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;  (define-datatype expval expval?
    (num-val
     (value number?))
    (bool-val
     (boolean boolean?))
    (pair-val
     (car expval?)
     (cdr expval?))
    (emptylist-val)
    ;;新增的proc-exp
    (proc-val 
     (proc proc?))
    )
  
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;增加expval-&amp;gt;proc类型转换的过程&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;proc其实就是一个closure的具体实现。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;  ;;;新增的expval-&amp;gt;proc 和proc类
  ;; expval-&amp;gt;proc : ExpVal -&amp;gt; Proc
  (define expval-&amp;gt;proc
    (lambda (v)
      (cases expval v
        (proc-val (proc) proc)
        (else (expval-extractor-error &#39;proc v)))))
  
  ;; proc? : SchemeVal -&amp;gt; Bool
  ;; procedure : Var * Exp * Env -&amp;gt; Proc
  (define-datatype proc proc?
    (procedure
     (var symbol?)
     (body expression?)
     (env environment?)))
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;增加过程定义和调用的测试结果&#34;&gt;增加过程定义和调用的测试结果&lt;/h2&gt;
&lt;h3 id=&#34;error1&#34;&gt; 错误1 &lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;. data-structures.scm:102:11: expression?: unbound identifier in module in: expression?
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;错误2&#34;&gt;错误2&lt;/h3&gt;
&lt;p&gt;如果按照错误1,把具体的expression?实现放入&lt;code&gt;data-structures.scm&lt;/code&gt;中，则会出现&lt;a href=&#34;#error1&#34;&gt;错误1&lt;/a&gt;的问题。&lt;/p&gt;
&lt;p&gt;expression?现在定义如下,具体参考&lt;a href=&#34;http://jueqingsizhe66.github.io/blog/2016/02/26/some-notations-in-the-design-of-the-language/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Some notations&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;expression ::= (var-exp ())
           ::= (const-exp ())
           ::= (zero?-exp ())
           ::= (if-exp ())
           ::= (diff-exp ())
           ::= (cons-exp ())
           ::= (car-exp ())
           ::= (cdr-exp ())
           ::= (null?-exp ())
           ::= (emptylist-exp)
           ::= (list-exp ())
           ::= (let-exp ())
           ::= (proc-exp ())
           ::= (call-exp ())
           ::= (letrec-exp ())  ;;并未再此体现

           ::= (less?-exp ())
           ::= (greater?-exp ())
           ::= (equal?-exp ())

           ::= (print-exp ())
           ::= (unpack-exp ())
           ::= (cond-exp ())

           ::= (add-exp ())
           ::= (mult-exp ())
           ::= (div-exp ())

           ::= (let*-exp ())

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;expression?实现如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  ;; datatype ;;;
  (define-datatype expression expression?
    (var-exp
     (id symbol?))
    (const-exp
     (num number?))
    (zero?-exp
     (expr expression?))
    (if-exp
     (predicate-exp expression?)
     (true-exp expression?)
     (false-exp expression?))
    ;;四则运算
    (minus-exp
     (body-exp expression?))
    (diff-exp
     (exp1 expression?)
     (exp2 expression?))
    (add-exp
     (exp1 expression?)
     (exp2 expression?))
    (mult-exp
     (exp1 expression?)
     (exp2 expression?))
    (div-exp
     (exp1 expression?)
     (exp2 expression?))
    
    ;;逻辑比较
    (equal?-exp
     (exp1 expression?)
     (exp2 expression?))
    (less?-exp
     (exp1 expression?)
     (exp2 expression?))
    (greater?-exp
     (exp1 expression?)
     (exp2 expression?))
    
    ;;列表操作
    (emptylist-exp)
    (cons-exp
     (exp1 expression?)
     (exp2 expression?))
    (car-exp
     (body expression?))
    (cdr-exp
     (body expression?))
    (null?-exp
     (body expression?))
    ;;list实现
    (list-exp
     (args (list-of expression?)))
    
    ;; cond实现
    (cond-exp
     (conds (list-of expression?))
     (acts (list-of expression?)))
  
    ;;let let*
    (let-exp
     (vars (list-of symbol?))  ;;;symbol不能写成symbols
     (vals (list-of expression?))
     (body expression?))
    
    (let*-exp
     (vars (list-of symbol?)) ;(vars (list-of symbols?))
     (vals (list-of expression?))
     (body expression?))
    
    ;;print实现
    (print-exp
     (arg expression?))
    ;;unpack实现
    (unpack-exp
     (args (list-of symbol?));(args (list-of identifier?))
     (vals expression?)
     (body expression?))
    
    ;;proc
    (proc-exp
     (var (list-of symbol?))
     (body expression?))
    (call-exp
     (rator expression?)
     (rand (list-of expression?)))
    
    )
  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为什么添加上expression？反而出现如下的错误？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(require &amp;quot;data-structures.scm&amp;quot;)
(require &amp;quot;lang.scm&amp;quot;)  =》 There are some problems here.
top.scm:8:11: module: identifier already imported from: &amp;quot;data-structures.scm&amp;quot; at: expression in: &amp;quot;lang.scm&amp;quot;
  #(174 21)
  #(235 10)
module: identifier already imported from a different source in:
  expression
  &amp;quot;lang.scm&amp;quot;
  &amp;quot;data-structures.scm&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;分析发现是因为lang.scm其实已经定义了expression?, &lt;code&gt;sllgen:make-define-datatypes&lt;/code&gt;中通过the grammer定义了所有的expression?的实现。
所以如果在&lt;code&gt;top.scm&lt;/code&gt;中同时导入&lt;code&gt;lang.scm&lt;/code&gt; 和&lt;code&gt;data-structures.scm&lt;/code&gt;则会报错，重复定义。
&lt;strong&gt;&lt;code&gt;于是仅仅在data-structures.scm中增加require &amp;quot;lang.scm&amp;quot;即可&lt;/code&gt;&lt;/strong&gt;,
&lt;font size=&#34;10&#34; color=&#34;red&#34;&gt;结果通过！&lt;/font&gt;&lt;/p&gt;
&lt;h3 id=&#34;正确的测试结果&#34;&gt;正确的测试结果&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(run &amp;quot;proc(x) -(x, 1)&amp;quot;)
(run &amp;quot;(proc(x) -(x,1)  30)&amp;quot;)
(run &amp;quot;(proc(f)(f 30)  proc(x)-(x,1))&amp;quot;)
(run &amp;quot;let x = 3 in -(x,1)&amp;quot;)
;;new stuff, the Currying
(run &amp;quot;let f = proc (x) proc (y) -(x, -(0, y)) in ((f 10) 20)&amp;quot;)

    (proc-val (procedure &#39;x (diff-exp (var-exp &#39;x) (const-exp 1)) (list (list &#39;i (num-val 1)) (list &#39;v (num-val 5)) (list &#39;x (num-val 10)))))
    (num-val 29)
    (num-val 29)
    (num-val 2)
    (num-val 30)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2&#34;&gt; 2. 一个y-combination的实现 &lt;/h2&gt;
&lt;p&gt;关于y-combination可以参考&lt;a href=&#34;http://jueqingsizhe66.github.io/blog/2015/05/17/cong-lambdadao-simple-plus-complexjie-shi-qi-zai-dao-shu-xing-chou-xiang/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;从lambda到simple+complex解释器再到树形抽象&lt;/a&gt;疑问关于y-comb的实现。
进一步可以参考:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[Fixed-point combinator] &lt;a href=&#34;https://en.wikipedia.org/wiki/Fixed-point_combinator#Fixed_point_combinators_in_lambda_calculus&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;5&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[Church and Turing] &lt;a href=&#34;http://www.yinwang.org/blog-cn/2013/07/13/church-turing/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;6&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[Neil Jones的computation and complexity,使用一种while语言] &lt;a href=&#34;http://www.diku.dk/~neil/comp2book2007/book-whole.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;7&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Matthias Felleisen 和 Matthew Flatt 的[《Programming Languages and Lambda Calculi》] &lt;a href=&#34;http://www.cs.utah.edu/~mflatt/past-courses/cs7520/public_html/s06/notes.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;8&lt;/a&gt; 教你认识lambda&lt;/li&gt;
&lt;li&gt;[最经典的Y combinator] &lt;a href=&#34;http://www.ece.uc.edu/~franco/C511/html/Scheme/ycomb.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;9&lt;/a&gt; 看了10遍以上&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;y-comb基本思想&#34;&gt;Y-comb基本思想&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;通过增加一层lambda表达式，进行更高一级抽象&lt;/li&gt;
&lt;li&gt;beta规约原则&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;比如&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define fact 
 (lambda (op)
   (lambda ( x y) (op  x y))))

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;比如&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(f arg) ==  (lambda (arg) (f arg))

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最为基本的fact实现是(构建与已经存在的fact)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define fact
 (lambda (x)
   (if (zero? x)
      0
      (fact (- x 1)))))

(fact 5)

120
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而如果运用思想1(也就是隐藏fact的调用，而使用局部过程变量procedure),则变换为&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;
(define fact
   (lambda (procedure)
     (lambda (x)
        (if (zero? x)
           0
           (procedure (- x 1))))))


((fact fact) 5)

120
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;于是有了下面的推导过程(把fact的表达式多给他还原 ，可以参考&lt;a href=&#34;http://jueqingsizhe66.github.io/blog/2016/02/26/some-notations-in-the-design-of-the-language/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;还原方法Some-notations&lt;/a&gt;)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt; (define fact
    ((lambda (procedure)
       ((lambda (func-arg)  ;;吸收5
          (lambda (n)
            (if (zero? n)
                1
                (* n (func-arg (- n 1))))))
        (lambda (arg) ((procedure procedure) arg))))
     (lambda (procedure)
       ((lambda (func-arg) ;;吸收5
          (lambda (n)
            (if (zero? n)
                1
                (* n (func-arg (- n 1))))))
        (lambda (arg) ((procedure procedure) arg))))))


  (((lambda (procedure)
      (lambda (n)
        (if (zero? n)
            1
            (* n ((procedure procedure) (- n 1))))))
    (lambda (procedure)
      (lambda (n)
        (if (zero? n)
            1
            (* n ((procedure procedure) (- n 1)))))))
   5)

 (define fact1
   (lambda (x)
   (letrec ((F (lambda (procedure)
       ((lambda (func-arg)  ;;吸收5
          (lambda (n)
            (if (zero? n)
                1
                (* n (func-arg (- n 1))))))
        (lambda (arg) ((procedure procedure) arg))))))
     ((F F) x))))


  (define Y
    (lambda (X)
      ((lambda (procedure)
         (X (lambda (arg) ((procedure procedure) arg))))
       (lambda (procedure)
         (X (lambda (arg) ((procedure procedure) arg)))))))

  (((lambda (X)
      ((lambda (procedure)
         (X (lambda (arg) ((procedure procedure) arg))))
       (lambda (procedure)
         (X (lambda (arg) ((procedure procedure) arg))))))
    (lambda (func-arg)
      (lambda (n)
        (if (zero? n)
            1
            (* n (func-arg (- n 1)))))))
   5)

;;如何吸收F 形成(F F)的形式 产生循环的调用过程
;; 只能是通过lambda 算子 构造proc 从而获得完整的表达式
  (((lambda (X)
      ((lambda (F)
         (lambda (arg) ((F F) arg)))  ;;一定要保证lambda封闭  
       (lambda (procedure)
         (X (lambda (arg) ((procedure procedure) arg))))))
    (lambda (func-arg)
      (lambda (n)
        (if (zero? n)
            1
            (* n (func-arg (- n 1)))))))
   5)

(define Y 
  (lambda (X)
      ((lambda (F)
         (lambda (arg) ((F F) arg)))  ;;一定要保证lambda封闭
       (lambda (procedure)
         (X (lambda (arg) ((procedure procedure) arg)))))))

((Y   (lambda (func-arg)
      (lambda (n)
        (if (zero? n)
            1
            (* n (func-arg (- n 1))))))) 5)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到每增加一层(lambada (arg) &amp;hellip;) ，也就是(lambda (arg) (lambda (arg2)  (lambda (arg) &amp;hellip; )))，
也就是  &lt;code&gt;&amp;lt;procedure&amp;gt;::= (lambda (arg) (&amp;lt;expression&amp;gt; |&amp;lt;procedure&amp;gt;)) | &amp;lt;procedure&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;3&#34;&gt;新语言的Y+实现&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(run &amp;quot;let makemult = proc (maker) proc (x)
      if zero?(x)
            then 0
      else
            -(((maker maker) -(x,1)), -4)
      in let times4 = proc (x) ((makemult makemult) x) in (times4 3)&amp;quot;)

;; ==&amp;gt; (num-val 12)

;;times
(run &amp;quot;let makemult = proc (maker) proc (x) proc(y)
      if zero?(x) then 0
      else -((((maker maker) -(x, 1)) y), -(0, y))
      in let times = proc(x) proc(y)
                    (((makemult makemult) x) y)
      in ((times 3) 8)&amp;quot;)

;; -&amp;gt; (num-val 24)

(run &amp;quot;let makemult = proc (maker) proc (x) proc(y)
      if zero?(x) then 0
      else -((((maker maker) -(x, 1)) y), -(0, y))
      in let times = proc(x) proc(y)
                    (((makemult makemult) x) y)
      in let f = proc(func) proc(num)
        if zero?(num)
           then 1
        else
           ((times ((func func) -(num, 1))) num)
      in let fact = proc (x) ((f f) x)
      in (fact 5)&amp;quot;)


(num-val 12)
(num-val 24)
(num-val 120)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最终提取一个更为精简的y-comb&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;

(run &amp;quot;let makerec = proc (f)
        let d = proc (x)
          proc (z) ((f (x x)) z)
        in proc (n) ((f (d d)) n)
     in let maketimes4 = proc (f) proc (x)
          if zero?(x)
             then 0
          else -((f -(x,1)), -4)
      in let times4 = (makerec maketimes4) in (times4 3)&amp;quot;)

    (num-val 12)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;结论&#34;&gt;结论&lt;/h2&gt;
&lt;p&gt;Y-comb是一个痛苦和希望的承载者(持保留意见)，韵味十足.又像一个走过岁月年轮，在家等待着归家儿女的思妇，祈祷，承担。
Y-Comb需要丝丝宁静,雨夜飘过。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>The Second Interpreter from One</title>
      <link>https://jueqingsizhe66.github.io/archives/the-second-interpreter-from-one/</link>
      <pubDate>Sat, 27 Feb 2016 01:04:52 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/archives/the-second-interpreter-from-one/</guid>
      <description>&lt;p&gt;在[First Interpreter From EOPL][1]中我们定义了一个最为基本的解释器，包含解释以下解释部分&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;const-exp&lt;/li&gt;
&lt;li&gt;diff-exp&lt;/li&gt;
&lt;li&gt;zero?-exp&lt;/li&gt;
&lt;li&gt;if-exp&lt;/li&gt;
&lt;li&gt;var-exp&lt;/li&gt;
&lt;li&gt;let-exp&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这六种是比较基础的形式，在此基础上我们可以增加四则运算，加入list操作，加入逻辑比较&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1&#34;&gt;1. 增加四则运算&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1.1&#34;&gt;1.1 lang.scm修改四则运算&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#1.2&#34;&gt;1.2 interp.scm修改四则运算&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#1.3&#34;&gt;1.3 测试四则运算结果&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2&#34;&gt;2. 增加逻辑比较&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#2.1&#34;&gt;2.1 lang.scm修改逻辑比较&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2.2&#34;&gt;2.2 interp.scm修改逻辑比较&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2.3&#34;&gt;2.3 测试逻辑比较结果&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3&#34;&gt;3. 加入列表操作&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#3.1&#34;&gt;3.1 lang.scm修改列表操作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3.2&#34;&gt;3.2 interp.scm修改列表操作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3.3&#34;&gt;3.3 data-structures.scm增加了expval值类型和4个操作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3.4&#34;&gt;3.4 测试修改列表操作结果&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4&#34;&gt;4. list具体实现&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#4.1&#34;&gt;4.1 lang.scm修改list具体实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4.2&#34;&gt;4.2 interp.scm修改list具体实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4.3&#34;&gt;4.3 data-structures.scm修改list的具体实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4.4&#34;&gt;4.3 测试list具体实现结果&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5&#34;&gt;5. cond条件比较&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#5.1&#34;&gt;5.1 lang.scm修改cond条件比较&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5.2&#34;&gt;5.2 interp.scm修改cond条件比较&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5.3&#34;&gt;5.3 测试cond条件比较结果&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6&#34;&gt;6. print显示&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#6.1&#34;&gt;6.1 lang.scm修改print显示&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6.2&#34;&gt;6.2 interp.scm修改print显示&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6.3&#34;&gt;6.3 测试print显示结果&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#7&#34;&gt;7. let的改进和let*的加入&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#7.1&#34;&gt;7.1 let改进之interp.scm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#7.2&#34;&gt;7.2 let改进之lang.scm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#7.3&#34;&gt;7.3 let改进结果&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#7.4&#34;&gt;7.4 let*的lang.scm具体实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#7.5&#34;&gt;7.5 let*的interp.scm具体实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#7.6&#34;&gt;7.6 let*的测试结果&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#8&#34;&gt;8. unpack列表赋值&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#8.1&#34;&gt;8.1 unpack的interp.scm修改&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#8.2&#34;&gt;8.2 unpack的lang.scm修改&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#8.3&#34;&gt;8.3 测试unpack修改结果&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;1&#34;&gt; 1. 增加四则运算  &lt;/h2&gt;
&lt;h3 id=&#34;1.1&#34;&gt; 1.1 lang.scm修改四则运算&lt;/h3&gt;
&lt;p&gt;在the-grammer增加如下expressions&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;      ;;;new add + * /
    (expression (&amp;quot;+&amp;quot; &amp;quot;(&amp;quot; expression &amp;quot;,&amp;quot; expression &amp;quot;)&amp;quot;) add-exp)
    (expression (&amp;quot;*&amp;quot; &amp;quot;(&amp;quot; expression &amp;quot;,&amp;quot; expression &amp;quot;)&amp;quot;) mult-exp)
    (expression (&amp;quot;/&amp;quot; &amp;quot;(&amp;quot; expression &amp;quot;,&amp;quot; expression &amp;quot;)&amp;quot;) div-exp)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;1.2&#34;&gt; 1.2 interp.scm修改四则运算&lt;/h3&gt;
&lt;p&gt;在value-of增加如下expressions&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;           (add-exp (exp1 exp2)
		    (let ((val1 (value-of exp1 env))
			  (val2 (value-of exp2 env)))
		      (let ((num1 (expval-&amp;gt;num val1))
			    (num2 (expval-&amp;gt;num val2)))
			(num-val
			 (+ num1 num2)))))
           (mult-exp (exp1 exp2)
                     (let ((val1 (value-of exp1 env))
                           (val2 (value-of exp2 env)))
                       (let ((num1 (expval-&amp;gt;num val1))
                             (num2 (expval-&amp;gt;num val2)))
                         (num-val
                          (* num1 num2)))))
           (div-exp (exp1 exp2)
		    (let ((val1 (value-of exp1 env))
			  (val2 (value-of exp2 env)))
		      (let ((num1 (expval-&amp;gt;num val1))
			    (num2 (expval-&amp;gt;num val2)))
			(num-val
			 (/ num1 num2)))))
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;1.3&#34;&gt; 1.3 测试四则运算结果&lt;/h3&gt;
&lt;p&gt;在原先减法的基础上增加了乘法、加法和除法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(run &amp;quot;let x = -(4,1) in +(x,1)&amp;quot;)
(run &amp;quot;let x = -(4,1) in *(x,2)&amp;quot;)
(run &amp;quot;let x = -(4,1) in /(x,2)&amp;quot;)

结果:
    (num-val 4)
    (num-val 6)
    (num-val 1 1/2)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2&#34;&gt; 2. 增加逻辑比较  &lt;/h2&gt;
&lt;h3 id=&#34;2.1&#34;&gt; 2.1 lang.scm修改逻辑比较&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt; ;;增加逻辑比较
    (expression (&amp;quot;equal?&amp;quot; &amp;quot;(&amp;quot; expression &amp;quot;,&amp;quot; expression &amp;quot;)&amp;quot;) equal?-exp)
    (expression (&amp;quot;less?&amp;quot; &amp;quot;(&amp;quot; expression &amp;quot;,&amp;quot; expression &amp;quot;)&amp;quot;) less?-exp)
    (expression (&amp;quot;greater?&amp;quot; &amp;quot;(&amp;quot; expression &amp;quot;,&amp;quot; expression &amp;quot;)&amp;quot;) greater?-exp)
    (expression (&amp;quot;minus&amp;quot; &amp;quot;(&amp;quot; expression &amp;quot;)&amp;quot;) minus-exp)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2.2&#34;&gt; 2.2 interp.scm修改逻辑比较&lt;/h3&gt;
``` scheme
           (equal?-exp (exp1 exp2)
                    (let ((val1 (value-of exp1 env))
                          (val2 (value-of exp2 env)))
                      (let ((num1 (expval-&gt;num val1))
                            (num2 (expval-&gt;num val2)))
                        (bool-val
                         (= num1 num2)))))
&lt;pre&gt;&lt;code&gt;       (less?-exp (exp1 exp2)
                (let ((val1 (value-of exp1 env))
                      (val2 (value-of exp2 env)))
                  (let ((num1 (expval-&amp;gt;num val1))
                        (num2 (expval-&amp;gt;num val2)))
                    (bool-val
                     (&amp;lt; num1 num2)))))

       (greater?-exp (exp1 exp2)
                (let ((val1 (value-of exp1 env))
                      (val2 (value-of exp2 env)))
                  (let ((num1 (expval-&amp;gt;num val1))
                        (num2 (expval-&amp;gt;num val2)))
                    (bool-val
                     (&amp;gt; num1 num2)))))
    (minus-exp (body-exp)
              (let ((val1 (value-of body-exp env)))
                (let ((num (expval-&amp;gt;num val1)))
                  (num-val (- 0 num)))))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;
&amp;lt;h3 id=&amp;quot;2.3&amp;quot;&amp;gt; 2.3 测试增加逻辑比较结果&amp;lt;/h3&amp;gt;

``` scheme
(run &amp;quot;if less?(1, 2) then 1 else 2&amp;quot;)
(run &amp;quot;if greater?(2, 1) then minus(1) else minus(2)&amp;quot;)

    (num-val 1)
    (num-val -1)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3&#34;&gt; 3. 加入列表操作  &lt;/h2&gt;
&lt;h3 id=&#34;3.1&#34;&gt; 3.1 lang.scm修改列表操作&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;;;; 增加list比较
        ;;new stuff
    (expression (&amp;quot;cons&amp;quot; &amp;quot;(&amp;quot; expression &amp;quot;,&amp;quot; expression &amp;quot;)&amp;quot;) cons-exp)
    (expression (&amp;quot;car&amp;quot; &amp;quot;(&amp;quot; expression &amp;quot;)&amp;quot;) car-exp)
    (expression (&amp;quot;cdr&amp;quot; &amp;quot;(&amp;quot; expression &amp;quot;)&amp;quot;) cdr-exp)
    (expression (&amp;quot;emptylist&amp;quot;) emptylist-exp)
    (expression (&amp;quot;null?&amp;quot; &amp;quot;(&amp;quot; expression &amp;quot;)&amp;quot;) null?-exp)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3.2&#34;&gt; 3.2 interp.scm修改列表操作&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;        ;;;增加了list操作
        (emptylist-exp ()
                      (emptylist-val))
        (cons-exp (exp1 exp2)
                 (let ((val1 (value-of exp1 env))
                       (val2 (value-of exp2 env)))
                   (pair-val val1 val2)))
        (car-exp (body)
                (expval-car (value-of body env)))
        (cdr-exp (body)
                (expval-cdr (value-of body env)))
        (null?-exp (exp)
                  (expval-null? (value-of exp env)))
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3.3&#34;&gt; 3.3 data-structures.scm增加了expval值类型和4个操作&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;修改expval部分&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;增加了&lt;code&gt;pair-val&lt;/code&gt;和&lt;code&gt;emptylist-val&lt;/code&gt; 两个语言的新值，这也是区分之前的&lt;a href=&#34;#1&#34;&gt;四则运算&lt;/a&gt;和&lt;a href=&#34;#2&#34;&gt;逻辑比较&lt;/a&gt;的过程&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;    (pair-val
     (car expval?)
     (cdr expval?))
    (emptylist-val)
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;增加了4个expval类型变换操作&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;
;;增加4个expval-&amp;gt;操作
(define expval-&amp;gt;pair
  (lambda (v)
    (cases expval v
	   (pair-val (car cdr)
		     (cons car cdr))
	   (else (expval-extractor-error &#39;pair v)))))

(define expval-car
  (lambda (v)
    (cases expval v
	   (pair-val (car cdr) car)
	   (else (expval-extractor-error &#39;car v)))))

(define expval-cdr
  (lambda (v)
    (cases expval v
	   (pair-val (car cdr) cdr)
	   (else (expval-extractor-error &#39;cdr v)))))

(define expval-null?
  (lambda (v)
    (cases expval v
	   (emptylist-val () (bool-val #t))
	   (else (bool-val #f)))))

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3.4&#34;&gt; 3.4 测试修改列表操作结果&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(run &amp;quot;cons(1, 2)&amp;quot;)
(run &amp;quot;car (cons (1, 2))&amp;quot;)
(run &amp;quot;cdr (cons (1, 2))&amp;quot;)
(run &amp;quot;null? (emptylist)&amp;quot;)
(run &amp;quot;null? (cons (1, 2))&amp;quot;)

(run &amp;quot;let x = 4
        in cons(x,
          cons(cons(-(x,1),
                    emptylist),
                   emptylist))&amp;quot;)

    (pair-val (num-val 1) (num-val 2))
    (num-val 1)
    (num-val 2)
    (bool-val #t)
    (bool-val #f)
    (pair-val (num-val 4) (pair-val (pair-val (num-val 3) (emptylist-val)) (emptylist-val)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;错误的测试：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;&amp;gt; (run &amp;quot;car (3 5 3)&amp;quot;)
. . parsing: at line 1: looking for &amp;quot;)&amp;quot;, found number 5 in production
((string &amp;quot;car&amp;quot;) (string &amp;quot;(&amp;quot;) (non-term expression) (string &amp;quot;)&amp;quot;) (reduce #&amp;lt;procedure:car-exp&amp;gt;))
&amp;gt; (run &amp;quot;car (3,5)&amp;quot;)
. . parsing: at line 1: looking for &amp;quot;)&amp;quot;, found literal-string111 &amp;quot;,&amp;quot; in production
((string &amp;quot;car&amp;quot;) (string &amp;quot;(&amp;quot;) (non-term expression) (string &amp;quot;)&amp;quot;) (reduce #&amp;lt;procedure:car-exp&amp;gt;))
&amp;gt; (run &amp;quot;null? ()&amp;quot;)
. . parsing: at line 1: nonterminal &amp;lt;expression&amp;gt; can&#39;t begin with literal-string111 &amp;quot;)&amp;quot;
&amp;gt; (run &amp;quot;car (cons (3,5))&amp;quot;)
(num-val 3)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;具体原因是car-exp的定义是通过expval-car的实现，而expval-car接受的是cons创造的数据结构，所以出现了问题。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;  (car-exp (body) (expval-car (value-of body env)))


(pair-val
 (car expval?)
 (cdr expval?))
(emptylist-val)


(define expval-car
  (lambda (v)
    (cases expval v
     (pair-val (car cdr) car)   ;;v在这边是expval类型,更具体来说是pair-val,其他类型没有对应的操作
                                ;;而在当前的情况细 pair-val只能通过cons创建！！
     (else (expval-extractor-error &#39;car v)))))


并需要增加pair-var?的数据类型

  (define-datatype expval expval?
    (num-val
     (value number?))
    (bool-val
     (boolean boolean?))
    (pair-val
     (car expval?)
     (cdr expval?))
    (emptylist-val))


可以参考value-of中关于cons-exp的定义：
    (cons-exp (exp1 exp2)
             (let ((val1 (value-of exp1 env))
                   (val2 (value-of exp2 env)))
               (pair-val val1 val2)))
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;注意操作符后面不是必须直接跟上括号空格会被直接忽略-而是应该保证括号的对称性&#34;&gt;注意操作符后面不是必须直接跟上括号(空格会被直接忽略) 而是应该保证括号的对称性。&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;&amp;gt; (run &amp;quot;* (3,4&amp;quot;)
. . parsing: at line 1: looking for &amp;quot;)&amp;quot;, found end-marker #f in production
((string &amp;quot;*&amp;quot;) (string &amp;quot;(&amp;quot;) (non-term expression) (string &amp;quot;,&amp;quot;) (non-term expression) (string &amp;quot;)&amp;quot;) (reduce #&amp;lt;procedure:mult-exp&amp;gt;))
&amp;gt; (run &amp;quot;+(3,4)&amp;quot;)
(num-val 7)
&amp;gt; (run &amp;quot;*(3,4)&amp;quot;)
(num-val 12)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4&#34;&gt; 4.list的具体实现 &lt;/h2&gt;
&lt;h3 id=&#34;4.1&#34;&gt; 4.1 lang.scm修改list具体实现&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;
    (expression (&amp;quot;list&amp;quot; &amp;quot;(&amp;quot; (separated-list expression &amp;quot;,&amp;quot;) &amp;quot;)&amp;quot; ) list-exp)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;4.2&#34;&gt; 4.2 interp.scm修改list具体实现&lt;/h3&gt; 
&lt;ol&gt;
&lt;li&gt;增加一个apply-elm用于list操作。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;  ;; used as map for the list
(define apply-elm
  (lambda (env)
    (lambda (elem)
      (value-of elem env))))
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;增加了list类型&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;  ;;; 增加了list操作
  (list-exp (args)
           (list-val (map (apply-elm env) args)))
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;4.3&#34;&gt; 4.3 data-structures.scm修改list的具体实现 &lt;/h3&gt;
&lt;p&gt;增加了list-val的实现:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;
;;;增加了list的具体实现
  (define list-val
  (lambda (args)
    (if (null? args)
	(emptylist-val)
	(pair-val (car args)
		  (list-val (cdr args))))))

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;4.4&#34;&gt; 4.4 测试list具体实现的结果&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(run &amp;quot;list(1, 2, 3)&amp;quot;)
(run &amp;quot;car(cdr(list(1, 2, 3)))&amp;quot;)
(run &amp;quot;let x = 4
      in list(x, -(x,1), -(x,3))&amp;quot;)

    (pair-val (num-val 1) (pair-val (num-val 2) (pair-val (num-val 3) (emptylist-val))))
    (num-val 2)
    (pair-val (num-val 4) (pair-val (num-val 3) (pair-val (num-val 1) (emptylist-val))))

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;5&#34;&gt;5. cond条件比较 &lt;/h2&gt;
&lt;h3 id=&#34;5.1&#34;&gt; 5.1 lang.scm修改cond条件比较 &lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;;;增加了cond具体语法
;; new stuff
(expression (&amp;quot;cond&amp;quot; (arbno expression &amp;quot;==&amp;gt;&amp;quot; expression) &amp;quot;end&amp;quot;) cond-exp)

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;5.2&#34;&gt; 5.2 interp.scm修改cond条件比较 &lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;增加一个cond-val，之所以不在类似&lt;a href=&#34;#3&#34;&gt;加入列表实现&lt;/a&gt;和&lt;a href=&#34;#4&#34;&gt;list具体实现&lt;/a&gt;添加val转换，是因为cond-val涉及到value-of
程序，所以需要放在interp.scm中,放在apply-elm之后即可.&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;;;增加了cond-val的处理
;;new stuff
(define cond-val
  (lambda (conds acts env)
    (cond ((null? conds)
	   (error &#39;cond-val &amp;quot;No conditions got into #t&amp;quot;))
	  ((expval-&amp;gt;bool (value-of (car conds) env))
	   (value-of (car acts) env))
	  (else
	   (cond-val (cdr conds) (cdr acts) env)))))
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;在value-of中增加了具体的实现&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;        ;;;增加了cond操作
        	   (cond-exp (conds acts)
		     (cond-val conds acts env))
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;5.3&#34;&gt; 5.3 测试cond条件比较结果&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(run &amp;quot;less?(1, 2)&amp;quot;)
(run &amp;quot;cond less?(1, 2) ==&amp;gt; 2 end&amp;quot;)
(run &amp;quot;cond less?(2, 1) ==&amp;gt; 1 greater?(2, 2) ==&amp;gt; 2  greater?(3, 2) ==&amp;gt; 3 end&amp;quot;)

    (bool-val #t)
    (num-val 2)
    (num-val 3)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;6&#34;&gt; 6. print显示 &lt;/h2&gt;
&lt;h3 id=&#34;6.1&#34;&gt; 6.1 lang.scm修改print显示&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;  ;; new stuff
    (expression (&amp;quot;print&amp;quot; &amp;quot;(&amp;quot; expression &amp;quot;)&amp;quot;) print-exp)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;6.2&#34;&gt; 6.2 interp.scm修改print显示&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;        ;;;增加了print
        (print-exp (arg)
                  (let ((val (value-of arg env)))
                    ;(print val)  ;;编译不通过 改为display
                    (display val) ;
                    (num-val 1)))
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;6.3&#34;&gt; 6.3 测试print显示结果&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(run &amp;quot;print( less? (1, 2))&amp;quot;)
    #(struct:bool-val #t)(num-val 1)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;7&#34;&gt; 7. let的改进和let*的加入 &lt;/h2&gt;
&lt;h3 id=&#34;一个问题&#34;&gt;一个问题&lt;/h3&gt;
&lt;p&gt;怎么会有问题？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; (run &amp;quot;let x = 30
      in let x = -(x,1)
             y = -(x,2)
         in -(x, y)&amp;quot;)
. . parsing: at line 3: looking for &amp;quot;in&amp;quot;, found identifier y in production
((string &amp;quot;let&amp;quot;) (term identifier) (string &amp;quot;=&amp;quot;) (non-term expression) (string &amp;quot;in&amp;quot;) (non-term expression) (reduce #&amp;lt;procedure:let-exp&amp;gt;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;分析原先的let设计程序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        (let-exp (var exp1 body)       
                (let ((val1 (value-of exp1 env)))
                  (value-of body
                           (extend-env var val1 env))))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这个具体实现其实并没有实现多重let的过程，所以导致有问题，所以下一步的关键问题是如何实现嵌套的let-exp解析。&lt;/p&gt;
&lt;h3 id=&#34;7.1&#34;&gt; let改进之interp.scm 修改 &lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;增加两个let-exp的辅助程序&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;  ;; let-exp的嵌套实现
  
  (define value-of-vals
    (lambda (vals env)
      (if (null? vals)
         &#39;()
         (cons (value-of (car vals) env)
              (value-of-vals (cdr vals) env)))))
  
  (define extend-env-list
    (lambda (vars vals env)
      (if (null? vars)
         env
         (let ((var1 (car vars))
               (val1 (car vals)))
           (extend-env-list (cdr vars) (cdr vals) (extend-env var1 val1 env))))))
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;改变letexp的具体实现&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;
 ;       (let-exp (var exp1 body)       
 ;               (let ((val1 (value-of exp1 env)))
 ;                (value-of body
 ;                          (extend-env var val1 env))))
        
        (let-exp (vars vals body)
                (let ((_vals (value-of-vals vals env)))
                  (value-of body (extend-env-list vars _vals env))))
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;7.2&#34;&gt; 7.2 let改进之lang.scm  &lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;  ;    (expression
  ;     (&amp;quot;let&amp;quot; identifier &amp;quot;=&amp;quot; expression &amp;quot;in&amp;quot; expression)
  ;     let-exp)
      (expression 
        (&amp;quot;let&amp;quot; (arbno identifier &amp;quot;=&amp;quot; expression) &amp;quot;in&amp;quot; expression) 
        let-exp)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;还是没改好？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;link: bad variable linkage;
 reference to a variable that is uninitialized
  reference phase level: 0
  variable module: &amp;quot;/home/canbetter/let-lang/lang.scm&amp;quot;
  variable phase: 0
  reference in module: &amp;quot;/home/canbetter/let-lang/interp.scm&amp;quot; in: a-program?
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;原因出现在let语法中增加了 &lt;code&gt;(arbno ...)&lt;/code&gt;操作。&lt;/p&gt;
&lt;p&gt;这个问题可以赘述到cond-exp的实现,其中也涉及到arbno的第一次键入。但是为什么会出现未初始化变量的情况？&lt;/p&gt;
&lt;p&gt;但是主要还是因为保存得不彻底！！导致了并未初始化，重新保存即可。&lt;/p&gt;
&lt;h3 id=&#34;7.3&#34;&gt; 7.3 let改进结果 &lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(run &amp;quot;let x = -(4,1) in let x =+(x,1) in -(x,10)&amp;quot;)

    (num-val -6)
(run &amp;quot;let x = -(4,1) in let x =+(x,1)  y=-(x,10) in -(x,y)&amp;quot;)

    (num-val 11) ;; x=4 y=-(3,10)=-7  所以-(x,y)=11而不是 10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么如何实现一个let*，使得let中的x变化的值立即反映到y中。&lt;/p&gt;
&lt;h3 id=&#34;7.4&#34;&gt; 7.4 let*的lang.scm具体实现 &lt;/h3&gt;
&lt;p&gt;该实现方式基本上和&lt;a href=&#34;#7.2&#34;&gt;let的语法&lt;/a&gt;一样&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;      (expression (&amp;quot;let*&amp;quot; (arbno identifier &amp;quot;=&amp;quot; expression) &amp;quot;in&amp;quot; expression) let*-exp)
      
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;7.5&#34;&gt; 7.5 let*的interp.scm具体实现 &lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;增加了一个extend-env-list-iter操作,由于也是存在value-of所以放入interp.scm中。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;  (define extend-env-list-iter
    (lambda(vars vals env)
      (if (null? vars)
         env
         (let ((var1 (car vars))
               (val1 (value-of (car vals) env)))
           (extend-env-list-iter (cdr vars) (cdr vals)
                                (extend-env var1 val1 env))))))
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;let*的类型定义&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;
        (let*-exp (vars vals body)
                 (value-of body (extend-env-list-iter vars vals env)))
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;7.6&#34;&gt; 7.6 let*的测试结果 &lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(run &amp;quot;let x = 30
      in let x = -(x,1)
             y = -(x,2)
         in -(x, y)&amp;quot;)

(run &amp;quot;let x = 30
      in let* x = -(x,1)
             y = -(x,2)
         in -(x, y)&amp;quot;)


    (num-val 1)
    (num-val 2)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;8&#34;&gt; 8. unpack列表赋值 &lt;/h2&gt;
&lt;h3 id=&#34;8.1&#34;&gt; 8.1 unpack的interp.scm修改 &lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;增加了extend-env-list-exp的操作，用于针对unpack的特殊的环境拓展,当然可以把它放在data-structures.scm中&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;  ;;; 关于unpack的操作
  (define extend-env-list-exp
    (lambda (vars vals env)
      (if (null? vars)
         env
         (let ((var1 (car vars))
               (val1 (expval-car vals)))
           (extend-env-list-exp (cdr vars)
                               (expval-cdr vals)
                               (extend-env var1 val1 env))))))
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;unpack-exp的具体实现:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;        (unpack-exp (vars vals body)
                   (let ((_vals (value-of vals env)))
                     (value-of body (extend-env-list-exp vars _vals env))))
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;8.2&#34;&gt; 8.2 unpack的lang.scm修改   &lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;;;new stuff
    (expression (&amp;quot;unpack&amp;quot; (arbno identifier) &amp;quot;=&amp;quot; expression &amp;quot;in&amp;quot; expression) unpack-exp)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;8.3&#34;&gt; 8.3 测试unpack修改结果  &lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;;; new testcase
(run &amp;quot;let u = 7
      in unpack x y = cons(u, cons(3,emptylist))
      in -(x,y)&amp;quot;)


(num-val 4)  ;;;(x y)= (7 3)  -(7,3)=4
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;结论&#34;&gt;结论&lt;/h2&gt;
&lt;p&gt;这是这对[First Interpreter From EOPL][1] 的8个方面的拓展，对于认识语言的设计有很大的帮助。&lt;/p&gt;
&lt;p&gt;1[]:http://jueqingsizhe66.github.io/blog/2016/02/25/first-interpreter-from-eopl/&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Some notations in the design of the language</title>
      <link>https://jueqingsizhe66.github.io/archives/some-notations-in-the-design-of-the-language/</link>
      <pubDate>Fri, 26 Feb 2016 15:35:17 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/archives/some-notations-in-the-design-of-the-language/</guid>
      <description>&lt;p&gt;What does it mean by Kleene star? What can it be used for?
It is not so important,but a good tools to record the grammer
of the language.目的就是如何更简洁地定义语法。&lt;/p&gt;
&lt;h2 id=&#34;几个基本字符&#34;&gt;几个基本字符&lt;/h2&gt;
&lt;h3 id=&#34;nonterminal-symbols&#34;&gt;Nonterminal Symbols&lt;/h3&gt;
&lt;p&gt;指代被定义的集合名字(These are the names of the sets being defined)，比如List-of-Int,List-of-Char&amp;hellip;,
这些集合有时候也被叫做语义分类(syntactic categories)&lt;/p&gt;
&lt;p&gt;而且一般是of连接词是小写，其他表征类型的是大写(capitalized)。
这是一个习惯，当然如果指引某个单一的元素的时候我们会用小写字母，
比如 Expression is a nonterminal, 可以写成&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  e &amp;lt;- Expression  or
  e is an expression
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然我们也可以写成更为简单的形式，叫做Backus-Naur Form(BNF),即用尖括号包裹小写字母表达式，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; &amp;lt;expression&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;terminal-symbols&#34;&gt;Terminal Symbols:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;left parenthesis 左括号 &lt;code&gt;(&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;right parenthesis 右括号 &lt;code&gt;)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;period 句号 点号  &lt;code&gt;.&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;productionthe-rules&#34;&gt;Production(The rules)&lt;/h3&gt;
&lt;p&gt;The rules are called productions.每一个Production包含left-handside（lhs),right-handside(rhs),并用&lt;code&gt;::=&lt;/code&gt;来连接
lhs和rhs，&lt;code&gt;::=&lt;/code&gt;也被读作&lt;em&gt;is or can be&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;lhs一般是nonterminal symbol,表征的是语义类(syntactic category)&lt;/li&gt;
&lt;li&gt;rhs一般是由terminal symbols(比如left and right parenthesis ,or period)和nonterminal symbols 组合起来。&lt;/li&gt;
&lt;li&gt;rhs的主要作用是用来按照其他语义分类(每一行都叫做一种语义分类）和Terminal symbolsl指定(specify)对应语义类
的构造成员的方法(a method of constructing the members of the syntactic category)&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Int ::= (1 2 3 ....)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Double ::= (1.11246 1.2 1.3 ...)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Char ::= (a b c ...)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Float ::= (1.1 1.2 1.3 ...)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;List-of-Int ::= ()&lt;/code&gt;
&lt;code&gt;List-of-Int ::= (Int . List-of-Int)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Lists ::= ()|(Scheme Val . List)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当然有时候我们也可以忽略第二个语义类的List-of-Int,比如&lt;/p&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;&lt;code&gt;List-of-Int ::= ()&lt;/code&gt;
&lt;code&gt;            ::= (Int . List-of-Int)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当然我们也可以只用一行来表示语义类（归一为一条语义）：使用vertical bar(| ),也被读作or&lt;/p&gt;
&lt;ol start=&#34;8&#34;&gt;
&lt;li&gt;&lt;code&gt;List-of-Int ::= ()|(Int . List-of-Int)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;另外我们也可以使用一种更为简洁的形式： 使用 Kleene Star利用大括号(flower braces), &lt;code&gt;{}*&lt;/code&gt;&lt;/p&gt;
&lt;ol start=&#34;9&#34;&gt;
&lt;li&gt;&lt;code&gt;List-of-Int ::= ({Int}*)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其中&lt;code&gt;*&lt;/code&gt;表示的是0个或者0个以上，也可以变换为&lt;code&gt;+&lt;/code&gt;。
&lt;code&gt;+&lt;/code&gt;:表示的是一个或者一个以上.&lt;/p&gt;
&lt;ol start=&#34;10&#34;&gt;
&lt;li&gt;&lt;code&gt;List-of-Int ::= ({Int}+)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当然我们也可以规定Int之间的分割标志,利用seperation list&lt;/p&gt;
&lt;ol start=&#34;11&#34;&gt;
&lt;li&gt;&lt;code&gt;List-of-Int ::= ({Int}*(,))  &lt;/code&gt;
表示的是&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;8
1,2
3,4,6
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;List-of-Int ::= (&lt;code&gt;{Int}*(;)&lt;/code&gt;)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;8
1;2
3;4;6
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;语义推导syntactic-derivation练习&#34;&gt;语义推导(Syntactic derivation)练习&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;(14 . ()) is a List-of-Int?&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;List-of-Int
=&amp;gt; (Int . (List-of-Int))
=&amp;gt; (14  . (List-of-Int))
=&amp;gt; (14  . ())

so, it is true.
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;(-7 . (3 . (14 . ()))) is a List-of-Int?&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;List-of-Int
=&amp;gt; (Int . (List-of-Int))
=&amp;gt; (-7  . (List-of-Int))
=&amp;gt; (-7  . (3 . (List-of-Int)))
=&amp;gt; (-7  . (3 . (14 . (List-of-Int))))
=&amp;gt; (-7  . (3 . (14 . ())))

so, it is true.
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;(a b c) is a S-list?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;S-list = ({S-exp}(`*`))
S-exp  = Symbol | S-list
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;S-list
=&amp;gt; ({S-exp}(*))
=&amp;gt; {Symbol | S-list}(*)
=&amp;gt; {a | S-list}(*)
=&amp;gt; {a b |S-list}(*)
=&amp;gt; {a b c}

so, it is S-list
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;(bar (biz 4 6) (foo 1 2)) is a binary tree?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;二叉树是非常重要的数据结构，它的定义形式是&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  Bintree ::= Int| (Symbol Bintree Bintree)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以我们可以这样解析&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; Bintree
=&amp;gt;(Int|(Symbol Bintree Bintree))
=&amp;gt;(bar (Int|(Symbol Bintree Bintree)) (Int|(Symbol Bintree Bintree)))
=&amp;gt;(bar (biz (Int|(Symbol Bintree Bintree)) (Int|(Symbol Bintree Bintree))) 
       (foo (Int|(Symbol Bintree Bintree)) (Int|(Symbol Bintree Bintree))))
=&amp;gt;(bar (biz 4 6) 
       (foo (Int|(Symbol Bintree Bintree)) (Int|(Symbol Bintree Bintree))))
=&amp;gt;(bar (biz 4 6) 
       (foo 1 2))

So,it is true

&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;(lambda (x) (+ x 6)) is a lambda calculus&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;lambda calculus 是程序语言设计中十分重要的小型语言。该门语言仅仅包含&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;变量引用(varient references)&lt;/li&gt;
&lt;li&gt;单参过程(procedures that takes a single argument)&lt;/li&gt;
&lt;li&gt;过程调用(procedure calls)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;定义如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   LcExp ::= Identifier
         ::= (lambda (Identifier) LcExp)
         ::= (LcExp LcExp)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以我们可以判断如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; LcExp
=&amp;gt; Identifier|(lambda (Identifier) LcExp)|(LcExp LcExp)
=&amp;gt; (lambda (Identifier) LcExp)
=&amp;gt; (lambda (x) Identifier|(lambda (Identifier) LcExp)|(LcExp LcExp))
=&amp;gt; (lambda (x) (LcExp LcExp))
=&amp;gt; (lambda (x) (+ Identifier|(lambda (Identifier) LcExp)|(LcExp LcExp)
                  Identifier|(lambda (Identifier) LcExp)|(LcExp LcExp)))
=&amp;gt; (lambda (x) (+ x
                  Identifier|(lambda (Identifier) LcExp)|(LcExp LcExp)))
=&amp;gt; (lambda (x) (+ x
                  6))

So, it is true.


&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;结论&#34;&gt;结论&lt;/h2&gt;
&lt;p&gt;上米那说的List-of-Int,Bintree，Lambda calculus等都可以叫做一种语义类，是一门语言
包含的原始类型。上面的syntatic derivation也可以被用来当作理论证明的一种入门，本质是递归理论。&lt;/p&gt;
&lt;p&gt;而其实他们都可以当作最为基本的解释器，因为他们在不断的解析他们所识别的expressions，上面的LcExp,
List-exp等都叫做expressions，也是解释器的元素。&lt;/p&gt;
&lt;p&gt;而假如我们有一个函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nth-element : List * Int -&amp;gt; SchemeVal
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;他说明的是nth-element是一个接受List和Int作为形参并返回SchemeVal的过程，也就是它属于LcExp范畴。&lt;/p&gt;
&lt;h2 id=&#34;subst采用kleene-star进行书写&#34;&gt;subst采用kleene star进行书写&lt;/h2&gt;
&lt;p&gt;subst的定义是&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;subst : Sym * Sym * S-list -&amp;gt; S-list
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面的实现过程从最为原始的只能处理lat的形式变为能够处理任意嵌套的expressions形式。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;#lang racket

;;替换在slist中old值出现的值为new值（引用值）
(define subst-original
  (lambda (new old slist)
    (if (null? slist)
	&#39;()
	(cons
	       (if (eqv? (car slist) old)
               new
               (car slist))
	 (subst new old (cdr slist))))))

;;map改进失败
(define subst-wrong
  (lambda (new old lst)
    (map (lambda (x) (if (eq? x old) new old)) lst)))
;;通过map 简化subst-original的原始写法
(define subst-map
  (lambda (new old lst)
    (map (lambda (x) (if (eq? x old) new x)) lst)))

;;;通过subst改进S-expression to list-expression
(define subst
  (lambda (new old slist)
    (if (null? slist)
	&#39;()
	(cons
	 (let ((sexp (car slist)))
	   (if (symbol? sexp)
	       (if (eqv? sexp old)
               new
               sexp)
	       (subst new old sexp)))
	 (subst new old (cdr slist))))))

;;;通过map 改进subst
(define subst-map-improve
  (lambda (new old lst)
    (map (lambda (x) (if (symbol? x) (if (eq? x old) new x) (subst-map new old x))) lst)))

(subst-original  &#39;a &#39;b &#39;(a b c (b b) d b))
;&#39;(a a c (a a) d a)
(subst-map &#39;a &#39;b &#39;(a b c (b b) d b))
;&#39;(a a c (b b) d a)
(subst-wrong &#39;a &#39;b &#39;(a b c (b b) d b))  ;;;错误在于所有的非old值都替换为old值了
;&#39;(b a b b b a)
(subst &#39;a &#39;b &#39;(a b c (b b) d b))
;;&#39;(a a c (a a) d a)
(subst-map-improve &#39;a &#39;b &#39;(a b c (b b) d b))
;&#39;(a a c (a a) d a)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个拓展的例子虽然和表达式的注释主题关系不大，但是确是对于递归递归理论的进一步阐述。递归要求满足两个条件。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;递归出口(null? slt)  (zero? (car lst)) &amp;hellip;&lt;/li&gt;
&lt;li&gt;逐渐朝向递归出口的算子 (cdr lst) (- n 1) &amp;hellip;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;define-datatype的运用&#34;&gt;define-datatype的运用&lt;/h2&gt;
&lt;p&gt;具体实现可以查看&lt;a href=&#34;http://jueqingsizhe66.github.io/blog/2016/02/19/the-implementation-of-define-datetype/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;The Implementation of Define-datatype&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;lc-exp-和s-list的具体实现&#34;&gt;Lc-Exp 和S-list的具体实现&lt;/h3&gt;
&lt;p&gt;上文所提记得Lc-Exp的定义为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    lc-exp  ::=identifier
            ::=(lambda (identifier) Lc-exp
            ::=(lc-exp lc-exp)

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;它使用define-datatype的实现如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(define-datatype lc-exp lc-exp?
    (var-exp (var identifier?))
    (lambda-exp (bound-var identifier?)
                (body lc-exp?))
    (app-exp (rator lc-exp?)
             (rand lc-exp?))
)

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而S-list的定义再现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   S-list   ::=({S-exp}*) 
   S-exp:=Symbol|S-list
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;他对应的实现如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(define-datatype s-list s-list?
    (empty-s-list)
    (non-empty-s-list
        (first s-exp?)
        (rest s-list?))
)
(define-datatype s-exp s-exp?
    (symbol-s-exp (sym symbol?))
    (s-list-s-exp (slst s-list?))
)

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;expression-和-expval的具体定义和实现&#34;&gt;expression 和 expval的具体定义和实现&lt;/h3&gt;
&lt;p&gt;在Interpreter的过程中肯定涉及到expression的设计和value值的表现（&lt;strong&gt;把exp和val的键值对叫做解释器的字典&lt;/strong&gt;）
expression的具体定义是&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;expression ::= (var-exp ())
           ::= (const-exp ())
           ::= (zero?-exp ())
           ::= (if-exp ())
           ::= (diff-exp ())
           ::= (cons-exp ())
           ::= (car-exp ())
           ::= (cdr-exp ())
           ::= (null?-exp ())
           ::= (emptylist-exp)
           ::= (list-exp ())
           ::= (let-exp ())
           ::= (proc-exp ())
           ::= (call-exp ())
           ::= (letrec-exp ())  ;;并未再此体现
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;具体实现如下所示:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;;;; datatype ;;;
(define-datatype expression expression?
  (var-exp
   (id symbol?))
  (const-exp
   (num number?))
  (zero?-exp
   (expr expression?))
  (if-exp
   (predicate-exp expression?)
   (true-exp expression?)
   (false-exp expression?))
  (diff-exp
   (exp1 expression?)
   (exp2 expression?))
  (emptylist-exp)
  (cons-exp
   (exp1 expression?)
   (exp2 expression?))
  (car-exp
   (body expression?))
  (cdr-exp
   (body expression?))
  (null?-exp
   (body expression?))
  (list-exp
   (args (list-of expression?)))
  (let-exp
   (vars (list-of symbols?))
   (vals (list-of expression?))
   (body expression?))
  (proc-exp
   (var (list-of symbol?))
   (body expression?))
  (call-exp
   (rator expression?)
   (rand (list-of expression?))))

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;expval的定义(主要是用于scheme value)如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; expval ::= (num-val ())
        ::= (bool-val ())
        ::= (proc-val ())
        ::= (pair-val ())
        ::= (emptylist-val)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;具体实现如下 所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;;;; an expressed value is either a number, a boolean or a procval.
(define-datatype expval expval?
  (num-val
   (value number?))
  (bool-val
   (boolean boolean?))
  (proc-val
   (proc proc?))
  (pair-val
   (car expval?)
   (cdr expval?))
  (emptylist-val))

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;proc的具体定义如下，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  proc ::= (procedure ())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;proc的实现如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;;; proc? : SchemeVal -&amp;gt; Bool
;; procedure : Var * Exp * Env -&amp;gt; Proc
(define-datatype proc proc?
  (procedure
   (var (list-of symbol?))
   (body expression?)
   (env environment?)))


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然具体的Define-datatype的定义还得配合&lt;a href=&#34;http://jueqingsizhe66.github.io/blog/2016/02/23/casesde-zuo-yong/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;cases的作用&lt;/a&gt;进行实现。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>First Interpreter from EOPL</title>
      <link>https://jueqingsizhe66.github.io/archives/first-interpreter-from-eopl/</link>
      <pubDate>Thu, 25 Feb 2016 11:20:09 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/archives/first-interpreter-from-eopl/</guid>
      <description>&lt;p&gt;这是EOPL一个最为基本的解释器，后面的解释器都在此基础上进行改造，所以
得理解各个部分，并知道如何使用和改造。最终告诉的是解释器如何解释表达式(每一种语言的表达式)。
&lt;strong&gt;解释器解释表达式的问题&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1&#34;&gt;1. 测试Interpreter程序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2&#34;&gt;2. 测试结果&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3&#34;&gt;3. 反思结果&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#3.1&#34;&gt;3.1 非expressions部分&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3.2&#34;&gt;3.2 expressions部分&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4&#34;&gt;4. 是解决问题，还是抽象问题？科学性何在?&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#4.1&#34;&gt;4.1 科学性问题何在？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4.2&#34;&gt;4.2 一个解释器该解决哪些问题？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4.3&#34;&gt;4.3 抽象的目的是什么&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5&#34;&gt;5.一个解释器的具体实现&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#5.1&#34;&gt;5.1 语言前端表现形式&lt;/a&gt; lang&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5.2&#34;&gt;5.2 语言数据结构&lt;/a&gt; data-structures&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5.3&#34;&gt;5.3 语言中间阶段&lt;/a&gt; environments&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5.4&#34;&gt;5.4 语言核心阶段&lt;/a&gt; interpreter&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5.5&#34;&gt;5.5 语言的初始化&lt;/a&gt; drscheme-init&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5.6&#34;&gt;5.6 语言的测试程序&lt;/a&gt; tests&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5.7&#34;&gt;5.7 语言前端封装测试&lt;/a&gt;Top&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;1&#34;&gt; 1. 测试Interpreter程序&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;
;;测试一个
(run-tests! run equal-answer? 
   &#39;(
      (positive &amp;quot;11&amp;quot; 11)
    ))

;;测试二个
(run-tests! run-fn equal-answer? 
   &#39;(
     (positive &amp;quot;11&amp;quot; 11)   
     (if-eval-test-true &amp;quot;if zero?(-(11,11)) then 3 else 4&amp;quot; 3)
    ))
   
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2&#34;&gt; 2. 测试结果&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;one test: positive&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;    test: positive
    correct

    no bugs found

&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;two tests:positive if-else&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;    test: positive
    correct

    test: if-eval-test-true
    correct

    no bugs found
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3&#34;&gt; 3. 反思结果&lt;/h2&gt;
&lt;p&gt;结果测试很理想并没有错误，并且可以在test中不断增加判断语句。
而run-test的解析分为两个部分&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;expressions 这部分的工作主要是value-of&lt;/li&gt;
&lt;li&gt;非expressions  这部分的主要工作就是sligen通过the-grammer的定义进行解析&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3.1&#34;&gt; 3.1 非expressions部分&lt;/h3&gt;
&lt;p&gt;这部分需要配合value-of的define-datatype进行对应的变化，且看the-grammer代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;
  (define the-grammar
    &#39;((program (expression) a-program)

      (expression (number) const-exp)
      (expression
        (&amp;quot;-&amp;quot; &amp;quot;(&amp;quot; expression &amp;quot;,&amp;quot; expression &amp;quot;)&amp;quot;)
        diff-exp)
      
      (expression
       (&amp;quot;zero?&amp;quot; &amp;quot;(&amp;quot; expression &amp;quot;)&amp;quot;)
       zero?-exp)

      (expression
       (&amp;quot;if&amp;quot; expression &amp;quot;then&amp;quot; expression &amp;quot;else&amp;quot; expression)
       if-exp)

      (expression (identifier) var-exp)

      (expression
       (&amp;quot;let&amp;quot; identifier &amp;quot;=&amp;quot; expression &amp;quot;in&amp;quot; expression)
       let-exp)   

      ))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到if,then,else都被当作不变的地方，而其中三个expressions被传动到value-of做进一步的解析。&lt;/p&gt;
&lt;h3 id=&#34;3.2&#34;&gt; 3. expressions部分&lt;/h3&gt;
&lt;p&gt;继续看value-of的部分，则是对if-exp,var-exp,let-exp,letrec-exp,diff-exp,zerp?-exp?等进行解析的过程。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;
(define value-of
    (lambda (exp env)
      (cases expression exp

        (const-exp (num) (num-val num))

        (var-exp (var) (apply-env env var))

        (diff-exp (exp1 exp2)
          (let ((val1 (value-of exp1 env))
                (val2 (value-of exp2 env)))
            (let ((num1 (expval-&amp;gt;num val1))
                  (num2 (expval-&amp;gt;num val2)))
              (num-val
                (- num1 num2)))))

        (zero?-exp (exp1)
          (let ((val1 (value-of exp1 env)))
            (let ((num1 (expval-&amp;gt;num val1)))
              (if (zero? num1)
                (bool-val #t)
                (bool-val #f)))))
              
        (if-exp (exp1 exp2 exp3)
          (let ((val1 (value-of exp1 env)))
            (if (expval-&amp;gt;bool val1)
              (value-of exp2 env)
              (value-of exp3 env))))

        (let-exp (var exp1 body)       
          (let ((val1 (value-of exp1 env)))
            (value-of body
              (extend-env var val1 env))))

        )))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以参考&lt;a href=&#34;http://jueqingsizhe66.github.io/blog/2016/02/19/the-implementation-of-define-datetype/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;cases的实现&lt;/a&gt;,以及&lt;a href=&#34;http://jueqingsizhe66.github.io/blog/2016/02/23/casesde-zuo-yong/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;cases的作用&lt;/a&gt;
当然&lt;a href=&#34;http://jueqingsizhe66.github.io/blog/2016/02/09/its-a-dead-program-dot-how-to-let-it-alive/#1&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;TLS&lt;/a&gt;也提供了比如*const,*application等的定义&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;;第一大部分 定义好整体框架
(define value
 (lambda (e)
  (meaning e (quote ()))))
(define meaning
 (lambda (e table)
  ((expression-to-action e) e table))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中的&lt;code&gt;(expression-to-action)&lt;/code&gt;就会产生对应的&lt;code&gt;*const*,*identifier*,*lambda* ,*cond*,*quote*,*application*&lt;/code&gt;以及&lt;a href=&#34;http://jueqingsizhe66.github.io/blog/2016/02/09/its-a-dead-program-dot-how-to-let-it-alive/#2&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;TSS&lt;/a&gt;中新增加的&lt;code&gt;*set*,*define*,*let*&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这两个部分是比较有趣的地方，规范了语言的前端部分，犹如左右手交换来交换去和penrose-stair















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://jueqingsizhe66.github.io/images/penrose-stair.png&#34; alt=&#34;penrose-stair&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;

,进一步可以看看&lt;a href=&#34;http://df.xq0510.blog.163.com/blog/static/16013465820108704920944/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;盗墓笔记(inception)的评述&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;4&#34;&gt; 4. 是解决问题，还是抽象问题？科学性何在?&lt;/h2&gt;
&lt;p&gt;科学进步的每一步发展，不是通过不断抽象来直觉抽取出进步，而是通过直觉发现问题，在利用抽象的方式进行求解，从而获得进步。
而抽象其实就是通过&lt;strong&gt;interface&lt;/strong&gt;和&lt;strong&gt;implementation&lt;/strong&gt;来进行，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;interface的定义就是通过&lt;a href=&#34;http://jueqingsizhe66.github.io/blog/2016/02/19/the-implementation-of-define-datetype/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;define-datatype&lt;/a&gt;进行，&lt;/li&gt;
&lt;li&gt;implementation则是通过cases进行。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4.1&#34;&gt;4.1 科学性问题何在？&lt;/h3&gt;
&lt;p&gt;现象和本质的探寻，透过现象看到本质，现象的产生都有其内在的原理，科学关注的是内在的本质联系。
scheme这门语言可以透过不断的抽象，产生许许多多的语言，但是这些语言层是否真的对科学问题有帮助，
这是值得怀疑的地方！科学必须要有怀疑！科学必须找寻问题所在，从而探索产生原因（持保留意见）。&lt;/p&gt;
&lt;h3 id=&#34;4.2&#34;&gt;4.2 一个解释器该解决哪些问题？&lt;/h3&gt;
&lt;p&gt;最基本的我觉得应该有两个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;词法解析问题
解决我输入的字符串，该如何由scan&amp;amp;parse进行解析&lt;/li&gt;
&lt;li&gt;语义解析问题
解决我得到的表达式(expression),它怎么由value-of进行解析，到底是const-exp,var-exp,proc-exp,let-exp等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其实语言系列的表达主要有&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;imperative language(C,fortran)&lt;/li&gt;
&lt;li&gt;functional programming language(Lisp,ML,Haskell,Scheme)&lt;/li&gt;
&lt;li&gt;message passing language(OOP: Java,C++,)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;他们在解析程序的过程中都离不开上述的两个基本问题的解析，他们也被叫做&lt;strong&gt;前端(front-end)&lt;/strong&gt;。















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://jueqingsizhe66.github.io/images/lisp/front-end.png&#34; alt=&#34;front-end&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;而任何语言如果仅仅有这个value的过程，而不会产生任何的effects，
比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;print&lt;/li&gt;
&lt;li&gt;read&lt;/li&gt;
&lt;li&gt;modify the memory state or file system&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那就太没有意思了，所以语言的完成需要他拓充到操作系统的处理、IO处理、显示处理，增加它的趣味性，而不是一味的解决问题（持保留意见）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;词法解析使我们获得从字符串到对应的语言的const-exp等的exp形式&lt;/li&gt;
&lt;li&gt;语义解析部分则是我们对const-exp等的具体实现部分&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以本质上来说这两点也是抽象的组成部分（&lt;a href=&#34;http://jueqingsizhe66.github.io/blog/2016/02/15/data-representation-the-same-interface-with-different-implementation/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;接口和实现&lt;/a&gt;）,所以本质上解决解释器的实现问题，其实就是&lt;strong&gt;如何抽象的问题?&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;4.3&#34;&gt;4.3 抽象的目的是什么？&lt;/h3&gt;
&lt;p&gt;在于解决现实出现的科学问题。
也就是这些问题都能够被设定的接口和实现通过递归进行解释，并最终获得结果(result or outcome)。&lt;/p&gt;
&lt;p&gt;而为什么要绕来绕去的谈这些问题呢？ 因为interpreter的实现过程本质也是递归的思想，在不断规约到一个结论。&lt;/p&gt;
&lt;h2 id=&#34;5&#34;&gt;5. 一个解释器的具体实现&lt;/h2&gt;
&lt;p&gt;参考EOPL第三章.&lt;/p&gt;
&lt;p&gt;一般过程是先思考新语言的表现形式lang.scm，设定几个数据类型放入data-structures.scm中,
然后我们需要给这两个阶段设定bridge，也就是环境封装.这样我们就可以写一个解释器interpreter,解释并获得最终结果。
简而言之，其实我们就是想看看计算机是如何解释我们输入的这句话，具体就是&lt;a href=&#34;https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-35.html#%25_sec_5.5&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;解释器如何解析输入的表达式&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;语言&lt;a href=&#34;#5.1&#34;&gt;前端表现形式&lt;/a&gt; lang&lt;/li&gt;
&lt;li&gt;语言&lt;a href=&#34;#5.2&#34;&gt;数据结构&lt;/a&gt; data-structures&lt;/li&gt;
&lt;li&gt;语言&lt;a href=&#34;#5.3&#34;&gt;中间阶段&lt;/a&gt; environments&lt;/li&gt;
&lt;li&gt;语言&lt;a href=&#34;#5.4&#34;&gt;核心阶段&lt;/a&gt; interpreter&lt;/li&gt;
&lt;li&gt;语言的&lt;a href=&#34;#5.5&#34;&gt;初始化&lt;/a&gt; drscheme-init&lt;/li&gt;
&lt;li&gt;语言的&lt;a href=&#34;#5.6&#34;&gt;测试程序&lt;/a&gt; tests&lt;/li&gt;
&lt;li&gt;语言&lt;a href=&#34;#5.7&#34;&gt;前端封装测试&lt;/a&gt;Top&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;5.1&#34;&gt;5.1 前端表现形式&lt;/h3&gt;
&lt;p&gt;保存为lang.scm&lt;/p&gt;
&lt;p&gt;该阶段的主要目的就是定义新生成的语言该是如何使用的？也就是语法部分。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;
(module lang

  ;; grammar for the LET language

  (lib &amp;quot;eopl.ss&amp;quot; &amp;quot;eopl&amp;quot;)                
  
  (require &amp;quot;drscheme-init.scm&amp;quot;)
  
  (provide (all-defined-out))

  ;;;;;;;;;;;;;;;; grammatical specification ;;;;;;;;;;;;;;;;
  
  (define the-lexical-spec
    &#39;((whitespace (whitespace) skip)
      (comment (&amp;quot;%&amp;quot; (arbno (not #\newline))) skip)
      (identifier
       (letter (arbno (or letter digit &amp;quot;_&amp;quot; &amp;quot;-&amp;quot; &amp;quot;?&amp;quot;)))
       symbol)
      (number (digit (arbno digit)) number)
      (number (&amp;quot;-&amp;quot; digit (arbno digit)) number)
      ))
  
  (define the-grammar
    &#39;((program (expression) a-program)

      (expression (number) const-exp)
      (expression
        (&amp;quot;-&amp;quot; &amp;quot;(&amp;quot; expression &amp;quot;,&amp;quot; expression &amp;quot;)&amp;quot;)
        diff-exp)
      
      (expression
       (&amp;quot;zero?&amp;quot; &amp;quot;(&amp;quot; expression &amp;quot;)&amp;quot;)
       zero?-exp)

      (expression
       (&amp;quot;if&amp;quot; expression &amp;quot;then&amp;quot; expression &amp;quot;else&amp;quot; expression)
       if-exp)

      (expression (identifier) var-exp)

      (expression
       (&amp;quot;let&amp;quot; identifier &amp;quot;=&amp;quot; expression &amp;quot;in&amp;quot; expression)
       let-exp)   

      ))
  
  ;;;;;;;;;;;;;;;; sllgen boilerplate ;;;;;;;;;;;;;;;;
  
  (sllgen:make-define-datatypes the-lexical-spec the-grammar)
  
  (define show-the-datatypes
    (lambda () (sllgen:list-define-datatypes the-lexical-spec the-grammar)))
  
  (define scan&amp;amp;parse
    (sllgen:make-string-parser the-lexical-spec the-grammar))
  
  (define just-scan
    (sllgen:make-string-scanner the-lexical-spec the-grammar))
  
  )
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;5.2&#34;&gt;5.2 数据结构&lt;/h3&gt;
&lt;p&gt;保存为data-structures.scm&lt;/p&gt;
&lt;p&gt;该阶段的主要目的就是定义对应的类型该具有什么样的接口，这些接口的实现部分在第四部分有具体的体现。
这部分就是程序的&lt;strong&gt;类型接口的转换部分&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;
(module data-structures (lib &amp;quot;eopl.ss&amp;quot; &amp;quot;eopl&amp;quot;)

  ;; data structures for let-lang.

  (provide (all-defined-out))               ; too many things to list

;;;;;;;;;;;;;;;; expressed values ;;;;;;;;;;;;;;;;

;;; an expressed value is either a number, a boolean or a procval.

  (define-datatype expval expval?
    (num-val
      (value number?))
    (bool-val
      (boolean boolean?)))

;;; extractors:

  ;; expval-&amp;gt;num : ExpVal -&amp;gt; Int
  ;; Page: 70
  (define expval-&amp;gt;num
    (lambda (v)
      (cases expval v
	(num-val (num) num)
	(else (expval-extractor-error &#39;num v)))))

  ;; expval-&amp;gt;bool : ExpVal -&amp;gt; Bool
  ;; Page: 70
  (define expval-&amp;gt;bool
    (lambda (v)
      (cases expval v
	(bool-val (bool) bool)
	(else (expval-extractor-error &#39;bool v)))))

  (define expval-extractor-error
    (lambda (variant value)
      (eopl:error &#39;expval-extractors &amp;quot;Looking for a ~s, found ~s&amp;quot;
	variant value)))

;;;;;;;;;;;;;;;; environment structures ;;;;;;;;;;;;;;;;

;; example of a data type built without define-datatype

  (define empty-env-record
    (lambda () 
      &#39;()))

  (define extended-env-record
    (lambda (sym val old-env)
      (cons (list sym val) old-env)))
  
  (define empty-env-record? null?)
  
  (define environment?
    (lambda (x)
      (or (empty-env-record? x)
          (and (pair? x)
               (symbol? (car (car x)))
               (expval? (cadr (car x)))
               (environment? (cdr x))))))

  (define extended-env-record-&amp;gt;sym
    (lambda (r)
      (car (car r))))

  (define extended-env-record-&amp;gt;val
    (lambda (r)
      (cadr (car r))))

  (define extended-env-record-&amp;gt;old-env
    (lambda (r)
      (cdr r)))

)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;5.3&#34;&gt;5.3 中间阶段&lt;/h3&gt;
&lt;p&gt;保存为environments.scm&lt;/p&gt;
&lt;p&gt;该阶段的主要目的是为了解释当遇到一些变量或者之后的解释器的lambda（将在下一个版本解释器体现），如何保存下来
，并供对应程序使用。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(module environments (lib &amp;quot;eopl.ss&amp;quot; &amp;quot;eopl&amp;quot;) 
  
  ;; builds environment interface, using data structures defined in
  ;; data-structures.scm. 

  (require &amp;quot;data-structures.scm&amp;quot;)

  (provide init-env empty-env extend-env apply-env)

;;;;;;;;;;;;;;;; initial environment ;;;;;;;;;;;;;;;;
  
  ;; init-env : () -&amp;gt; Env
  ;; usage: (init-env) = [i=1, v=5, x=10]
  ;; (init-env) builds an environment in which i is bound to the
  ;; expressed value 1, v is bound to the expressed value 5, and x is
  ;; bound to the expressed value 10.
  ;; Page: 69

  (define init-env 
    (lambda ()
      (extend-env 
       &#39;i (num-val 1)
       (extend-env
        &#39;v (num-val 5)
        (extend-env
         &#39;x (num-val 10)
         (empty-env))))))

;;;;;;;;;;;;;;;; environment constructors and observers ;;;;;;;;;;;;;;;;

  (define empty-env
    (lambda ()
      (empty-env-record)))
  
  (define empty-env? 
    (lambda (x)
      (empty-env-record? x)))

  (define extend-env
    (lambda (sym val old-env)
      (extended-env-record sym val old-env)))

  (define apply-env
    (lambda (env search-sym)
      (if (empty-env? env)
	(eopl:error &#39;apply-env &amp;quot;No binding for ~s&amp;quot; search-sym)
	(let ((sym (extended-env-record-&amp;gt;sym env))
	      (val (extended-env-record-&amp;gt;val env))
	      (old-env (extended-env-record-&amp;gt;old-env env)))
	  (if (eqv? search-sym sym)
	    val
	    (apply-env old-env search-sym))))))

  )
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;5.4&#34;&gt;5.4 核心阶段&lt;/h3&gt;
&lt;p&gt;保存为interp.scm&lt;/p&gt;
&lt;p&gt;该阶段的主要目的就是编写针对第3阶段生成的var-exp、const-exp等expval的解析，算是核心部分，最终的结果的产生地，
后面的几个阶段只不过是针对这部分内容做了一些前端的准备，算是死门，而这部分和前面的词法解析、类型转换接口算是一个语言的生门部分。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;
(module interp (lib &amp;quot;eopl.ss&amp;quot; &amp;quot;eopl&amp;quot;)
  
  ;; interpreter for the LET language.  The \commentboxes are the
  ;; latex code for inserting the rules into the code in the book.
  ;; These are too complicated to put here, see the text, sorry.

  (require &amp;quot;drscheme-init.scm&amp;quot;)

  (require &amp;quot;lang.scm&amp;quot;)
  (require &amp;quot;data-structures.scm&amp;quot;)
  (require &amp;quot;environments.scm&amp;quot;)

  (provide value-of-program value-of)

;;;;;;;;;;;;;;;; the interpreter ;;;;;;;;;;;;;;;;

  ;; value-of-program : Program -&amp;gt; ExpVal
  ;; Page: 71
  (define value-of-program 
    (lambda (pgm)
      (cases program pgm
        (a-program (exp1)
          (value-of exp1 (init-env))))))

  ;; value-of : Exp * Env -&amp;gt; ExpVal
  ;; Page: 71
  (define value-of
    (lambda (exp env)
      (cases expression exp

        (const-exp (num) (num-val num))

        (var-exp (var) (apply-env env var))

        (diff-exp (exp1 exp2)
          (let ((val1 (value-of exp1 env))
                (val2 (value-of exp2 env)))
            (let ((num1 (expval-&amp;gt;num val1))
                  (num2 (expval-&amp;gt;num val2)))
              (num-val
                (- num1 num2)))))

        (zero?-exp (exp1)
          (let ((val1 (value-of exp1 env)))
            (let ((num1 (expval-&amp;gt;num val1)))
              (if (zero? num1)
                (bool-val #t)
                (bool-val #f)))))
              
        (if-exp (exp1 exp2 exp3)
          (let ((val1 (value-of exp1 env)))
            (if (expval-&amp;gt;bool val1)
              (value-of exp2 env)
              (value-of exp3 env))))

        (let-exp (var exp1 body)       
          (let ((val1 (value-of exp1 env)))
            (value-of body
              (extend-env var val1 env))))

        )))


  )

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;5.5&#34;&gt;5.5 初始化&lt;/h3&gt;
&lt;p&gt;保存为drscheme-init.scm&lt;/p&gt;
&lt;p&gt;该阶段主要目的是编写测试需要的套件，提供测试是否成功的判断标准。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;
;; drscheme-init.scm - compatibility file for DrScheme
;; usage: (require &amp;quot;drscheme-init.scm&amp;quot;)

;;; makes structs printable, and provides basic functionality for
;;; testing.  This includes pretty-printing and tracing.


(module drscheme-init mzscheme

  ;; show the contents of define-datatype values
  (print-struct #t)

  (require (lib &amp;quot;pretty.ss&amp;quot;))
  (provide (all-from (lib &amp;quot;pretty.ss&amp;quot;)))

  (require (lib &amp;quot;trace.ss&amp;quot;))
  (provide (all-from (lib &amp;quot;trace.ss&amp;quot;)))

  (provide make-parameter)

  (provide 
   run-experiment
   run-tests!
   stop-after-first-error
   run-quietly
   )
  
  ;; safely apply procedure fn to a list of args.
  ;; if successful, return (cons #t val)
  ;; if eopl:error is invoked, returns (cons #f string), where string is the
  ;; format string generated by eopl:error.  If somebody manages to raise a 
  ;; value other than an exception, then the raised value is reported.
  
  (define apply-safely
    (lambda (proc args)
      (with-handlers ([(lambda (exn) #t)      ; catch any error
                       (lambda (exn)          ; evaluate to a failed test result
                         (cons #f 
                               (if (exn? exn)
                                   (exn-message exn)
                                   exn)))])  
        (let ([actual (apply proc args)])
          (cons #t actual)))))

  ;; run-experiment :
  ;;  ((a ...) -&amp;gt; b) * (a ...) * b * (b * b -&amp;gt; bool)
  ;;  -&amp;gt; (cons bool b)
  
  ;; usage: (run-experiment fn args correct-answer equal-answer?)
  ;; Applies fn to args.  Compares the result to correct-answer. 
  ;; Returns (cons bool b) where bool indicates whether the
  ;; answer is correct.

  (define run-experiment
    (lambda (fn args correct-answer equal-answer?)
      (let*
          ((result (apply-safely fn args))
           ;; ans is either the answer or the args to eopl:error
           (error-thrown? (not (car result)))
           (ans (cdr result)))
          
        (cons
         (if (eqv? correct-answer &#39;error)
             error-thrown?
             (equal-answer? ans correct-answer))
         ans))))
  
  (define stop-after-first-error (make-parameter #f))
  (define run-quietly (make-parameter #t))
   
  ;; run-tests! : (arg -&amp;gt; outcome) * (any * any -&amp;gt; bool) * (list-of test)
  ;;             -&amp;gt; unspecified

  ;; where:
  ;; test ::= (name arg outcome)
  ;; outcome ::= ERROR | any
  
  ;; usage: (run-tests! run-fn equal-answer? tests)

  ;; for each item in tests, apply run-fn to the arg.  Check to see if
  ;; the outcome is right, comparing values using equal-answer?.

  ;; print a log of the tests.

  ;; at the end, print either &amp;quot;no bugs found&amp;quot; or the list of tests
  ;; failed. 
  
  ;; Normally, run-tests! will recover from any error and continue to
  ;; the end of the test suite.  This behavior can be altered by
  ;; setting (stop-after-first-error #t).

  (define (run-tests! run-fn equal-answer? tests)
    (let ((tests-failed &#39;()))
      (for-each
       (lambda (test-item)
         (let ((name (car test-item))
               (pgm (cadr test-item))
               (correct-answer (caddr test-item)))
           (printf &amp;quot;test: ~a~%&amp;quot; name)
           (let* ((result
                   (run-experiment
		     run-fn (list pgm) correct-answer equal-answer?))
                  (correct? (car result))
                  (actual-answer (cdr result)))
             (if (or
                   (not correct?)
                   (not (run-quietly)))
               (begin
                 (printf &amp;quot;~a~%&amp;quot; pgm)
                 (printf &amp;quot;correct outcome: ~a~%&amp;quot; correct-answer)
                 (printf &amp;quot;actual outcome:  &amp;quot;)
                 (pretty-display actual-answer)))
             (if correct?
                 (printf &amp;quot;correct~%~%&amp;quot;)
                 (begin
                   (printf &amp;quot;incorrect~%~%&amp;quot;)
                   ;; stop on first error if stop-after-first? is set:
                   (if (stop-after-first-error)
                       (error name &amp;quot;incorrect outcome detected&amp;quot;)) 
                   (set! tests-failed
                         (cons name tests-failed)))))))
       tests)
      (if (null? tests-failed)
          (printf &amp;quot;no bugs found~%&amp;quot;)
          (printf &amp;quot;incorrect answers on tests: ~a~%&amp;quot;
            (reverse tests-failed)))))

  )  
  
  
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;5.6&#34;&gt;5.6 测试程序&lt;/h3&gt;
&lt;p&gt;保存为tests.scm&lt;/p&gt;
&lt;p&gt;该阶段的主要目的就是编写测试语句，包括常量、变量、表达式、if、diff、let等语句的使用。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(module tests mzscheme
  
  (provide test-list)

  ;;;;;;;;;;;;;;;; tests ;;;;;;;;;;;;;;;;
  
  (define test-list
    &#39;(
  
      ;; simple arithmetic
      (positive-const &amp;quot;11&amp;quot; 11)
      (negative-const &amp;quot;-33&amp;quot; -33)
      (simple-arith-1 &amp;quot;-(44,33)&amp;quot; 11)
  
      ;; nested arithmetic
      (nested-arith-left &amp;quot;-(-(44,33),22)&amp;quot; -11)
      (nested-arith-right &amp;quot;-(55, -(22,11))&amp;quot; 44)
  
      ;; simple variables
      (test-var-1 &amp;quot;x&amp;quot; 10)
      (test-var-2 &amp;quot;-(x,1)&amp;quot; 9)
      (test-var-3 &amp;quot;-(1,x)&amp;quot; -9)
      
      ;; simple unbound variables
      (test-unbound-var-1 &amp;quot;foo&amp;quot; error)
      (test-unbound-var-2 &amp;quot;-(x,foo)&amp;quot; error)
  
      ;; simple conditionals
      (if-true &amp;quot;if zero?(0) then 3 else 4&amp;quot; 3)
      (if-false &amp;quot;if zero?(1) then 3 else 4&amp;quot; 4)
      
      ;; test dynamic typechecking
      (no-bool-to-diff-1 &amp;quot;-(zero?(0),1)&amp;quot; error)
      (no-bool-to-diff-2 &amp;quot;-(1,zero?(0))&amp;quot; error)
      (no-int-to-if &amp;quot;if 1 then 2 else 3&amp;quot; error)

      ;; make sure that the test and both arms get evaluated
      ;; properly. 
      (if-eval-test-true &amp;quot;if zero?(-(11,11)) then 3 else 4&amp;quot; 3)
      (if-eval-test-false &amp;quot;if zero?(-(11, 12)) then 3 else 4&amp;quot; 4)
      
      ;; and make sure the other arm doesn&#39;t get evaluated.
      (if-eval-test-true-2 &amp;quot;if zero?(-(11, 11)) then 3 else foo&amp;quot; 3)
      (if-eval-test-false-2 &amp;quot;if zero?(-(11,12)) then foo else 4&amp;quot; 4)

      ;; simple let
      (simple-let-1 &amp;quot;let x = 3 in x&amp;quot; 3)

      ;; make sure the body and rhs get evaluated
      (eval-let-body &amp;quot;let x = 3 in -(x,1)&amp;quot; 2)
      (eval-let-rhs &amp;quot;let x = -(4,1) in -(x,1)&amp;quot; 2)

      ;; check nested let and shadowing
      (simple-nested-let &amp;quot;let x = 3 in let y = 4 in -(x,y)&amp;quot; -1)
      (check-shadowing-in-body &amp;quot;let x = 3 in let x = 4 in x&amp;quot; 4)
      (check-shadowing-in-rhs &amp;quot;let x = 3 in let x = -(x,1) in x&amp;quot; 2)

      ))
  )
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;5.7&#34;&gt;5.7 前端封装测试&lt;/h3&gt;
&lt;p&gt;保存为top.scm&lt;/p&gt;
&lt;p&gt;该阶段的目的就是测试这个新的解释器语言到底有没有用？他是否能够解释从tests中导入的
程序片段？是否测试通过。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(module top (lib &amp;quot;eopl.ss&amp;quot; &amp;quot;eopl&amp;quot;)
  
  ;; top level module.  Loads all required pieces.
  ;; Run the test suite with (run-all).

  (require &amp;quot;drscheme-init.scm&amp;quot;)
  (require &amp;quot;data-structures.scm&amp;quot;)  ; for expval constructors
  (require &amp;quot;lang.scm&amp;quot;)             ; for scan&amp;amp;parse
  (require &amp;quot;interp.scm&amp;quot;)           ; for value-of-program
  (require &amp;quot;tests.scm&amp;quot;)            ; for test-list
  
  ;; since this is the top-level module, we don&#39;t really need to
  ;; provide anything, but we do so just in case.  

  (provide run run-all)

  (provide test-all)

  (define (test-all) (run-all))

  ;; here are some other things that could be provided:

  ;;   (provide (all-defined-out))
  ;;   (provide (all-from &amp;quot;interp.scm&amp;quot;))
  ;;   (provide (all-from &amp;quot;lang.scm&amp;quot;))
  
  ;;;;;;;;;;;;;;;; interface to test harness ;;;;;;;;;;;;;;;;
  
  ;; run : String -&amp;gt; ExpVal
  ;; Page: 71
  (define run
    (lambda (string)
      (value-of-program (scan&amp;amp;parse string))))
  
  ;; run-all : () -&amp;gt; unspecified
  
  ;; runs all the tests in test-list, comparing the results with
  ;; equal-answer?  

  (define run-all
    (lambda ()
      (run-tests! run equal-answer? test-list)))
  
  (define equal-answer?
    (lambda (ans correct-ans)
      (equal? ans (sloppy-&amp;gt;expval correct-ans))))
  
  (define sloppy-&amp;gt;expval 
    (lambda (sloppy-val)
      (cond
        ((number? sloppy-val) (num-val sloppy-val))
        ((boolean? sloppy-val) (bool-val sloppy-val))
        (else
         (eopl:error &#39;sloppy-&amp;gt;expval 
                     &amp;quot;Can&#39;t convert sloppy value to expval: ~s&amp;quot;
                     sloppy-val)))))
    
  ;; run-one : symbol -&amp;gt; expval

  ;; (run-one sym) runs the test whose name is sym
  
  (define run-one
    (lambda (test-name)
      (let ((the-test (assoc test-name test-list)))
        (cond
          ((assoc test-name test-list)
           =&amp;gt; (lambda (test)
                (run (cadr test))))
          (else (eopl:error &#39;run-one &amp;quot;no such test: ~s&amp;quot; test-name))))))
 
  ;; (run-all)
  
  )


&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;</description>
    </item>
    
    <item>
      <title>Chicago really only has 7 characters?</title>
      <link>https://jueqingsizhe66.github.io/archives/chicago-really-only-has-7-characters/</link>
      <pubDate>Wed, 24 Feb 2016 17:19:30 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/archives/chicago-really-only-has-7-characters/</guid>
      <description>&lt;p&gt;我在听&lt;a href=&#34;http://v.youku.com/v_show/id_XMTQ3NDEwODUyNA==.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SICP的优酷视频&lt;/a&gt;时，听到“芝加哥也可以说是具有7个字符，同时他也可以表述为美国的中西部伊利诺伊州的全美第三大国际大都市”.
它可以仅仅表示语言的表面意思，也可以表示语言中的隐含意思。这体现了语言实现的一种魅力，Chicago really only has 7 characters?&lt;/p&gt;
&lt;h2 id=&#34;value&#34;&gt;Value&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Value，价值。&lt;/li&gt;
&lt;li&gt;scheme的每一个程序都是由exressions构成，每一个expression都对应一个expression value，简称expval。&lt;/li&gt;
&lt;li&gt;expval对应的有exp-val和den-val。&lt;/li&gt;
&lt;li&gt;exp-val表示表达式的值，也就是可能是变量绑定也可能是列表(表达式)的值；而den-val单单只是变量绑定。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了分析每一个价值的过程，姑且把程序写为&amp;laquo;expressions&amp;raquo;&lt;/p&gt;
&lt;p&gt;如果&lt;code&gt;expressions=((lambda (x) (+ x 3)) 10)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;那么scheme如何解析？&lt;/p&gt;
&lt;p&gt;假定我们的解析程序叫做value-of,init-env是我们的初始环境(变量绑定或者字典),[10]表示scheme-val(每一种语言都有着自己的value),
[x=10]init-env表示拓展的环境&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(value-of &amp;lt;&amp;lt;expressions&amp;gt;&amp;gt;)
         =(value-of &amp;lt;&amp;lt;((lambda (x) (+ x 3)) 10)&amp;gt;&amp;gt;)
         =(value-of ((lambda (x) (+ x 3)) 10) init-env)
         =(apply-procedure (value-of &amp;lt;&amp;lt;(lambda (x) (+ x 3))&amp;gt;&amp;gt; init-env) 
                           (value-of 10 init-env))
         =(apply-procedure (procedure x &amp;lt;&amp;lt;(+ x 3))&amp;gt;&amp;gt; init-env) 
                           [10])
         =(value-of &amp;lt;&amp;lt;(+ x 3))&amp;gt;&amp;gt; [x=10]init-env) 
         =(apply-procedure (value-of + [x=10]init-env)
                           (value-of x [x=10]init-env)
                           (value-of 3 [x=10]init-env)
                )
         = (apply-procedure (procedure + [x=10]init-env)
                           [10]
                           [3] 
                )
         =(+ (val-num [10])  (val-num [3]))
         =(+ 10 3)

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;刚开始&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;也许你不可能替代&amp;laquo;&amp;raquo;表达式的意思，&lt;/li&gt;
&lt;li&gt;你也可能不理解解析10的过程，&lt;/li&gt;
&lt;li&gt;你也分不清出解析lambda和+的不同（一种是自定义程序，一种是内置operator），&lt;/li&gt;
&lt;li&gt;甚至你不可以静下心来好好分析我正在说的话。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我想表达的是，程序给你的是program or data，而你作为语言的创造者或者使用者，你需要进一步体味program是什么？
&lt;strong&gt;Does program really has only 7 characters?&lt;/strong&gt;(思考你写过的程序的各个部分的用途，如何来的？)&lt;/p&gt;
&lt;p&gt;进一步的解析可以&lt;a href=&#34;http://jueqingsizhe66.github.io/blog/2016/02/09/its-a-dead-program-dot-how-to-let-it-alive/#4&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;参考&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;源语言到目标语言的转变&#34;&gt;源语言到目标语言的转变&lt;/h2&gt;
&lt;p&gt;有一种程序员喜欢利用各种语言所具有的特色，组合使用语言形成自己的程序，内部是控制流动和数据流动。而从第一种语言
也就是源语言(source language)开始，利用变换，输入到第二种、第三种…… ，最终输入到目标语言(target language).程序并不是
我们想的单一性的语言调用，每一个问题都可以通过新构造一种新的语言进行求解(持保留意见)。现在已经有人能够作出输入一种输入和输出
结果，从而产生你要的scheme程序，也就是产生对应的语言解决这个问题。然而我们更需要思考的是变的表面含义。&amp;ldquo;变&amp;quot;的是什么？
可深入了解Dan. Friedman的&lt;a href=&#34;http://www.eopl3.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;EOPL&lt;/a&gt;程序设计书籍。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>cases的作用</title>
      <link>https://jueqingsizhe66.github.io/archives/casesde-zuo-yong/</link>
      <pubDate>Tue, 23 Feb 2016 12:10:12 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/archives/casesde-zuo-yong/</guid>
      <description>&lt;p&gt;为什么要实现&lt;a href=&#34;http://jueqingsizhe66.github.io/blog/2016/02/19/the-implementation-of-define-datetype/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;cases&lt;/a&gt;,目的在于进一步抽象简化过程。&lt;/p&gt;
&lt;h2 id=&#34;原先的程序&#34;&gt;原先的程序&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;      procedure :   Var * Exp * Env -&amp;gt;  Proc
apply-procedure :   Proc * ExpVal   -&amp;gt;  ExpVal
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt; ;; procedure : Var * Exp * Env -&amp;gt; Proc
 ;; Page: 79
  (define procedure
    (lambda (var body env)
      (lambda (val)
        (value-of body (extend-env var val env)))))
  
  ;; apply-procedure : Proc * ExpVal -&amp;gt; ExpVal
  ;; Page: 79
  (define apply-procedure
    (lambda (proc val)
      (proc val)))
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;简化的程序&#34;&gt;简化的程序&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;apply-procedure : Proc * ExpVal -&amp;gt; ExpVal
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;  ;; apply-procedure : Proc * ExpVal -&amp;gt; ExpVal
  ;; Page: 79
  (define apply-procedure
    (lambda (proc1 val)
      (cases proc proc1
        (procedure (var body saved-env)
          (value-of body (extend-env var val saved-env))))))

&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;通过cases的proc1找到输入的expressions（scheme的expressions即是数据）,转移val分配到extend-env中，&lt;/li&gt;
&lt;li&gt;通过变量名和变量列表&lt;code&gt;(var body...)&lt;/code&gt;引入var，&lt;/li&gt;
&lt;li&gt;并形成&lt;code&gt;(var val)&lt;/code&gt;词汇表打入saved-env，&lt;/li&gt;
&lt;li&gt;最后利用value-of解析body，也就是解析由&lt;code&gt;(var body saved-env)&lt;/code&gt;构成的closure，递归解析所有的body,
如果proc1满足&lt;code&gt;(procedure (var body saved-env))&lt;/code&gt;的形式，则通过value-of进行解析.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;saved-env是假定的保存的环境变量，而对应的apply-procedure的最终结果是&lt;code&gt;(proc1 val)&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;value-of实现&#34;&gt;value-of实现&lt;/h2&gt;
&lt;p&gt;它是在语言设计阶段比较重要的实现，在其中可以存在很多的变种。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;  ;; value-of : Exp * Env -&amp;gt; ExpVal
  (define value-of
    (lambda (exp env)
      (cases expression exp

        ;\commentbox{ (value-of (const-exp \n{}) \r) = \n{}}
        (const-exp (num) (num-val num))

        ;\commentbox{ (value-of (var-exp \x{}) \r) = (apply-env \r \x{})}
        (var-exp (var) (apply-env env var))

        ;\commentbox{\diffspec}
        (diff-exp (exp1 exp2)
          (let ((val1 (value-of exp1 env))
                (val2 (value-of exp2 env)))
            (let ((num1 (expval-&amp;gt;num val1))
                  (num2 (expval-&amp;gt;num val2)))
              (num-val
                (- num1 num2)))))

        ;\commentbox{\zerotestspec}
        (zero?-exp (exp1)
          (let ((val1 (value-of exp1 env)))
            (let ((num1 (expval-&amp;gt;num val1)))
              (if (zero? num1)
                (bool-val #t)
                (bool-val #f)))))
              
        ;\commentbox{\ma{\theifspec}}
        (if-exp (exp1 exp2 exp3)
          (let ((val1 (value-of exp1 env)))
            (if (expval-&amp;gt;bool val1)
              (value-of exp2 env)
              (value-of exp3 env))))

        ;\commentbox{\ma{\theletspecsplit}}
        (let-exp (var exp1 body)       
          (let ((val1 (value-of exp1 env)))
            (value-of body
              (extend-env var val1 env))))
        
        (proc-exp (var body)
          (proc-val (procedure var body env)))

        (call-exp (rator rand)
          (let ((proc (expval-&amp;gt;proc (value-of rator env)))
                (arg (value-of rand env)))
            (apply-procedure proc arg)))

        )))
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;在value-of中，如果exp满足&lt;code&gt;if-exp (exp1 exp2 exp3)&lt;/code&gt;则解析乘对应的，&lt;/li&gt;
&lt;li&gt;依次类推,当看到&lt;code&gt;let-exp (va exp1 body)&lt;/code&gt;的形式则对应的进行演变.&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>通过Scheme读取文件</title>
      <link>https://jueqingsizhe66.github.io/archives/tong-guo-schemedu-qu-wen-jian/</link>
      <pubDate>Mon, 22 Feb 2016 22:54:21 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/archives/tong-guo-schemedu-qu-wen-jian/</guid>
      <description>&lt;ol&gt;
&lt;li&gt;通过IO monad的open-input-file 读取文件&lt;/li&gt;
&lt;li&gt;通过read-line 读取接口文件&lt;/li&gt;
&lt;li&gt;通过name-loop命名loop来循环读取文件。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;通过文件句柄读取文件，这边接口就是文件句柄&lt;/li&gt;
&lt;li&gt;现在还不清楚文件模式的几种类型
&lt;ul&gt;
&lt;li&gt;text&lt;/li&gt;
&lt;li&gt;append&lt;/li&gt;
&lt;li&gt;write（是否有）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;eof-object?判断是否文件末尾&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define read-file
  (lambda (filename)
    (let ([port (open-input-file filename #:mode &#39;text)])
      (let loop ([line (read-line port)]
                 [all &amp;quot;&amp;quot;])
        (cond
         [(eof-object? line) all]
         [else
          (loop (read-line port)
                (string-append all line &amp;quot;\n&amp;quot;))])))))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从这边提取出一个最常用的let loop循环可以用于很多地方，重复几条语句分析所有程序&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;
    (let loop ([start 0] [toks &#39;()])
      (letv ([(tok newstart) (scan1 s start)])
        (cond
         [(eq? tok &#39;eof)
          (reverse toks)]
         [else
          (loop newstart (cons tok toks))])))))

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另外，比如onstack? 用于判断是否存于栈&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;

(define onstack?
  (lambda (u v stk)
    (let loop ([stk stk] [trace &#39;()])
      (cond
       [(null? stk) #f]
       [(and (eq? u (car (car stk)))
             (eq? v (cdr (car stk))))
        (reverse (cons (car stk) trace))]
       [else
        (loop (cdr stk) (cons (car stk) trace))]))))

&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>The implementation of define-datatype</title>
      <link>https://jueqingsizhe66.github.io/archives/the-implementation-of-define-datetype/</link>
      <pubDate>Fri, 19 Feb 2016 11:40:28 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/archives/the-implementation-of-define-datetype/</guid>
      <description>&lt;p&gt;设计一个语言很重要的一点就是有一个工具来创建接口，define-datatype和cases就是这种工具&lt;/p&gt;
&lt;h2 id=&#34;define-datatype&#34;&gt;define-datatype&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;;; NOTE: datatypes are currently transparent, for the sake of EoPL&#39;s
;; use of `equal?&#39;

#lang racket/base

(require (for-syntax racket/base &amp;quot;private/utils.rkt&amp;quot;))

(define-syntax (define-datatype stx)
  (syntax-case stx ()
    [(_ name pred-name
        (variant-name (field-name field-pred) ...)
        ...)
     (let ([variant-names (syntax-&amp;gt;list #&#39;(variant-name ...))])
       ;; More syntax checks...
       (unless (identifier? #&#39;name)
         (raise-syntax-error
          #f &amp;quot;expected an identifier for the datatype name&amp;quot; stx #&#39;name))
       (unless (identifier? #&#39;pred-name)
         (raise-syntax-error
          #f &amp;quot;expected an identifier for the predicate name&amp;quot; stx #&#39;pred-name))
       (for ([vt     (in-list variant-names)]
             [fields (in-list (syntax-&amp;gt;list #&#39;((field-name ...) ...)))])
         (unless (identifier? vt)
           (raise-syntax-error
            &#39;cases &amp;quot;expected an identifier for the variant name&amp;quot; stx vt))
         (for ([field (in-list (syntax-&amp;gt;list fields))])
           (unless (identifier? field)
             (raise-syntax-error
              &#39;cases &amp;quot;expected an identifier for the field name&amp;quot; stx field))))
       ;; Count the fields for each variant:
       (with-syntax ([(variant-field-count ...)
                      (for/list ([x (in-list (syntax-&amp;gt;list
                                              #&#39;((field-name ...) ...)))])
                        (datum-&amp;gt;syntax (quote-syntax here)
                                       (length (syntax-&amp;gt;list x))
                                       #f))]
                     [(variant? ...)
                      (for/list ([vn (in-list variant-names)])
                        (datum-&amp;gt;syntax
                         vn
                         (string-&amp;gt;uninterned-symbol
                          (format &amp;quot;~a?&amp;quot; (syntax-e vn)))))]
                     [(variant-accessor ...)
                      (for/list ([vn (in-list variant-names)])
                        (datum-&amp;gt;syntax
                         vn
                         (string-&amp;gt;uninterned-symbol
                          (format &amp;quot;~a-accessor&amp;quot; (syntax-e vn)))))]
                     [(variant-mutator ...)
                      (generate-temporaries variant-names)]
                     [(make-variant ...)
                      (generate-temporaries variant-names)]
                     [(struct:variant ...)
                      (generate-temporaries variant-names)]
                     [(make-variant-name ...)
                      (for/list ([vn (in-list variant-names)])
                        (datum-&amp;gt;syntax
                         vn
                         (string-&amp;gt;symbol
                          (format &amp;quot;make-~a&amp;quot; (syntax-e vn)))))])
         #&#39;(begin
             (define-syntax name
               ;; Note: we&#39;re back to the transformer environment, here.
               ;; Also, this isn&#39;t a transformer function, so any direct
               ;;  use of the name will trigger a syntax error. The name
               ;;  can be found by `syntax-local-value&#39;, though.
               (let ([cert (syntax-local-certifier #t)])
                 (make-dt (cert #&#39;pred-name)
                          (list (make-vt (cert #&#39;variant-name)
                                         (cert #&#39;variant?)
                                         (cert #&#39;variant-accessor)
                                         variant-field-count)
                                ...))))
             ;; Bind the predicate and selector functions:
             (define-values (pred-name
                             variant-name ...
                             variant? ...
                             variant-accessor ...)
               ;; Create a new structure for the datatype (using the
               ;; datatype name in `struct&#39;, so it prints nicely).
               (let-values ([(struct:x make-x x? acc mut)
                             (make-struct-type &#39;name #f 0 0 #f null (make-inspector))])
                 (let-values ([(struct:variant make-variant variant?
                                variant-accessor variant-mutator)
                               (make-struct-type &#39;variant-name struct:x variant-field-count 0
                                                 #f
                                                 null
                                                 (make-inspector))]
                              ...)
                   ;; User-available functions:
                   (values
                    x? ;; The datatype predicate
                    ;; Create the constructor functions:
                    (let* ([vname &#39;variant-name]
                           [variant-name
                            (lambda (field-name ...)
                              (unless (field-pred field-name)
                                (error vname &amp;quot;bad value for ~a field: ~e&amp;quot;
                                       &#39;field-name field-name))
                              ...
                              (make-variant field-name ...))])
                      variant-name)
                    ...
                    variant? ...
                    variant-accessor ...))))
             ;; Compatibility bindings
             (define-values (make-variant-name ...) (values variant-name ...)))))]
    [(_ name pred-name variant ...)
     ;; Must be a bad variant...
     (for ([variant (in-list (syntax-&amp;gt;list #&#39;(variant ...)))])
       (syntax-case variant ()
         [(variant-name field ...)
          (let ([name #&#39;variant-name])
            (unless (identifier? name)
              (raise-syntax-error
               #f &amp;quot;expected an identifier for the variant name&amp;quot; stx name))
            ;; Must be a bad field:
            (for ([field (in-list (syntax-&amp;gt;list #&#39;(field ...)))])
              (syntax-case field ()
                [(field-name field-pred)
                 (let ([name #&#39;field-name])
                   (unless (identifier? name)
                     (raise-syntax-error
                      #f &amp;quot;expected an identifier for the field name&amp;quot; stx name)))]
                [_else
                 (raise-syntax-error
                  #f &amp;quot;expected a field name followed by a predicate expression, all in parentheses&amp;quot; stx field)])))]
         [_else
          (raise-syntax-error
           #f &amp;quot;expected a variant name followed by a sequence of field declarations, all in parentheses&amp;quot; stx variant)]))]
    [(_ name)
     (raise-syntax-error
      #f &amp;quot;missing predicate name and variant clauses&amp;quot; stx)]))
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;cases&#34;&gt;cases&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;
(define-syntax (cases stx)
  (syntax-case stx ()
    [(_ datatype expr
        clause
        ...)
     ;; Get datatype information:
     (let ([dt (and (identifier? #&#39;datatype)
                    (syntax-local-value #&#39;datatype (lambda () #f)))])
       (unless (dt? dt)
         (raise-syntax-error &#39;cases &amp;quot;not a datatype name&amp;quot; stx #&#39;datatype))

       ;; Parse clauses:
       (define-values (vts field-idss bodys else-body)
         (let loop ([clauses (syntax-&amp;gt;list #&#39;(clause ...))]
                    [saw-cases null])
           (if (null? clauses)
             (values null null null #f)
             (let ([clause (car clauses)])
               (syntax-case* clause ()
                             (lambda (a b)
                               (and (eq? (syntax-e b) &#39;else)
                                    (not (identifier-binding b))))
                 [(variant (field-id ...) body0 body1 ...)
                  (let* ([variant #&#39;variant]
                         [vt (ormap (lambda (dtv)
                                      (define vt-name (vt-name-stx dtv))
                                      (and (free-identifier=? variant vt-name)
                                           dtv))
                                    (dt-variants dt))]
                         [orig-variant (and vt (vt-name-stx vt))])
                    (unless orig-variant
                      (raise-syntax-error
                       #f
                       (format &amp;quot;not a variant of `~a&#39;&amp;quot;
                               (syntax-&amp;gt;datum #&#39;datatype))
                       stx
                       variant))

                    (let ([field-ids (syntax-&amp;gt;list #&#39;(field-id ...))])
                      (for ([fid (in-list field-ids)])
                        (unless (identifier? fid)
                          (raise-syntax-error
                           #f &amp;quot;expected an identifier for a field&amp;quot; stx fid)))
                      (let ([dtv (variant-assq variant (dt-variants dt))])
                        (unless (= (length field-ids) (vt-field-count dtv))
                          (raise-syntax-error
                           #f
                           (format
                            &amp;quot;variant case `~a&#39; for `~a&#39; has wrong field count (expected ~a, found ~a)&amp;quot;
                            (syntax-&amp;gt;datum variant)
                            (syntax-&amp;gt;datum #&#39;datatype)
                            (vt-field-count dtv)
                            (length field-ids))
                           stx
                           clause)))

                      ;; Check for duplicate local field ids:
                      (let ([dup (check-duplicate-identifier field-ids)])
                        (when dup
                          (raise-syntax-error
                           #f &amp;quot;duplicate field identifier&amp;quot; stx dup)))

                      ;; Check for redundant case:
                      (when (memq orig-variant saw-cases)
                        (raise-syntax-error #f &amp;quot;duplicate case&amp;quot; stx clause))

                      ;; This clause is ok:
                      (let-values ([(vts idss bodys else)
                                    (loop (cdr clauses) (cons orig-variant saw-cases))])
                        (values (cons vt vts)
                                (cons field-ids idss)
                                (cons #&#39;(begin body0 body1 ...) bodys)
                                else))))]
                 [(else body0 body1 ...)
                  (begin
                    (unless (null? (cdr clauses))
                      (raise-syntax-error
                       #f &amp;quot;else clause must be last&amp;quot; stx clause))
                    (values null null null #&#39;(begin body0 body1 ...)))]
                 [_else (raise-syntax-error #f &amp;quot;bad clause&amp;quot; stx clause)])))))
       ;; Missing any variants?
       (unless (or else-body (= (length vts) (length (dt-variants dt))))
         (define here (map vt-name-stx vts))
         (define missing
           (let loop ([l (dt-variants dt)])
             (cond [(null? l) &amp;quot;&amp;quot;]
                   [(ormap (lambda (i) (free-identifier=? (vt-name-stx (car l)) i)) here)
                    (loop (cdr l))]
                   [else (format &amp;quot; ~a~a&amp;quot;
                                 (syntax-e (vt-name-stx (car l)))
                                 (loop (cdr l)))])))
         (raise-syntax-error
          #f
          (format &amp;quot;missing cases for the following variants:~a&amp;quot; missing)
          stx))

       ;; Create the result:
       (with-syntax ([pred (dt-pred-stx dt)]
                     [(variant? ...) (map vt-predicate-stx vts)]
                     [((field-extraction ...) ...)
                      (for/list ([vt (in-list vts)])
                        (with-syntax ([accessor (vt-accessor-stx vt)])
                          (let loop ([n 0])
                            (if (= n (vt-field-count vt))
                              null
                              (cons #`(accessor v #,n)
                                    (loop (add1 n)))))))]
                     [((field-id ...) ...) field-idss]
                     [(body ...) bodys]
                     [else-body (or else-body
                                    #&#39;(error &#39;cases &amp;quot;no variant case matched&amp;quot;))])
         #&#39;(let ([v expr])
             (if (not (pred v))
               (error &#39;cases &amp;quot;not a ~a: ~s&amp;quot; (quote datatype) v)
               (cond
                 [(variant? v)
                  (let ([field-id field-extraction] ...)
                    body)]
                 ...
                 [else else-body])))))]))


&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;provide-datatype&#34;&gt;provide-datatype&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define-syntax (provide-datatype stx)
  (syntax-case stx ()
    [(_ datatype)
     (let ([dt (syntax-local-value #&#39;datatype (lambda () #f))])
       (unless (dt? dt)
         (raise-syntax-error #f &amp;quot;not a datatype name&amp;quot; stx #&#39;datatype))
       (with-syntax ([pred (dt-pred-stx dt)]
                     [(orig-variant ...) (map vt-name-stx (dt-variants dt))])
         #&#39;(provide datatype pred orig-variant ...)))]))

(provide define-datatype cases provide-datatype)



&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;基本形式&#34;&gt;基本形式&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;
(define-datatype typename type-predicate-name
{(varient-name {(field-name predicate)}*)}+
)

(cases type-name expression
    {(variant-name ({field-name}*) consequent)}*
    (else default)
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一般type-predicate-name 和predicate 都是胃词判断&lt;/p&gt;
&lt;h2 id=&#34;lambda-church&#34;&gt;lambda church&lt;/h2&gt;
&lt;p&gt;lambda church expression(lc-exp)::=identifier
::=(lambda (identifier) Lc-exp
::=(lc-exp lc-exp)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define-datatype lc-exp lc-exp?
    (var-exp (var identifier?))
    (lambda-exp (bound-var identifier?)
                (body lc-exp?))
    (app-exp (rator lc-exp?)
             (rand lc-exp?))
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;S-list::=({s-exp}*)
s-exp:=Symbol|S-list&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define-datatype s-list s-list?
    (empty-s-list)
    (non-empty-s-list
        (first s-exp?)
        (rest s-list?))
)
(define-datatype s-exp s-exp?
    (symbol-s-exp (sym symbol?))
    (s-list-s-exp (slst s-list?))
)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;进一步使用&#34;&gt;进一步使用？&lt;/h2&gt;</description>
    </item>
    
    <item>
      <title>基于continuation的cps表达式，保存计算过程</title>
      <link>https://jueqingsizhe66.github.io/archives/ji-yu-continuationde-cpsbiao-da-shi-bao-cun-ji-suan-guo-cheng/</link>
      <pubDate>Wed, 17 Feb 2016 16:55:50 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/archives/ji-yu-continuationde-cpsbiao-da-shi-bao-cun-ji-suan-guo-cheng/</guid>
      <description>&lt;p&gt;CPS其实是实现branch分支的一种scheme技术，对于程序流程的控制具有
重要的作用。下面就一个细节对CPS进行简单说明。&lt;/p&gt;
&lt;details class=&#34;toc-inpage d-print-none  &#34; open&gt;
  &lt;summary class=&#34;font-weight-bold&#34;&gt;Table of Contents&lt;/summary&gt;
  &lt;nav id=&#34;TableOfContents&#34;&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;#如果改变1-为3呢&#34;&gt;如果改变+1 为+3呢？&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#cps分析最好记住下面的分析方法&#34;&gt;CPS分析最好记住下面的分析方法&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;
&lt;/details&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define r #f)
(+ 1 (call/cc
(lambda (k)
(set! r k)
(+ 2 (k 3)))))

(r 0)
(r 10)

结果：
    4     ==&amp;gt; (+ 1 3)
    1     ==&amp;gt; (+ 1 0)
    11    ==&amp;gt; (+ 1 10)
分析：
    一般形式是 (+ 1 [])
    []代表着continuation的值，而整个continuation的返回值确是(+ 3 [c])
    在第一种情况下是3,紧接着0,最后10

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;如果改变1-为3呢&#34;&gt;如果改变+1 为+3呢？&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;
(+ 3 (call/cc
(lambda (k)
(set! r k)
(+ 2 (k 3)))))

(r 0)
(r 10)

结果:
    6     ==&amp;gt;(+ 3 3)
    3     ==&amp;gt;(+ 3 0)
    13    ==&amp;gt;(+ 3 10)


分析：
    一般形式是 (+ 3 [])
    []代表着continuation的值，而整个continuation的返回值确是(+ 3 [c])
    在第一种情况下是3,紧接着0,最后10
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;cps分析最好记住下面的分析方法&#34;&gt;CPS分析最好记住下面的分析方法&lt;/h2&gt;
&lt;p&gt;具体的过程参考&lt;a href=&#34;http://jueqingsizhe66.github.io/blog/2016/02/09/its-a-dead-program-dot-how-to-let-it-alive/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Dead_Program&lt;/a&gt;,包括rember8的修改。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;Let&#39;s trace (rember8  (lambda (x) x))

ls | k

&#39;(1 2 8 3 4 6 7 8 5) | (lambda (x) x) = id
&#39;(2 8 3 4 6 7 8 5)   | (lambda (x) (id (cons 1 x))) = k2
&#39;(8 3 4 6 7 8 5)     | (lambda (x) (k2 (cons 2 x))) = k3  ==&amp;gt;不断存储计算结果

Once we hit the 8, we apply (k (cdr ls)) where k is k3 and ls is &#39;(8 3
4 6 7 8 5)

(k3 &#39;(3 4 6 7 8 5)) = (k2 (cons 2 &#39;(3 4 6 7 8 5)))      ==&amp;gt; what is k2?
(k2 &#39;(2 3 4 6 7 8 5)) = (id (cons 1 &#39;(2 3 4 6 7 8 5)))  ==&amp;gt; what is id?
(id &#39;(1 2 3 4 6 7 8 5)) = &#39;(1 2 3 4 6 7 8 5)            ==&amp;gt; what is final result?

And we&#39;re done.

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;之所以写这个note的目的也是为了能够分析continuation的返回值。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>scheme IO实现来自于CPS或者haskell的monod范畴思想</title>
      <link>https://jueqingsizhe66.github.io/archives/scheme-ioshi-xian-lai-zi-yu-cpshuo-zhe-haskellde-monodfan-chou-si-xiang/</link>
      <pubDate>Wed, 17 Feb 2016 10:58:46 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/archives/scheme-ioshi-xian-lai-zi-yu-cpshuo-zhe-haskellde-monodfan-chou-si-xiang/</guid>
      <description>&lt;p&gt;scheme中IO的实现类似于CPS在原来函数的基础上增加了一个控制变量。&lt;/p&gt;
&lt;p&gt;之前曾经写过&lt;a href=&#34;http://jueqingsizhe66.github.io/blog/2016/02/09/its-a-dead-program-dot-how-to-let-it-alive/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CPS的控制过程&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;original-style&#34;&gt;original style&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define rember8
  (lambda (ls)
    (cond
      [(null? ls) &#39;()]
      [(= (car ls) 8) (cdr ls)]
      [else (cons (car ls) (rember8 (cdr ls)))])))

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;cps-style&#34;&gt;cps style&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;
;1
(define rember8
  (lambda (ls k)
    (cond
      [(null? ls) (k &#39;())]                           ==&amp;gt; k
      [(= (car ls) 8) (cdr ls)]
      [else (cons (car ls) (rember8 (cdr ls)))])))

;2
(define rember8
  (lambda (ls k)
    (cond
      [(null? ls) (k &#39;())]
      [(= (car ls) 8) (k (cdr ls))]                  ==&amp;gt;k
      [else (rember8 (cdr ls) (lambda (x) (cons (car ls) x)))]))) ==&amp;gt; rember8

;3
(define rember8
  (lambda (ls k)
    (cond
      [(null? ls) (k &#39;())]
      [(= (car ls) 8) (k (cdr ls))]
      [else (rember8 (cdr ls) (lambda (x) (k (cons (car ls) x)))]))) ==&amp;gt;  k 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个k的作用将在IO中体现出来。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;
(define o (open-output-file &amp;quot;greeting.txt&amp;quot;))
(display &amp;quot;hello&amp;quot; o)
(write-char #\space o)
(display &#39;world o)
(newline o)
(close-output-port o)


&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;结果：
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://jueqingsizhe66.github.io/images/greeting.png&#34; alt=&#34;result&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;其他io语法&#34;&gt;其他IO语法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;open-input-file&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;
;;打开文件句柄 用于读操作
(define in10 (open-input-file &amp;quot;greeting.txt&amp;quot;))
;;利用read-char 读取单个字符char
(read-char in10)
(read-char in10)
(read-char in10)
;;利用read 读取一个字word
(read in10)
(read in10)
;;利用read-line读取一行字符
(read-line in10)
(read-line in10)
(read in10)

;;结果
    #\h             ==&amp;gt;read-char
    #\e             ==&amp;gt;read-char
    #\l             ==&amp;gt;read-char
    &#39;lo             ==&amp;gt;read
    &#39;world          ==&amp;gt;read
    &amp;quot;&amp;quot;              ==&amp;gt;read-line
    &amp;quot;made in DaXi&amp;quot;  ==&amp;gt;read-line
    #&amp;lt;eof&amp;gt;          ==&amp;gt;read
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;open-input-string&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt; (define i (open-input-string &amp;quot;hello world&amp;quot;))
 (read-char i)
    #\h       ==&amp;gt;read-char
 (read-char i)
    #\e       ==&amp;gt;read-char
 (read-char i)
    #\l       ==&amp;gt;read-char
 (read i)
    &#39;lo       ==&amp;gt;read
 (read i)
    &#39;world    ==&amp;gt;read
 (read i)
    #&amp;lt;eof&amp;gt;    ==&amp;gt;read
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;open-output-string&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;
;;;定义字符串变量
(define op (open-output-string))
(write &#39;hello op)
(write-char #\, op)
(display &amp;quot; &amp;quot; op)
(display &amp;quot;world&amp;quot; op)

;;获取存取的值
(get-output-string op)


;;结果
    &amp;quot;hello,world&amp;quot;    ==&amp;gt; get-output-string
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中o的作用其实就是类似于k的作用，都是体现者一种程序的控制一种续延（具体未讲的十分清楚，待以后补充load等）。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>let and letrec makes programming orient object</title>
      <link>https://jueqingsizhe66.github.io/archives/let-and-letrec-makes-programming-orient-object/</link>
      <pubDate>Tue, 16 Feb 2016 21:35:15 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/archives/let-and-letrec-makes-programming-orient-object/</guid>
      <description>&lt;p&gt;面向对象已经大行其道，而在scheme是如何实现，本文仅仅是刹那的思路，
可以通过let来定义局部变量，而可以通过letrec定义method的过程来实现
面向对象的数据抽象的能力。&lt;/p&gt;
&lt;h2 id=&#34;let-不具备局部传递功能&#34;&gt;let 不具备局部传递功能&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define  x 10)  ;;; x的值不会影响到局部变量的值
(let ((x 1) (y 2) (z 3))
   (list  x y z))

(define  x 10) ;;;x的值会影响到局部变量的值
(let ((x 1) (y x) (z 3))
   (list  x y z))

;结果
    (1 2 3)
    (1 10 3) 
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;第一次注意看let的实现&#34;&gt;第一次注意看let的实现&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;
(define-syntax
    (syntax-rules ()
        ((let ((var expr) ...) body ...) ((lambda (var ...) body ...) expr ...))))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(let ((x 2) (y 3)) (+  x y)) 转变为
((lambda (x y) (+ x y)) 2 3) 的形式.&lt;/p&gt;
&lt;h2 id=&#34;let-star-具备局部传递功能&#34;&gt;let star 具备局部传递功能&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(let* (( x  1) (y  x) (z 3))
  (list x  y z))


;结果
    (1 1 3)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另外有一种叫做fluid-let的暂时没有在这边出现&lt;/p&gt;
&lt;h2 id=&#34;letrec-具备自指的能力递归&#34;&gt;letrec 具备自指的能力(递归)&lt;/h2&gt;
&lt;p&gt;如果想定义一个procedure局部变量？
如果用let 或者let*都无法达到此目的，因为他们不能自指（也就是没有递归的能力）
而如果是letrec则是拥有此功能&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(letrec
    ((my-even? (lambda (x)
              (if (zero? x) #t
                 (my-odd? (-  x 1)))))
     (my-odd? (lambda (x)
                (if (zero? x) #f
                   (my-even? (- x 1))))))
  (my-even? 10) ;
  (my-odd? 10) ;;只会打印出最后一个结果
  )


;结果
    #f
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;named-let-一种更加紧凑的letrec&#34;&gt;Named Let 一种更加紧凑的letrec&lt;/h3&gt;
&lt;p&gt;在上文，let是用来指定局部变量，而letrec是来指定procedure，
现在我们可以用Named let来使letrec写起来更加紧凑些，但是
不适合书写多个局部方法的情况，比如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(letrec ((countdown (lambda (i)
                      (if(= i 0) &#39;ole
                         (begin
                           (display i)
                           (newline)
                           (countdown (- i 1)))))))
  (countdown 10)) 

结果:
    10
    9
    8
    7
    6
    5
    4
    3
    2
    1
    &#39;ole
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(let countdown ((i 10))
  (if (= i 0) &#39;ole
     (begin
       (display i)
       (newline)
       (countdown (- i 1)))))

结果:
    10
    9
    8
    7
    6
    5
    4
    3
    2
    1
    &#39;ole
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;进一步实现留待以后&#34;&gt;进一步实现留待以后&lt;/h2&gt;</description>
    </item>
    
    <item>
      <title>Engine your life</title>
      <link>https://jueqingsizhe66.github.io/archives/engine-your-life/</link>
      <pubDate>Tue, 16 Feb 2016 17:26:03 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/archives/engine-your-life/</guid>
      <description>&lt;p&gt;有很多时候在思考engine是什么东西？
偶尔在一本书中看到Engine包含三个部分&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;clock ticks时间戳（什么时候做什么事情）&lt;/li&gt;
&lt;li&gt;success procedure&lt;/li&gt;
&lt;li&gt;failure procedure&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;也就是一个Engine交代了按照时间的发展，满足某个条件
该做什么事情，如果失败了该做什么东西。
















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://jueqingsizhe66.github.io/images/life/listen.jpg&#34; alt=&#34;listen&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在上一篇&lt;a href=&#34;http://jueqingsizhe66.github.io/blog/2016/02/15/data-representation-the-same-interface-with-different-implementation/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;博文&lt;/a&gt;并未详细说出一个数据抽象Data Abstraction 其实就是由基本的
创建部分和判断部分两部分组成。创建部分也叫做constructor比如上一篇&lt;a href=&#34;http://jueqingsizhe66.github.io/blog/2016/02/15/data-representation-the-same-interface-with-different-implementation/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;博文&lt;/a&gt;的
zero，successor，predecessor。而判断部分也叫做胃词部分predicate。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;constructor
&lt;ul&gt;
&lt;li&gt;add&lt;/li&gt;
&lt;li&gt;delete&lt;/li&gt;
&lt;li&gt;modify&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;observer
&lt;ul&gt;
&lt;li&gt;false?&lt;/li&gt;
&lt;li&gt;null?&lt;/li&gt;
&lt;li&gt;zero?&lt;/li&gt;
&lt;li&gt;atom?&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;而综合Engine和Data Abstraction,其实Engine也是由着constructor和observer两部分组成进行数据抽象，只不过可能引入时间的概念。&lt;/p&gt;
&lt;p&gt;而下午坐在山间，感受着潺潺的流水，Engine正如这潺潺的泉水















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://jueqingsizhe66.github.io/images/life/waterDown.jpg&#34; alt=&#34;waterDown&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
，绵绵不息。一直想着让程序中复合哲学、心理门，
多一些人情味，而不是机器的呆板味。而Engine的CPS思想正好让程序体现的变化和流动的感觉，犹如潺潺的泉水,遇物则绕，有路则行。&lt;/p&gt;
&lt;p&gt;一盘池水，流下了似水流年，规则依然
















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://jueqingsizhe66.github.io/images/life/reservoir.jpg&#34; alt=&#34;shuiku&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;坚信&lt;strong&gt;任何科学问题都可以通过子语言进行求解&lt;/strong&gt;，当前语言无法解决只能说现在的语言对问题的解释不清楚，得进一步进行&lt;strong&gt;语言分层&lt;/strong&gt;,
&lt;a href=&#34;http://tianchunbinghe.blog.163.com/blog/static/7001201542402420584/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;每一个未解之谜都是要被解开的。&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Data Representation-The Same interface with Different implementation</title>
      <link>https://jueqingsizhe66.github.io/archives/data-representation-the-same-interface-with-different-implementation/</link>
      <pubDate>Mon, 15 Feb 2016 16:39:26 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/archives/data-representation-the-same-interface-with-different-implementation/</guid>
      <description>&lt;p&gt;我们设定一个接口，该接口实现包括三个constructor和1个observer&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;zero&lt;/li&gt;
&lt;li&gt;successor&lt;/li&gt;
&lt;li&gt;predecessor&lt;/li&gt;
&lt;li&gt;zero?&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当然也可以拓展该接口包括scheme-val-&amp;gt;my-val,my-val-&amp;gt;scheme-val,plus等。
下面看一下如何实现三个相同接口的实现，从而体味data abstraction(data
representation or data boundary).&lt;/p&gt;
&lt;h2 id=&#34;unary-implementation&#34;&gt;unary implementation&lt;/h2&gt;
&lt;h3 id=&#34;辅助测试程序&#34;&gt;辅助测试程序&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define-syntax equal??
  (syntax-rules ()
    ((_ test-exp correct-ans)
     (let ((evaluate-ans test-exp))
       (if (not (equal? evaluate-ans correct-ans))
          (printf &amp;quot;~s returned ~s~%, should have returned ~s~%&amp;quot;
                 &#39;test-exp
                 evaluate-ans
                 correct-ans)
          &#39;OK)))))

(define report-unit-tests-completed
(lambda (fn-name)
  (printf &amp;quot;unit tests completed: ~s~%&amp;quot; fn-name)))

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(let ()
  (define zero (lambda () &#39;()))
  (define is-zero? (lambda (n) (null? n)))
  (define successor (lambda (n) (cons #t n)))
  (define predecessor (lambda (n) (cdr n)))
  
  (define plus
    (lambda (x  y)
      (if (is-zero? x)
         y
         (successor (plus (predecessor x) y)))))
 (report-unit-tests-completed &#39;unary-representation)
  )

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;scheme-value-implementation&#34;&gt;scheme value implementation&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(let()
  (define  zero (lambda () 0))
  (define is-zero? (lambda (n) (zero? n)))
  (define successor (lambda (n) (+ n 1)))
  (define predecessor (lambda (n) (- n 1)))

  (define plus
    (lambda (x y)
      (if (is-zero? x)
         y
         (successor (plus (predecessor x) y)))))

  (equal??  (plus 3 7) 10)
 (printf &amp;quot;~s test completed.~% &amp;quot; &#39;scheme-number-presentation)
  )


&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;5-inverse-implementation&#34;&gt;5-inverse implementation&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;
(let ()
  (define zero (lambda () 5))
  (define is-zero? (lambda (n) (=  n 5)))
  (define successor (lambda (n) (- n 5)))
  (define predecessor (lambda (n) (+ n 5)))
  (define plus
    (lambda (x y)
      (if (is-zero? x)
         y
         (successor (plus (predecessor x) y)))))

  (define scheme-int-&amp;gt;my-int
    (lambda (n)
      (if (zero? n) (zero)
         (successor (scheme-int-&amp;gt;my-int  (- n 1))))))

  (define my-int-&amp;gt;scheme-int
    (lambda  (n)
      (if (is-zero? n) 0
         (+ 1 (my-int-&amp;gt;scheme-int (predecessor n))))))

  (equal??
   (my-int-&amp;gt;scheme-int
    (plus (scheme-int-&amp;gt;my-int 3)
         (scheme-int-&amp;gt;my-int 7)))
   10)
(printf &amp;quot;~s unit tested completed&amp;quot; &#39;reverse-number-representation)
  )
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;拓展整体的接口程序&#34;&gt;拓展整体的接口程序&lt;/h2&gt;
&lt;p&gt;在上面的(let &amp;hellip;.) 中都可以添加如下的接口slots,
你会发现他们的实现在任意一种实现都是一样的过程，只要4个基本接口
实现一样那他们的result is the same.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;  (define scheme-int-&amp;gt;my-int
    (lambda (n)
      (if (zero? n) (zero)
         (successor (scheme-int-&amp;gt;my-int  (- n 1))))))

  (define my-int-&amp;gt;scheme-int
    (lambda  (n)
      (if (is-zero? n) 0
         (+ 1 (my-int-&amp;gt;scheme-int (predecessor n))))))

  (define plus
    (lambda (x y)
      (if (is-zero? x)
         y
         (successor (plus (predecessor x) y)))))

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过者三个实现过程认识[v] is the data representation of the v in certain
interface. 只要确定接口，那么实现有n种情况只要满足你的要求，从而达到问题的
求解。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>shuffle cards</title>
      <link>https://jueqingsizhe66.github.io/archives/shuffle-cards/</link>
      <pubDate>Sun, 14 Feb 2016 14:37:43 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/archives/shuffle-cards/</guid>
      <description>&lt;p&gt;这个程序是参考&lt;a href=&#34;http://www.oschina.net/code/snippet_2363209_47912&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;洗牌&lt;/a&gt;而来，主要定位于scheme的算法运用实现。&lt;/p&gt;
&lt;p&gt;源代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;#lang racket
;四种花色分别为黑桃(spade)、红心(heart)、梅花(club)、方块(diamond)
 
(define suits &#39;(&amp;quot;王&amp;quot; &amp;quot;黑桃&amp;quot; &amp;quot;红桃&amp;quot; &amp;quot;梅花&amp;quot; &amp;quot;方块&amp;quot;))
(define faces &#39;(&amp;quot;B&amp;quot; &amp;quot;L&amp;quot; &amp;quot;A&amp;quot; &amp;quot;2&amp;quot; &amp;quot;3&amp;quot; &amp;quot;4&amp;quot; &amp;quot;5&amp;quot; &amp;quot;6&amp;quot; &amp;quot;7&amp;quot; &amp;quot;8&amp;quot; &amp;quot;9&amp;quot; &amp;quot;10&amp;quot; &amp;quot;J&amp;quot; &amp;quot;Q&amp;quot; &amp;quot;K&amp;quot;))
 
;生成一张牌
(define (creat-card suit face)
    (cons suit face)
)
;生成n副牌
(define (creat-cards n mysuits myfaces)
        (define (afaces suit myfaces)
                (if (null? myfaces)
                    myfaces
                    (append (list (creat-card suit (car myfaces))) 
                             (afaces suit (cdr myfaces))
                     
                    )
                )
        )
        (define (asuits suits myfaces)
                (if (null? suits)
                    suits
                    (append  (afaces (car suits) myfaces)
                             (asuits (cdr suits) myfaces)
                    )
                 
                )
         
        )
         
        ;(make-list n (asuits mysuits myfaces))
        (define (n-cards n alist return) 
                (if (= n 0)
                    return
                    (n-cards (- n 1) alist (append return alist))
                )
        )
        ;(n-cards 4 &#39;(a b c d e) &#39;())
        (n-cards n (asuits mysuits myfaces) &#39;())
)
;显示牌 
(define (print-cards alist . number)
        (define (iter alist n num)
                (if (= 0 (remainder n num))
                    (newline)
                    &#39;ok
                )
                (if (null? alist)
                    (newline)
                    (begin (display (car alist)) 
                           (display &amp;quot;  &amp;quot;)
                           (iter (cdr alist) (+ n 1) num)
                    )
                )
        )
        (if (null? number)
            (iter alist 0 5)
            (iter alist 0 (car number))
        )
)
;获取牌的花色
(define (get-suit card)
    ((lambda (x) (cond ((equal? x &amp;quot;黑桃&amp;quot;) 4)
                       ((equal? x &amp;quot;红桃&amp;quot;) 3)
                       ((equal? x &amp;quot;梅花&amp;quot;) 2)
                       ((equal? x &amp;quot;方块&amp;quot;) 1)
                       ((equal? x &amp;quot;王&amp;quot;)   0)
                 )
     )
     
     (car card)
    )
)
 
;获取牌的数值
(define (get-face card)
    ((lambda (x) (cond ((equal? x &amp;quot;A&amp;quot;) 1)
                       ((equal? x &amp;quot;2&amp;quot;) 2)
                       ((equal? x &amp;quot;3&amp;quot;) 3)
                       ((equal? x &amp;quot;4&amp;quot;) 4)
                       ((equal? x &amp;quot;5&amp;quot;) 5)
                       ((equal? x &amp;quot;6&amp;quot;) 6)
                       ((equal? x &amp;quot;7&amp;quot;) 7)
                       ((equal? x &amp;quot;8&amp;quot;) 8)
                       ((equal? x &amp;quot;9&amp;quot;) 9)
                       ((equal? x &amp;quot;10&amp;quot;) 10)
                       ((equal? x &amp;quot;J&amp;quot;) 11)
                       ((equal? x &amp;quot;Q&amp;quot;) 12)
                       ((equal? x &amp;quot;K&amp;quot;) 13)
                       ((equal? x &amp;quot;B&amp;quot;) 30)
                       ((equal? x &amp;quot;L&amp;quot;) 20)
                 )
     )
     
     (cdr card)
    )
)
;洗牌
(define (shuffle-card cards)
        (define (append-amb x y return)
                (cond ((and (null? x) (null? y)) return)
                      ((null? x) (append return y))
                      ((null? y) (append return x))
                      (else      (append-amb (cdr y) 
                                             (cdr x) 
                                             (append return (append (list (car x)) (list (car y))))
                                 )
                      )
                 
                )
             
        )
        ;--
        (define (shuffle scards)
                ((lambda (x) 
                        (append-amb (list-tail scards x) (list-head scards x) &#39;()))
                 (random (length scards))
                  
                )
        )
        ;--
        (define (iter cards n)
                (if (= n 0)
                    cards
                    (iter (shuffle cards) (- n 1))
                )
        )
        ;--
        (iter cards (length cards))
        ;(shuffle cards)
)
;分牌(deal-card &#39;(1 2 3 4 5 6 7 8) 4) =&amp;gt; return ((1 5) (2 6) (3 7) (4 8))
;;还没完成
(define (deal-card alist n)
        (define (iter alist n return)
            (if (null? alist)
                return
                ;(append )
                &#39;ok
            )
        )
        (iter alist n &#39;())
             
)
;--------------------------------
;返回list中k以前的sublist
(define (list-head lst k)
    (if (zero? k)
        &#39;()
        (append (list (car lst)) (list-head (cdr lst) (- k 1)) )
     
    )
)
;-------------test---------------
(define x (creat-card &amp;quot;梅花&amp;quot; &amp;quot;8&amp;quot;))
(define k (creat-cards 1 (cdr suits) (cdr (cdr faces))))
(define n &#39;(1 2 3 4 5 6 7 8 9 10))
(print-cards k)
(print-cards (list-head k 9))
(print-cards (list-tail k 9) 13)
;(print-cards (shuffle-card k))
;------------------
;(display (shuffle-card n))
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;运行结果&#34;&gt;运行结果&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;(黑桃 . A)  (黑桃 . 2)  (黑桃 . 3)  (黑桃 . 4)  (黑桃 . 5)  
(黑桃 . 6)  (黑桃 . 7)  (黑桃 . 8)  (黑桃 . 9)  (黑桃 . 10)  
(黑桃 . J)  (黑桃 . Q)  (黑桃 . K)  (红桃 . A)  (红桃 . 2)  
(红桃 . 3)  (红桃 . 4)  (红桃 . 5)  (红桃 . 6)  (红桃 . 7)  
(红桃 . 8)  (红桃 . 9)  (红桃 . 10)  (红桃 . J)  (红桃 . Q)  
(红桃 . K)  (梅花 . A)  (梅花 . 2)  (梅花 . 3)  (梅花 . 4)  
(梅花 . 5)  (梅花 . 6)  (梅花 . 7)  (梅花 . 8)  (梅花 . 9)  
(梅花 . 10)  (梅花 . J)  (梅花 . Q)  (梅花 . K)  (方块 . A)  
(方块 . 2)  (方块 . 3)  (方块 . 4)  (方块 . 5)  (方块 . 6)  
(方块 . 7)  (方块 . 8)  (方块 . 9)  (方块 . 10)  (方块 . J)  
(方块 . Q)  (方块 . K)  

(黑桃 . A)  (黑桃 . 2)  (黑桃 . 3)  (黑桃 . 4)  (黑桃 . 5)  
(黑桃 . 6)  (黑桃 . 7)  (黑桃 . 8)  (黑桃 . 9)  

(黑桃 . 10)  (黑桃 . J)  (黑桃 . Q)  (黑桃 . K)  (红桃 . A)  (红桃 . 2)  (红桃 . 3)  (红桃 . 4)  (红桃 . 5)  (红桃 . 6)  (红桃 . 7)  (红桃 . 8)  (红桃 . 9)  
(红桃 . 10)  (红桃 . J)  (红桃 . Q)  (红桃 . K)  (梅花 . A)  (梅花 . 2)  (梅花 . 3)  (梅花 . 4)  (梅花 . 5)  (梅花 . 6)  (梅花 . 7)  (梅花 . 8)  (梅花 . 9)  
(梅花 . 10)  (梅花 . J)  (梅花 . Q)  (梅花 . K)  (方块 . A)  (方块 . 2)  (方块 . 3)  (方块 . 4)  (方块 . 5)  (方块 . 6)  (方块 . 7)  (方块 . 8)  (方块 . 9)  
(方块 . 10)  (方块 . J)  (方块 . Q)  (方块 . K)  
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>斯基摩斯的乐园schemers</title>
      <link>https://jueqingsizhe66.github.io/archives/si-ji-mo-si-de-le-yuan-schemers/</link>
      <pubDate>Sun, 14 Feb 2016 14:11:54 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/archives/si-ji-mo-si-de-le-yuan-schemers/</guid>
      <description>&lt;p&gt;作为一个schemer，你得去学习，编程，社交，工作，保持畅通等,
当然你最不该错过的是&lt;a href=&#34;http://www.schemers.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;斯基摩斯的乐园&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;学习&#34;&gt;学习&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;FAQ&lt;/li&gt;
&lt;li&gt;textbooks书本&lt;/li&gt;
&lt;li&gt;videos&lt;/li&gt;
&lt;li&gt;blogs&lt;/li&gt;
&lt;li&gt;standards 标准手册&lt;/li&gt;
&lt;li&gt;tutorials 入门书籍&lt;/li&gt;
&lt;li&gt;bibliography 参考文献&lt;/li&gt;
&lt;li&gt;other documents 其他文档&lt;/li&gt;
&lt;li&gt;education 教育&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过以上几个部分可以完成你学习的过程。&lt;/p&gt;
&lt;h2 id=&#34;编程&#34;&gt;编程&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;implementation 通过实现一门语言&lt;/li&gt;
&lt;li&gt;libraries 通过调用库&lt;/li&gt;
&lt;li&gt;environments 通过搭建环境 了解环境&lt;/li&gt;
&lt;li&gt;Scheme Requests for Implementation&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;社交&#34;&gt;社交&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;中国lisp组织&lt;/li&gt;
&lt;li&gt;google讨论组&lt;/li&gt;
&lt;li&gt;开发者邮箱&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;工作&#34;&gt;工作&lt;/h2&gt;
&lt;p&gt;从工作中获得消息&lt;/p&gt;
&lt;h2 id=&#34;保持畅通&#34;&gt;保持畅通&lt;/h2&gt;
&lt;p&gt;从一些具体的新闻事件中获取消息&lt;/p&gt;
&lt;h2 id=&#34;斯基摩斯清单&#34;&gt;斯基摩斯清单&lt;/h2&gt;
&lt;p&gt;具体下面的事项参看&lt;a href=&#34;http://www.schemers.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;首页&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(case (what-would-you-like-to-do?)
  ((learn)
   (choose-from FAQ
                textbooks
                videos
                blogs
                standards
                tutorials
                bibliography
                other documents
                education))
  ((program)
   (choose-from implementations
                libraries
                environments
                SRFIs))
  ((socialize)
   (choose-from ABQ Lisp/Scheme - Albuquerque, NM, USA
                Chinese Lisp Users Group - China
                Bay Area Lisp &amp;amp; Scheme - Bay Area, CA, USA
                Scheme Boston and Boston Lisp Announce - Boston, MA, USA
                Denver Lispers - Denver, CO, USA
                Scheme UK - London, UK
                munich-lisp - Munich, Germany
                CRACL - Los Angeles, CA, USA
                Lambdaheads - Vienna, Austria
                FringeDC - Washington, DC, USA))
  ((work)
   (choose-from jobs))
  ((stay-informed)
   (choose-from events))
  (else
   (choose-from the lighter side
                wares
                other resources)))
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>chicken-scheme</title>
      <link>https://jueqingsizhe66.github.io/archives/chicken-scheme/</link>
      <pubDate>Sun, 14 Feb 2016 13:52:48 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/archives/chicken-scheme/</guid>
      <description>&lt;p&gt;它的主要住用适用于产生exe文件，并且对应产生的c代码更加的有效，
运行效率较高。&lt;/p&gt;
&lt;h2 id=&#34;产生可运行文件&#34;&gt;产生可运行文件&lt;/h2&gt;
&lt;p&gt;该可运行的文件是通过chicken生成egg文件，也就是c语言,然后编译成机器代码。
所以运行效率更高一些。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;;;; hello-world.scm
(print &amp;quot;Hello, world!&amp;quot;)

;;; Running it interpreted:
$ csi -s hello-world.scm 
Hello, world!

;;; Compiling and running the executable binary:
$ csc hello-world.scm 

$ ./hello-world
Hello, world!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&#34;http://www.call-cc.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;chicken-scheme&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Notes from Teach yourself scheme</title>
      <link>https://jueqingsizhe66.github.io/archives/notes-from-teach-yourself-scheme/</link>
      <pubDate>Sun, 14 Feb 2016 11:56:24 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/archives/notes-from-teach-yourself-scheme/</guid>
      <description>&lt;p&gt;The notes is published for rethinking what I am reading
in the book called [《Teach Yourself Scheme in Fixnum Days》][3].
It is a good book for introducing scheme(you&amp;rsquo;d better have read
the TLS)&lt;/p&gt;
&lt;h2 id=&#34;forms&#34;&gt;Forms&lt;/h2&gt;
&lt;p&gt;All expression can be inducted into Forms,such as define,begin,set! forms.
Before, I only said the define,begin,set! expression without forms.&lt;/p&gt;
&lt;h2 id=&#34;data-types&#34;&gt;Data Types&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;list&lt;/li&gt;
&lt;li&gt;vector&lt;/li&gt;
&lt;li&gt;procedure&lt;/li&gt;
&lt;li&gt;port (原来port也是数据类型的一种，这样就并入了文件的IO)
当然也包括open-string-port相当于创建了fortran的[内部文件][4]的作用。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所有的形式(forms)在scheme其实都是一种对于数据的representation.要反复思考这个过程。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Data abstraction divides a data type into two pieces: an interface
and an implementation. The interface tells us what the data of the type
represents,what the operations on the data are,and what properties these
operations may be relied to have.The implementation provides a specific
representation of the data and code for the operations that make use
of that data representation.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;implicit-and-explicit&#34;&gt;implicit and explicit&lt;/h2&gt;
&lt;p&gt;lambda 的内部自带(begin &amp;hellip;)的作用，也就是可以连接多个expressions（forms）。
而if没有，对应的when，unless conditions则是存在隐式的implicit begin的作用。
并且when和unless其实就差在一个not表达式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;lambda implicit begin&lt;/li&gt;
&lt;li&gt;when   implicit begin&lt;/li&gt;
&lt;li&gt;unless implicit begin&lt;/li&gt;
&lt;li&gt;if     explicit begin&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;macro-expansion&#34;&gt;macro expansion&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;`(.. , &amp;hellip;)    叫做comon 形式&lt;/li&gt;
&lt;li&gt;`(&amp;hellip; ,@ &amp;hellip;)  叫做comon slice形式&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;jumpscps&#34;&gt;Jumps(CPS)&lt;/h2&gt;
&lt;p&gt;Continuation is the special contribution of the book.&lt;/p&gt;
&lt;p&gt;[很多其他的scheme解释器和编译器.][1] [Mit_scheme][2]
[1]: &lt;a href=&#34;http://tunes.org/wiki/scheme.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://tunes.org/wiki/scheme.html&lt;/a&gt;
[2]: &lt;a href=&#34;http://groups.csail.mit.edu/mac/projects/scheme/index.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://groups.csail.mit.edu/mac/projects/scheme/index.html&lt;/a&gt;
[3]: &lt;a href=&#34;http://ds26gte.github.io/tyscheme/index.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://ds26gte.github.io/tyscheme/index.html&lt;/a&gt;
[4]: &lt;a href=&#34;http://v.fcode.cn/video-internal_file.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://v.fcode.cn/video-internal_file.html&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Different data types decide the different operations</title>
      <link>https://jueqingsizhe66.github.io/archives/different-data-types-decide-the-different-operations/</link>
      <pubDate>Sat, 13 Feb 2016 13:33:06 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/archives/different-data-types-decide-the-different-operations/</guid>
      <description>&lt;p&gt;Data types such as list,vector,array,linkedlist,tree etc, all have the self operations
to add,delete,modify the content referred.&lt;/p&gt;
&lt;h2 id=&#34;list&#34;&gt;List&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;    (define list-sum
     (lambda (lst)
      (if (null? lst)
       0
       (+ (car lst) (list-sum (cdr lst))))))
    (list-sum &#39;(1 2 3 4))

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;vector&#34;&gt;Vector&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;    (define vector-sum
     (lambda (vec)
      (define vector-sum-help
       (lambda (vec n)
        ;(if (eq? n 0)
            (if (zero? n)
             (vector-ref vec 0)
             (+ (vector-ref vec n) (vector-sum-help vec (- n 1))))))
       (let ((n (vector-length vec)))
        (if (zero? n)
         0
         (vector-sum-help vec (- n 1)))))) ;;;wrong  (n)
     (vector-sum (vector 1 2 3 4))
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;the-box-function-in-the-tss&#34;&gt;The box function in the TSS&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;     box 的作用虽然有点类似 kons kar kdr
     (define kons (lambda (kar kdr) (lambda (selector) (selector kar kdr))))
    (define kar (lambda (c) (c (lambda (a d) a))))
    (define kdr (lambda (c) (c (lambda (a d) d))))
(define kdr2 (lambda (c) (c (lambda (a d) (quote d)))))

    (kar (kons &#39;a &#39;b))
    (kdr (kons &#39;a &#39;b))
    (kdr2 (kons &#39;a &#39;b))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Now let&#39;s see the function of the box.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;
    (define (box it)
     (lambda (sel)
      (sel it (lambda (new)
               (set! it new)))))

    (define (setbox box new)
     (box (lambda (it set)
           (set new))))

    (define (unbox box)
     (box (lambda (it set)
           it)))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;我们使用的前提是通过box进行cons的作用
比如setbox
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;    ((lambda (it set) (set new)) it (lambda (new) (set! it new)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也就是 it对一个it 而set对应 (lambda (new) (set! it new))
所以这边真正起作用的就是第一个lambda里面的(set new)返回值
比如unbox&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    ((lambda (it set) it) it (lambda (new) (set! it new)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也就是此时 it依然对应it set对应的是(lambda (new) (set! it new))
所以这边真正起作用的就是第一个lambda里面的it返回值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;所以box只不过是提供了一种映射结构，想到那关于数据结构的创建，把所有的基于这个框架的
变体放入首个位置，类似closure的table位置
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>It&#39;s a dead program.How to let it alive?</title>
      <link>https://jueqingsizhe66.github.io/archives/its-a-dead-program-dot-how-to-let-it-alive/</link>
      <pubDate>Tue, 09 Feb 2016 23:20:18 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/archives/its-a-dead-program-dot-how-to-let-it-alive/</guid>
      <description>&lt;p&gt;All programs are data.
All intepreters are program.
All Handware and software,or type checkers etc are interpreter.&lt;/p&gt;
&lt;p&gt;I think data conceives the soul,not only the fixed process,but changing vari-language.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1&#34;&gt;1.The Little Scheme interpreter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2&#34;&gt;2.The Season Scheme interpreter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3&#34;&gt;3.The CPS control struture&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#3.1&#34;&gt;3.1 how to add arguments?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3.2&#34;&gt;3.2 what is the small stuff?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4&#34;&gt;4. how to evaluate or interpreter  a procedre?&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#4.1&#34;&gt;4.1 ordinary tracing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4.2&#34;&gt;4.2 cps tracing&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5&#34;&gt;5. It is not the end&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;1&#34;&gt;The Little Scheme&lt;/h2&gt;
&lt;p&gt;Here below is the interpreter from TLS&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;#lang racket
;;简单环境配置
    (define atom?
     (lambda (x)
      (and (not (pair? x)) (not (null? x)))))


    ;第一大部分 定义好整体框架
    (define value
     (lambda (e)
      (meaning e (quote ()))))
    (define meaning
     (lambda (e table)
      ((expression-to-action e) e table)))

    ;;第二大部分 解析atom and list action

    (define expression-to-action
     (lambda (e)
      (cond
       ((atom? e) (atom-to-action e))
       (else (list-to-action e)))))
    (define atom-to-action
     (lambda (e)
      (cond
       ((number? e) *const)
       ((eq? e #t) *const)
       ((eq? e #f) *const)
       ((eq? e (quote cons)) *const)
       ((eq? e (quote car)) *const)
       ((eq? e (quote cdr)) *const)
       ((eq? e (quote null?)) *const)
       ((eq? e (quote eq?)) *const)
       ((eq? e (quote atom?)) *const)
       ((eq? e (quote zero?)) *const)
       ((eq? e (quote add1)) *const)
       ((eq? e (quote sub1)) *const)
       ((eq? e (quote number?)) *const)
       (else *identifier))))
    (define list-to-action
     (lambda (e)
      (cond
       ((atom? (car e))
        (cond
         ((eq? (car e) (quote quote))
          *quote)
         ((eq? (car e) (quote lambda))
          *lambda)
         ((eq? (car e) (quote cond))
          *cond)
         (else *application)))
       (else *application))))

    ;; 第三大部分 定义 6星==5个special forms 和一个general forms（*application)

    ;;;环境额外配置 这些配置仅仅是为了增加可读性 无任何编程技巧
    (define first
     (lambda (p)
      (cond
       (else (car p)))))
    (define second
     (lambda (p)
      (cond
       (else car (cdr p)))))
    (define third
     (lambda (p)
      (cond
       (else car (cdr (cdr p))))))
(define text-of second)
    ;; *identifier
    (define table-of first)
    (define formals-of second)
(define body-of third)
    ;;*cond
    (define question-of first)
    (define answer-of second)
(define cond-lines-of cdr)
    ;;*application
    (define function-of car)
(define arguments-of cdr)

    (define build
     (lambda (s1 s2)
      (cond
       (else (cons s1
              (cons s2 (quote ())))))))
    ;;1st star
    (define *const
     (lambda (e table)
      (cond
       ((number? e) e)
       ((eq? e #t) #t)
       ((eq? e #f) #f)
       (else (build (quote primitive) e)))))
    ;;2nd star
    (define *quote
     (lambda (e table)
      (text-of e)))
    ;;3rd star
    (define *lambda
     (lambda (e table)
      (build (quote non-primitive)
       (cons table (cdr e)))))
    ;;4th star
    (define *identifier
     (lambda (e table)
      (lookup-in-table e table initial-table)))
    (define initial-table
     (lambda (name)
      (car (quote ()))))
    (define lookup-in-table
     (lambda (name table table-f)
      (cond
       ((null? table) (table-f name))
       (else (lookup-in-entry name
              (car table)
              ; (lambda (name)
                  ; (cdr table)
                  ; (table-f)))))))
(lambda (name)
 (lookup-in-table name
  (cdr table)
  table-f)))))))
    (define lookup-in-entry
     (lambda (name entry entry-f)
      (lookup-in-entry-help name
       (first entry)
       (second entry)
       entry-f)))
    (define lookup-in-entry-help
     (lambda (name names values entry-f)
      (cond
       ((null? names) (entry-f name))
       ((eq? (car names) name)
        (car values))
       (else (lookup-in-entry-help name
              (cdr names)
              (cdr values)
              entry-f)))))

    ;; 5th star
    (define *cond
     (lambda (e table)
      (evcon (cond-lines-of e) table)))
    (define evcon
     (lambda (lines table)
      (cond
       ((else? (question-of (car lines)))
        (meaning (answer-of (car lines))
         table))
       ((meaning (question-of (car lines))
         table)
        (meaning (answer-of (car lines))
         table))
       (else (evcon (cdr lines) table)))))

    (define else?
     (lambda (x)
      (cond
       ((atom? x) (eq? x (quote else)))
       (else #f))))


    ;;6th star 你需要解析arguments的各个部分这是evlis的工作
    (define *application
     (lambda (e table)
      (apply
       (meaning (function-of e) table)
       (evlis (arguments-of e) table))))

    (define evlis
     (lambda (args table)
      (cond
       ((null? args) (quote ()))
       (else
        (cons (meaning (car args) table)
         (evlis (cdr args) table))))))


    ;;第四大部分 进行 apply的定义 反向运用primitive和non-primitive 去除核心的primitive和non-primitive前缀，并升级环境

    (define apply
     (lambda (fun vals)
      (cond
       ((primitive? fun)
        (apply-primitive
         (second fun) vals))
       ((non-primitive? fun)
        (apply-closure
         (second fun) vals)))))

    (define primitive?
     (lambda (l)
      (eq? (first l) (quote primitive))))
    (define non-primitive?
     (lambda (l)
      (eq? (first l) (quote non-primitive))))
    (define apply-primitive
     (lambda (name vals)
      (cond
       ((eq? name (quote cons))
        (cons (first vals) (second vals)))
       ((eq? name (quote car))
        (car (first vals)))
       ((eq? name (quote cdr))
        ((eq? name (quote cdr))
         (cdr (first vals)))
        ((eq? name (quote null?))
         (null? (first vals)))
        ((eq? name (quote eq?))
         (eq? (first vals) (second vals)))
        ((eq? name (quote atom?))
         (:atom? (first vals)))
        ((eq? name (quote zero?))
         (zero? (first vals)))
        ((eq? name (quote add1))
         (add1 (first vals)))
        ((eq? name (quote sub1))
         (sub1 (first vals)))
        ((eq? name (quote number?))
         (number? (first vals)))))))
    (define :atom?
     (lambda (x)
      (cond
       ((atom? x) #t)
       ((null? x) #f)
       ((eq? (car x) (quote primitive))
#t)
       ((eq? (car x) (quote non-primitive))
#t)
       (else #f))))

    ;;closure=table+arguments+body ;;arguments 通过formals-of获取 body-of获取body
    (define apply-closure
     (lambda (closure vals)
      (meaning (body-of closure)
       (extend-table
        (new-entry
         (formals-of closure)
         vals)
        (table-of closure)))))
    (define new-entry build)
(define extend-table cons)


    ;;测试这个解释器
    ;(value (cons (* (+ 1 3) 4) &#39;hello)) ;;不通过
    (value (+ 2 4))
(value (* 15 (+ 2 4)))
    ;;(value (cons (quote (* (+ 1 3) 4)) (cons &#39;h &#39;()))) ;;测试不通过

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2&#34;&gt; The Season scheme&lt;/h2&gt;
&lt;p&gt;Here below is the interpreter from TLS&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;#lang racket
;; The Seasoned Schemer
;; chapter 20
;; What&#39;s in Store ?

(define abort &#39;())

(define global-table &#39;())

(define (add1 n)
 (+ n 1))

(define (sub1 n)
 (- n 1))

    (define (atom? a)
     (and (not (pair? a))
      (not (null? a))))

(define (text-of x)
 (cadr x))

(define (formals-of x)
 (cadr x))

(define (body-of x)
 (cddr x))

(define (ccbody-of x)
 (cddr x))

(define (name-of x)
 (cadr x))

    (define (right-side-of x)
     (if (null? (cddr x))
      0
      (caddr x)))

(define (cond-lines-of x)
 (cdr x))

    (define (else? x)
     (if (atom? x)
      (eq? x &#39;else)
#f))

(define (question-of x)
 (car x))

(define (answer-of x)
 (cadr x))

(define (function-of x)
 (car x))

(define (arguments-of x)
 (cdr x))


(define (lookup table name)
 (table name))

    (define (extend name1 val table)
     (lambda (name2)
      (if (eq? name1 name2)
       val
       (table name2))))

    (define (define? e)
     (eq? (and (pair? e)
           (car e)) &#39;def))

(define (*define e)
 (set! global-table
  (extend (name-of e)
   (box (the-meaning (right-side-of e)))
   global-table)))

    (define (box it)
     (lambda (sel)
      (sel it (lambda (new)
               (set! it new)))))

    (define (setbox box new)
     (box (lambda (it set)
           (set new))))

    (define (unbox box)
     (box (lambda (it set)
           it)))

(define (the-meaning e)
 (meaning e lookup-in-global-table))

(define (lookup-in-global-table name)
 (lookup global-table name))

(define (meaning e table)
 ((expression-to-action e) e table))

(define (*quote e table)
 (text-of e))

(define (*identifier e table)
 (unbox (lookup table e)))

(define (*set e table)
 (setbox
  (lookup table (name-of e))
  (meaning (right-side-of e) table)))

    (define (*lambda e table)
     (lambda (args)
      (beglis (body-of e)
       (multi-extend (formals-of e)
        (box-all args)
        table))))

    ;; (define (beglis es table)
            ;; (cond
                ;; ((null? (cdr es))
                    ;; (meaning (car es) table))
                ;; (else ((lambda (val)
                            ;; (beglis (cdr es) table))
                        ;; (meaning (car es) table)))))

    ;; (define (beglis es table)
            ;; (let ((m (meaning (car es) table)))
                ;; (if (null? (cdr es))
                    ;; m
                    ;; ((lambda (val)
                            ;; (beglis (cdr es) table)) m))))

    ;; (define (beglis es table)
            ;; (let ((m (meaning (car es) table)))
                ;; (if (null? (cdr es))
                    ;; m
                    ;; (let ((val m))
                        ;; (beglis (cdr es) table)))))

    (define (beglis es table)
     (let ((m (meaning (car es) table))
           (d (cdr es)))
      (if (null? d)
       m
       (beglis d table))))

    ;; (define (box-all vals)
            ;; (if (null? vals)
                ;; &#39;()
                ;; (cons (box (car vals))
                    ;; (box-all (cdr vals)))))

    ;; (define (box-all vals)
            ;; (letrec
                ;; ((rec
                        ;; (lambda (vals acc)
                            ;; (if (null? vals)
                                ;; acc
                                ;; (rec (cdr vals)
                                    ;; (cons (box (car vals)) acc))))))
                ;; (rec (reverse vals) &#39;())))

    (define (box-all vals)
     (let loop ((vals (reverse vals))
                (acc &#39;()))
      (if (null? vals)
       acc
       (loop (cdr vals)
        (cons (box (car vals)) acc)))))

    (define (multi-extend names vals table)
     (if (null? names)
      table
      (extend (car names)(car vals)
       (multi-extend (cdr names)(cdr vals)
        table))))

    (define (*application e table)
     ((meaning (function-of e) table)
      (evlis (arguments-of e) table)))

    ;; (define (evlis args table)
            ;; (if (null? args)
                ;; &#39;()
                ;; ((lambda (val)
                        ;; (cons val
                            ;; (evlis (cdr args) table)))
                    ;; (meaning (car args) table))))

    ;; (define (evlis args table)
            ;; (if (null? args)
                ;; &#39;()
                ;; (cons (meaning (car args) table)
                    ;; (evlis (cdr args) table))))

    ;; (define (evlis args table)
            ;; (letrec
                ;; ((rec
                        ;; (lambda (args table acc)
                            ;; (if (null? args)
                                ;; acc
                                ;; (rec (cdr args)
                                    ;; table
                                    ;; (cons (meaning (car args) table)
                                        ;; acc))))))
                ;; (rec (reverse args) table &#39;())))

    (define (evlis args table)
     (let loop ((args (reverse args))
                (table table)
                (acc &#39;()))
      (if (null? args)
       acc
       (loop (cdr args) table
        (cons (meaning (car args) table)
         acc)))))

    (define (a-prim p)
     (lambda (args-in-a-list)
      (p (car args-in-a-list))))

    (define (b-prim p)
     (lambda (args-in-a-list)
      (p (car args-in-a-list)
       (cadr args-in-a-list))))

(define (*const e table)
 (cond
  ((number? e) e)
  ((eq? e #t) #t)
  ((eq? e #f) #f)
  ((eq? e &#39;cons)(b-prim cons))
  ((eq? e &#39;car )(a-prim car))
  ((eq? e &#39;cdr)(a-prim cdr))
  ((eq? e &#39;eq?)(b-prim eq?))
  ((eq? e &#39;atom?)(a-prim atom?))
  ((eq? e &#39;null?)(a-prim null?))
  ((eq? e &#39;zero?)(a-prim zero?))
  ((eq? e &#39;add1)(a-prim add1))
  ((eq? e &#39;sub1)(a-prim sub1))
  ((eq? e &#39;number)(a-prim number?))))

(define (*cond e table)
 (evcon (cond-lines-of e) table))

(define (evcon lines table)
 (cond
  ((else? (question-of (car lines)))
   (meaning (answer-of (car lines)) table))
  ((meaning (question-of (car lines)) table)
   (meaning (answer-of (car lines)) table))
  (else (evcon (cdr lines) table))))

(define (*letcc e table)
 (let/cc skip
  (beglis (ccbody-of e)
   (extend (name-of e)
    (box (a-prim skip) table)))))

(define (value e)
 (let/cc the-end
  (set! abort the-end)
  (if (define? e)
   (*define e)
   (the-meaning e))))

(define (the-empty-table name)
 (abort
  (cons &#39;no-answer
   (cons name &#39;()))))

    (define (expression-to-action e)
     (if (atom? e)
      (atom-to-action e)
      (list-to-action e)))

(define (atom-to-action e)
 (cond
  ((number? e) *const)
  ((eq? e #t) *const)
  ((eq? e #f) *const)
  ((eq? e &#39;cons) *const)
  ((eq? e &#39;car) *const)
  ((eq? e &#39;cdr) *const)
  ((eq? e &#39;null?) *const)
  ((eq? e &#39;eq?) *const)
  ((eq? e &#39;atom?) *const)
  ((eq? e &#39;zero?) *const)
  ((eq? e &#39;add1) *const)
  ((eq? e &#39;sub1) *const)
  ((eq? e &#39;number?) *const)
  (else *identifier)))

    (define (list-to-action e)
     (let ((a (car e)))
      (if (atom? a)
       (let ((prim-of? (lambda (x) (eq? x a ))))
        (cond
         ((prim-of? &#39;quote) *quote)
         ((prim-of? &#39;lambda) *lambda)
         ((prim-of? &#39;letcc) *letcc)
         ((prim-of? &#39;set!) *set)
         ((prim-of? &#39;cond) *cond)
         (else *application)))
       *application)))


(set! global-table (lambda (name)
                    (the-empty-table name)))
    (value (cons &#39;a &#39;b))
(value (+ (- 3 2) 6))


&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3&#34;&gt;The CPS control struture&lt;/h2&gt;
&lt;p&gt;Here below is the method how to change the ordinary subroutine to the continuation passing style &lt;a href=&#34;https://cgi.soic.indiana.edu/~c311/lib/exe/fetch.php?media=cps-notes.scm&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Ref.&lt;/a&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;First rule: whenever we see a lambda in the code we want to CPS, we have to add an argument, and then process the body&lt;/li&gt;
&lt;li&gt;Second rule: &amp;ldquo;Don&amp;rsquo;t sweat the small stuff!&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3.1&#34;&gt;how to add argument?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;orignial style:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define rember8
  (lambda (ls)
    (cond
      [(null? ls) &#39;()]
      [(= (car ls) 8) (cdr ls)]
      [else (cons (car ls) (rember8 (cdr ls)))])))
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;incompleted cps style:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define rember8
  (lambda (ls k)
    (cond
      [(null? ls) &#39;()]
      [(= (car ls) 8) (cdr ls)]
      [else (cons (car ls) (rember8 (cdr ls)))])))
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3.2&#34;&gt;what is the small stuff?&lt;/h3&gt;
&lt;p&gt;Small stuff is stuff we know will terminate right away.
Don&amp;rsquo;t sweat the small stuff if we know it will be evaluated.
Don&amp;rsquo;t sweat the small stuff if it &lt;em&gt;might&lt;/em&gt; be evaluated, but instead
pass it to k.&lt;/p&gt;
&lt;p&gt;为了更好辨别，我们改为如下形式&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;
(define rember8
  (lambda (ls k)
    (cond
      [(null? ls) (*k* &#39;())]
      [(= (car ls) 8) (*k* (cdr ls))]
      [else (*rember8* (cdr ls) (lambda (x) (*k* (cons (car ls) x))))])))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;凡是加上*号的，都代表者continuation的过程。
Why don&amp;rsquo;t null?, =, car, cdr, and cons count? Because they&amp;rsquo;re just
small stuff, and when we combine small stuff together in small ways,
the combination remains small.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Second, all arguments are small stuff. Yep, even the lambda in the
else line, because lambda is *always* small stuff.
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;complete cps style:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;
(define rember8
  (lambda (ls k)
    (cond
      [(null? ls) (k &#39;())]
      [(= (car ls) 8) (k (cdr ls))]
      [else (rember8 (cdr ls) (lambda (x) (k (cons (car ls) x)))])))
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4&#34;&gt;how to evaluate or interpreter  a procedre?&lt;/h2&gt;
&lt;h3 id=&#34;4.1&#34;&gt;ordinary tracing&lt;/h3&gt;
&lt;p&gt;we will develop a unimplemented language to do give an explanation to it.&lt;/p&gt;
&lt;p&gt;Here below is the main language(we can change it ,but now it is not the main cause.)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;
;1 eval
(define eval
   (lambda (Exp Env )
 (cond 
    ((number? Exp)  Exp)
    ((symbol? Exp) (looking Exp Env))
    ((eq? (car Exp) &#39;QUADE) (cadr Exp))
    ((eq? (car Exp) &#39;lambda) 
        (list &#39;Closure (cdr Exp) Env))
    ((eq? (car Exp) &#39;Cond) 
        （Evcond (cadr Exp） Env))
    (else
        (apply  
           (eval (car Exp) Env)
           (Evlist (cdr Exp) Env)))))) 

;2 apply
(define apply
   (lambda (PROC ARGS)
     (cond 
        ((primitive? PROC) 
          (Apply-primitive Proc ARGS))
        ((EQ? (car proc) &#39;closure)
          (EVAL  (cadadr proc)
            (Bind (caadr proc) 
                ARGS
               (Caddr proc))))
         (else error)))))

;;;Attention, primitvie?  apply-primitive  is not finished

;3 Evlist
(define Evlist
  (lambda (l Env)
    (cond 
      ((eq? (car l) &#39;()) &#39;())
      (else
         (cons (eval (car l) Env)
               (eval (cdr l) Env))))))

;4 Evcond
(define Evcond
   (lambda (clauses Env)
     (cond
        ((eq? clauses &#39;()) &#39;())
        ((eq? (caar clauses) &#39;else) 
            (eval (cadar clauses) Env))
         ((false? (Eval (caar clauses) Env))
            (Evcond (cdr clauses) Env))
         (else
            (Eval (cadar clauses) Env)))))

;;;Attention false? is not finished.

;5 looking
(define looking
   (lambda (sym env)
     (cond 
       ((eq? env &#39;()) (error &#39;unbound-value))
       (else
         ((lambda (vcell)
             (cond 
               ((eq? vcell &#39;())
                  (looking sym (cdr env)))
               (else (cdr vcell))))
           (assq sym (car env)))))))

;6 assq
(define assq
    (lambda (syms alist)
       (cond
         ((eq? alist &#39;()) &#39;())
         ((eq? syms (caar alist)) (car alist))
         (else (assq syms (cdr alist))))))


;7 Bind
(define Bind
   (lambda (vars vals Env)
     (cons (pair-up  vars vals) env)))

;8 Pair-up
(define Pair-up
   (lambda (vars vals)
     (cond 
        ((eq? vars &#39;())
            (cond 
               ((eq? vals? &#39;()) &#39;())
               (else (error &#39;Too-much-arguments))))
         ((eq? vals &#39;()) (error &#39;Too-few-arguments))
         (else 
           (cons (cons (car vars)  (car vals))
                  (pair-up (cdr vars) (cdr vals))))))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So now we can use the language below to interpret the form&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(eval &#39;(((lambda (x）（lambda (y) (+  x y))) 3) 4) e0)

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Good explanation begin(kernal part)：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;

(apply (eval &#39;((lambda (x) (lambda (y) (+ x y))） 3）  e0)
       (Evlist &#39;(4) e0))

(apply (eval &#39;((lambda (x) (lambda (y) (+ x y))） 3）  e0)
       （cons (eval &#39;(4) e0) (evlist &#39;() e0)))

(apply (eval &#39;((lambda (x) (lambda (y) (+ x y))） 3）  e0)
       （cons 4 &#39;()))

(apply (eval &#39;((lambda (x) (lambda (y) (+ x y))） 3）  e0)
       &#39;(4))


(apply (apply (eval &#39;(lambda (x) (lambda (y) (+ x y))  e0)
       &#39;(3) )
      &#39;(4))

(apply (apply &#39;(closure ((x) (lambad (y) (+ x y))) e0) 
       &#39;(3) )
      &#39;(4))

(apply (eval (lambda (y) (+ x y)) e1)
      &#39;(4))

(apply &#39;(closure ((y) (+ x y)) e1)
      &#39;(4))

(eval &#39;(+ x y) e2)

(apply (Eval &#39;+ e2)  (Evlist &#39;(x y) e2))

(apply &#39;(add0101)  &#39;(3 4))   ;add0101 is the assemble executable binary code(speed fast)


（+ 3 4） = 7
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finished~  Good ~  Well done.&lt;/p&gt;
&lt;h3 id=&#34;4.2&#34;&gt;cps tracing&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;Let&#39;s trace (rember8  (lambda (x) x))

ls | k

&#39;(1 2 8 3 4 6 7 8 5) | (lambda (x) x) = id
&#39;(2 8 3 4 6 7 8 5)   | (lambda (x) (id (cons 1 x))) = k2
&#39;(8 3 4 6 7 8 5)     | (lambda (x) (k2 (cons 2 x))) = k3

Once we hit the 8, we apply (k (cdr ls)) where k is k3 and ls is &#39;(8 3
4 6 7 8 5)

(k3 &#39;(3 4 6 7 8 5)) = (k2 (cons 2 &#39;(3 4 6 7 8 5)))
(k2 &#39;(2 3 4 6 7 8 5)) = (id (cons 1 &#39;(2 3 4 6 7 8 5)))
(id &#39;(1 2 3 4 6 7 8 5)) = &#39;(1 2 3 4 6 7 8 5)

And we&#39;re done.

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;5&#34;&gt; It is not the end&lt;/h2&gt;
&lt;p&gt;how to change the procedure above? Leave to you.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>The-Little-Scheme-And-Part-Of-TSS</title>
      <link>https://jueqingsizhe66.github.io/archives/the-little-scheme-and-part-of-tss/</link>
      <pubDate>Mon, 18 May 2015 09:25:11 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/archives/the-little-scheme-and-part-of-tss/</guid>
      <description>&lt;p&gt;这部分内容是我练习TLS和TSS的全部学习资料，里面有详细的记录和一些心路历程，以后慢慢修改。
总行数5800左右。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;#lang racket

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; I will introuduce The little scheme From the angles below
;;; 1:
;;;     why introuduce the concept
;;; 2:  
;;;     The main knowledge
;;; 3: 
;;;     Map-reduce 
;;;     .......
;;; 4:  How you describe the function works in  your own words? 
;;; 5:  How do you determine the output when you apply a function?Is it what you want?
;;;     no? why no?
;;;;Namely, Can you write down the definition of the function member? and its arguments
;;;     and refer to them as you go through the next group of questions????
;; Do not rush through this book! Read carefully
;;; From the introuduction chapter 
;;; else implicit said that if the condition is wrong do it recurly
;;;      also infer that after the recuring ,please go back to home along the Original road!
;;;  COns &#39;s function: save the buffer to the stack
;;;  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;The first part;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; The Basic operator
;;;   The primitive variables of scheme ::  car ,cdr(is pronounced as &amp;quot;could_er&amp;quot;,cons,  null? zero?
;;;                                         eq?(compare two non-numericas atoms),
;;;                                         or (or asks two questions,one at a time. If the first one is true
;;;                                         .Otherwise it asks the second question and answers with whatever the 
;;;                                         second question answers)
;;;                                         numbers,add1,sub1
;;;  COns &#39;s function: save the buffer to the stack
(define atom?
  (lambda (x)
    (and (not (pair? x)) (not (null? x)))))


;;;; New added after myracet1.rkt
;;;  I want to find ( a  h fd  fs)  but not ( a h (fd s) fs),so I want to create the lat?
;;;  can you describe what the function lat? does in your own words? *****************

;;;  lat? looks at each S-expression in a list ,in turn,and asks if each S-expression 
;;;  is an atom ,untill it runs out of S-expression. If it runs out without encountering 
;;;  a list,the value is #f. If it finds a list,the value is #f,false
;;;   What is the meaning of the question *else* ??  
;;;             *else* asks if else if true
;;;                is *else* true?  Yes,because the question else is always true!
;;;         so what is (else #f) means?  ----&amp;gt; as if else is true,If else is true--as it always is
;;; else implicit said that if the condition is wrong do it recurly
;;;      also infer that after the recuring ,please go back to home along the Original road!
;;;
;;;               --then the answer if #f ---false
;;;               In a word:   else is a question whose value is always (implicit)
(define lat?
  (lambda (l)
    (cond
      ((null? l) #t)
      ((atom? (car l)) (lat? (cdr l)))
      (else #f))))

;;;; New added after myracet1.rkt
;;;
(define &amp;gt;
  (lambda (n m)
    (cond 
      ((zero? n) #f)
      ((zero? m) #t)
      (else (&amp;gt; (sub1 n) (sub1 m))))))

;;; What is the maning of (&amp;gt; (sub1 n) (sub1 m))
;;;        Recur, but with both arguments reduced by one
(define dd
  (lambda (n m)
    (cond 
      ((zero? n) #f)
      ((zero? m) #t)
      (else (&amp;gt; (sub1 n) (sub1 m))))))

;;; Can you describe what leftmost does?
;;;      Here is our description:
;;;       &amp;quot;The function leftmost finds the leftmost atom in a non-empty list of S-expressions that does not
;;;       contain the empty list&amp;quot;
;;;
;;;       Is left a *-function?
;;;            It works on lists of S-expressions,but it only recurs on the car(so no)
;;;
;;;     Does leftmost need to ask questions about all three possible cases?
;;;       No,it only needs to ask two questions,We agreed that leftmost works on non-empty
;;;       list that don&#39;t contain empty list
;;;
;;;       So in a word,the two discussed before,1:recur in car(not together with cdr) 2:2 questions ,not 3 questions which S-expressions
;;;
;;;
;;;       Do you remember what (or ...) does?
;;;            (or as questions one at a time until it finds one that is true.Then (or ...) stops,making its value true.
;;;            If it cannot find a true argument,the value of (or...) is false
;;;
;;;     After so many illustration ,can you put in your own words what (and ....) does
;;;             We put in our words:(lispers&#39; words)
;;;             &amp;quot;(and ...) ask questions one at a time until it finds one whose value is false.Then (and ...) stops with false.
;;;              If none of the expressions are false,(and ...) is true.&amp;quot;
;;;
;;;     Both (and ...) and (or ...) can be expressed as abbreviations of (cond ...)-expressions:
;;;              (and a b) == (cond a b) (else #f))
;;;              (or a b) == (cond (a #t) (else b))
(define leftmost
  (lambda (l)
    (cond 
      ((atom? (car l)) (car l))
      (else (leftmost(car l))))))

(define rember
  (lambda (a lat)
    (cond 
      ((null? lat) (quote()))
      (else (cond
              ((eq? (car lat) a) (cdr lat))
              (else 
               (cons (car lat)
                     (rember a
                             (cdr lat)))))))))
;;; Can you write number? which is true if its argument is a numerica atom and false if it is anything else
;;;      No:number? like add1,sub1,zero?,car , cdr, cons,null?, eq?,and atom? is a primitive function
;;;
;;;      Can you write a function no-nums which gives as a final value a lat obtained by removing all the
;;;      numbers from the lat.

;;; Remember to use = for numbers
;;;                 eq? for all other atoms(non-numericas atoms)
;;;     eqan? contains two part to compare the two atoms: 1 a number   2:an atom
;;;     Can you assume that all funtions written using eq? can be generalized by replacing eq?
;;;          By eqan?   ------------------Yes,excpet,of course ,for eqan? itself
(define eqan?
  (lambda (a1 a2)
    (cond
      ((and (number? a1) (number? a2))
       (= a1 a2))
      ((or (number? a1) (number? a2))
       #f)
      (else (eq? a1  a2)))))

;;;after the introuction of (and  (or   define leftmost
;;; What is eqlist?
;;;
;;;  It is a function that determines if two lists are equals
;;;
;;; How many questions will eqlist? have to ask about it arguments?
;;;             Nine  --------------------------------------------------------------&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;The first time so many questions!
;;;
;;; Can you explain why there are nine questions?
;;;        Here are out words:
;;;         &amp;quot;Each arguments may be either
;;;             ----empty
;;;             ----an atom consed onto a list,or
;;;             ----a list consed onto a list
;;;        For example,at the same time as the first argument may be the empty list,the 
;;;              seconds argument could be the empty list or have an atom or a list in the car position.&amp;quot;
;;;
;;;         Is it okay to asK (atom? (car l2)) in the second question?
;;;               Yes ,because we know that the second  list cannot be empty.otherwise the first question would have been true.
;;;
;;;         And why is the third question (null? l1)???
;;;              At that point ,we know that when the firs argument is empty,the second argument is neither empty list
;;;              nor a list with an atom as the first element .If(null? l1) is true now,the second argument must be a list whose first element
;;;              is also a list.
;;;
;;;         Does this mean the questions (and (null? l1) (null? l2)) and (or (null? l1) (null? l2)) 
;;;                suffice to determine the answer in the first three cases?
;;;             Yes .If the first question is true,eqlist? respoinse with #t; otherwise ,the answer if #f
(define eqlist?
  (lambda (l1 l2)
    (cond 
      ((and (null? l1) (null? l2)) #t)
      ((and (null? l1) (atom? (car l2))) #f)
      ((null? l1) #f)
      ((and (atom? (car l1)) (null? l2)) #f)
      ((and (atom? (car l1)) (atom? (car l2)))
       (and (eqan? (car l1) (car l2)) (eqlist? (cdr l1) (cdr l2))))
      ((atom? (car l1)) #f)
      ((null? l2) #f)
      ((atom? (car l2)) #f)
      (else
       (and (eqlist? (car l1) (car l2))
            (eqlist? (cdr l1) (cdr l2)))))))
;; eqlist? 需要借用eqan?解析数字和字符的等价，eqan?需要借用eq?解析字符，借用等号解析数字
(define eqlist1?
  (lambda (l1 l2)
    (cond 
      ((and (null? l1) (null? l2)) #t)
      ((or (null? l1) (null? l2)) #f)
      ((and (atom? (car l1)) (atom? (car l2)))
       (and (eqan? (car l1) (car l2)) (eqlist1? (cdr l1) (cdr l2))))
      ((or (atom? (car l1))
           (atom? (car l2)))
       #f)
      (else
       (and (eqlist1? (car l1) (car l2))
            (eqlist1? (cdr l1) (cdr l2)))))))

;;; So What is an S-expresssion? 
;;; An S-expression is either an atom or a (possibly empty) list of S-expressions.
;;;
;;; How many questions does equal? ask to determine whether two S-empty are the same?
;;; Four. The first argument  may be an atom or a list of S-expressions at the same time as the second argument may be
;;;   an atom or a list of S-expressions.
;;; can we summarize the second questions and the third question of the equal? 
;;;   as   (or (atom? s1) (atom? s2))
;;;              Yes, we can

;; eqlist 无法解析atom，因为他直接处理(car ...)
;; equal?既可以解析原子 也可以解析list
(define equal?
  (lambda (s1 s2)
    (cond
      ((and (atom? s1) (atom? s2)) 
       (eqan? s1 s2))
      ((atom? s1) #f)
      ((atom? s2) #f)
      (else
       (eqlist? s1 s2)))))

(define equal1?
  (lambda (s1 s2)
    (cond
      ((and (atom? s1) (atom? s2)) 
       (eqan? s1 s2))
      ((or (atom? s1) (atom? s1))
       #f)
      (else
       (eqlist? s1 s2)))))

;;; The sixth chapter:
;;;    Is 1,3,1+3,1+3*4,cookie,3^y_5 all arithmetic expression?  Yes ,of course
;;;
;;; What is an arithmetic expression? in your words?
;;;       In ours:
;;;         &amp;quot;For the purpose of this chapter,an arithmetic expression is either an atom
;;;         (including numbers),or two arithmetic expressions combined by +,-,*,/,or expr.
;;;
;;; Is (n+3) an arithmetic expression?
;;;        Not really,since there are parentheses around n+3, our definition of arithmetic
;;;        expression does not mention parentheses....
;;;
;;; Could we think of (n+3) as an arithmetic expression?
;;;        Yes if we keep in mind that the parentheses are not really there (the empire&#39;s new clothes)
;;;
;;; What would you call (n+3)  
;;;                   we call it a representation for n+3
;;;         why is (n+3) a good representation?
;;;                  Because 
;;;                          1. (n+3) is an S-expression. 
;;;                               It can therefore serve as an argument for a function
;;;                          2.It stucturally resembles n+3
;;;
;;; True or false: (numbered? x)  True while x is 1
;;;
;;; How do you represent 3+4*5  ?                      ------&amp;gt; (3+4*5)
;;;
;;; What is numbered?     
;;;                     It is a function that determines whether a representation? of an arithmetic expression 
;;;                      contains only number besides the +,* and expr
;;;
;;; Now you can write a skeleton for numbered?
;;;           (define numbered?
;;;           (lambda (axep)
;;;           (cond 
;;;           (_________   _________)
;;;           (_________   _________)
;;;           (_________   _________)
;;;           (_________   _________))))
;;;
;;; What is the first question?        --------------(atom? axep)
;;; What is (eq? (car (cdr aexp)) (quote +))  ------It is the second question
;;; can you guess the third one (eq? (car (cdr aexp)) (quote *))
;;; And you must know the fourth one.                     (eq? (car (cdr aexp)) (quote )e)
;;;
;;; why do we ask four,instead of two,  
;;;          questions about the arithmetic expressions?
;;;          after all,arithmetic expressions like (1+3) are lats
;;;
;;;         ------------------------------Because we consider (1+3) as a representation of an arithmetic expression in 
;;;         list form,not as a list itself.And,an arithmetic expression is either a number,or two arithmetic expressions combined
;;;         by + ,*,expr.
;;;
(define numbered?
  (lambda (aexp)
    (cond
      ((atom? aexp) (number? aexp))
      ((eq? (car (cdr aexp)) (quote +))
       ...)
      ((eq? (car (cdr aexp)) (quote +))
       ...)
     ((eq? (car (cdr aexp)) (quote +))
       ...))))


(define numbered1?
  (lambda (aexp)
    (cond
      ((atom? aexp) (number? aexp))
      ((eq? (car (cdr aexp)) (quote +))
       (and (numbered? (car aexp))
            (numbered? 
              (car (cdr (cdr aexp))))))
      ((eq? (car (cdr aexp)) (quote +))
       (and (numbered? (car aexp))
            (numbered? 
              (car (cdr (cdr aexp))))))
     ((eq? (car (cdr aexp)) (quote +))
       (and (numbered? (car aexp))
            (numbered? 
              (car (cdr (cdr aexp)))))))))

;;; Since aexp was already understood to be an arithmetic expression,could we have written numbered? in a simpler way?

(defin numbered2?
       (lambda (aexp)
         (cond
           ((atom? aexp) (number? aexp))
           (else
             (and (numbered2? (car aexp))
                  (numbered2? 
                    (car (cdr (cdr aexp))))))))))

;;; why can we simplify ??-
;;;                        because we know we&#39;ve got the function right!

;;; We want to value the arithmetic expressions? ------------------
;;;
;;; THe seventh commandments!!
;;;
;;; Recur on the subparts that are of the same nature:
;;;            On the sublists of a list
;;;            on the subexpressions of an arithmetic expression
;;;
;;; To (3 + 4)    &#39;s value
(define value
  (lambda (nexp)
    (cond
      ((atom? nexp) nexp)
      ((eq? (car (cdr nexp)) (quote +))
       (+ (value (car nexp))
          (value (car (cdr (cdr nexp))))))
      ((eq? (car (cdr nexp)) (quote *))
       (+ (value (car nexp))
          (value (car (cdr (cdr nexp))))))
      (else
       (expr (value (car nexp))
          (value (car (cdr (cdr nexp)))))))))

;;; Can you think of a different representation of arithmetic expressions?
;;;          There are several of thme
;;;
;;;          (3 4 +)
;;;          (+ 3 4)
;;;          (plus 3 4)
;;;          (+ (* 3 6) (expr 8 2))
;;;         TO value (+ 3 4)
      
(define value1
  (lambda (nexp)
    (cond
      ((atom? nexp) nexp)
      ((eq? (car nexp) (quote +))
       (+ (value1 (car (cdr nexp)))
          (value1 (car (cdr (cdr nexp))))))
      ((eq? (car nexp) (quote *))
       (+ (value1 (car (cdr nexp)))
          (value1 (car (cdr (cdr nexp))))))
      (else
       (expr (value1 (car nexp))
          (value1 (car (cdr (cdr nexp)))))))))

;;;(1 2) is not a arithmetic expressions ,so we  violated The Seventh Commandments. (1 3) is not a subpart that is 
;;;   representation of an arithmetic expression! We obviosuly  recurred on a list.But,remember,not all lists are representations
;;;   of arithmetic expressions. We have to recur subexpressions.
;;;   (3) is the (cdr (cdr nexp)) ,but (3) is not an arithmetic expressions,because there are no parentheses in our 
;;;   definition of the arithmetic expressions.

(define 1st-sub-exp
  (lambda (aexp)
    (cond
      (else (car (cdr aexp))))))

;;; why do we ask else,
;;;  because the first question is also the last question
;;;
;;; Can we get by without (cons. ..) if we don&#39;t need to ask questions?
;;;   Yes remember one-liners from chapter4
;;;

(define 1st-sub-exp1
  (lambda (aexp)
      (car (cdr aexp))))


(define 2nd-sub-exp
  (lambda (aexp)
    (cond
      (else (car (cdr (cdr aexp)))))))

(define operator
  (lambda (aexp)
    (car aexp)))


(define value2
  (lambda (nexp)
    (cond
      ((atom? nexp) nexp)
      ((eq? (operator nexp) (quote +))
       (+ (value (1st-sub-exp1 nexp))
          (value (2nd-sub-exp nexp))))
      ((eq? (operator nexp) (quote +))
       (* (value (1st-sub-exp1 nexp))
          (value (2nd-sub-exp nexp))))
      (else
       (expr (value (1st-sub-exp1 nexp))
          (value (2nd-sub-exp nexp)))))))

;;; so it we chang the (define operator ) and (1st-sub-exp1) exchangeabley ,the different form of arithmetic expressioned.


;;;       ********************************************************************************
;;; The Eighth Commandments:
;;;       Use help functions to abstract from representation
;;;       ********************************************************************************
;;;
;;;
;;;
;;;   Have we seen representation? before
;;;    Yes ,we just did not tell you that were representations.
;;;    For what entities have we used representations?
;;;    Truth-values!  Numbers!
;;;    Numbers are representations?
;;;    Yes ,for example 4 stands for the concpet four. we close the symbol because
;;;   we are accustomed to arabic representation.
;;;   What else could we have used?
;;;    (() () () ())  would have serve just as well
;;;    what about  (((((((())))))))?  How about (I V)&amp;quot;
;;;                                         Do you know how many primitives we need for numbers?
;;;                                          Four: number? ,zero?, add1,and sub1-------------------------------------------&amp;lt;
;;;                                                            ****Do You know how many primitives we need for list?
;;;                                                                   Four:   atom? null? car cdr
;;;                                         Let&#39;s try anouther representation for numbers. How shall we represent zero now/
;;;                                                       () is our choice
;;;                                         How is one represented?
;;;                                                       (()) 
;;;
;;;                                         How is two represented?
;;;                                                       (() () )
;;;                                          Got it,What&#39;s Three?
;;;                                                       (() () ())
;;; So now write thefunction to test zero
(define sero?
  (lambda (n)
    (null? n)))
;;; write a function that is like add1
(define edd1
  (lambda (n)
    (cons (quote ()) n)))

;;;what about sub1
(define zub1
  (lambda (n)
    (cdr n)))

;;; so we can rewrite +
(define plus
  (lambda (n m)
    (cond
      ((sero? m) n)
      (else (edd1 (+ n (zub1 m)))))))

;;; but what&#39;s lat????t
;;;(define lat?
;;;  (lambda (l)
;;;  (cond
;;;      ((null? l) #t)
;;;      ((atom? (car l)) (lat? (cdr l)))
;;;      (else #f))))
;;; So (lat? (1 2 3))     why did you ask???  but now (lat? ((()) (()()) (()()()))) It is very false,!!!
;;;    So you must beware of shadows!!!bugs implicit!!


;;;                         
;;; Why dow we ask (number? aexp) when we know that aexp is an atom?
;;;                   Because we want to know if all arithmetic expressions that are atoms are numbers

;;; Does equal1? ask enough questions? --The first commandments!!  
;;;              Yes,The questions cover all four possible cases

;; Now rewrite the eqlist? using equal???                --------------equal? is the most common ,which  S-expression as the arguments
    
(define eqlist1?
  (lambda (l1 l2)
    (cond
      ((and (null? l1) (null? l2)) #t)
      ((or (null? l1) (null? l2)) #f)
      (else
       (and (equal? (car l1) (car l2))
            (eqlist? (cdr l1) (cdr l2)))))))

;;;; THe sixth Commandments
;;;     Simplify  only  after the function is correct.   ---------------------------------&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;

;;;; Can you describe what (rember1 a lat) do?
;;;          It takes an atom and a lat as its *arguments*,and makes a new *lat*
;;;          with the *first* occurrence of the atom in the old lat removed
;;;
;;;     How do we(lispers,implicitly) ask questions?
;;;            By using
;;;                   (cond
;;;                     (__________     ____________)
;;;                     (__________     ____________)
;;;                     (__________     ____________)
;;;                     ...
;;;                     (__________     ____________)).
;;;     How do we  remove the first occurrence of a in the rest of lat?
;;;             (rember a (cdr lat))
;;;
;;;
;;; Write down the function rember and its arguments, and refer to them as you go
;;; through the next sequence of questions(the unit test)
;;;    In our words:
;;;              &amp;quot;The function rember checked each atom of the lat , one at a time,
;;;               to see if it was the same  as the atom &#39;and&#39;.If the car was not the
;;;               same as the atom, we saved it to be consed to the final value later.
;;;               when rember found the atom &#39;and&#39;,it dropped it ,and consed the previous
;;;               atoms back onto the rest of the lat
;;;  ---------------------------------cons --------------------------------------
(define rember
  (lambda (a lat)
    (cond 
      ((null? lat) (quote ()))
      (else cond
            ((eq? (car lat) a) 
             (cdr lat))
            (else (cons (car lat)
                        (rember a (cdr lat))))))))

;;; Can you rewrite rember so that it reflects the abouve description
;;;
(define rembersimple
  (lambda (a lat)
    (cond
      ((null? lat) (quote ()))
      ((eq? (car lat) a) (cdr lat))
      (else (cons (car lat)
                  (rember a (cdr lat)))))))

;;;;  What is the meaning of the  (cons (car lat) (rember a (cdr lat))) 
;;;   This says to refer to the funciton rember but with the 
;;;   argument lat replaced by (cdr lat) and  that after we arrive at a value for
;;;   (rember a (cdr lat)) we must cons (car lat) --bacon --onto it
;;;
;;;  This also says we recur using the function rember, with the argument lat
;;; replaced by (cdr lat),and that after we arrive at a value for (rember a (cdr lat))
;;;  we must cons (car lat)---lettuce --onto it
;;;
;;; Here is rember1  after we replace lat by a list l of S-expression 
(define rember1
  (lambda (s l)
    (cond
      ((null? l) (quote()))
      ((atom? (car l))
       (cond 
         ((equal? (car l) s) (cdr l))
             (else (cons (car l)
                         (rember1 s (cdr l))))))
      (else
       (cond
         ((equal? (car l) s) (cdr l ))
         (else (cons (car l)
                     (rember1 s 
                             (cdr l)))))))))
;;;  And how does that differ?
;;;        The funciton rember now removes the first matching S-expression s in l,
;;;                  instead of the first matching atom a in lat.
;;;    Is rember a  &amp;quot;star&amp;quot; function now? 
;;;             NO.
;;;     Why not?
;;;          because rember recurs with the cdr of l only (not togeterh with the car of l ,,correspoding to (define leftmost)
;;;; can we simplify rember1 ?
(define rember2
  (lambda (s l)
    (cond
      ((null? l) (quote()))
      (else 
       (cond
         ((equal? (car l) s) (cdr l))
         (else
          (cons (car l)
                (rember2 s (cdr l)0))))))))

;;; Can rember2 be further simplified????????????????????????
;;;   Yes,the inner(cond...) asks questions that the outer(cond...) could ask1
(define rember3
  (lambda (s l)
    (cond 
      ((null? l) (quote ()))
      ((equal? (car l) s) (cdr l))
      (else (cons (car l)
                  (rember3 s (cdr l)))))))

;;; &amp;quot;...*&amp;quot; makes us think &amp;quot;oh my gawd&amp;quot;
(define rember*
  (lambda (a l)
    (cond 
      ((null? l ) (quote ()))
      ((atom? (car l))
       (cond 
        ((eq? (car l) a)
         (rember* a (cdr l)))
        (else (cons (car l)
                    (rember* a (cdr l))))))
      (else (cons (rember* a (car l))
                  (rember* a (cdr l)))))))
;; Notice that now we are recurring down the car of the list,instead of just the cdr of the list


(define insertL
       (lambda (new old lat)
         (cond
           ((null? lat) (quote ()))
           (else (cond
                   ((eq? (car lat) old)
                    (cons new 
                          (cons old (cdr lat))))
                   (else (cons (car lat)
                               (insertL new old 
                                        (cdr lat)))))))))

;;;; after ------------------------------------&amp;lt;the (define firsts  
;;;In your own words, what does (insertR new old lat) do?
;;;     In our words:
;;;             &amp;quot;It takes three arguments: the atoms new  and old,and lat.
;;;             The function insertR builds a lat with new inserted to the
;;;             right of the *first* occurence of old
;;;
;;;
;;;     Which arguments changes when we recur with insertR?
;;;           lat, because we can only  look at one of its atoms at a time.
;;;
;;;     Which questions do we ask?
;;;       First, we ask (null? lat) .Second we ask else,because else is 
;;;       always the last question.
;;;     Which questions do we ask about the first elements?????? Still rember the typical element
;;;       in the (define firsts)
;;;
;;;     First,we ask (eq? (car lat) old ) .Then we ask else,because there are no other interesting cases
;;;  
;;;  COns &#39;s function: save the buffer to the stack
;;;
;;;  I want to write an procedure: which sort the list  afterwards?
;;;            So I want the change the function&#39; return value?????????????????????????
;;;            What I should do??
(define insertR
  (lambda (new old lat)
    (cond
      ((null? lat) (quote ()))
      (else (cond
              ((eq? (car lat) old)
               (cons old 
                     (cons new (cdr lat))))
              (else (cons (car lat)
                           (insertR new old 
                                    (cdr lat)))))))))

;;;; after the (define makeset1)

(define subset
  (lambda (new old lat)
    (cond 
      ((null? lat) (quote ()))
      (else (cond
              ((eq? (car lat) old)
               (cons new (cdr lat)))
              (else (cons (car lat)
                          (subset new old 
                                  (cdr lat)))))))))

(define subset2
  (lambda (new o1 o2 lat)
    (cond
      ((null? lat) (quote ()))
      (else (cond
              ((eq? (car lat) o1)
               (cons new (cdr lat)))
              ((eq? (car lat) o2)
               (cons new (cdr lat)))
              (else (cons (car lat)
                          (subset2 new o1 o2
                                   (cdr lat)))))))))


(define rember5
  (lambda (a lat)
    (cond 
      ((null? lat) (quote ()))
      ((eq? (car lat) a) (cdr lat))
      (else (cons (car lat)
                  (rember5 a (cdr lat)))))))

(define factorial 
    (lambda (x)
      (if (&amp;lt;= x 1) 1
          (* x (factorial (- x 1))))))

;;;;  after rember ---------------------------------------------------&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;
;;; In  your own words , what does (firsts l) do
;;;          We tried the following:
;;;          &amp;quot;The function firsts takes one argument, a list,which is either
;;;          a null list or contains only non-empty lists. It builds another list
;;;          composed of the first S-expression(atom or list  or pair) of each internal list
;;;
;;;          REMEMBER THe Commandments
;;;
;;;          Why (define firsts
;;;                 (lambda (l)
;;;                  ...)                     Because we always state the function name,(lambda,and the 
;;;                                           argument(s) of the function
;;;          Why (cond ...)
;;;                                           Because we need to ask questions about the actual arguments
;;;          Why ((null? l) ...)
;;;                                           The first Commandments
;;;          Why (else
;;;                                           Because we only have two equstions to ask about the list l:
;;;                                                      either It is the null list,
;;;                                                                or it contains at least one non-empty list.
;;;                                                 And Because the last question is always else
;;;         Why (cons 
;;;                                           Because we are building  a list  -----The second commandments
;;;
;;;         Why (firsts (cdr l)) 
;;;                                           Because we can only  look at one S-expression at at time .
;;;                                                   To look at the rest,we must recur
;;;         why )))
;;;                                           Because these are the matching  parentheses for (cond, (lambda,
;;;                                           and (define, and they always appear at the end of a function 
;;;                                           definition
;;;
;;;        When we find a typical element of (firsts l) 
;;;                 what do we do with it?
;;;                                       --cons it onto the recursion --(firsts (cdr l))
;;;
;;;
;;;     The third commandments :
;;;                 When building a list, describe the first typical element,and then cons it onto the natural recursion
;;;         So What is the first typical element?
;;;                             -----------------------&amp;gt;  In the (define firsts  The typical element is (car (car l))
;;;            What  is the natural recursion?
;;;                            -----------------------&amp;gt; (firsts (cdr l))
;;;
;;;
;;;             ****************************we are still missing one important ingredient in our recipe!
;;;
;;;
;;;             So what is the meaning of (cons (car (car l))  (firsts (cdr l)))
;;;                           Save (car (car l)) ,and recur with (firsts (cdr l))
(define firsts
  (lambda (l)
    (cond
      ((null? l) (quote ()))
      (else (cons (car (car l))
                  (firsts (cdr l)))))))

(define multirember
  (lambda (a lat)
    (cond
      ((null? lat) (quote ()))
      (else
       (cond
         ((eq? (car lat) a)
          (multirember a (cdr lat)))
         (else (cons (car lat)
                     (multirember a (cdr lat)))))))))
;;; What is the meaning of (cons (car lat) (multirember a (cdr lat)))
;;;  Save (car lat) ---coffee ---- to be consed onto the value of (multirember a (cdr lat)) later
;;;  Now determine (multirember a (cdr lat))
;;;
;;;  THe Fourth commandments:
;;;         Always change at least one arguments while recuring.It must be changed to be closer to 
;;;         termination.The changing argument must be tested in the termination condition:
;;;                   When using cdr, test termination with null?, such as (null? lat)  lat is the 
;;;                   changing argument,so it occur in the terminal condition.

(define multiinsertR
  (lambda (new old lat)
    (cond
      ((null? lat) (quote ()))
      (else 
       (cond
         ((eq? (car lat) old)
          (cons (car lat)
                (cons new
                      (multiinsertR new old (cdr lat)))))
         (else (cons (car lat)
                     (multiinsertR new old (cdr lat)))))))))


(define multiinsertL
  (lambda (new old lat)
    (cond
      ((null? lat) (quote ()))
      (else 
       (cond
         ((eq? (car lat) old)
          (cons new
                (cons (car lat)
                      (multiinsertL new old (cdr lat)))))
         (else (cons (car lat)
                     (multiinsertL new old (cdr lat)))))))))

(define multisubset
  (lambda (new old lat)
    (cond
      ((null? lat) (quote ()))
      (else
       (cond
         ((eq? (car lat) old)
          (cons new
                (multisubset new old 
                             (cdr lat))))
         (else
          (cons (car lat)
                (multisubset new old 
                             (cdr lat)))))))))

(define add1
  (lambda (x)
    (+ x 1)))

(define sub1
  (lambda (x)
    (- x 1)))




; (define +
;   (lambda (n m)
;     (cond 
;       ((zero? m) n)
;       (else (add1 (+ n (sub1 m)))))))
; 
; (define -
;   (lambda (n m)
;     (cond 
;       ((zero? m) n)
;       (else (sub1 (- n (sub1 m)))))))
;
;
;
;;;  Can you describe how (- n m) works??
;;;    It takes two numbers as arguments,and reduces the second until it hits zeros.
;;;    It subtracts one from the result as many times as it did to cause the second 
;;;    one to reach zero!!!

;if add the box above the wrong to the expr define

;;;  What is the natural terminal condition for a list?
;;;              (null? l)
;;;
;;;  What is the natural terminal conditon for a tup?
;;;              (null? tup)
;;;              
;;; When we build a number from a list of numbers, what should the terminal condition line look like?
;;;               ((null? tup) 0)  ,just as ((null? l) (quote ()))  is ofter the terminal conditon line
;;;               for lists
;;;     So what is the terminal condition line of addtup?
;;;           What does addtup do?
;;;             It builds a number by totalling all the numbers in its arguments
;;;
;;;
;;; What is used in the natural recursion on a list?
;;;       (cdr lat)
;;;
;;; What is used in the natural recursion on a tup?
;;;        (cdr tup)
;;; Why?
;;;      Because the rest of a non-empty list is a list
;;;              The rest of a non-empty tup  is a tup
;;;
;;;
;;; How is a number defined?
;;;    It is either zero or it is one added to a res,
;;;           where rest is again  a number
;;;
;;; what is  the natural terminal condition for numbers?
;;;         (zero? n)
;;;
;;; What is the natural recursion on a number? (sub1 n)            (Cdr tup)  (cdr l)
;;;        (how many questions do we need to ask about a number?   ---------------&amp;lt; two
;;;
;;;        So The first commandments(revision)
;;;          When recurring on a list of atoms,lat, ask two questions about it: (null? lat) and else
;;;          When recurring on a number,n ,as two questions about it:(zero? n) and else
;;;
;;;
;;;    and What is the terminal condition line of addtup
;;;           ((null? tup) 0)
;;; So what is the natural recursion for addtup?
;;;           (addtup (cdr tup))
;;;
;;;     what does addtup use to build a number?
;;;               It uses + , because + builds numbers, too!!!!!!!!!!!!!!!!!!!!!!!!!!!
;;;
;;;
(define addtup
  (lambda (tup)
    (cond 
      ((null? tup) 0)
      (else (+ (car tup) (addtup (cdr tup)))))))

       ;;(cons (car tup) (addtup (cdr tup)))))))   The last line of function rember is the similar to the one in the addtup!!!!
       ;;
;;;; The fourth commandments(revision)
;;;  Always change at least one arguments while recurring. It must be changed to be closer to termination.The changing argument must
;;;  be tested in the termination condition:
;;;         when using cdr, test termination with  null? and
;;;         when using sub1, test termination with zero


(define expr
  (lambda (n m)
    (cond
      ((zero? m) 1)
      (else (* n (expr n (sub1 m)))))))


(define multiplication
  (lambda (n m)
    (cond 
      ((zero? m) 0)
      (else (+ n (multiplication n (sub1 m)))))))

(define divide
  (lambda ( n m)
    (cond
      ((&amp;lt; n m ) 0)
      (else (add1 (divide (- n m) m))))))


(define pick 
  (lambda (n lat)
    (cond 
      ((zero? (sub1 n)) (car lat))
      (else (pick (sub1 n) (cdr lat))))))

;;; Can you write number? which is true if its argument is a numerica atom and false if it is anything else
;;;      No:number? like add1,sub1,zero?,car , cdr, cons,null?, eq?,and atom? is a primitive function
;;;
;;;      Can you write a function no-nums which gives as a final value a lat obtained by removing all the
;;;      numbers from the lat.

;;; after (define rempick)  --------------------------------------------&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;
(define no-nums
  (lambda (lat)
    (cond
      ((null? lat) (quote ()))
      (else
       (cond
         ((number? (car lat))
          (no-nums (cdr lat)))
         (else (cons (car lat)
                     (no-nums (cdr lat)))))))))

(define all-nums
  (lambda (lat)
    (cond
      ((null? lat) (quote ()))
      (else 
       (cond
         ((number? (car lat))
          (cons (car lat)
                (all-nums (cdr lat))))
         (else (all-nums (cdr lat))))))))

;;;;     after the define of eqan? (define eqan?)
;;;what does occur do?
;;;        the function occur which counts the number of times an atom a appears in a lat
(define occur
  (lambda (a lat)
    (cond 
      ((null? lat) 0)
      (else
       (cond
         ((eq? (car lat) a)
          (add1 (occur a (cdr lat))))
         (else (occur a (cdr lat))))))))

(define one?
  (lambda (n)
    (cond 
      ((zero? n) #f)
      (else (zero? (sub1 n))))))

(define one1? 
  (lambda (n)
    (cond
      (= n 1)
      (else #f))))
(define one11?
  (lambda (n)
    (= n 1)))
;;; Guess how we can further simplify this  function ,maing it a one-liner
;;;       By removing the (cond )clause.

(define negativeone?
  (lambda (n)
    (cond 
      ((zero? n) #f)
      (else (zero? (add1 n))))))

(define rember*
  (lambda (a l)
    (cond
      ((null? l) (quote ()))
      ((atom? (car l))
       (cond 
         ((eq? (car l) a)
          (rember* a (cdr l)))
         (else (cons (car l)
                     (rember* a (cdr l))))))
     (else (cons (rember* a (car l))
           (rember* a (cdr l)))))))

;;; After rember*            (define rember*) -----------------------------------------&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;
;;; How are insertR* and rember* similar?
;;;        0--------------------Each function asks three questions,. Each function recurs on the car
;;;                  of its argument when it finds out that the argument&#39;s car is a list
;;;                  namely,They both recur with car,whenever the car is alist,as well as with the cdr
;;; ******************************************************************************************************************
;;;        The first commandments(Final version)
;;;          When recurring on  a list of atoms,lat,ask two questions about it:
;;;                       (null? lat) and else
;;;          When recurring on a number,n ,ask two questions about it:
;;;                       (zero? n) and else.
;;;          When recurring on a list of S-expression,l ,ask three questtion,about it:
;;;                       (null? l),(atom? (car l)) , and else
;;;
;;;
;;; ******************************************************************************************************************
;;; How are rember* and multirember different?
;;;         The function multirember does not recur with the car. The function rember* recurs with the car when if
;;;           finds out that the car is a list
;;;
;;; So how are all *-functions similar?
;;;          They all ask three questions and recur with the car as well as   with the cdr,whenever the car is a list
;;;          Why?
;;;                             Because all *-functions work on lists that are either 
;;;                                                                      ---empty
;;;                                                                      ---an atom consed onto a list,or
;;;                                                                      ---a list consed onto a list
;;;
;;; ******************************************************************************************************************
;;;
;;;         TheFourthe commandments(final version)
;;;             Always change at least one argument while recurring. 
;;;              when recurring on alist of atoms, lat,use (cdr lat.
;;;              When recurring on a number,n ,use (sub1 n). And  
;;;              when recurring on a list of S-expressions,l,use (car l) and (cdr l) if neither (null? l) nor (atom? (car l) are true
;;;
;;;              It must be changed to be closer to termination. The changing argument must be tested in the termination condition:
;;;                     When using cdr, test termination with null? and
;;;                     When using sub1, test termination with zero?
;;; ******************************************************************************************************************
(define insertR*
  (lambda (new old l)
    (cond 
      ((null? l) (quote ()))
      ((atom? (car l))
       (cond 
         ((eq? (car l) old)
          (cons old
                (cons new (insertR* new old (cdr l)))))
         (else (cons (car l)
                     (insertR* new old
                               (cdr l)))))
       (else (cons (insertR* new old
                            (car l))
             (insertR* new old (cdr l))))))))

;;; 
(define insertL*
  (lambda (new old l)
    (cond 
      ((null? l) (quote ()))
      ((atom? (car l))
       (cond 
         ((eq? (car l) old)
          (cons new
                (cons old (insertR* new old (cdr l)))))
         (else (cons (car l)
                     (insertL* new old
                               (cdr l)))))
       (else (cons (insertL* new old
                            (car l))
             (insertL* new old (cdr l)))))))


(define occur*
  (lambda (a l)
    (cond
      ((null? l) 0)
      ((atom? (car l 0))
       (cond
         ((eq? (car l) a)
          (add1 (occur* a (cdr l))))
         (else 
          (occur* a (cdr l)))))
      (else
       (+ (occur* a (car l))
          (occur* a (cdr l)))))))

;;;;
;;;  I introuduce how the (or (null? l) (atom? a))  works,Then I can go on 
;;;    introuducing the member
;;; else implicit said that if the condition is wrong do it recurly
;;;      also infer that after the recuring ,please go back to home along the Original road!
(define member*
  (lambda (a l)
    (cond
      ((null? l) #f)
      ((atom? (car l))
       (or (eq? (car l) a)
           (member* a (cdr l))))
      (else
       (or (member* a (car l))
           (member* a (cdr l)))))))
;;;
;;; The function tells:
;;;          (condition return values)
;;; Can you write down the definition of the function member? and its arguments
;;;     and refer to them as you go through the next group of questions????
(define member?
  (lambda (a lat)
    (cond
      ((null? lat) #f)
      (else (or (eq? (car lat) a)
                (member? a (cdr lat)))))))



(define first
  (lambda (p)
    (cond (else (car p)))))

(define second
  (lambda (p)
    (cond
      (else (car (cdr p))))))

;;;;Could  after (define subset? )        write a function (intersect?)
(define intersect?
  (lambda (set1 set2)
    (cond
      ((null? set1) #f)
      (else
        (cond
          ((member? (car set1) set2) #t)
          (else 
            (intersect? 
              (cdr set1) set2)))))))

(define intersect1?
  (lambda (set1 set2)
    (cond
      ((null? set1) #f)
      ((member? (car set1) set2) #t)
      (else 
            (intersect1? 
              (cdr set1) set2)))))

(define intersect2?
  (lambda (set1 set2)
    (cond
      ((null? set1) #f)
      (else (or (member? (car set1) set2)
                (intersect1? (cdr set1) set2))))))

(define intersect
  (lambda (set1 set2)
    (cond
      ((null? set1) (quote ()))
      ((member? (car set1) set2)
       (cons (car set1)
             (intersect (cdr set1) set2)))
      (else
       (intersect (cdr set1) set2)))))

(define intersect
  (lambda (set1 set2)
    (cond
      ((null? set1) (quote ()))
      ((member? (car set1) set2)
       (cons (car set1)
             (intersect (cdr set1) set2)))
      (else
       (intersect (cdr set1) set2)))))

;;;; In our words: It is a function that return s all the atoms
;;;in set1 that are not in the set2,That is ,xxx is the (set) difference functions=
(define xxx
  (lambda (set1 set2)
    (cond
      ((null? set1) (quote ()))
      ((member? (car set1) set2)
       (xxx (cdr set1) set2)))
      (else
        (cons (car set1)
              (xxx (cdr set1) set2)))))

(define instersectall
  (lambda (l-set)
    (cond
      ((null? (cdr l-set)) (car l-set))
      (else
        (interset (car l-set)
                  (intersectall (cdr l-set)))))))


(define union
  (lambda (set1 set2)
     (cond
       ((null? set1) set2)
       ((member? (car set1) set2)
        (union (cdr set1) set2))
       (else
        (cons (car set1)
              (union (cdr set1) (set2)))))))

(define build 
  (lambda (s1 s2)
    (cond 
      (else (cons s1 
                  (cons s2 (quote ())))))))


;;;;;;;;;;;;;;;;;;;;;;;The first part;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;;
;;;;;;;;;;;;;;;;;;;;;;;The second part;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;  myracet2.rkt ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;;Can you write a function  insert-g that would insert either at the left or at the right!!
;;;
;;;Which pieces differ?
;;;              The second lines differ from each other ,In insertL it is:
;;;               ((eq? (car l) old)
;;;                (cons new (cons old (cdr l))))
;;;               But in the insertR it is:
;;;               ((eq? (car l) old)
;;;                (cons new (cons old (cdr l))))
;;;
;;;         Put the difference in words!
;;;               We say:
;;;                      &amp;quot;The two functions cons old and new in a different order onto the cdr of the list l
;;;
;;;         So how can we get rid of the difference &amp;gt;
;;;                You probably guessed it: by passing in a function that expresses tha appropriate consing.
(define seqL
  (lambda (new old l)
    (cons new (cons old l))))
(define seqR
  (lambda (new old l)
    (cons old (cons new l))))

;;; so you can (insert-g seqL)  (insert-g seqR)
;;; (define insertL (insert-g seqL))
;;; (define insertR (insert-g seqR))
;;;
;;;
(define insert-g
  (lambda (seq)
    (lambda (new old l)
      (cond
        ((null? l) (quote ()))
        ((eq? (car l) old)
         (seq new old (cdr l)))
        (else (cons (car l)
                    ((insert-g seq) new old
                                    (cdr l))))))))
;;; So we can define insertL again with insert-g *****************************^-^************************************
;;; Do not pass in seqL this time.
(define insertL1
  (insert-g
    (lambda (new old l)
      (cons new (cons old l)))))

;;;;;; Perfect--- it is  a great abstraction!
;;;
;;;Is it better?
;;;      Yes,Because youu do not need to remember as many names,you can
;;;      (rember func-name &amp;quot;your-mind&amp;quot;) 
;;;                Where func-name is seqL
;;;
;;;                Do you remember the definition of subst
;;;                Yes! it looks like insert-L  insertR  .Just the answer of the second cond-line is differenct

(define subst
  (lambda (new old l)
    (cond
      ((null? l) (quote ()))
      ((eq? (car l) old)
       (cons new (cdr l)))
      (else (cons (car l)
                  (subst new old (cdr l)))))))

;subst insertL insertR the common property is else and different 
;operator so we can abstract them to the insert-g
(define seqS
  (lambda (new old l)
    (cons new l)))

(define subst1 (insert-g seqS))

(define seqrem
  (lambda (new old l)
    l))
(define yyy
  (lambda (a l)
    ((insert-g seqrem) #f a l)))
;;;;;What do you yyy is?
;;;            Surprise ! It is our old friend rember,
;;;            Step through the evaluation of (yyy a l)
;;;            where 
;;;                a  is sausage
;;;                and l is (pizza with sausage and bacon)
;;;             What role does #f paly?
;;;             New in the insertL and insertR   ,a is old in the insertL and insertR
;;;
;;;
;;;             **********************************************************************
;;;             THe ninth commandments:
;;;              Abstract the common patterns with a new function.
;;;
;;;             **********************************************************************
;;;

;;;So can you simplify the function (define value1)
;;; Can you write the funciton atom-to-function 
;;;         which:
;;;               1: Taes one argument x 
;;;               2: returns the function + if (eq? x (quote +))
;;;                  returns the function * if (eq? x (quote *))
;;;                  returns the function expr if (eq? x (quote expr))
;;;
(define atom-to-function
  (lambda (x)
    (cond
      ((eq? x (quote +) +))
      ((eq? x (quote *) *))
      (else expr))))
;;;(atom-to-function (operator nexp))

(define value3
  (lambda (nexp)
    ((atom? nexp) nexp)
    (else
      ((atom-to-function
         (operator nexp))
       (value3 (1st-sub-exp nexp))
       (value3 (2nd-sub-exp nexp))))))


(define multirember
  (lambda (a lat)
    (cond 
      ((null? lat) (quote ()))
      ((eq? (car lat) a)
       (multirember a (cdr lat)))
      (else (cons (car lat)
                  (multirember a (cdr lat)))))))

(define multirember-f
  (lambda (test?)
    (lambda (a lat)
      (cond 
        ((null? lat) (quote ()))
        ((test? a (car lat))
         ((multirember-f test?) a
                               (cdr lat)))
        (else (cons (car lat)
                    ((multirember test?)  a 
                                          (cdr lat))))))))

(define multirember-eq? (multirember-f &#39;eq?))

;;; After the insturciton os a pair----&amp;gt;  
(define first
  (lambda (p)
    (cond 
      (else (car p)))))
(define second 
  (lambda (p)
    (cond 
      (else (car (cdr p))))))
(define third
  (lambda (p)
    (cond 
      (else (car (cdr (cdr p)))))))
(define third1
  (lambda (l)
    (car (cdr (cdr l)))))
(define build
  (lambda (s1 s2)
    (cond 
      (else (cons s1
                  (cons s2 (quote ())))))))

;;;; After the (define fun?)
;;;
(define revrel
  (lambda (rel)
    (cond
      ((null? rel) (quote ()))
      (else
       (cons (build
              (second  (car rel))
              (first (car rel)))
             (revrel (cdr rel)))))))
;; maybe we can abstract the build part,because it&#39;s the pair part
;;
;; Now do you see how representabtion aids readability????
;;         second   first is the (car (car rel))         second is (car (cdr (car rel)
;; so it can hide the build inverse process 
;;
;; Suppose we had the funciton revpair that reversed the two componets of a pair like this:
;;
(define revpair;;hide the build process
  (lambda (pair)
    (build (second pair) (first pair))))

(define revrel1
  (lambda (rel)
    (cond
      ((null? rel) (quote ()))
      (else
       (cons (revpair (car rel));so it can be hided
             (revrel1 (cdr rel)))))))
(define member?
  (lambda (a lat)
    (cond
      ((null? lat) #f)
      (else (or (eq? (car lat) a)
                (member? a (cdr lat)))))))
  
;;; The 7 chapter ,,after the numbered
(define set?
  (lambda (lat)
    (cond
      ((null? lat) #t)
      (else
       (cond 
         ((member? (car lat) (cdr lat)) #f
               )
         (else
          (set? (cdr lat))))))))

;;; simplify set?              -------------------------&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;
(define set1?
  (lambda (lat)
    (cond 
      ((null? lat) #t)
      ((member? (car lat) (cdr lat)) #f)
      (else (set? (cdr lat))))))
;;; Were you surprised to see the function member? appear in the definition of set?
;;;       You should not be,because we have written memeber? already,and now we can 
;;;       use it whenever we want
         

(define makeset
  (lambda (lat)
    (cond
      ((null? lat) (quote ()))
      ((member? (car lat) (cdr lat))
       (makeset (cdr lat)))
      (else (cons (car lat)
                  (makeset (cdr lat)))))))
(define makeset1
  (lambda (lat)
    (cond
      ((null? lat) (quote ()))
      (else (cons (car lat)
                  (makeset (multirember (car lat) (cdr lat))))))))
;;; Describe in your own words how the second definition of makeset works?????
;;;        Here are our words:
;;;         &amp;quot;&amp;quot;THe function makeset remembers to cons the first atom in the lat onto the result of the
;;;          natural recursion ,after removing all occurences of the first atom from the rest of the lat.
;;;
(define subset?
  (lambda (set1 set2)
    (cond
      ((null? set1) #t)
      (else (cond
              ((member? (car set1) set2)
               (subset? (cdr set1) set2))
              (else #f))))))

;;; can you  write a shorter version of subset?
(define subset1?
  (lambda (set1 set2)
    (cond
      ((null? set1) #t )
      ((member? (car set1) set2)
       (subset? (cdr set1) set2))
      (else #f)))

;;; Try to write subset1? with (and ...)

(define subset2?
  (lambda (set1 set2)
    (cond
      ((null? set1) #t)
      (else
        (and (member? (car set1) set2)
             (subset? (cdr set1) set2))))))

;;; equip list
;;;
(define eqset?
  (lambda (set1 set2)
    (cond
      ((subset? set1 set2)
       (subset? set2 set1))
      (else #f))))

(define eqset1?
  (lambda (set1 set2)
    (cond
      (else
      (and (subset? set1 set2)
       (subset? set2 set1))))))

(define eqset2?
  (lambda (set1 set2)
      (and (subset? set1 set2)
       (subset? set2 set1))))


(define firsts
  (lambda (rel)
    (cond
      ((null? rel) (quote ()))
      (else
       (cons (first (car rel))
             (firsts (cdr rel)))))))
(define seconds
  (lambda (rel)
    (cond
      ((null? rel) (quote ()))
      (else
       (cons (second (car rel))
             (seconds (cdr rel)))))))
;; one important known : in the (else,things is called recur
;; in the cond&#39;s first question is called the end condtion
;; multi and sigle is recognise by the doing&#39;s if satisfied the 
;; questions!
;;
;; After te define (pair)
;;
;;Is fun? a simple one-liner?  It sure is
;;
;;How do we reprensent a finite function?
;;       For us(lispers)m
;;                         a finite function is a list of pairs in which
;;                         no first element of any pair is the same as any
;;                         other first element
(define fun?
  (lambda (rel)
    (set? (firsts rel))))


;
(define fullfun?;;fun is also a relation
  (lambda (fun);;fullfun is based on the fun
    (set? (seconds fun))))

;;fullfun&#39;s another name is one-to-one
;;so we can define it another way
(define one-to-one?
  (lambda (fun)
    (fun? (revrel fun))))


(define expr
  (lambda (n m)
    (cond
      ((zero? m) 1)
      (else
       (* n (expr n (- m 1)))))))

(define cookies
  (lambda ()
    (bake
      (quote (350 degrees))
      (quote (12 minitus))
      (mix
        (quote (walnuts 1 cup))
        (quote (chocolate-chips 16 ounces))
        mix
        (mix
          (quote (flour 2 cups))
          (quote (oatmeal 2 cups))
          (quote (salt .5 teaspoon))
          (quote (baking-powder 1 teaspoon))
          (quote (baking-soda 1 teaspoon)))
        (mix
          (quote (eggs 2 large))
          (quote (vanilla 1 teaspoon))
          (cream
            (quote (butter 1 cup))
            (quote (sugar 2 cups))))))))
;;;  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Y
;;;The Fifth commandments:
;;;  When building a  value with +, always use 0 for the value of the terminating line,for adding 0 does not change the value of an addiction
;;;  When building a  value with *, always use 1 for the value of the termination line,for multiplying 1 does not change the value of a multiplication
;;;  When building a  value with cons, always consider () for the value of the terminating line
;;;  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Y
;;;
;;; What does (tup+ tup1 tup2) do?
;;;         It adds the first number of tup1 to the first number of tup2,then it adds the second number of tup1 to the second number of tup2,etc
;;;               building a tup of answers,for tups of the same length
;;; What is the unusal about tup+?
;;;         It looks at each element of two tups at the same time,or in other words, it recus on two tups.
;;;
;;; If you recur on one tup how many questions do you have to ask?
;;;         two,they are (null? tup) and else
;;;
;;; When recuring on two tups, how many question need to be asked about the tups? 
;;;      Four: if the first tup is empty or none-empty,and if the second tup is empty or non-emptyy
;;;      Do you mean the questions (and (null? tup1) (null? tup2)) (null? tup1) (null? tup2) and else 
;;;
;;;      But can the first tup be () at the same time as the second is other than ().
;;;         No ,because the tups must have the same length
;;;     Does this mean (and (null? tup1) (null? tup2))  and else are the only questions we need to ask?
;;;     Yes!
(define tup+
  (lambda (tup1 tup2)
    (cond
      ((and  (null? tup1) (null? tup2))
       (quote ()))
      (else
        (cons (+ (car tup1) (car tup2))
              (tup+ (cdr tup1) (cdr tup2)))))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;  Why  does the natural recursion include the cdr of bouth arguments?
;;;      Because the typical element of the final value use the car of both tups,so now
;;;      we are ready to consider the rest of both tups -----------------------------&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;Yes the right logic
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define tup++
  (lambda (tup1 tup2)
    (cond
      ((and (null? tup1) (null? tup2)) 
       (quote ()))
      ((null? tup1) tup2)
      ((null? tup2) tup1)
      (else
        (cons (+ (car tup1) (car tup2))
              (tup++  
                (cdr tup1) (cdr tup2)))))))

;;;; can you simplify it????????????????????????????////
(define tup+++
  (lambda (tup1 tup2)
    (cond
      ((null? tup1) tup2)
      ((null? tup2) tup1)
      (else
        (cons (+ (car tup1) (car tup2))
              (tup+++  
                (cdr tup1) (cdr tup2)))))))



(define atom-to-function
  (lambda (x)
    (cond 
      ((eq? x (quote +)) +)
      ((eq? x (quote *)) *)
      ((eq? x (quote ^)) expr)
      ((eq? x (quote eq?)) eq?)
      (else -))))
; (rember-f (atom-to-function &#39;eq?) &#39;ff &#39;(dfds gi ff sd))  
;
; In the common lisp:
;            L: (funcall test? (car l) a) ,use the funcall when invoking a function argument or a function that has 
;            not been defuned
(define rember-f
  (lambda (test? a l)
    (cond 
      ((null? l) (quote ()))
      (else
       (cond 
         ((test? (car l) a) (cdr l));;I think here needs atom2function
         (else (cons (car l)
                     (rember-f test? a 
                               (cdr l)))))))))

;;; The short version! 
(define rember1-f
  (lambda (test? a l)
    (cond 
      ((null? l) (quote ()))
      ((test? (car l) a) (cdr l));;I think here needs atom2function
      (else (cons (car l)
                     (rember-f test? a 
                               (cdr l)))))))
;;; What kind of values can functions return&amp;gt;
;;;                  Lists and atoms
;;;                       But in the eye of us ,all the things are the lists and atoms
;;;                        so we can return all the kind of values
;;;                        so what about function themselves? Yes
;;;                         such as (lambda (a l) ...) is a function of two arguments ,a and l! returns the function!
;;;                 This is calld &amp;quot;Curry-ing&amp;quot;
;;;     In the scheme ,Using (define ...)give the preceding function a name,
;;;     but in theCL: (define eq?-c  (a) (function (lambda (x) (eq x a))))
;;;     while the scheme : (define eq?-c (lambda (a) (lambda (x) (eq? x a))))

(define insertL-f
  (lambda (test?)
    (lambda (new old l)
      (cond 
        (( null? l) (quote ()))
        ((test? (car l) old)
         (cons new (cons old (cdr l))))
        (else (cons (car l)
                    ((insertL-f test?) new old
                                       (cdr l))))))))
(define insertR-f
  (lambda (test?)
    (lambda (new old l)
      (cond 
        (( null? l) (quote ()))
        ((test? (car l) old)
         (cons old (cons new (cdr l))))
        (else (cons (car l)
                    ((insertR-f test?) new old
                                       (cdr l))))))))
;;The basic principle
;;(name --&amp;gt;(null? ---&amp;gt;(eq?    ---&amp;gt;single (cons new (cdr l))    --&amp;gt;(else
;;                            ---&amp;gt;multi (cons new (name (cdr l)))--&amp;gt;(else
;;                ---&amp;gt;(eqan?   ---&amp;gt;single (cons new (cdr l))    --&amp;gt;(else
;;                            ---&amp;gt;multi (cons new (name (cdr l)))--&amp;gt;(else
;;                ---&amp;gt;(equal?  ---&amp;gt;single (cons new (cdr l))    --&amp;gt;(else
;;                            ---&amp;gt;multi (cons new (name (cdr l)))--&amp;gt;(else
;;                ---&amp;gt;(eqlist? ---&amp;gt;single (cons new (cdr l))    --&amp;gt;(else
;;                            ---&amp;gt;multi (cons new (name (cdr l)))--&amp;gt;(else
;;sometimes we abstuct the condition to adapt to different state
;; sometimes we abstuct the operations to simplify it
(define multirember1 
 (lambda (a lat)
   (cond
     ((null? lat) (quote ()))
     ((eq? (car lat) a)
      (multirember a (cdr lat)))
     (else (cons (car lat)
                 (multirember a (cdr lat)))))))
(define multirember1-f
  (lambda (test?)
    (lambda (a lat)
      (cond
        ((null? lat) (quote ()))
        ((test? a (car lat))
         ((multirember1-f test?) a 
                                (cdr lat)))
        (else (cons (car lat)
                    ((multirember1-f test?)  a 
                                            (cdr lat))))))))
;;((multirember1-f (atom-to-function &#39;eq?)) &#39;fd &#39;(sgs fd gasdg fd))
;;&#39;(sgs gasdg)
;;(define multirember1-eq (multirember1-f (atom-to-function &#39;eq?)))
;;Actually:
;;((multirember1-f eq?) &#39;fd &#39;(gsd fd gjsi fd go))
;;direct apply function eq?,That doesn&#39;t need (eq?, I learn from
;; (multiremberT eq?-salad)
(define rembern
  (lambda (a l)
    ((insert-g seqrem) #f a l)));;seqrem doesn&#39;t need (seqrem solve my ?.
(define seqrem
  (lambda (new old l) 
    l))

(define multiremberT
  (lambda (test? lat)
    (cond
      ((null? lat) (quote ()))
      ((test? (car lat))
       (multiremberT test? (cdr lat)))
      (else
       (cons (car lat)
             (multiremberT test? 
                           (cdr lat)))))))
(define eq?-c
  (lambda (a)
    (lambda (x)
      (eq? x a))))
(define eq?-salad (eq?-c &#39;salad))
;;(multiremberT eq?-salad &#39;(fsfd salad fsdf sald sg salad))

;;; What is the name of the third arguments that multiremberco uses for the natural recursion?
;;; what is the name of the third argument ? And do you know what col stands for?
;;;       The name col is short for &amp;quot;collector&amp;quot;, A collector is sometimes called a continuation
(define multiremberco
  (lambda (a lat col)
    (cond 
      ((null? lat)
       (col (quote ()) (quote ())))
      ((eq? (car lat) a)
       (multiremberco a 
                      (cdr lat)
                      (lambda (newlat seen) 
                        (col newlat (cons (car lat) seen)))))
      (else
       (multiremberco a 
                      (cdr lat)
        )             (lambda (newlat seen)
                        (col (cons (car lat) newlat)
                             seen)))))))

(define a-friend
  (lambda (x y)
    (null? y)))
;(multiremberco &#39;tuna &#39;(sfds tuna fsd jif) a-friend)
;#f
;&amp;gt; (multiremberco &#39;tuna &#39;(sfds tuna1 fsd jif) a-friend)
;#t
;;how can  you get another value in the col
;;
;;can you write this definition differently!  Do you mean the new way where we put tuna into the definition?
;;  col is to a-frined what (car lat) is to tuna.   so we can replace the col with a-frined
;;
(define new-friend
  (lambda (newlat seen)
    (a-friend newlat
         (cons (quote tuna) seen))))

;;;; So ANd now?
;;;      multiremberco finds out that(null? lat) is true, which means that it uses the collector on two empty lists.
;;;        which collector is this?
;;;          It is new-friend.
;;; how does a-friend differ from new-friend ?
;;;              New-friend uses a-friend on the empty list and 
;;;               the value of (cons (quote tuna) (quote ()))
;;;
;;; And what does the old-collector do (a-friend) with such arguments?
;;;              It answers #f,because its second argument is (tuna),which is not the empty list!

;;;;;;;; I don&#39;t know that the list length ,so easy but I don&#39;t think it clearly!!!!
;;;What is terminal condition ?  (null? lat)
;;;what is terminal condition line ? ((null? lat) 0)   (terminal_contition terminal_value)
;;;what is the (+1 (length (cdr lat)))
;;;        build the number with +,so the terminal condition line is ((null? lat) 0)   use (cdr lat) to closer the terminal!
(define length
  (lambda (lat)
    (cond 
      ((null? lat) 0)
      (else (+ 1 (length (cdr lat)))))))

;;; a is tuna and lat is (and tuna)  col is a-friend
(define latest-friend
  (lambda (newlat seen)
    (a-friend (cons (quotee and) newlat)
              seen))))

;;The third collector : the last-friend
(define last-friend
  (lambda (newlat seen)
    (length newlat)))
;;;;;;;;;;;;;****************************************************************************
;;;;;;;;;;;;;****************************************************************************
;;;;;;;;;;;;;****************************************************************************
;;;;So  what does (multiremberco a lat f) do?
;;;      It looks at every atom of the lat to see whether 
;;;      it is eq? to a.Those atoms that are  not  are collected in one list ls1
;;;      it is eq? to a.The others which the answer is true    are collected in second list ls2
;;;
;;;      Finally  it determine the value of (f ls1 ls2)
;;;
;;;      Namely under the process of time(timestep=0,1,2,3,n-1),In the col it classify the data: use cons 
;;;              while at the last time(timestep=n) in the a-friend (col) it determine the cons datas!!

;;;;;;;;;;;;;****************************************************************************
;;;;;;;;;;;;;****************************************************************************
;;;;;;;;;;;;;****************************************************************************
;;;;;;;;;;;;;****************************************************************************
;;;        The Tenth commandments:
;;;            Build functions to collect more than one value at a time.
;;;
;;;;;;;;;;;;;****************************************************************************
;&amp;gt; (multiremberco &#39;tuna &#39;(tunanfdfj tuan jsidjf tuna) last-friend)
;3

;;actually
;;The basic principle
;;(name --&amp;gt;(null? (col (quote()...)---&amp;gt;(eq?    ---&amp;gt;single (cons new (cdr l))    --&amp;gt;(else
;;                            ---&amp;gt;multi (cons new (name (cdr l)))--&amp;gt;(else
;;                ---&amp;gt;(eqan?   ---&amp;gt;single (cons new (cdr l))    --&amp;gt;(else
;;                            ---&amp;gt;multi (cons new (name (cdr l)))--&amp;gt;(else
;;                ---&amp;gt;(equal?  ---&amp;gt;single (cons new (cdr l))    --&amp;gt;(else
;;                            ---&amp;gt;multi (cons new (name (cdr l)))--&amp;gt;(else
;;                ---&amp;gt;(eqlist? ---&amp;gt;single (cons new (cdr l))    --&amp;gt;(else
;;                            ---&amp;gt;multi (cons new (name (cdr l)))--&amp;gt;(else
;;sometimes we abstuct the condition to adapt to different state
;; sometimes we abstuct the operations to simplify it
;;multiremboco sometimes we want to change the return value,so co it

(define multiinsertLR
  (lambda (new oldL oldR lat)
    (cond
      ((null? lat) (quote ()))
      ((eq? (car lat) oldL)
       (cons new 
             (cons oldL
                   (multiinsertLR new oldL oldR
                                  (cdr lat)))))
      ((eq? (car lat) oldR)
       (cons oldR
             (cons new
                   (multiinsertLR new oldL oldR
                                 (cdr lat)))))
      (else
        (cons (car lat)
              (multiinsertLR new oldL oldR (cdr lat)))))))

;;;; The function multiinsertLRco is to multiinsertLR what multiremberco is to multirember
;;;           Does this mean that multiinsertLRco takes one more argument than multiinsertLR?
;;;            Yes! and what kind of argument is it? 
;;;                   It is a collector function.
(define multiinsertLRco
  (lambda (new oldL oldR lat col)
    (cond
      ((null? lat)
       (col (quote ()) 0 0))
      ((eq? (car lat) oldL)
       (multiinsertLRco new oldL oldR
                        (cdr lat)
                        (lambda (newlat L R)
                          (col (cons new 
                                     (cons oldL newlat))
                               (+ 1 L) R))))
      ((eq? (car lat) oldR)
       (multiinsertLRco new oldL oldR
                        (cdr lat)
                        (lambda (newlat L R)
                          (col (cons oldR
                                     (cons new newlat))
                               L (+ 1 R)))))
      (else
       (multiinsertLRco new oldL oldR 
                        (cdr lat)
                        (lambda (newlat L R)
                          (col (cons (car lat) newlat)
                               L R)))))))

(define even?
  (lambda (n)
    (= (* (/ n 2) 2) n)))

(define /  ;rewrite the divide to replace the origianl divide from Drracket
  (lambda (n m)
    (cond
      ((&amp;lt; n m) 0)
      (else
       (+ 1 (/ (- n m) m))))))
(define evens-only*
  (lambda (l)
    (cond
      ((null? l) (quote ()))
      ((atom? (car l))
       (cond
         ((even? (car l))
          (cons (car l)
                (evens-only* (cdr l))))
         (else
          (evens-only* (cdr l)))))
      (else (cons (evens-only* (car l))
                  (evens-only* (cdr l)))))))
(define atom?
  (lambda (x)
    (and (not (pair? x)) (not (null? x)))))

;;;  Can you explain what (evens-only*co (carl) ...) accomplishes?
;;;      It visits every number in the car of l and collects the list without odd numbers,the
;;;      product of the even numbers,and the sum of the odd numbers.
;;;      So it is the most complicated,actually not very easy to be understood!
;;;         You can understand with another lat,so you how to associate two lat!
;;;         Youknow (even? (car l)) is in  a lat,so it do +*cons in the lat&#39;s number!
;;;
(define evens-only*co
  (lambda (l col)
    (cond
      ((null? l)
       (col (quote ()) 1 0))
      ((atom? (car l))
       (cond 
         ((even? (car l))
          (evens-only*co (cdr l)
                         (lambda (newl p s)
                           (col (cons (car l) newl);if it is evens ,so cons it into the newl
                                (* (car l) p) s))))
         (else (evens-only*co (cdr l)
                              (lambda (newl p s)
                                (col newl p (+ (car l) s)))))))
       (else (evens-only*co (car l)
                            (lambda (al ap as)
                              (evens-only*co (cdr l)
                                             (lambda (dl dp ds)
                                               (col (cons al dl)
                                                    (* ap dp)
                                                    (+ as ds))))))))))

;the fourth collector :: the last-last-friend
(define the-last-last-friend
  (lambda (newl product sum)
    (cons sum 
          (cons product 
                newl))))
;&amp;gt; (evens-only*co &#39;(45389 63 45 6 4 234  6 4 23 52 43) the-last-last-friend)
;&#39;(45563 7008768 6 4 234 6 4 52)

;;;;  after the length !!!!(define length) -------------------------------------&amp;lt;
;;;  use car !!   zero?  sub1
(define pick
  (lambda (n lat)
    (cond
      ((zero? (sub1 n)) (car lat))
      (else (pick (sub1 n) (cdr lat))))))

(define rempick
  (lambda (n lat)
    (cond 
      ((zero? (sub1 n)) (cdr lat))
      (else (cons (car lat)
                  (rempick (sub1 n) (cdr lat))))
      ;;;; because n  lat is occur in the terminal condition!!!!!
;;; use the function one? to rewrite the function rempick that removes the nth atom from a lat.
;;;
;;;
(define rempick1
  (lambda (n lat)
    (cond 
      ((one? n) (cdr lat))
      (else (cons (car lat)
                  (rempick ((sub1 n)
                            (cdr lat))))))))

(define keep-looking
  (lambda (a sorn lat)
    (cond
      ((number? sorn)
       (keep-looking a (pick sorn lat) lat))
      (else (eq? sorn a)))))

(define looking
  (lambda (a lat)
    (keep-looking a (pick 1 lat) lat)))
;&amp;gt; (looking &#39;cavier &#39;(6 2 4 cavier 5 7 3))
;#t

(define eternity
  (lambda (x)
    (eternity x)))
;;it doesn&#39;t stop ,because the goal is not absolutely, rather then
;; 相对的

;;; This is trivival; It&#39;s not even recursive
;;; What does shift do?
;;;   Here are our words:
;;;     The shift function takes a pair whose first component is a pair and builds a pair
;;;     by shifting the second part of the first component into the second component!
;;;
;;;     So what is the meaning of component?  --------Component can means atom,pair and list
;;;                  Now it means pair.
(define shift 
  (lambda (pair)
    (build (first (first pair))
           (build (second (first pair))
                  (second pair)))))
;&amp;gt; (shift &#39;((fsd fd)(fd gs)))
;&#39;(fsd (fd (fd gs)))
(define align
  (lambda (pora)
    (cond 
      ((atom? pora) pora)
      ((a-pair? (first pora))
       (align (shift pora)))
      (else (build (first pora)
                   (align (second pora)))))))
;;; What does it  have in common with keep-looking 
;;;          Both functions change their arguments for their recursive uses but in neither
;;;          case is the change guaranteed to get us closer to the goal
;;;
;;; Why are we not guaranteed that align makes progress?
;;;                In the second cond-line shift creates an argument for align that 
;;;                is not a part of the original argument.
;;;
;;; Which commandment does that violate?
;;;              The Seventh Commandment.
;;;
;;; Is the new argument at least  smaller than the original one?
;;;            It does not look that way
;;;
;;; Why not?
;;;           The function shift only rearranges the pair it gets.
;;; And?
;;;           Both the result and the argument of shift have the same number of atoms.
;;; Can you write a function that counts the number of atoms
;;; After the (define intersectall)
;;;
;;;align do what shift can&#39;t do?
;;;        Such as  (align &#39;(a b))         but (shift &#39;(a b)) will get wrong message.
(define a-pair?
  (lambda (x)
    (cond
      ((atom? x) #f)
      ((null? x) #f)
      ((null? (cdr x)) #f)
      ((null? (cdr (cdr x))) #t)
      (else #f))))
;;; how can you refer to the first S-expression of a pair?
;;;      By taking the car of the pari
;;; How can you refer to the second S-expression of a pair?
;;;      By taking the car of the cdr of the pair
;;;
;;; How can you build a pair with two atoms?
;;;  You cons the first ne onto the cons of the second one onto (). Thatis (cons x1 (cons x2 (quote ())))
;;;
;;;  How can you build a pair with two S-expressions?
;;;   you cns the first one onto the cons of the second one onto ().That is
;;;   (cons s1 (cons s2 (quote ()))) or (cons x1 (cons x2 (quote ())))
;;;
;;;   Did you notice the difference between the last two answers?
;;;     No ,there aren&#39;t any
;;;
;;;Is align a partial function?
;;;        We don&#39;t now yet.There may be arguments for which it keeps aligning things.
;;;
;;; Is there something else that changes about the arguments to align and its recursive uses?
;;;        Yes, there is .The first component of a  pair becomes simpler,though the second component becomes more complicated
;;;
;;; In what way is the first component simpler?
;;;       IT is only a part (IT intelligent technique is equal to it) of the original pair&#39;s first component.
;;;
;;; Doesn&#39;t this mean that lenght * is the wrong function for determining the length of the argument? Can you find a better function
;;;         A better function should pay more attention to the first component
;;;
;;; How much more attention should we pay to the first component?
;;;          At least twice as much
;;;          Do you mean something like weight*
;;;     DOes This mean that the arguments get simpler?
;;;       Yes ,the weigth* of align&#39;s arguments become successively smaller
;;;     Is align a partial function?
;;;        No,it yields a value for every argument rather than the partial function looking and looking again.
;;;
(define length*
  (lambda (pora)
    (cond 
      (( atom? pora) 1)
      (else
       (+ (length* (first pora))
          (length* (second pora)))))))

(define weight*
  (lambda (pora)
    (cond 
      ((atom? pora) 1)
      (else
       (+ (* (weight* (first pora)) 2)
          (weight* (second pora)))))))

;;;  Here is shuffle which is like align but uses revpair from chapter7, instead of shift:(when the first component is a-pair?
;;;       THen do revpair.
;;; The function shuffle and revpair swap the components of pairs when the first component is a pair...
;;;
;;; Does this mean that shuffle is total?
;;;        We don&#39;t know yet.(actually  it is not.)
;;; Okay,let&#39;s do something interesting. What is the value of (shuffle x) where x is ((a b) (c d))
;;;
;;; And how are you going to do that?
;;;          We are going to determine the value (shuffle pora) where pora is ((c d) (a b))
;;;
;;; Doesn&#39;t this mean that we need to know the value of (shuffle (revpair pora))
;;;            where (revpair pora) is ((a b) (c d))  , yes we do.
;;;
;;; And?
;;;         The function shuffle is not total because it now swaps the components of the pair again, which means that we start all over.
(define shuffle
  (lambda (pora)
    (cond
      ((atom? pora) pora)
      ((a-pair? (first pora))
       (shuffle (revpair pora)))
      (else (build (first pora)
                   (shuffle (second pora)))))))
;&amp;gt; (shuffle &#39;(a (b c)))
;&#39;(a (b c))
;&amp;gt; (shuffle &#39;(a b c))
;&#39;(a b)
;&amp;gt; (shuffle &#39;(a b))
;&#39;(a b)
;;;;         Thankyou ,Lother Collatz(1910-1990)! It doesn&#39;t yield a value for 0, but otherwise nobody knows.
(define C
  (lambda (n)
    (cond
      ((one? n) 1)
      (else
        (cond
          ((even? n) (C (/ n 2)))
          (else (C (add1 (* 3 n)))))))))

;;;;          Thank you,Wilhelm ackermann(1853-1946)
(define A
  (lambda (n m)
    (cond
      ((zero? n) (+ 1 m))
      ((zero? m) (A (- 1 n) 1))
      (else (A (sub1 n)
               (A n (sub1 m)))))))
;;; What does A have in common with shuffle and looking?
;;;         A&#39;s arguments ,like shuffle&#39;s and looking&#39;s,  do not necessarily decrease for the recursion
;;;
;;; Dose A always give an answer? 
;;;         Yes,it&#39;s total
;;;
;;; Wouldn&#39;t it be great if we could write a function that tells us whether some function returns with a 
;;; value for every  argument.
;;;        It sure would.Now that we have seen function that never return a value or return a value so lat that 
;;;        it is too late ,we should have some tool like this around
;;;Okay,let&#39;s write it
;;;
;;;            It sounds complicated.A function can work for many different arguments
;;; Then let&#39;s make it simpler.For a warm-up exercise,let&#39;s focus on a function that checks whether some function stops
;;; for just the empty list,the simplest of all arguments.
;;;          That world simplify it a lot
;;; Here is the beginning of this function:
;;;
;;; (define will-stop?  (lambda (f) ...)))
;;;
;;;
;;; What does it do?  Do will-stop? return a value for all arguments?
;;; That&#39;s the easy part: we said that it either returns #t or #f,depending on whether the argument stops when applied to ()
;;;
;;; Is will-stop? total then?
;;;   Yes,it is.It always return #t or #f
;;;
;;;okay here is  a function that could be an interesting argument for will-stop?
(define last-try
  (lambda(x)
    (and (will-stop? last-try)
         (eternity x)))))

    ;;; what is (will-stop? last-try)
    ;;;
    ;;; What does it do?
    ;;;
    ;;; Here is our meaning:
    ;;;    &amp;quot;we took a really close look at the two possible cases.IF we can define will-stop?,
    ;;;     then (will-stop? last-try) must yield either #t or #f.Bu it cannot- due to the very
    ;;;     definition of what will-stop? is supposed to do.This must mean that will-stop? cannot 
    ;;;     be defined&amp;quot;
    ;;;
    ;;;     Because you know,let&#39;s make up some examples.
    ;;;     what is the value of (will-stop? last-try) (eternity (quote ()))))
    ;;;         That depends on the value of (will-stop? last-try)
    ;;;
    ;;;         we said that will-stop? will stop,so it must return #t or #f,
    ;;;         let&#39;s say (will-stop? last-try) is #f ,yes,itis .we predict just the opposite
    ;;;            if the value of (will-stop? last-try) is #f,which really means that last-try
    ;;;            will not stop..
    ;;;        So we must have been wrong about (will-stop? last-try) (because it cannot be stopped)
    ;;;               That&#39;s correct.It must return #t,because will-stop? always gives an answer. we
    ;;;               said it total(assume)
    ;;;         Fine. If(will-stop? last-try) is #t. What is the value of (last-try (quote ())) in the definition of last-try.
    ;;;           Now we just need to determine the value of (and #t (eternity (quote ()))
    ;;;           which is the same as the value of (eternity (quote ()))
    ;;;
    ;;;           What is the value of (eternity (quote ())) 
    ;;;                 It doesn&#39;t have a value.we know that it doesn&#39;t stop
    ;;;                 !
    ;;;         But that means that we were wrong again!!! The will-stop? neither return #f nor #t. What the hell
    ;;;                will-stop? will return?
    ;;;
    ;;;         So will-stop? cannot be defined.
    ;;;         Is this unique?
    ;;;                Yes , it is .It makes will-stop? the first function that we can describe percisely but cannot 
    ;;;                define in our language.
    ;;;
    ;;;         Is there any way around this problem?
    ;;;                No ,thank you  ,Alan M. Turing (1912-1954)
    ;;;                and Kurt Godel(1906-1978)
    ;;;
    ;;;         What is (define...)
    ;;;                 That is an interesting question. We just saw that (define...) doesn&#39;t work for will-stop?.
    ;;;
    ;;;             So what are the recurive definition?
    ;;;               Hold tight,take a deep breath,and plunge forward when you&#39;re ready.


;;;;;;;;;;;;;;;;;;;;;;;The second part;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;****************;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;;
;;;
;;;;;;;;;;;;;;;;;;;;;;;The third part;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;   myracet3.rkt;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define length 
  (lambda (l)
    (cond 
      ((null? l) 0)
      (else (+ 1 (length (cdr l)))))))
(define eternity
  (lambda (x)
    (eternity x)))
(lambda (l)
    (cond 
      ((null? l ) 0)
      (else (+ 1 (eternity (cdr l))))))
;length&amp;lt;=1
(lambda (l)
    (cond 
      ((null? l) 0)
      (else 
       (+ 1 
          ((lambda (l)
             (cond 
               ((null? l) 0)
               (else (+ 1 
                        (eternity (cdr l))))))
           (cdr l))))))

;length &amp;lt;=2
(lambda (l)
    (cond 
      ((null? l) 0)
      (else
       (+ 1
        ((lambda (l)
           (cond
             ((null? l) 0)
             (else 
              (+ 1
                 ((lambda (l)
                    (cond
                      ((null? l) 0)
                      (else
                       (+ 1
                          (eternity
                           (cdr l))))))
                  (cdr l))))))
         (cdr l))))))

;;; Now what do you thin recursion is?
;;;           What do you mean?
;;;
;;; Well,we have seen how to determine the length of a list with no items,with no more that
;;; one item,with no more than two items,and so on. How could we get the function length back.
;;;           If we could write an infinite function in the style of length0 ,length1,length2..
;;;           then we could write lengthinfinite,which would determine the length of all lists
;;;           we can make.
;;;     But we cannot write an infinite function. No we can&#39;t, (yes ,we can&#39;t mae it)
;;;
;;;      And we still have all these repetitions and patterns in these functions. yes we do.
;;;
;;;      What do these pattern look like?
;;;               All these programs contain a function that looks like length.Perhaps we should
;;;               abstract out this function: see The Ninth Commandment.
;;;     We need a function that looks just lie length but starts with (lambda (length) ...).
;;;
;;;Do you mean this?
;;;((lambda (length)
;;;(lambda (l)  (cond ((null? l) 0)  (else (add1 (length (cdr l)))))) eternity)
;;;       Yes,that&#39;s okay. It creates length0
;;;so rewrite length1  in the same style
;;;See below.
;;;
;;;
;we need a function that looks just like length 
;but starts with (lambda (length)...) and inside it is not 
;(lambda (length) but maybe (lambda (l)
;length0
(lambda (legnth)
  (lambda (l)
      (cond 
        ((null? l) 0)
        (else (add1 (length (cdr l))))))
    eternity)


;length1
((lambda (f)
    (lambda (l)
      (cond 
        ((null? l) 0)
        (else 
         (+ 1 (f (cdr l)))))))
   ((lambda (g)
      (lambda (l)
        (cond 
          ((null? l) 0)
          (else (+ 1 (g (cdr l)))))))
    eternity))

;;  Do we have to use length to name the argument?
;;         No ,we just used f and g. As long as we are consistent,everything&#39;s okay
;length2
;;length &amp;lt;=2
((lambda (length)
   (lambda (l)
     (cond
       ((null? l) 0)
       (else (+ 1 (length (cdr l)))))))
 ((lambda (length)
    (lambda (l)
      (cond
        ((null? l) 0)
        (else (+ 1 (length (cdr l)))))))
  ((lambda (length)
     (lambda (l)
       (cond
         ((null? l) 0)
         (else (+ 1 (length (cdr l)))))))
   eternity)))

;;; close,  But there are still repetitions.  True,let&#39;s get rid of it.
;;;
;;;  Where should we start?
;;;         Name the function that takes length as an argument and that returns a function that looks like length.
;;;  What&#39;s a good-name for this function?
;;;           how about mk-length  for &amp;quot;make length&amp;quot;
;;;
;let eternity move ahead , eternity in the first part
((lambda (mk-length)
   (mk-length eternity))
 (lambda (length)
   (lambda (l)
     (cond 
       ((null? l) 0)
       (else (+ 1 (length (cdr l))))))))

((lambda (mk-length)
   ;;提取池
   (mk-length 
    (mk-length eternity)))
 ;;发生池
 (lambda (length)
   (lambda (l)
     (cond 
       ((null? l) 0)
       (else (+ 1 (length (cdr l))))))))
;;length&amp;lt;=2
((lambda (mk-length)
   ;;提取池
   (mk-length 
    (mk-length 
     (mk-length eternity))))
 ;;发生池
 (lambda (length)
   (lambda (l)
     (cond 
       ((null? l) 0)
       (else (+ 1 (length (cdr l))))))))
 ;;length &amp;lt;=3
 ((lambda (mk-length)
   ;;提取池
   (mk-length 
    (mk-length 
     (mk-length
      (mk-length eternity)))))

  ;;;;              So   What is recursion like?
  ;;;                             It is like an infinite tower of applications of mk-length to ab arbitrary function.
  ;;;               Do you really need an infinite tower?
  ;;;                      Not really of course.Everytime we use length we only need a finite number,but we never know 
  ;;;                      know many.
  ;;;               could we guess how many we need?
  ;;;                     Sure,but we may not guess a large enough number!
  ;;;               When do  we  find out that we didn&#39;t guess a large enough number?
  ;;;                     When we apply the function eternity that is  passed to innermost mk-length.
  ;;;               What if we could create another application of mk-length to eternity at this point?
  ;;;                       That would only postpone the problem by one and besides,how could we do that?
  ;;;
  ;;;                Well,since nobody cares what function we passwd to mk-length we could pass it mk-length initially.
  ;;;                      That&#39;s the right idea(right?       )             And then we invoke mk-length on eternity and the 
  ;;;                      result of this on the cdr so that we get one more piece of this tower.
 ;;发生池
 (lambda (length)
   (lambda (l)
     (cond 
       ((null? l) 0)
       (else (+ 1 (length (cdr l))))))))
 
 ;;how if we replace the eternity with the mk-length
 
 ;length0; 因为没有人关心我们到底我们传递什么给mk-length 如果他是无穷的话
 ;那我们可不可以第一次初始化的时候就传递给他 mk-length 来替代eternity呢？
 ;;; Yes,we could even use mk-length instead of length.
 ((lambda (mk-length)
     (mk-length mk-length))
   (lambda (length)
     (lambda (l)
       (cond 
         ((null? l) 0)
         (else (+ 1 
                  (length (cdr l))))))))
 ;;和上面一样
 ((lambda (mk-length)
     (mk-length mk-length))
   (lambda (mk-length)
     (lambda (l)
       (cond 
         ((null? l) 0)
         (else (+ 1 
                  (mk-length (cdr l))))))))
 ;; WHy would we want to do that?
 ;;         All names are equal, but some names are more equal than others! (with apologies to George Orwell(1903-1950)
 ;;         True: as long as we use the names consistently ,we are just fine.
 ;;
 ;;     And mk-length is a far more equal  name than length. If we use a name like mk-length, it is a  contstant reminder that
 ;;      the first argument to mk-length is mk-length
 
 ;;我们为什么想着上面的做法呢？
 ;;因为所有的名字都是一样的，但是有些名字是更一样比其他
 ((lambda (mk-length)
    (mk-length mk-length))
  (lambda (mk-length)
    (lambda (l)
      (cond 
        ((null? l) 0)
        (else (add1 
               ((mk-length eternity)
                (cdr l))))))))
 
 ((lambda (mk-length)
    (mk-length mk-length))
  (lambda (mk-length)
    ((lambda (length)
       (lambda (l)
         (cond
           ((null? l) 0)
           (else (add1 (length (cdr l)))))))
     (mk-length mk-length))))

;;; How about this?
;;;     Yes,this looks just fine.
;;; Let&#39;s see thether it works?
;;;      Yes ,okay
;;; First,we need to know the value of it?

 
 ;;; what would  you call this  function above?
 ;;;        It&#39;s length,of course
 ;;;
 ;;;    How does it work?
 ;;;           It keeps adding recurive uses by  passing mk-length to itself,just as it is about to expire
 ;;;
 ;;;           One problem is left: it  no longer contains the function that looks like length.
 ;;;
 ;;;           can you fix the (mk-length mk-length) .?
 ;;;            We could extract this new application of mk-length to itself and call it length
 ;;;        WHy?
 ;;;             Because it really makes the function length.
 
 ;;since (mk-length mk-length returns a fucntion of one argument,
 ;;does (lambda (x) ((mk-length mk-length) x)) retrun a function of
 ;;one argument? Actually,it is a function
 ;;
 ;;Okay ,let&#39;s do this to the application of mk-length to itself
  ((lambda (mk-length)
    (mk-length mk-length))
  (lambda (mk-length)
    (lambda (l)
      (cond 
        ((null? l) 0)
        (else (add1 
               ((lambda (x)
                  ((mk-length mk-length) x))
                (cdr l))))))))
  
  ;;move out the new function so that we get length back
  ;;Why can&#39;t you move out (lambda (x) ((mk-length mk-length) x))  
  ;;       
  ;;            Because you add the (lambda (length)  which is like the definition of define.(actually are)
  ;;            also here the meaning of length is  (lambda(x) ((mk-length mk-length) x)),so you can use the
  ;;            usage of lambda(length) and the definition of length in the same S-expressions!!(By zhaoliang)
  ;;                    You know the same S-expression (the same parathese here)
  ;;
  ;;            Is it okay to move out the function?
  ;;                     Yes,we just always did the opposite by replacing a name with its value. Here we
  ;;                     extract a value and give it a name.
  ;;            Can we extract the function in the box(p171) that looks like length and give it a name
  ;;                          Yes,it does not depend on mk-length at all!
  ((lambda (mk-length)
     (mk-length mk-length))
   (lambda (mk-length)
     ((lambda (length)
        (lambda (l)
          (cond 
            ((null? l) 0)
            (else
             (add1 (length (cdr l)))))))
      (lambda (x)
        ((mk-length mk-length) x)))))


;;;;;;;;;;;;;;;;;;;;;;;The third part;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;***************;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;The fourth part;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;  myracet4.rkt ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;; Is this the right function!             ------you can check back the nottation above.
;;;
;;;Here the definition of le(lambda (length)...) and the usage of le (lambda (le)...) is in the same 
;;;S-expressions!!(the same parathese)
;;;
((lambda (le)
   ((lambda (mk-length)
      (mk-length mk-length))
    (lambda (mk-length)
      (le (lambda (x)
            ((mk-length mk-length) x))))))
 (lambda (length)
   (lambda (l)
     (cond
       ((null? l) 0)
       (else (add1 (length (cdr l))))))))

;;;; Let&#39;s separate the funtion that makes length from the function that looks like length.
(lambda (le)
  ((lambda (mk-length)
     (mk-length mk-length))
   (lambda (mk-length)
     (le (lambda (x)
           ((mk-length mk-length) x))))))
;;; Does this function have a name?
;;;         Yes ,it is called the application-order Y combinator.
(define Y
  (lambda (le)
    ((lambda (f) 
       (f f))
     (lambda (f)
       (le (lambda (x)
             ((f f) x)))))))
;;; the above function is replace the mk-length with  f ,so it looks more common!      BUt
;;;      it lacks the definition of (le)  just the usage of le.so it means the Y combinator.
;;;
;;;      (lambda (length)
;;;            (lambda  (l)
;;;                 ...           ---&amp;lt; it is the definition of function length
;;;
;;;     ((lambda  (le)
;;;          ...
;;;        )
;;;     (lambda (length)
;;;         ...
;;;         ))
;;;                             ----&amp;lt;  it is the definition of function le is the (lambda (length)...)) and the use 
;;;                             of the le is in the (lambda (le) ...)   Take care what the left parathese and right 
;;;                             parathese I utilize.
;;;                             ----------------------which is similar to apply-closure that contains three part
;;;                                                            table-of   form-of    body-of


;; An entry is a pair of lists whose first list is a set. Also ,the two lists must be of equal 
;; length.Make up some examples for entries
;;              Here are some examples:
;;              ((appetizer entree beverage)
;;              (pate boeuf vin))
;;
;;              and
;;              ((appetizer entree beverage)
;;              (beer beer beer)  ---------------------------&amp;lt; but the second list can be not a set
;;
;;              and 
;;              (( beverage dessert)
;;               ((food is) (number one with us)))
;;
;;
;;How can we build an entry from a set of names and a list of values?
;;           (define new-entry build)           ----&amp;gt;Try to build our examples with this function.
;;
;;What is (lookup-in-entry name entry)
;;     where name is entree
;;
;;     and entry is ((appetizer entree beverage)
;;                   (food tastes  good))
;;                ------------------------------&amp;gt;tastes
;;
;;      What if name is dessert
;;             In this case we would like to leave the decision about what to do with the user of lookup-in-entry
;;      How can we accomplish this?
;;             lookup-in-entry takes an additional argument this is invoked when name is not found in the first 
;;                list of an entry.
;;
;;      How many arguments do you think this extra function should take?
;;            We think it should take one , name. Why?
;;
;;;;;;;;;;;;;;;;;;;;;;;The fourth part;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;***************;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;The fifth part;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;myracet5.rkt ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;;

(define atom?
  (lambda (x)
    (and (not (pair? x)) (not (null? x)))))
  
(define build
  (lambda (s1 s2)
    (cond
      (else (cons s1
                  (cons s2 (quote ())))))))
((lambda (nothing)
     (cond
       (nothing (quote something))
       (else (quote nothing))))
   #t)

;;;; Here is our dfinition of lookup-in-entry:
(define lookup-in-entry
  (lambda (name entry entry-f)
    (lookup-in-entry-help name
                          (first entry)
                          (second entry)
                          (entry-f))))
;;;Finish the function lookup-in-entry-help-----------------
;;;
;;;
(define lookup-in-entry-help
  (lambda (name names values entry-f)
    (cond
      ((null? names) (entry-f name))
      ((eq? (car names) name)
       (car values))
      (else (lookup-in-entry-help name
                                  (cdr names)
                                  (cdr values)
                                  entry-f)))))
;;;     A table(based on entries) (also   called an environment) is a list of entries.Here is one example: The empty table
;;;     ,represented by ()
;;;     Make up some others.
;;;      Here is another one:
;;;                          (((appetizer entree beverage)
;;;                            (pate boeuf vin))
;;;                            ((beverage desert)
;;;                             ((food is) (number one with us)))
;;;                           )
;;;
;;;         Define the function extend-table which takes an entry and a table (possibly the empty one)
;;;         and create a new table by putting the new entry in front of the old table.
;;;         (define extend-table cons)
;;;
;;; What is  
;;;         (lookup-in-table name table table-f)
;;;          where 
;;;                 name is entree
;;;                 table is (((entree dessert)
;;;                            (spaghetti spumoni))
;;;                           ((appetizer entree beverage)
;;;                            (food tastes good)))
;;;                 and 
;;;                    table-f is (lambda (name) ...)
;;;
;;;             -----&amp;gt; It could be either spaghetti or tastes,but lookup-in-table searches the list of entries in order
;;;                    So it is spaghetti
;;;
;;; Can you describe what the following function 
;;; represents:
;;;            (lambda (name)
;;;                (lookup-in-table name
;;;                     (cdr table)
;;;                     table-f))
;;;
;;;                     ---------------------------&amp;gt; This function is the action to take when the name is not found in the first entry
;;;                                                  In one table there are a set of entries (set means each of the entries is different 
;;;                                                  from each other)
;;;
;;; Have we chosen a good representation for expressions?
;;;           Yes .They are all S-expressions so they can be data for functions.
;;; What kind of functions?
;;;           For example ,value(later on ,the value is defined as another name  compiler.(like gcc  gfortran  ifort  python perl etc)
;;;
;;; Do you remember value from chapter 6?
;;;          Recall that value is the function that returns the natural value of expressions.
;;;
;;; What is the value of
;;;  (car (quote (a b c)))
;;;         We don&#39;t even know  what (quote (a b c)) is .---------------------------------&amp;lt;&amp;lt;&amp;lt;&amp;lt;The original state of you learning english!
;;;                                                                          You don&#39;t know &#39;am&#39; &#39;are&#39; &#39;is&#39; etc.
;;;
;;;What is the value of
;;;      (cons rep-a
;;;        (cons rep-b
;;;          (cons rep-c
;;;             (quote ()))))
;;;
;;;     Where 
;;;       rep-a is a
;;;       rep-b is b
;;;     and
;;;       rep-c is c
;;;                                         ==================&amp;gt;&amp;gt; It is the same as (a b c)
;;;
;;;And what is the value of
;;; (cons rep-car
;;;     (cons (cons rep-quote
;;;              (cons 
;;;                  (cons rep-a
;;;                     (cons rep-b
;;;                        (cons rep-c
;;;                             (quote ()))))
;;;                  (quote ())))
;;;       (quote ())))
;;;       where 
;;;         rep-car is car
;;;         rep-quote is quote
;;;         rep-a is a
;;;         rep-b is b
;;;         and
;;;         rep-c is c
;;;                                        ====================&amp;gt;&amp;gt; It is the representation of the expressions:
;;;                                                                      (car (quote (a b c)))
;;;
;;;                                                                      ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^
;;;                                                                      The above is  what I say: Lisp is the data with program!
;;;                                                                              Data can be code,code can also become data!
;;;
;;; What is value of
;;;      (car (quote (a b c)))           
;;;                                       =====================&amp;gt;&amp;gt; a
;;; What is (value e)
;;;      where 
;;;          e is (car (quote (a b c)))
;;;                                       =====================&amp;gt;&amp;gt; a
;;; What is (value e)
;;;       where 
;;;           e is (quote (car (quote (a b c))))
;;;                                       =====================&amp;gt;&amp;gt; (car (quote (a b c)))
;;;
;;; What is (value e)
;;;        where
;;;            e is (add1 6)
;;;                                        ====================&amp;gt;&amp;gt; 7
;;; What is (value e)
;;;        where 
;;;            e is 6
;;;                                        ====================&amp;gt;&amp;gt; 6 .because numbers are constants
;;; What is (value e)
;;;        where 
;;;            e is (quote nothing)
;;;                                        ====================&amp;gt;&amp;gt; nothing
;;; What is (value e)
;;;         where
;;;           e is ((lambda (nothing)
;;;                    (cons nothing (quote ())))
;;;                 (quote 
;;;                    (from nothing comes something)))
;;;                                        ====================&amp;gt;&amp;gt; ((from nothing come something)).
;;;
;;;
;;;
;;; What is (value e)
;;;        where 
;;;            e is ((lambda (nothing)
;;;                     (cond
;;;                        (nothing (quote something))
;;;                        (else (quote nothing))))
;;;                  #t)             -------------------------&amp;lt; It means nothing is #t(The semtatics of language (the infer of language))
;;;
;;;                                       =====================&amp;gt;&amp;gt; something
;;;
;;; What is the type of e
;;;         where  
;;;              e is 6
;;;                                        ====================&amp;gt;&amp;gt; *const
;;; What is the type of e
;;;         where 
;;;              e is #f
;;;                                       ======================&amp;gt;&amp;gt; *const
;;; What is (value e)
;;;         where 
;;;              e is #f                 ======================&amp;gt;&amp;gt; #f
;;;; What is the type of e
;;;         where 
;;;              e is cons
;;;                                       ======================&amp;gt;&amp;gt; *const             -----------------------&amp;gt;I think is must be somethin wrong 
;;;                                                                                   -----------------------&amp;gt;I think it is primitive car
;;;                                                                                   -----------------------&amp;gt;I am wrong ,primitive is also *const
;;;;; What is the type of e
;;;         where 
;;;              e is car
;;;                                       ======================&amp;gt;&amp;gt; (primitive car)
;;;
;;;;;; What is the type of e
;;;         where 
;;;              e is (quote nothing)
;;;                                       ======================&amp;gt;&amp;gt; *quote
;;; What is the type of e
;;;         where 
;;;              e is nothing
;;;                                       ======================&amp;gt;&amp;gt; *identifier
;;;;;; What is the type of e
;;;         where 
;;;              e is (lambda (x y) (cons x y))
;;;                                       ======================&amp;gt;&amp;gt; *lambda
;;; What is the type of e
;;;         where 
;;;              e is ((lambda (nothing)
;;;                      (cond
;;;                          (nothing (quote something))
;;;                          (else (quote nothing))))
;;;                     #t)
;;;                                       ======================&amp;gt;&amp;gt; *application
;;; What is the type of e
;;;         where 
;;;              e is (cond
;;;                      (nothing  (quote something))
;;;                      (else (quote nothing)))
;;;                                       ======================&amp;gt;&amp;gt; *cond
;;;
;;; How many types do you think there are?
;;;                          we found six:
;;;                                         *const
;;;                                         *quote
;;;                                         *identifier
;;;                                         *lambda
;;;                                         *cond
;;;                                         and
;;;                                           *application
;;; How do you think we should represent types?
;;;              We choose functions.We call these functions &amp;quot;action&amp;quot;;------------------------------------&amp;lt;In python ,it is called as objects
;;;                                                                   or,in oop(orient object programming) ,it is called as objects
;;;
;;; If actions are functions that do &amp;quot;the right thing&amp;quot;  when applied to the appropriate type of expression,
;;;                 What should value do?
;;;     You guessed it. It would have to find out the type of expression it was passed  and then use the associated action.
;;;
;;; Do you remember atom-to-function from chapter8?
;;;         We found atom-to-function usefule when we rewrote value for numbered expressions.

;;;
;;;
(define lookup-in-table
  (lambda (name table table-f)
    (cond 
      ((null? table) (table-f name))
      (else (lookup-in-entry name
                             (car table)
                             (lambda (name)
                               (lookup-in-table name
                                                (cdr table)
                                                (table-f))))))))
(lambda (name table table-f)
    (lookup-in-table name
                     (cdr table)
                     (table-f)))
;;; Below is a function that produces the correct action (or function) for each possible S-expression:
;;;
;;; The top level make-up
(define expression-to-action
  (lambda (e)
    (cond
      ((atom? e) (atom-to-action e))
      (else (list-to-action e)))))

;;; IN the III-formed S-expressions suchas (quote a b), () , (lambda (#t) #t),(lambda (4) 4)  ,(lambda (car) car)
;;;         (lambda a),(cond (3 c) (else b) (5 a)) , And (1 2) are not considered here.They can be detected by an 
;;;         appropriate function to which S-expressions are submitted before they are passed to value.

(define atom-to-action
  (lambda (e)
    (cond
      ((number? e) *const)
      ((eq? e #t) *const)
      ((eq? e #f) *const)
      ((eq? e (quote cons)) *const)
      ((eq? e (quote car)) *const)
      ((eq? e (quote cdr)) *const)
      ((eq? e (quote null?)) *const)
      ((eq? e (quote eq?)) *const)
      ((eq? e (quote atom?)) *const)
      ((eq? e (quote zero?)) *const)
      ((eq? e (quote add1)) *const)
      ((eq? e (quote sub1)) *const)
      ((eq? e (quote number?)) *const)
      (else *identifier))))
;;;; so *const is consed by three parts: primitive part ,number , #t or #f part.(not include string part, because string part is called *identifier)
;;;
;;;By zhaoliang
;;;It means that the following identifier can see the list as its function&#39;s argument!    --------------------------&amp;lt;
(define list-to-action
  (lambda (e)
    (cond
      ((atom? (car e))
       (cond
         ((eq? (car e) (quote quote))
          *quote)
         ((eq? (car e) (quote lambda))
          *lambda)
         ((eq? (car e) (quote cond))
          *cond)
         (else *application)))
      (else *application))))

;;;;; So the compiler is comming on the way............................
;;;       If we assuming the expression-to-action works,we can use it to define value and meanning
;;;
;;;
(define value
  (lambda (e)
    (meaning e (quote ()))))  ;;;Now table is empty set.
(define meaning
  (lambda (e table)
    ((expression-to-action e) e table)))

;;;; The function value, together with all the functions it uses ,is called an interpreter.(Note that: all the relevent function value use
;;;
;;;The function value approximates the function eval  available in Schemes(and Lisp)
;;;
;;;How many arguments should actions take according to the above?
;;;
;;;             Two,the expression e and a table
;;;
;;;
;;; Here is the action for constants:
;;;
;;;
;;;
(define *const
  (lambda (e table)
    (cond 
      ((number? e) e)
      ((eq? e #t) #t)
      ((eq? e #f) #f)
      (else (build (quote primitive) e)))))  ;;;;-----------------&amp;lt;&amp;lt;&amp;lt;&amp;lt; Yes,primitive car,primitive con,primitive cdr

;;; Here is the action for constants:
;;; 
;;;
(define *quote
  (lambda (e table)
    (text-of e)))

(define first
  (lambda (p)
    (cond 
      (else (car p)))))

(define second
  (lambda (p)
    (cond
      (else car (cdr p)))))

(define third
  (lambda (p)
    (cond 
      (else car (cdr (cdr p))))))

(define text-of second)

;;; Have we used the table yet?
;;;                   No, But we will in a moment.
;;;
;;; Why do we need the table?
;;;                   To remember the values of identifiers
;;;
;;;; Given that the table contains the values of identifiers ,write the action of *identifier
;;;
(define *identifier
  (lambda (e table)
    (lookup-in-table e table initial-table)))

;;; Here is the initial-table ---------------------------------------------&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;
(define initial-table
  (lambda (name)
    (car (quote ()))))

;;; When is it used?
;;;                       Let&#39;s hope never. Why?
;;
;;What is the value of (lambda (x) x)
;;         We don&#39;t know yet, But we know that it must be the representation for a non-primitive
;;                  function.
;;
;;  How are non-primitive functions different from primitives?
;;   We know what primitives do;  non-primitives are defined by their argumentss and their function bodier
;;                                                     ^^^^^ ^^ ^^^^^ ^^^^^^^^^^ ^^^ ^^^^^ ^^^^^^^^ ^^^^^^
;;                                                     What does it mean?
;;                                                      arguments (x y ...)       function bodier: x
;;  So when we want to use a non-primitive we need to remember its formal arguments and its function body.
;;       At least. Fortunately this is just the cdr of a lambda expression! Because the car of the lambda expression is lambda
;;
;;  And what else do we need to remember?
;;                             
;;                              We wll also put the table in,just in case we might need it later
;;
;;  And How do we represent this?
;;                   In a list,of course.
;;
;; Here is the action *lambda
;;
(define *lambda
  (lambda (e table)
    (build (quote non-primitive)
           (cons table (cdr e)))))
;;; What is (meanning a table)
;;;        where
;;;              e is (lambda (x) (cons x y))
;;;        and
;;;              table is (((y z) ((8) 9)))
;;;
;;;              ==========================================&amp;gt;&amp;gt;&amp;gt; (non-primitive
;;;                                                                   (   (((y z) ((8) 9)))         (x)             (cons x y)   ))
;;;                                                                       ^^^^^^^^^^^^^^^^^         ^^^             ^^^^^^^^^^^^^^^
;;;                                                                           table                 formals             body
;;;It is probably a good idea to define some help functions for getting back the parts in this three elements
;;;list (i.e. the tables,the formal arguments,and the body).
;;;
(define table-of first)
(define formals-of second)
(define body-of third)


;;; Describe (cond...) in your own words
;;;     
;;;      It is a special form that takes any number of cond-lines. It considers
;;;      each line in turn. If the question part on the left is false, it looks
;;;      at the rest of the lines.Otherwise it proceeds to answer the right part.
;;;       If it sees an else-line,it treats that cond-line as if its question part
;;;       were true.

;;;;
;;; Here is the function evcon that does what we said in words
;;;
(define evcon
  (lambda (lines table)
    (cond 
      ((else? (question-of (car lines)))
       (meaning (answer-of (car lines))
                table))
      ((meaning (question-of (car lines))
                table)
       (meaning (answer-of (car lines))
                table))
      (else (evcon (cdr lines) table)))))

;;;; else? determine whether the (car expression)  is else or not!
(define else?
  (lambda (x)
    (cond
      ((atom? x) (eq? x (quote else)))
      (else #f))))
;;; didn&#39;t we violate the First Commandment?
;;;          Yes,we don&#39;t ask (null? lines), so one of the questions in every cond better be true
(define question-of first)
(define answer-of second)

;;; Now use the function evcon to write the *cond action
;;; 
;;; Here is the action for *cond
;;;
(define *cond
  (lambda (e table)
    (evcon (cond-lines-of e) table)))
;;; Aren&#39;t these help functions useful?
;;;          Yes they make things quite a bit more readable.But you already knew that.
;;;
;;; Do you understand *cond now?
;;;           Perhaps not
;;;
;;; How can you become familiar with it?
;;;         The best way is to try an example.
;;;         A good one (examples ) is
;;;                (*cond e table)
;;;                  where 
;;;                       e is (cond (coffee klatsch) (else (party))
;;;                  and 
;;;                       table is (((coffee) (#t))
;;;                                 ((klatsch party) (5 (6))))
(define cond-lines-of cdr)

;;; Have we seen how the table gets used?
;;;            Yes,*lambda and *identifier use it
;;;
;;;But how do the identifiers get into the table?
;;;            In the only action we have not defined:
;;;                      *application
;;;                      ^^^^^^^^^^^^
;;;                      ||||||||||||
;;; How is an application represented?
;;;       
;;;        An application us a list of  expressions whose car position contains an expression whose value is a function.
;;;
;;;How does an application differ from a special form, like (and ...) (or ...) or (cond ...)
;;;     An application must always determine the meaning of all its arguments.
;;; Before we can apply a function ,do we have to get the meaning of all of its arguments?
;;;       Yes.
;;;
;;; Write a function evils that takes a list of (representations of) arguments and a table, and
;;;  returns a list composed of the meaning of each argument
;;;
(define evlis
  (lambda (args table)
    (cond
      ((null? args) (quote ()))
      (else
       (cons (meaning (car args) table)  ;;; really  importan  for every argument!
             (evlis (cdr args) table))))))
;;;; What else do we need before we can determine the meaning of an application?
;;;
;;;We need to find out what its function-of means
;;;
;;;And what then?
;;;  
;;;  Then we apply the meaning of the function to the meaning of the arguments
;;;
;;;  Here is *application
;;;
(define *application
  (lambda (e table)
    (apply
     (meaning (function-of e) table)
     (evlis (arguments-of e) table))))
;;; Of course, we just have to define apply , function-of, and arguments-of correctly
;;;
(define function-of car)

(define arguments-of cdr)

;;;; How many different kinds of functions are there?
;;;
;;;     Two: primitive and non-primitive
;;; What are the two representation of functions?
;;;
;;; (primitive primitive-name)
;;; and (non-primitive (table formals body))
;;;      The list (table formals body) is called a  closure record.
;;;
;;;      Write primitive? and non-primitive?
(define primitive?
  (lambda (l)
    (eq? (first l) (quote primitive))))
(define non-primitive?
  (lambda (l)
    (eq? (first l) (quote non-primitive))))
;;;
;;; If fun does not evaluate to either a primitive or a non-primitive as
;;;         in the expression ((lambda (x) (x 5)) 3) ------&amp;lt;&amp;lt;&amp;lt; This expression cannot be detected in the now preocedure
;;;         there is no answer. The function apply approximatly the funcion apply available in Scheme (and lisp)
;;;
(define apply
  (lambda (fun vals)
    (cond
      ((primitive? fun)
       (apply-primitive
        (second fun) vals))
      ((non-primitive? fun)
       (apply-closure
        (second fun) vals)))))

;;;; This is the definition of apply-primitive
;;;
(define apply-primitive
  (lambda (name vals)
    (cond
      ((eq? name (quote cons))
       (cons (first vals) (second vals)))
      ((eq? name (quote car))
       (car (first vals)))
      ((eq? name (quote cdr))
       (cdr (first vals)))
      ((eq? name (quote null?))
       (null? (first vals)))
      ((eq? name (quote eq?))
       (eq? (first vals) (second vals)))
      ((eq? name (quote atom?))
       (:atom? (first vals)))
      ((eq? name (quote zero?))
       (zero? (first vals)))
      ((eq? name (quote add1))
       (add1 (first vals)))
      ((eq? name (quote sub1))
       (sub1 (first vals)))
      ((eq? name (quote number?))
       (number? (first vals))))))
(define :atom?
  (lambda (x)
    (cond
      ((atom? x) #t)
      ((null? x) #f)
      ((eq? (car x) (quote primitive))
       #t)
      ((eq? (car x) (quote non-primitive))
       #t)
      (else #f))))
;;;Is apply-closure  the only function left?
;;;        Yes,and apply-closure must extent the table
;;;                    extent the table?
;;;
;;;     how could we first find the result of (f a b)
;;;     where
;;;       f is (lambda (x y) (cons x y))
;;;       a is 1
;;;       and 
;;;       b  is (2)
;;;
;;;       ===================That&#39;s tricky. But we know what to do to find the meaning of (cons x y)
;;;                                               where 
;;;                                                     table is (((x y)
;;;                                                                (1 (2)))).
;;;
;;;  Table is the contain of the variables defined by you!!!
;;;  Why can we do this?
;;;           Here ,we don&#39;t need apply-closure
;;;
;;; Can you generalize the last two steps?
;;;                                 Applying a non-primitive function --a closure---to
;;;                                 a list of values  is the same as finding the meaning  of 
;;;                                 closure&#39;s body with its table extended by an entry of the form
;;;                                 (formals values)
;;;                                 In this entry,formals is the formals of closure and values is 
;;;                                 the result of evils
;;;
(define apply-closure
  (lambda (closure vals)
    (meaning (body-of closure)
             (extend-table
              (new-entry
               (formals-of closure)
               vals)
              (table-of closure)))))
;;;; This is a complicated function and it deserves an example.
;;;         In the following,
;;;              closure is ((((u v w)          ;;; entry name
;;;                            (1 2 3))         ;;; entry value
;;;                            ((x y  z)        ;;;;entry name
;;;                             (4 5 6)))       ;;;; entry value
;;;                            (x y)             ;;; formal
;;;                            (cons z x))        ;;; body 
(define new-entry build)
(define extend-table cons)


;;;;;;;;;;;;;;;;;;;;;;;The fifth part;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;****************;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;The sixth part;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;; myracet6.rkt ;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;;

(define member1?
  (lambda (a lat)
    (cond
      ((null? lat) #f)
      (else (or (eq? a (car lat))
                (member1? a (cdr lat)))))))
;;the most common thinking,find it and then continul
(define is-first?
  (lambda (a lat)
    (cond
      ((null? lat) #f)
      (else (eq? (car lat) a)))))

(define two-in-a-row?
  (lambda (lat)
    (cond
      ((null? lat) #f)
      (else
       (or (is-first? (car lat) (cdr lat))
           (two-in-a-row? (cdr lat)))))))
;;;the development, more close,but if-first-b must use
;;the two-in-a-row? ,so can we write a version which 
;;didn&#39;t use two-in-a-row? at all?
(define is-first-b?
  (lambda (a lat)
    (cond
      ((null? lat) #f)
      (else (or (eq? (car lat) a )
                (two-in-a-row? lat))))))
(define two-in-a-row-b?
  (lambda (lat)
    (cond 
      ((null? lat) #f)
      (else
       (is-first-b? (car lat) (cdr lat))))))
;;the is-first-b? only do the job about eq?,so why can I
;;let is-first-b? also do another thing,recur. So I
;;don&#39;t need two-in-a-row? again.
(define is-first-c?
  (lambda (preceding lat)
    (cond
      ((null? lat) #f)
      (else
       (or (eq? (car lat) preceding)
           (is-first-c? (car lat)
                        (cdr lat)))))))
(define two-in-a-row-c?
  (lambda (lat)
    (cond 
      ((null? lat) #f)
      (else (is-first-c? (car lat)
                         (cdr lat))))))
;;although two-in-a-row-c? and two-in-a-row-b? look
;;the same in the shape;
;;but the essence is not the same!
;;version b, is just encasual the is-first? and two-
;;in-a-row?
;;version c, is updated version, used it by itself?

(define sum-of-prefixes-b
  (lambda (sonssf tup)
    (cond
      ((null? tup) (quote ()))
      (else (cons (+ sonssf (car tup))
                  (sum-of-prefixes-b
                   (+ sonssf (car tup));;thinking hole
                   (cdr tup)))))))
;;not leave before,important for your thinking
;;(sum-of-prefixes-b 0 &#39;(1 3 5))
;;two arguments

(define pick
  (lambda (n lat)
    (cond
      ((eq? n 1) (car lat))
      (else 
       (pick (- n 1) (cdr lat))))))


(define scramble-b
  (lambda (tup rev-pre)
    (cond
      ((null? tup) (quote ()))
      (else
       (cons (pick (car tup)
                   (cons (car tup) rev-pre))
             (scramble-b (cdr tup)
                         (cons (car tup) rev-pre)))))))
;;&amp;gt;  (scramble-b &#39;(1 1 1 3 4 2 1 1 9 2) (quote ()))
;;&#39;(1 1 1 1 1 4 1 1 1 9)
;;(scramble-b &#39;(2 1 1 3 4 2 1 1 9 2) (quote ())) have a bug
;;&amp;gt; (scramble-b &#39;(1 2 1 3 4 2 1 1 9 2) (quote ()))
;;&#39;(1 1 1 2 2 4 1 1 1 9)

;;the base procedure
;;result     rev-pre
;;1          1
;;1 1        2(tup di er wei) 1
;;1 1 1      1(tup di san wei) 2 1
;;1 1 1 2    3 1 2 1 (from here to select the index 3 so is 2)
;;1 1 1 2 2  4 3 1 2 1  (select the index 4 of lat)
;;1 1 1 2 2 4    2 4 3 1 2 1
;;1 1 1 2 2 4 1  1 2 4 3 1 2 1
;;1 1 1 2 2 4 1 1     1 1 2 4 3 1 2 1
;;1 1 1 2 2 4 1 1 1   9 1 1 2 4 2 1 2 1
;;1 1 1 2 2 4 1 1 1 9   2 9 1 1 2 4 2 1 2 1
;;actually in the list of the lat,
;;the first number in the rev-pre expose the target I 
;;should get from the rev-pre,so on the one-hand,I should
;;pick-up the value according the index from varient and
;;increasing lat ,on the second hand I should constuct
;;the varient list of revpre!
;;step1 car the current tup 
;;step2 and put it into the list of revpre
;;step3 watch the index it on the list of revpre
;;step4 put the index value into the results! ok!

;;;;;;;;;;;;;;;;;;;;;;;The sixth part;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;
; Chapter 11 of The Seasoned Schemer:
; Welcome Back to the Show
;
; Code examples assemled by Peteris Krumins (peter@catonmat.net).
; His blog is at http://www.catonmat.net  --  good coders code, great reuse.
;
; Get yourself this wonderful book at Amazon: http://bit.ly/8cyjgw
;

; Remember member? from The Little Schemer? (http://bit.ly/4GjWdP)
; It finds if an element &#39;a&#39; is in a list of atoms &#39;lat&#39;.
;
(define member?
  (lambda (a lat)
    (cond
      ((null? lat) #f)
      (else (or (eq? a (car lat))
                (member? a (cdr lat)))))))



; member? helper function
;
(define member1?
  (lambda (a l)
    (letrec
      ((yes? (lambda (l)
               (cond
                 ((null? l) #f)
                 ((eq? (car l) a) #t)
                 (else (yes? (cdr l)))))))
      (yes? l))))


; is-first? function finds out whether the next element in lat, if there is
; one, is identical to this element.
;
(define is-first?
  (lambda (a lat)
    (cond
      ((null? lat) #f)
      (else (eq? (car lat) a)))))

; two-in-a-row? function determines whether any atom occurs twice in a row.
;
(define two-in-a-row?
  (lambda (lat)
    (cond
      ((null? lat) #f)
      (else
        (or (is-first? (car lat) (cdr lat))
            (two-in-a-row? (cdr lat)))))))

; Examples of two-in-a-row?
;
(two-in-a-row? &#39;(Italian sardines spaghetti parsley))           ; false
(two-in-a-row? &#39;(Italian sardines sardines spaghetti parsley))  ; true
(two-in-a-row? &#39;(Italian sardines more sardines spaghetti))     ; false

; Another version of two-in-a-row? that leaves decision of what to do to
; is-first-b?
;
(define two-in-a-row-2?
  (lambda (lat)
    (cond
      ((null? lat) #f)
      (else
       (is-first-b? (car lat) (cdr lat))))))

; is-first-b? function for two-in-a-row-2?
;
(define is-first-b?
  (lambda (a lat)
    (cond
      ((null? lat) #f)
      (else (or (eq? (car lat) a)
                (two-in-a-row-2? lat))))))

; Examples of two-in-a-row-2?
;
(two-in-a-row-2? &#39;(Italian sardines spaghetti parsley))           ; false
(two-in-a-row-2? &#39;(Italian sardines sardines spaghetti parsley))  ; true
(two-in-a-row-2? &#39;(Italian sardines more sardines spaghetti))     ; false

; Another version of two-in-a-row? that recurs itself instead of using
; is-first?
;
(define two-in-a-row-b?
  (lambda (preceding lat)
    (cond
      ((null? lat) #f)
      (else (or (eq? (car lat) preceding)
                (two-in-a-row-b? (car lat) (cdr lat)))))))

; The final version of two-in-a-row?
;
(define two-in-a-row-final?
  (lambda (lat)
    (cond
      ((null? lat) #f)
      (else (two-in-a-row-b? (car lat) (cdr lat))))))

(two-in-a-row-final? &#39;(Italian sardines spaghetti parsley))           ; false
(two-in-a-row-final? &#39;(Italian sardines sardines spaghetti parsley))  ; true
(two-in-a-row-final? &#39;(Italian sardines more sardines spaghetti))     ; false

; Helper function for upcoming sum-of-prefixes function
;
(define sum-of-prefixes-b
  (lambda (sonssf tup)     ; sonssf stands for &#39;sum of numbers seen so far&#39;
    (cond
      ((null? tup) &#39;())
      (else (cons (+ sonssf (car tup))
                  (sum-of-prefixes-b
                   (+ sonssf (car tup))
                   (cdr tup)))))))

; sum-of-prefixes function finds the running sum of a list of numbers
;
(define sum-of-prefixes
  (lambda (tup)
    (sum-of-prefixes-b 0 tup)))

; Examples of sum-of-prefixes
;
(sum-of-prefixes &#39;(2 1 9 17 0))   ; &#39;(2 3 12 29 29)
(sum-of-prefixes &#39;(1 1 1 1 1))    ; &#39;(1 2 3 4 5)
(sum-of-prefixes &#39;(1 1 1))        ; &#39;(1 2 3)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;                                                                            ;
; The eleventh commandment                                                   ;
;                                                                            ;
; Use additional arguments when a function needs to know what the other      ;
; arguments to the function have been like so far.                           ;
;                                                                            ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Remember the pick function from chapter 4 of The Little Schemer?
;
(define pick
  (lambda (n lat)
    (cond
      ((one? n) (car lat))
      (else (pick (sub1 n) (cdr lat))))))

; It uses one? and sub1 helper functions
;
(define one?
  (lambda (n) (= n 1)))

(define sub1
  (lambda (n) (- n 1)))

; scramble-b is a helper function for scramble
;
(define scramble-b
  (lambda (tup rev-pre)
    (cond
      ((null? tup) &#39;())
      (else
       (cons (pick (car tup) (cons (car tup) rev-pre))
             (scramble-b (cdr tup)
                         (cons (car tup) rev-pre)))))))

; scramble
(define scramble
  (lambda (tup)
    (scramble-b tup &#39;())))

; Examples of scramble
;
(scramble &#39;(1 1 1 3 4 2 1 1 9 2))       ; &#39;(1 1 1 1 1 4 1 1 1 9)
(scramble &#39;(1 2 3 4 5 6 7 8 9))         ; &#39;(1 1 1 1 1 1 1 1 1)
(scramble &#39;(1 2 3 1 2 3 4 1 8 2 10))    ; &#39;(1 1 1 1 1 1 1 1 2 8 2)

;
; Chapter 12 of The Seasoned Schemer:
; Take Cover
;
; Code examples assemled by Peteris Krumins (peter@catonmat.net).
; His blog is at http://www.catonmat.net  --  good coders code, great reuse.
;
; Get yourself this wonderful book at Amazon: http://bit.ly/8cyjgw
;

; add1 primitive
;
(define add1
  (lambda (x) (+ x 1)))

; The Y-combinator
;
(define Y
  (lambda (le)
    ((lambda (f) (f f))
     (lambda (f)
       (le (lambda (x) ((f f) x)))))))

; length function written via Y-combinator and applied to &#39;(a b c)
;
((Y (lambda (length)
     (lambda (l)
       (cond
         ((null? l) 0)
         (else (add1 (length (cdr l)))))))) &#39;(a b c))  ; produces output 3

; No need to pass &#39;a&#39; around in multirember
; Use Y-combinator not to pass it around
;
(define multirember
  (lambda (a lat)
    ((Y (lambda (mr)
          (lambda (lat)
            (cond
              ((null? lat) &#39;())
              ((eq? a (car lat)) (mr (cdr lat)))
              (else
               (cons (car lat) (mr (cdr lat))))))))
     lat)))

; Example of multirember
;
(multirember &#39;a &#39;(a b c a a a x))             ; &#39;(b c x)

; multirember via letrec
;
(define multirember-letrec
  (lambda (a lat)
    ((letrec
       ((mr (lambda (lat)
              (cond
                ((null? lat) &#39;())
                ((eq? a (car lat)) (mr (cdr lat)))
                (else
                  (cons (car lat) (mr (cdr lat))))))))
       mr)
     lat)))

; Example of multirember-letrec
;
(multirember-letrec &#39;a &#39;(a b c a a a x))      ; &#39;(b c x) 

; Structure of letrec
;
; ((letrec ((mr ...)) mr) values)

; Another way to write multirember via letrec
;
(define multirember-letrec-2
  (lambda (a lat)
    (letrec
      ((mr (lambda (lat)
             (cond
               ((null? lat) &#39;())
               ((eq? a (car lat)) (mr (cdr lat)))
               (else
                 (cons (car lat) (mr (cdr lat))))))))
       (mr lat))))

; Another test of applying multirember-letrec-2
;
(multirember-letrec-2 &#39;a &#39;(a b c a a a x))      ; &#39;(b c x) 

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;                                                                            ;
; The twelfth commandment                                                    ;
;                                                                            ;
; Use (letrec ...) to remove arguments that do not change for recursive      ;
; applications.                                                              ;
;                                                                            ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Yet another way to write multirember via letrec
;
(define multirember-letrec-3
  (letrec
    ((mr (lambda (a lat)
           (cond
             ((null? lat) &#39;())
             ((eq? (car lat) a) (mr a (cdr lat)))
             (else
               (cons (car lat) (mr a (cdr lat))))))))
    mr))

; Test multirember-letrec-3
;
(multirember-letrec-3 &#39;a &#39;(a b c a a a x))      ; &#39;(b c x) 

; The member? function determines if the given element is in the list
;
(define member?
  (lambda (a lat)
    (cond
      ((null? lat) #f)
      ((eq? (car lat) a) #t)
      (else (member? a (cdr lat))))))

; Test member?
;
(member? &#39;x &#39;(a b c x d e f))   ; #t
(member? &#39;x &#39;(a b c d e f))     ; #f

; member? via letrec
;
(define member-letrec?
  (lambda (a l)
    ((letrec
       ((yes? (lambda (l)
                (cond
                  ((null? l) #f)
                  ((eq? (car l) a) #t)
                  (else (yes? (cdr l)))))))
     yes?)
    l)))

; Test member-letrec?
;
(member-letrec? &#39;x &#39;(a b c x d e f))   ; #t
(member-letrec? &#39;x &#39;(a b c d e f))     ; #f

; Another member? via letrec
;
(define member-letrec-2?
  (lambda (a l)
    (letrec
      ((yes? (lambda (l)
               (cond
                 ((null? l) #f)
                 ((eq? (car l) a) #t)
                 (else (yes? (cdr l)))))))
      (yes? l))))

; Test member-letrec-2?
;
(member-letrec-2? &#39;x &#39;(a b c x d e f))   ; #t
(member-letrec-2? &#39;x &#39;(a b c d e f))     ; #f

; The union function takes two sets and merges them
;
(define union
  (lambda (set1 set2)
    (cond
      ((null? set1) set2)
      ((member? (car set1) set2) 
       (union (cdr set1) set2))
      (else
        (cons (car set1) (union (cdr set1) set2))))))

; Example of union
;
(union
  &#39;(tomatoes and macaroni casserole)
  &#39;(macaroni and cheese)) ; &#39;(tomatoes and macaroni casserole cheese)

; union via letrec
;
(define union-letrec
  (lambda (set1 set2)
    (letrec
      ((U (lambda (set)
            (cond
              ((null? set) set2)
              ((member? (car set) set2)
               (U (cdr set)))
              (else
                (cons (car set) (U (cdr set))))))))
      (U set1))))

; Test of union-letrec
;
(union-letrec
  &#39;(tomatoes and macaroni casserole)
  &#39;(macaroni and cheese)) ; &#39;(tomatoes and macaroni casserole cheese)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;                                                                            ;
; The thirteenth commandment                                                 ;
;                                                                            ;
; Use (letrec ...) to hide and to protect functions.                         ;
;                                                                            ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define union-letrec-protected
  (lambda (set1 set2)
    (letrec
      ((U (lambda (set)
            (cond
              ((null? set) set2)
              ((M? (car set) set2)
               (U (cdr set)))
              (else
                (cons (car set) (U (cdr set)))))))
       (M?
         (lambda (a lat)
           (cond
             ((null? lat) #f)
             ((eq? (car lat) a) #t)
             (else
               (M? a (cdr lat)))))))
      (U set1))))

; Test of union-letrec-protected
;
(union-letrec-protected
  &#39;(tomatoes and macaroni casserole)
  &#39;(macaroni and cheese)) ; &#39;(tomatoes and macaroni casserole cheese)

; Fixing M? to follow 12th commandment
;
(define union-letrec-protected-12
  (lambda (set1 set2)
    (letrec
      ((U (lambda (set)
            (cond
              ((null? set) set2)
              ((M? (car set) set2)
               (U (cdr set)))
              (else
                (cons (car set) (U (cdr set)))))))
       (M?
         (lambda (a lat)
           (letrec
             ((N? (lambda (lat)
                    (cond
                      ((null? lat) #f)
                      ((eq? (car lat) a) #t)
                      (else
                        (N? (cdr lat)))))))
             (N? lat)))))
      (U set1))))

; Test of union-letrec-protected-12
;
(union-letrec-protected-12
  &#39;(tomatoes and macaroni casserole)
  &#39;(macaroni and cheese)) ; &#39;(tomatoes and macaroni casserole cheese)

; The two-in-a-row? checks if a lat contains two equal elements
;
(define two-in-a-row?
  (lambda (lat)
    (letrec
      ((W (lambda (a lat)
            (cond
              ((null? lat) #f)
              ((eq? a (car lat)) #t)
              (else
                (W (car lat) (cdr lat)))))))
      (cond
        ((null? lat) #f)
        (else (W (car lat) (cdr lat)))))))

; Test two-in-a-row?
; 
(two-in-a-row? &#39;(Italian sardines spaghetti parsley))           ; #f
(two-in-a-row? &#39;(Italian sardines sardines spaghetti parsley))  ; #t
(two-in-a-row? &#39;(Italian sardines more sardines spaghetti))     ; #f

; Another version of two-in-a-row?
;
(define two-in-a-row-2?
  (letrec
    ((W (lambda (a lat)
          (cond
            ((null? lat) #f)
            ((eq? a (car lat)) #t)
            (else
              (W (car lat) (cdr lat)))))))
    (lambda (lat)
      (cond
        ((null? lat) #f)
        (else (W (car lat) (cdr lat)))))))

; Test two-in-a-row-2?
;
(two-in-a-row-2? &#39;(Italian sardines spaghetti parsley))           ; #f
(two-in-a-row-2? &#39;(Italian sardines sardines spaghetti parsley))  ; #t
(two-in-a-row-2? &#39;(Italian sardines more sardines spaghetti))     ; #f

; The sum-of-prefixes finds the running sum of a list of numbers
;
(define sum-of-prefixes
  (lambda (tup)
    (letrec
      ((S (lambda (sss tup)
            (cond
              ((null? tup) &#39;())
              (else
                (cons (+ sss (car tup))
                      (S (+ sss (car tup)) (cdr tup))))))))
      (S 0 tup))))

; Examples of sum-of-prefixes
;
(sum-of-prefixes &#39;(2 1 9 17 0))   ; &#39;(2 3 12 29 29)
(sum-of-prefixes &#39;(1 1 1 1 1))    ; &#39;(1 2 3 4 5)
(sum-of-prefixes &#39;(1 1 1))        ; &#39;(1 2 3)



(define intersect
  (lambda (set1 set2)
    (cond
      ((null? set1) &#39;())  ; don&#39;t forget the 1st commandment
      ((member? (car set1) set2)
       (cons (car set1) (intersect (cdr set1) set2)))
      (else
        (intersect (cdr set1) set2)))))

; It needs member? helper function
;
(define member?
  (lambda (a l)
    (letrec
      ((yes? (lambda (l)
               (cond
                 ((null? l) #f)
                 ((eq? (car l) a) #t)
                 (else (yes? (cdr l)))))))
      (yes? l))))

; Examples of intersect
;
(intersect &#39;(a b x c d) &#39;(q w e x r t y a))     ; &#39;(a x)
(intersect &#39;(a b x c d) &#39;())                    ; &#39;()
(intersect &#39;() &#39;())                             ; &#39;()
(intersect &#39;() &#39;(a b x c d))                    ; &#39;()
(intersect &#39;(a b x c d) &#39;(a b x c d))           ; &#39;(a b x c d)

; We forgot the 12th commandment - use letrec to remove arguments
; that do not change for recursive applications
;
(define intersect-letrec
  (lambda (set1 set2)
    (letrec
      ((I (lambda (set)
            (cond
              ((null? set) &#39;())
              ((member? (car set) set2)
               (cons (car set) (I (cdr set))))
              (else
                (I (cdr set)))))))
      (I set1))))

; Test of intersect-letrec
;
(intersect-letrec &#39;(a b x c d) &#39;(q w e x r t y a))     ; &#39;(a x)
(intersect-letrec &#39;(a b x c d) &#39;())                    ; &#39;()
(intersect-letrec &#39;() &#39;())                             ; &#39;()
(intersect-letrec &#39;() &#39;(a b x c d))                    ; &#39;()
(intersect-letrec &#39;(a b x c d) &#39;(a b x c d))           ; &#39;(a b x c d)

; The intersectall function finds intersect of a bunch of sets
;
(define intersectall
  (lambda (lset)
    (cond
      ((null? lset) &#39;())
      ((null? (cdr lset)) (car lset))
      (else
        (intersect (car lset)
                   (intersectall (cdr lset)))))))

; Examples of intersectall


; Examples of intersectall
;
(intersectall &#39;((a) (a) (a)))                   ; &#39;(a)
(intersectall &#39;((a) () (a)))                    ; &#39;()
(intersectall &#39;())                              ; &#39;()
(intersectall &#39;((a b c d) (b c d e) (c d e f))) ; &#39;(c d)



(define intersectall-letrec
  (lambda (lset)
    (letrec
      ((A (lambda (lset)
            (cond
              ((null? (cdr lset)) (car lset))
              (else
                (intersect (car lset)
                           (A (cdr lset))))))))
      (cond
        ((null? lset) &#39;())
        (else (A lset))))))

; Tests of intersectall-letrec
;
(intersectall-letrec &#39;((a) (a) (a)))                   ; &#39;(a)
(intersectall-letrec &#39;((a) () (a)))                    ; &#39;()
(intersectall-letrec &#39;())                              ; &#39;()
(intersectall-letrec &#39;((a b c d) (b c d e) (c d e f))) ; &#39;(c d)




; Introducing letcc
;
(define intersectall-letcc
  (lambda (lset)
    (call-with-current-continuation
      (lambda (hop)
        (letrec
          ((A (lambda (lset)
                (cond
                  ((null? (car lset)) (hop &#39;()))
                  ((null? (cdr lset)) (car lset))
                  (else
                    (intersect (car lset)
                               (A (cdr lset))))))))
          (cond
            ((null? lset) &#39;())
            (else (A lset))))))))

; Tests of intersectall-letcc
;
(intersectall-letcc &#39;((a) (a) (a)))                   ; &#39;(a)
(intersectall-letcc &#39;((a) () (a)))                    ; &#39;()
(intersectall-letcc &#39;())                              ; &#39;()
(intersectall-letcc &#39;((a b c d) (b c d e) (c d e f))) ; &#39;(c d)



; intersectall that returns abruptly and promptly
;
(define intersectall-ap
  (lambda (lset)
    (call-with-current-continuation
      (lambda (hop)
        (letrec
          ((A (lambda (lset)
                (cond
                  ;;;hop one
                  ((null? (car lset)) (hop &#39;()))
                  ((null? (cdr lset)) (car lset))
                  (else
                    (I (car lset)
                       (A (cdr lset)))))))
           (I (lambda (s1 s2)
                (letrec
                  ((J (lambda (s1)
                        (cond
                          ((null? s1) &#39;())
                          ((member? (car s1) s2)
                           ;;;get the one you need
                           (cons (car s1) (J (cdr s1))))
                          (else
                            (J (cdr s1)))))))
                  (cond
                    ;;;hop two
                    ((null? s2) (hop &#39;()))
                    (else (J s1)))))))
          (cond
            ((null? lset) &#39;())
            (else (A lset))))))))

; Tests of intersectall-ap
;
(intersectall-ap &#39;((a) (a) (a)))                   ; &#39;(a)
(intersectall-ap &#39;((a) () (a)))                    ; &#39;()
(intersectall-ap &#39;())                              ; &#39;()
(intersectall-ap &#39;((a b c d) (b c d e) (c d e f))) ; &#39;(c d)

; rember function via letrec
;
;
;
; Chapter 14 of The Seasoned Schemer:
; Let There Be Names
;
; Code examples assemled by Peteris Krumins (peter@catonmat.net).
; His blog is at http://www.catonmat.net  --  good coders code, great reuse.
;
; Get yourself this wonderful book at Amazon: http://bit.ly/8cyjgw
;

; atom? primitive
;
(define atom?
  (lambda (x)
   (and (not (pair? x)) (not (null? x)))))  

; add1 primitive
;
(define add1
  (lambda (n)
    (+ n 1)))

; The leftmost function finds the leftmost atom in a non-empty list of
; s-expressions that does not contain the empty list.
;
(define leftmost
  (lambda (l)
    (cond
      ((atom? (car l)) (car l))
      (else (leftmost (car l))))))

; Example of leftmost
;
(leftmost &#39;(((a) b) (c d)))         ; &#39;a

; Example of not-applicable leftmost
;
; (leftmost &#39;((() a) ()))           ; not applicable because leftmost item is an empty list

; Let&#39;s fix this.
;
(define leftmost-fixed
  (lambda (l)
    (cond
      ((null? l) &#39;())
      ((atom? (car l)) (car l))
      (else
        (cond
          ((atom? (leftmost-fixed (car l)))
           (leftmost-fixed (car l)))
          (else (leftmost-fixed (cdr l))))))))

; Examples of leftmost-fixed
;
(leftmost-fixed &#39;(((x) b) (c d)))   ; &#39;x
(leftmost-fixed &#39;(((x) ()) () (e))) ; &#39;x
(leftmost-fixed &#39;(((() x) ())))     ; &#39;x
(leftmost-fixed &#39;(((()) ())))       ; &#39;()

(define leftmost-let
  (lambda (l)
    (cond
      ((null? l) &#39;())
      ((atom? (car l)) (car l))
      (else
        (let ((a (leftmost-let (car l))))
          (cond
            ((atom? a) a)
            (else (leftmost-let (cdr l)))))))))

; Tests of leftmost-let
;
(leftmost-let &#39;(((y) b) (c d)))   ; &#39;y
(leftmost-let &#39;(((y) ()) () (e))) ; &#39;y
(leftmost-let &#39;(((() y) ())))     ; &#39;y
(leftmost-let &#39;(((()) ())))       ; &#39;()

; The rember1* function removes the leftmost occurrence of a in l
;
(define rember1*
  (lambda (a l)
    (cond
      ((null? l) &#39;())
      ((atom? (car l))
       (cond
         ((eq? (car l) a) (cdr l))
         (else
           (cons (car l) (rember1* a (cdr l))))))
      (else
        (cond
          ((equal? (rember1* a (car l)) (car l)) ; if the list with &#39;a&#39; removed doesn&#39;t change
           (cons (car l) (rember1* a (cdr l))))  ; then recurse
          (else
            (cons (rember1* a (car l)) (cdr l)))))))) ; otherwise remove &#39;a&#39;

; Examples of rember1*
;
(rember1*
  &#39;salad
  &#39;((Swedish rye) (French (mustard salad turkey)) salad))
; ==&amp;gt; &#39;((Swedish rye) (French (mustard turkey)) salad)

(rember1*
  &#39;meat
  &#39;((pasta meat) pasta (noodles meat sauce) meat tomatoes))
; ==&amp;gt; &#39;((pasta) pasta (noodles meat sauce) meat tomatoes)

; rember1* rewritten using the 12th commandment
;
(define rember1*-letrec
  (lambda (a l)
    (letrec
      ((R (lambda (l)
            (cond
              ((null? l) &#39;())
              ((atom? (car l))
               (cond
                 ((eq? (car l) a) (cdr l))
                 (else
                   (cons (car l) (R (cdr l))))))
              (else
                (cond
                  ((equal? (R (car l)) (car l)) ; if the list with &#39;a&#39; removed doesn&#39;t change
                   (cons (car l) (R (cdr l))))  ; then recurse
                  (else
                    (cons (R (car l)) (cdr l))))))))) ; otherwise remove &#39;a&#39;
      (R l))))

; Tests of rember1*-letrec
;
(rember1*-letrec
  &#39;salad
  &#39;((Swedish rye) (French (mustard salad turkey)) salad))
; ==&amp;gt; &#39;((Swedish rye) (French (mustard turkey)) salad)

(rember1*-letrec
  &#39;meat
  &#39;((pasta meat) pasta (noodles meat sauce) meat tomatoes))
; ==&amp;gt; &#39;((pasta) pasta (noodles meat sauce) meat tomatoes)

; rember* rewritten using the 12th commandment and let
;
(define rember1*-letrec-let
  (lambda (a l)
    (letrec
      ((R (lambda (l)
            (cond
              ((null? l) &#39;())
              ((atom? (car l))
               (cond
                 ((eq? (car l) a) (cdr l))
                 (else
                   (cons (car l) (R (cdr l))))))
              (else
                (let ((av (R (car l))))
                  (cond
                    ((equal? (car l) av)         ; if the list with &#39;a&#39; removed didn&#39;t change
                     (cons (car l) (R (cdr l)))) ; then recurse
                    (else
                      (cons av (cdr l))))))))))  ; otherwise remove &#39;a&#39;
      (R l))))

; Tests of rember1*-letrec-let
;
(rember1*-letrec-let
  &#39;salad
  &#39;((Swedish rye) (French (mustard salad turkey)) salad))
; ==&amp;gt; &#39;((Swedish rye) (French (mustard turkey)) salad)

(rember1*-letrec-let
  &#39;meat
  &#39;((pasta meat) pasta (noodles meat sauce) meat tomatoes))
; ==&amp;gt; &#39;((pasta) pasta (noodles meat sauce) meat tomatoes)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;                                                                            ;
; The fifteenth commandment (preliminary version)                            ;
;                                                                            ;
; Use (let ...) to name the values of repeated expressions.                  ;
;                                                                            ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; The depth* function finds the max depth of an s-expression
;
(define depth*
  (lambda (l)
    (cond
      ((null? l) 1)
      ((atom? (car l)) (depth* (cdr l)))
      (else
        (cond
          ((&amp;gt; (depth* (cdr l))
              (add1 (depth* (car l))))
           (depth* (cdr l)))
          (else
            (add1 (depth* (car l)))))))))

; Examples of depth*
;
(depth* &#39;((pickled) peppers (peppers pickled)))                          ; 2
(depth* &#39;(margarine ((bitter butter) (makes) (batter (bitter))) butter)) ; 4
(depth* &#39;(c (b (a b) a) a))                                              ; 3

; depth* rewritten using let
;
(define depth*-let
  (lambda (l)
    (cond
      ((null? l) 1)
      ((atom? (car l)) (depth*-let (cdr l)))
      (else 
        (let ((a (add1 (depth*-let (car l))))
              (d (depth*-let (cdr l))))
          (cond
            ((&amp;gt; d a) d)
            (else a)))))))

; Tests of depth*-let
;
(depth*-let &#39;((pickled) peppers (peppers pickled)))                          ; 2
(depth*-let &#39;(margarine ((bitter butter) (makes) (batter (bitter))) butter)) ; 4
(depth*-let &#39;(c (b (a b) a) a))                                              ; 3

; Another version of depth*
;
(define depth*-let-2
  (lambda (l)
    (cond
      ((null? l) 1)
      (else
        (let ((d (depth*-let-2 (cdr l))))
          (cond
            ((atom? (car l)) d)
            (else
              (let ((a (add1 (depth*-let-2 (car l)))))
                (cond
                  ((&amp;gt; d a) d)
                  (else a))))))))))

; Tests of depth*-let
;
(depth*-let-2 &#39;((pickled) peppers (peppers pickled)))                          ; 2
(depth*-let-2 &#39;(margarine ((bitter butter) (makes) (batter (bitter))) butter)) ; 4
(depth*-let-2 &#39;(c (b (a b) a) a))                                              ; 3

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;                                                                            ;
; The fifteenth commandment (revised version)                                ;
;                                                                            ;
; Use (let ...) to name the values of repeated expressions in a function     ;
; definition if they may be evaluated twice for one and the same use of the  ;
; function.                                                                  ;
;                                                                            ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; depth* via if
;
(define depth*-if
  (lambda (l)
    (cond
      ((null? l) 1)
      ((atom? (car l))
       (depth*-if (cdr l)))
      (else
        (let ((a (add1 (depth* (car l))))
              (d (depth* (cdr l))))
          (if (&amp;gt; d a) d a))))))

; Tests of depth*-if
;
(depth*-if &#39;((pickled) peppers (peppers pickled)))                          ; 2
(depth*-if &#39;(margarine ((bitter butter) (makes) (batter (bitter))) butter)) ; 4
(depth*-if &#39;(c (b (a b) a) a))                                              ; 3

; depth* via max
;
(define depth*-max
  (lambda (l)
    (cond
      ((null? l) 1)
      ((atom? (car l))
       (depth*-max (cdr l)))
      (else
        (max
          (add1 (depth*-max (car l)))
          (depth*-max (cdr l)))))))

; Tests of depth*-max
;
(depth*-max &#39;((pickled) peppers (peppers pickled)))                          ; 2
(depth*-max &#39;(margarine ((bitter butter) (makes) (batter (bitter))) butter)) ; 4
(depth*-max &#39;(c (b (a b) a) a))                                              ; 3

; Not interested in scramble problem, skipping it.

; leftmost via letcc
;
(define leftmost-letcc
  (lambda (l)
    (call-with-current-continuation
      (lambda (skip)
        (lm l skip)))))

; lm is leftmost-letcc&#39;s helper function
;
(define lm
  (lambda (l out)
    (cond
      ((null? l) &#39;())
      ((atom? (car l)) (out (car l)))
      (else
        (let () ; can also use &#39;begin&#39;
          (lm (car l) out)
          (lm (cdr l) out))))))

(leftmost-letcc &#39;(((x) b) (c d)))   ; &#39;x
(leftmost-letcc &#39;(((x) ()) () (e))) ; &#39;x
(leftmost-letcc &#39;(((() x) ())))     ; &#39;x
(leftmost-letcc &#39;(((()) ())))       ; &#39;()

; letfmost following 13th and 14th commandments
;
(define leftmost-1314
  (letrec
    ((lm (lambda (l out)
           (cond
             ((null? l) &#39;())
             ((atom? (car l)) (out (car l)))
             (else
               (begin
                 (lm (car l) out)
                 (lm (cdr l) out)))))))
    (lambda (l)
      (call-with-current-continuation
        (lambda (skip)
          (lm l skip))))))

(leftmost-1314 &#39;(((x) b) (c d)))   ; &#39;x
(leftmost-1314 &#39;(((x) ()) () (e))) ; &#39;x
(leftmost-1314 &#39;(((() x) ())))     ; &#39;x
(leftmost-1314 &#39;(((()) ())))       ; &#39;()

; another way to follow 13th and 14th commandments
;
(define leftmost-13142
  (lambda (l)
      (letrec
        ((lm (lambda (l out)
               (cond
                 ((null? l) &#39;())
                 ((atom? (car l)) (out (car l)))
                 (else
                   (begin
                     (lm (car l) out)
                     (lm (cdr l) out)))))))
        (call-with-current-continuation
          (lambda (skip)
            (lm l skip))))))

(leftmost-13142 &#39;(((x) b) (c d)))   ; &#39;x
(leftmost-13142 &#39;(((x) ()) () (e))) ; &#39;x
(leftmost-13142 &#39;(((() x) ())))     ; &#39;x
(leftmost-13142 &#39;(((()) ())))       ; &#39;()

; yet another way
;
(define leftmost-131422
  (lambda (l)
    (call-with-current-continuation
      (lambda (skip)
        (letrec
          ((lm (lambda (l)
                 (cond
                   ((null? l) &#39;())
                   ((atom? (car l)) (skip (car l)))
                   (else
                     (begin
                       (lm (car l))
                       (lm (cdr l))))))))
          (lm l))))))

(leftmost-131422 &#39;(((x) b) (c d)))   ; &#39;x
(leftmost-131422 &#39;(((x) ()) () (e))) ; &#39;x
(leftmost-131422 &#39;(((() x) ())))     ; &#39;x
(leftmost-131422 &#39;(((()) ())))       ; &#39;()

; rember1* via letcc
;
(define rember1*-letcc
  (lambda (a l)
    (letrec
      ((rm (lambda (a l oh)
             (cond
               ((null? l) (oh &#39;no))
               ((atom? (car l))
                (if (eq? (car l) a)
                  (cdr l)
                  (cons (car l) (rm a (cdr l) oh))))
               (else
                 (let ((new-car
                         (call-with-current-continuation
                           (lambda (oh)
                             (rm a (car l) oh)))))
                   (if (atom? new-car)
                     (cons (car l) (rm a (cdr l) oh))
                     (cons new-car (cdr l)))))))))
      (let ((new-l
              (call-with-current-continuation
                (lambda (oh)
                  (rm a l oh)))))
        (if (atom? new-l)
          l
          new-l)))))

; Tests of rember1*-letcc
;
(rember1*-letcc
  &#39;salad
  &#39;((Swedish rye) (French (mustard salad turkey)) salad))
; ==&amp;gt; &#39;((Swedish rye) (French (mustard turkey)) salad)

(rember1*-letcc
  &#39;meat
  &#39;((pasta meat) pasta (noodles meat sauce) meat tomatoes))
; ==&amp;gt; &#39;((pasta) pasta (noodles meat sauce) meat tomatoes)

(rember1*-letcc
  &#39;a
  &#39;((foo bar) baz))
; ==&amp;gt; &#39;((foo bar) baz)


;
; Chapter 16 of The Seasoned Schemer:
; Ready, Set, Bang!
;
; Code examples assemled by Peteris Krumins (peter@catonmat.net).
; His blog is at http://www.catonmat.net  --  good coders code, great reuse.
;
; Get yourself this wonderful book at Amazon: http://bit.ly/8cyjgw
;

; sub1 primitive
;
(define sub1
  (lambda (n)
    (- n 1)))

; add1 primitive
;
(define add1
  (lambda (n)
    (+ n 1)))

; atom? primitive
;
(define atom?
  (lambda (x)
   (and (not (pair? x)) (not (null? x)))))  

; member? helper function
;
(define member?
  (lambda (a l)
    (letrec
      ((yes? (lambda (l)
               (cond
                 ((null? l) #f)
                 ((eq? (car l) a) #t)
                 (else (yes? (cdr l)))))))
      (yes? l))))


; Code examples start here
;
(define sweet-tooth
  (lambda (food)
    (cons food (cons &#39;cake &#39;()))))

(define last &#39;angelfood)

(sweet-tooth &#39;fruit)        ; &#39;(fruit cake)
last                        ; &#39;angelfood

; The sweet-toothL function saves the last food
;
(define sweet-toothL
  (lambda (food)
    (set! last food)
    (cons food (cons &#39;cake &#39;()))))

(sweet-toothL &#39;chocolate)   ; &#39;(chocolate cake)
last                        ; &#39;chocolate

(sweet-toothL &#39;fruit)       ; &#39;(fruit cake)
last                        ; &#39;fruit

(define ingredients &#39;())

; The sweet-toothR function builds a list of foods
;
(define sweet-toothR
  (lambda (food)
    (set! ingredients
      (cons food ingredients))
    (cons food (cons &#39;cake &#39;()))))

(sweet-toothR &#39;chocolate)   ; &#39;(chocolate cake)
ingredients                 ; &#39;(chocolate)

(sweet-toothR &#39;fruit)       ; &#39;(fruit cake)
ingredients                 ; &#39;(fruit chocolate)

(sweet-toothR &#39;cheese)      ; &#39;(cheese cake)
ingredients                 ; &#39;(cheese fruit chocolate)

(sweet-toothR &#39;carrot)      ; &#39;(carrot cake)
ingredients                 ; &#39;(carrot cheese fruit chocolate)

; The deep function wraps pizza in n parenthesis
;
(define deep
  (lambda (m)
    (cond
      ((zero? m) &#39;pizza)
      (else
        (cons (deep (sub1 m)) &#39;())))))

; Example of deep
;
(deep 3)                    ; &#39;(((pizza)))
(deep 0)                    ; &#39;pizza

; The deepR1 function remembers the numbers deep has seen so far
;
(define Ns1 &#39;())
(define deepR1
  (lambda (n)
    (set! Ns1 (cons n Ns1))
    (deep n)))

; Examples of deepR1
;
(deepR1 3)                  ; &#39;(((pizza)))
Ns1                         ; (3)
(deepR1 0)                  ; &#39;pizza
Ns1                         ; (0 3)

; The deepR function remembers the numbers and the results
;
(define Ns &#39;())
(define Rs &#39;())
(define deepR
  (lambda (n)
    (let ((result (deep n)))
      (set! Ns (cons n Ns))
      (set! Rs (cons result Rs))
      result)))

; Examples of deepR
;
(deepR 3)                   ; &#39;(((pizza)))
Ns                          ; &#39;(3)
Rs                          ; &#39;((((pizza))))
(deepR 5)                   ; &#39;(((((pizza)))))
Ns                          ; &#39;(5 3)
Rs                          ; &#39;((((((pizza))))) (((pizza))))
(deepR 3)                   ; &#39;(((pizza)))
Ns                          ; &#39;(3 5 3)
Rs                          ; &#39;((((pizza))) (((((pizza))))) (((pizza))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;                                                                            ;
; The nineteenth commandment                                                 ;
;                                                                            ;
; Use (set! ...) to remember valuable things between two distinct uses of a  ;
; function.                                                                  ;
;                                                                            ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; The find function finds pizza in Rs
;
(define find
  (lambda (n Ns Rs)
    (letrec
      ((A (lambda (ns rs)
            (cond
              ((= (car ns) n) (car rs))
              (else
                (A (cdr ns) (cdr rs)))))))
      (A Ns Rs))))

; Examples of find
;
(find 3 Ns Rs)              ; &#39;(((pizza)))
(find 5 Ns Rs)              ; &#39;(((((pizza)))))
;(find 7 Ns Rs)             ; not applicable at this time

; The deepM function either uses find or computes pizza (temporary version)
;
(define deepM-tmp
  (lambda (n)
    (if (member? n Ns)
      (find n Ns Rs)
      (deepR n))))

Ns                          ; &#39;(3 5 3)
Rs                          ; &#39;((((pizza))) (((((pizza))))) (((pizza))))

(set! Ns (cdr Ns))
(set! Rs (cdr Rs))

Ns                          ; &#39;(5 3)
Rs                          ; &#39;((((((pizza))))) (((pizza))))

; The final deepM version
;
(define deepM
  (lambda (n)
    (if (member? n Ns)
      (find n Ns Rs)
      (let ((result (deep n)))
        (set! Rs (cons result Rs))
        (set! Ns (cons n Ns))
        result))))

; Examples of deepM
(deepM 3)                   ; &#39;(((pizza)))
(deepM 6)                   ; &#39;((((((pizza))))))

; Redefining deep
;
(define deep
  (lambda (m)
    (cond
      ((zero? m) &#39;pizza)
      (else (cons (deepM (sub1 m)) &#39;())))))

(deepM 9)                   ; &#39;(((((((((pizza)))))))))

Ns                          ; &#39;(9 8 7 6 5 3)

; Redefining deepM to folow 16th commandment
;
(define deepM
  (let ((Rs &#39;())
        (Ns &#39;()))
    (lambda (n)
      (if (member? n Ns)
        (find n Ns Rs)
        (let ((result (deep n)))
          (set! Rs (cons result Rs))
          (set! Ns (cons n Ns))
          result)))))

; Tests of the new deepM
;
(deepM 10)                  ; &#39;((((((((((pizza))))))))))
(deepM 16)                  ; &#39;((((((((((((((((pizza))))))))))))))))

; Better answer for find on empty lists
;
(define find
  (lambda (n Ns Rs)
    (letrec
      ((A (lambda (ns rs)
            (cond
              ((null? ns) #f)
              ((= (car ns) n) (car rs))
              (else
                (A (cdr ns) (cdr rs)))))))
      (A Ns Rs))))

; And a better deepM
;
(define deepM
  (let ((Rs &#39;())
        (Ns &#39;()))
    (lambda (n)
      (let ((exists (find n Ns Rs)))
        (if (atom? exists)
          (let ((result (deep n)))
            (set! Rs (cons result Rs))
            (set! Ns (cons n Ns))
            result)
          exists)))))

; Example of the new deepM
;
(deepM 10)                  ; &#39;((((((((((pizza))))))))))
(deepM 16)                  ; &#39;((((((((((((((((pizza))))))))))))))))
(deepM 0)                   ; &#39;pizza


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;                                                                            ;
;              Take a deep breath or a deep pizza, now.                      ;
;                                                                            ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Our good, old friend length
;
(define lengthz
  (lambda (l)
    (cond
      ((null? l) 0)
      (else (add1 (lengthz (cdr l)))))))

; Test length
;
(lengthz &#39;())        ; 0
(lengthz &#39;(a b x))   ; 3

; length via set!
;
(define lengthz
  (lambda (l) 0))

(set! lengthz
  (lambda (l)
    (cond
      ((null? l) 0)
      (else (add1 (lengthz (cdr l)))))))

; Test length
;
(lengthz &#39;())        ; 0
(lengthz &#39;(a b x))   ; 3

; length via set! again
;
(define lengthz
  (let ((h (lambda (l) 0)))
    (set! h
      (lambda (l)
        (cond
          ((null? l) 0)
          (else (add1 (h (cdr l)))))))
    h))

; Test length
;
(lengthz &#39;())        ; 0
(lengthz &#39;(a b x))   ; 3

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;                                                                            ;
; The seventeenth commandment (final version)                                ;
;                                                                            ;
; Use (set! x ...) for (let ((x ...)) ...) only if there is at least one     ;
; (lambda ... between it and the (let ...), or if the new value for x is a   ;
; function that refers to x                                                  ;
;                                                                            ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Another way to write length
;
(define h1              ; h1 is actually an anonymous name
  (lambda (l) 0))

(define lengthz
  (let ()
    (set! h1
      (lambda (l)
        (cond
          ((null? l) 0)
          (else (add1 (h1 (cdr l)))))))
    h1))

; Test length
;
(lengthz &#39;())        ; 0
(lengthz &#39;(a b x))   ; 3

; Another way
;
(define h2              ; h2 is actually an anonymous name
  (lambda (l)
    (cond
      ((null? l) 0)
      (else (add1 (h2 (cdr l)))))))

(define lengthz
  (let () h2))

; Test length
;
(lengthz &#39;())        ; 0
(lengthz &#39;(a b x))   ; 3

; length again
;
(define lengthz
  (let ((h (lambda (l) 0)))
    (set! h
      (lambda (l)
        (cond
          ((null? l) 0)
          (else (add1 (h (cdr l)))))))
    h))

; Test length
;
(lengthz &#39;())        ; 0
(lengthz &#39;(a b x))   ; 3

; Let&#39;s eliminate parts that are specific to length
;
(define L
  (lambda (lengthz)
    (lambda (l)
      (cond
        ((null? l) 0)
        (else (add1 (lengthz (cdr l))))))))

(define lengthz
  (let ((h (lambda (l) 0)))
    (set! h
      (L (lambda (arg) (h arg))))
    h))

; Test length
;
(lengthz &#39;())        ; 0
(lengthz &#39;(a b x))   ; 3

; Y-bang - the applicative-order imperative y-combinator
; (discovered by Peter Landin)
;
(define Y-bang
  (lambda (f)
    (letrec
      ((h (f (lambda (arg) (h arg)))))
      h)))

(define lengthz (Y-bang L))

; Test length
;
(lengthz &#39;())        ; 0
(lengthz &#39;(a b x))   ; 3

; depth* via Y-bang
;
(define D
  (lambda (depth*)
    (lambda (s)
      (cond
        ((null? s) 1)
        ((atom? (car s)) (depth* (cdr s)))
        (else
          (max (add1 (depth* (car s))) (depth* (cdr s))))))))

(define depth* (Y-bang D))

; Test depth*
;
(depth* &#39;())                ; 1
(depth* &#39;(((pizza)) ()))    ; 3

; The bizarre function
;
(define biz
  (let ((x 0))
    (lambda (f)
      (set! x (add1 x))
      (lambda (a)
        (if (= a x)
          0
          (f a))))))

; Another way to write bizarre
;
(define x1 0)               ; anonymous var
(define biz
  (lambda (f)
    (set! x1 (add1 x1))
    (lambda (a)
      (if (= a x1)
        0
        (f a)))))

; The Y-Combinator
;
(define Y
  (lambda (le)
    ((lambda (f) (f f))
     (lambda (f)
       (le (lambda (x) ((f f) x)))))))

((Y biz) 5)

; ((Y-bang biz) 5)          ; doesn&#39;t compute... why?


;
; Chapter 17 of The Seasoned Schemer:
; We Change, Therefore We Are!
;
; Code examples assemled by Peteris Krumins (peter@catonmat.net).
; His blog is at http://www.catonmat.net  --  good coders code, great reuse.
;
; Get yourself this wonderful book at Amazon: http://bit.ly/8cyjgw
;

; The atom? primitive
;
(define atom?
  (lambda (x)
   (and (not (pair? x)) (not (null? x)))))  

; The sub1 primitive
;
(define sub1
  (lambda (n)
    (- n 1)))

; The add1 primitive
;
(define add1
  (lambda (n)
    (+ n 1)))

; The deep function wraps pizza in m parenthesis
;
(define deep
  (lambda (m)
    (if (zero? m)
      &#39;pizza
      (cons (deep (sub1 m)) &#39;()))))

; Examples of deep
;
(deep 3)                ; &#39;(((pizza)))
(deep 0)                ; &#39;pizza

; The deepM function remembers calls to deep
;
; The deepM function uses find function to find n in Ns and return 
; the correct value from Rs
;
(define find
  (lambda (n Ns Rs)
    (letrec
      ((A (lambda (ns rs)
            (cond
              ((null? ns) #f)
              ((= (car Ns) n) (car Rs))
              (else
                (A (cdr ns) (cdr rs)))))))
      (A Ns Rs))))

(define deepM
  (let ((Rs &#39;())
        (Ns &#39;()))
    (letrec
      ((D (lambda (m)
            (if (zero? m)
              &#39;pizza
              (cons (deepM (sub1 m)) &#39;())))))
      (lambda (n)
        (let ((exists (find n Ns Rs)))
          (if (atom? exists)
            (let ((result (D n)))
              (set! Rs (cons result Rs))
              (set! Ns (cons n Ns))
              result)
            exists))))))

; Examples of deepM
;
(deepM 3)               ; &#39;(((pizza)))
(deepM 0)               ; &#39;pizza

; No need to use letrec in deepM
;
(define deepM-letrec
  (let ((Rs &#39;())
        (Ns &#39;())
        (D (lambda (m)
              (if (zero? m)
                &#39;pizza
                (cons (deepM-letrec (sub1 m)) &#39;())))))
    (lambda (n)
      (let ((exists (find n Ns Rs)))
        (if (atom? exists)
          (let ((result (D n)))
            (set! Rs (cons result Rs))
            (set! Ns (cons n Ns))
            result)
          exists)))))

; Test of the new deepM
;
(deepM-letrec 3)               ; &#39;(((pizza)))
(deepM-letrec 0)               ; &#39;pizza

; No need for D in deepM
;
(define deepM-D
  (let ((Rs &#39;())
        (Ns &#39;()))
    (lambda (n)
      (let ((exists (find n Ns Rs)))
        (if (atom? exists)
          (let ((result ((lambda (m)
                           (if (zero? m)
                             &#39;pizza
                             (cons (deepM-D (sub1 m)) &#39;()))) n)))
            (set! Rs (cons result Rs))
            (set! Ns (cons n Ns))
            result)
          exists)))))

; Test of the new deepM
;
(deepM-D 3)               ; &#39;(((pizza)))
(deepM-D 0)               ; &#39;pizza

; No need for the 2nd lambda 
;
(define deepM-2nd
  (let ((Rs &#39;())
        (Ns &#39;()))
    (lambda (n)
      (let ((exists (find n Ns Rs)))
        (if (atom? exists)
          (let ((result (if (zero? n)
                            &#39;pizza
                            (cons (deepM-2nd (sub1 n)) &#39;()))))
            (set! Rs (cons result Rs))
            (set! Ns (cons n Ns))
            result)
          exists)))))

; Test of the new deepM
;
(deepM-2nd 3)               ; &#39;(((pizza)))
(deepM-2nd 0)               ; &#39;pizza

; The consC function counts number of conses needed to build
; n-deep pizza
;
(define consC
  (let ((N 0))
    (lambda (x y)
      (set! N (add1 N))
      (cons x y))))

; No way to get N out of this consC, so we need the counter
; function that will hold the count
;
(define counter 0)

; And a modification of consC
;
(define consC
  (let ((N 0))
    (set! counter (lambda() N))
    (lambda (x y)
      (set! N (add1 N))
      (cons x y))))
        
; And we need to modify deep
;
(define deep
  (lambda (m)
    (if (zero? m)
      &#39;pizza
      (consC (deep (sub1 m)) &#39;()))))

(deep 5)            ; &#39;(((((pizza)))))
(counter)           ; 5

(deep 7)            ; &#39;(((pizza))
(counter)           ; 12                ;;; (5 + 7) 

; Let&#39;s determine how many cons&#39;es are necessary to find
; values of (deep 0) ... (deep 1000).
;
(define supercounter
  (lambda (f)
    (letrec
      ((S (lambda (n)
            (if (zero? n)
              (f n)
              (let ()
                (f n)
                (S (sub1 n)))))))
      (S 1000)
      (counter))))

; Try out supercounter
;
(supercounter deep)         ; 500512    ;;; not 500500 as expected

; Need to wipe out counter before using it again
;
(define set-counter 0)

(define consC
  (let ((N 0))
    (set! counter (lambda() N))
    (set! set-counter
      (lambda (x) (set! N x)))
    (lambda (x y)
      (set! N (add1 N))
      (cons x y))))

(set-counter 0)

; Try out supercounter again
;
(supercounter deep)

; How many conses are used by (deepM 5)?
; Need to modify deepM to use consC first.
;
(define deepM-consC
  (let ((Rs &#39;())
        (Ns &#39;()))
    (lambda (n)
      (let ((exists (find n Ns Rs)))
        (if (atom? exists)
          (let ((result
                  (if (zero? n)
                    &#39;pizza
                    (consC (deepM-consC (sub1 n)) &#39;()))))
            (set! Rs (cons result Rs))
            (set! Ns (cons n Ns))
            result)
          exists)))))

; How many conses are used by (deepM 5)?
;
(deepM 5)           ; &#39;(((((pizza)))))
(counter)           ; 500505    ;;; because we forgot to reset counter

(set-counter 0)
(deepM-consC 5)     ; &#39;(((((pizza)))))
(counter)           ; 5

(deep 7)            ;
(counter)           ; ??? the book says it should be 0, I get 12, why?

(supercounter deepM-consC)  ; ??? how did this work? it didn&#39;t take an argument?

; Book has also talks about conses in rember* function but I am not interested
; in it at the moment.



;
; Chapter 18 of The Seasoned Schemer:
; We Change, Therefore We Are the Same!
;
; Code examples assemled by Peteris Krumins (peter@catonmat.net).
; His blog is at http://www.catonmat.net  --  good coders code, great reuse.
;
; Get yourself this wonderful book at Amazon: http://bit.ly/8cyjgw
;

; The atom? primitive
;
(define atom?
  (lambda (x)
   (and (not (pair? x)) (not (null? x)))))  

; The sub1 primitive
;
(define sub1
  (lambda (n)
    (- n 1)))

; The add1 primitive
;
(define add1
  (lambda (n)
    (+ n 1)))

; The lots function creates lots of eggs
;
(define lots
  (lambda (n)
    (cond
      ((zero? n) &#39;())
      (else
        (cons &#39;egg (lots (sub1 n)))))))

; The lenkth function counts the eggs
;
(define lenkth
  (lambda (l)
    (cond
      ((null? l) 0)
      (else
        (add1 (lenkth (cdr l)))))))

; Examples of lots and lenkth
;
(lots 3)                ; &#39;(egg egg egg)
(lots 5)                ; &#39;(egg egg egg egg egg)
(lots 12)               ; &#39;(egg egg egg egg egg egg egg egg egg egg egg egg)
(lenkth (lots 3))       ; 3
(lenkth (lots 5))       ; 5
(lenkth (lots 15))      ; 15

; Create 4 eggs from 3 eggs
;
(cons &#39;egg (lots 3))    ; &#39;(egg egg egg egg)

; consC, counter, set-counter from chapter 17
;
(define counter (lambda() 0))
(define set-counter (lambda () 0))
(define consC
  (let ((N 0))
    (set! counter (lambda() N))
    (set! set-counter
      (lambda (x) (set! N x)))
    (lambda (x y)
      (set! N (add1 N))
      (cons x y))))

; Add an egg at the end
;
(define add-at-end
  (lambda (l)
    (cond
      ((null? (cdr l))
       (consC (car l) (cons &#39;egg-end &#39;())))
      (else
        (consC (car l) (add-at-end (cdr l)))))))

; Example of add-at-end
;
(add-at-end (lots 3))   ; &#39;(egg egg egg egg-end)

(counter)               ; 3

; Add an egg at the end without making any new conses except for the last one
;
(define add-at-end-too
  (lambda (l)
    (letrec
      ((A (lambda (ls)
            (cond
              ((null? (cdr ls))
               (set-cdr! ls (cons &#39;egg-end2 &#39;())))
              (else
                (A (cdr ls)))))))
      (A l)
      l)))

; Example of add-at-end-too
;
(set-counter 0)
(add-at-end-too (lots 3))   ; &#39;(egg egg egg egg-end2)
(counter)                   ; 0

; kons the magnificent
;
(define kons
  (lambda (kar kdr)
    (lambda (selector)          ; returns lambda (selector)
      (selector kar kdr))))     ; calls selector with kar and kdr arguments

; kar
;
(define kar
  (lambda (c)                   ; applies selector on (a d) and returns &#39;a (car)
    (c (lambda (a d) a))))

; kdr
;
(define kdr
  (lambda (c)                   ; applies selector on (a d) and returns d (cdr)
    (c (lambda (a d) d))))

; Examples of kons kar kdr
;
(kar (kons &#39;a &#39;()))                 ; &#39;a
(kdr (kons &#39;a &#39;()))                 ; &#39;()
(kar (kdr (kons &#39;a (kons &#39;b &#39;())))) ; &#39;b
(kar (kons &#39;a (kons &#39;b &#39;())))       ; &#39;a

; Another cons
;
(define bons
  (lambda (kar)
    (let ((kdr &#39;()))
      (lambda (selector)
        (selector
          (lambda (x) (set! kdr x))
          kar
          kdr)))))

; Another kar
;
(define bar
  (lambda (c)
    (c (lambda (s a d) a))))

; Another kdr
;
(define bdr
  (lambda (c)
    (c (lambda (s a d) d))))

; set-kdr
;
(define set-kdr
  (lambda (c x)
    ((c (lambda (s a d) s)) x)))

; create kons using set-kdr and bons
;
(define kons2
  (lambda (a d)
    (let ((c (bons a)))
      (set-kdr c d)
      c)))

; Example of kons2 bar and bdr
;
(bar (kons2 &#39;a &#39;(1 2 3)))       ; &#39;a
(bdr (kons2 &#39;a &#39;(1 2 3)))       ; &#39;(1 2 3)

; Now eggs again
;
(define dozen (lots 12))

dozen           ; &#39;(egg egg egg egg egg egg egg egg egg egg egg egg)
                ; used 12 conses

(define bakers-dozen (add-at-end dozen))

bakers-dozen    ; &#39;(egg egg egg egg egg egg egg egg egg egg egg egg egg-end)
                ; used 13 conses (25 total now)

(define bakers-dozen-too (add-at-end-too dozen))

bakers-dozen-too    ; &#39;(egg egg egg egg egg egg egg egg egg egg egg egg egg-end egg-end2)
                    ; used 1 cons (26 total)

(define bakers-dozen-again (add-at-end dozen))

bakers-dozen-again  ; &#39;(egg egg egg egg egg egg egg egg egg egg egg egg egg-end egg-end2 egg-end)
                    ; used 14 conses (40 total)

(define same?
  (lambda (c1 c2)
    (cond
      ((and (null? c1) (null? c2)) #t)
      ((or (null? c1) (null? c2)) #f)
      (else
       (let ((t1 (cdr c1))
             (t2 (cdr c2)))
         (set-cdr! c1 1)
         (set-cdr! c2 2)
         (let ((v (= (cdr c1) (cdr c2))))
           (set-cdr! c1 t1)
           (set-cdr! c2 t2)
           v))))))

(same? dozen dozen)                     ; #t
(same? dozen bakers-dozen)              ; #f
(same? dozen bakers-dozen-too)          ; #t
(same? dozen bakers-dozen-again)        ; #f
(same? bakers-dozen bakers-dozen-too)   ; #f   ;;; the book says #t???

; The last-kons function returns the last cons in a non-empty kons-list
;
(define last-kons
  (lambda (ls)
    (cond
      ((null? (cdr ls)) ls)
      (else (last-kons (cdr ls))))))

(define long (lots 12))                 ; &#39;(egg egg egg egg egg egg egg egg egg egg egg egg)

(set-cdr! (last-kons long) long)        ; #0 = &#39;(egg egg egg egg egg egg egg egg egg egg egg . #0#) 

; The finite-lenkth function returns length of a list
; or #f if it&#39;s an infinite list
;
(define finite-lenkth
  (lambda (p)
    (call-with-current-continuation
      (lambda (infinite)
        (letrec
          ((C (lambda (p q)
                (cond
                  ((same? p q) (infinite #f))
                  ((null? q) 0)
                  ((null? (cdr q)) 1)
                  (else
                    (+ (C (sl p) (qk q)) 2)))))
           (qk (lambda (x) (cdr (cdr x))))
           (sl (lambda (x) (cdr x))))
          (cond
            ((null? p) 0)
            (else
              (add1 (C p (cdr p))))))))))

; Examples of finite-lenkth
;
(define not-so-long (lots 5))         ; &#39;(egg egg egg egg egg)
(finite-lenkth not-so-long)           ; 5
(finite-lenkth long)                  ; #f

; Guy&#39;s Favorite Pie
;
(define mongo
  (cons &#39;pie
   (cons &#39;a
    (cons &#39;la
     (cons &#39;mode &#39;())))))
(set-cdr! (cdr (cdr (cdr mongo))) (cdr mongo))

; mongo

;
; Chapter 19 of The Seasoned Schemer:
; Absconding with the Jewels
;
; Code examples assemled by Peteris Krumins (peter@catonmat.net).
; His blog is at http://www.catonmat.net  --  good coders code, great reuse.
;
; Get yourself this wonderful book at Amazon: http://bit.ly/8cyjgw
;

; The atom? primitive
;
(define atom?
  (lambda (x)
   (and (not (pair? x)) (not (null? x)))))  

; The sub1 primitive
;
(define sub1
  (lambda (n)
    (- n 1)))

; Our friend deep
;
(define deep
  (lambda (m)
    (cond
      ((zero? m) &#39;pizza)
      (else (cons (deep (sub1 m)) &#39;())))))

; Example of deep
;
(deep 6)                    ; &#39;((((((pizza))))))

; Six layers creates six layered pizza
;
(define six-layers
  (lambda (p)
    (cons (cons (cons
    (cons (cons (cons p &#39;()) &#39;()) &#39;()) &#39;()) &#39;()) &#39;())))

; Example of six-layers
;
(six-layers &#39;pizza)         ; &#39;((((((pizza))))))

; Four layers makes a four layered pizza
;
(define four-layers
  (lambda (p)
    (cons (cons (cons
    (cons p &#39;()) &#39;()) &#39;()) &#39;())))

; Example of four-layers
;
(four-layers &#39;pizza)        ; &#39;((((pizza))))

; The deepB function does layering
;
(define toppings 0)
(define deepB
  (lambda (m)
    (cond
      ((zero? m)
       (call-with-current-continuation
         (lambda (jump)
           (set! toppings jump)
           &#39;pizza)))
      (else
        (cons (deepB (sub1 m)) &#39;())))))

; Example of deepB
;
(deepB 6)                   ; &#39;((((((pizza)))))), but what does jump do?

; Six layers again
;
(six-layers &#39;mozzarella)    ; &#39;((((((mozarella))))))

; Now the toppings
;
(toppings &#39;mozzarella)      ; &#39;((((((mozarella))))))
(toppings &#39;cake)            ; &#39;((((((cake))))))
(toppings &#39;pizza)           ; &#39;((((((pizza))))))

; What about his
;
(cons (toppings &#39;cake) &#39;()) ; it&#39;s still &#39;((((((cake)))))) and not &#39;(((((((cake)))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;                                                                            ;
; The twentieth commandment                                                  ;
;                                                                            ;
; When thinking about a value created with (letcc ...), write down the       ;
; function that is equivalent but does not forget. Then, when you use it,    ;
; remember to forget.                                                        ;
;                                                                            ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Deep&amp;amp;co
;
(define deep&amp;amp;co
  (lambda (m k)
    (cond
      ((zero? m) (k &#39;pizza))
      (else
        (deep&amp;amp;co (sub1 m)
         (lambda (x) (k (cons x &#39;()))))))))

; Examples of deep&amp;amp;co
;
(deep&amp;amp;co 0 (lambda (x) x))          ; &#39;pizza
(deep&amp;amp;co 6 (lambda (x) x))          ; &#39;((((((pizza))))))
(deep&amp;amp;co 2 (lambda (x) x))          ; &#39;((pizza))

; Deep&amp;amp;coB
;
(define deep&amp;amp;coB
  (lambda (m k)
    (cond
      ((zero? m)
       (let ()
         (set! toppings k)
         (k &#39;pizza)))
    (else
      (deep&amp;amp;coB (sub1 m)
        (lambda (x)
          (k (cons x &#39;()))))))))

; Examples of deep&amp;amp;coB
;
(deep&amp;amp;coB 6 (lambda (x) x))         ; &#39;((((((pizza))))))
(deep&amp;amp;coB 4 (lambda (x) x))         ; &#39;((((pizza))))

; toppings is now four-layers

(toppings &#39;cake)                    ; &#39;((((cake))))
(cons
  (toppings &#39;cake)
  (toppings &#39;cake))                 ; &#39;(((((cake)))) (((cake))))

; Remember two-in-a-row?
;
(define two-in-a-row?
  (letrec
    ((W (lambda (a lat)
          (cond
            ((null? lat) #f)
            (else
              (let ((nxt (car lat)))
                (or
                  (eq? nxt a)
                  (W nxt (cdr lat)))))))))
    (lambda (lat)
      (cond
        ((null? lat) #f)
        (else (W (car lat) (cdr lat)))))))

; Examples of two-in-a-row?
;
(two-in-a-row? &#39;(mozzarella cake mozzarella))      ; #f
(two-in-a-row? &#39;(mozzarella mozzarella cake))      ; #t

; walk
;
(define leave &#39;0)
(define walk
  (lambda (l)
    (cond
      ((null? l) &#39;())
      ((atom? (car l))
       (leave (car l)))
      (else
        (begin
          (walk (car l))
          (walk (cdr l)))))))

; we need leave
(define start-it
  (lambda (l)
    (call-with-current-continuation
      (lambda (here)
        (set! leave here)
        (walk l)))))

; Example of start-it
;
(start-it &#39;((potato) (chips (chips (with))) fish))  ; &#39;potato

; waddle, just like walk but remembers where it left
;
(define fill 0)
(define waddle
  (lambda (l)
    (cond
      ((null? l) &#39;())
      ((atom? (car l))
       (begin
         (call-with-current-continuation
           (lambda (rest)
             (set! fill rest)
             (leave (car l))))
         (waddle (cdr l))))
      (else
        (begin
          (waddle (car l))
          (waddle (cdr l)))))))

; A new start
;
(define start-it2
  (lambda (l)
    (call-with-current-continuation
      (lambda (here)
        (set! leave here)
        (waddle l)))))

; Example of start-it2
;
(start-it2 &#39;((donuts) (cheerios (cheerios (spaghettios))) donuts))
; ===&amp;gt; &#39;donuts

; get-next gets the next atom
;
(define get-next
  (lambda (x)
    (call-with-current-continuation
      (lambda (here-again)
        (set! leave here-again)
        (fill &#39;go)))))

; Examples of get-next
;
(get-next &#39;go)      ; &#39;cheerios
(get-next &#39;go)      ; &#39;cheerios
(get-next &#39;go)      ; &#39;paghettios
(get-next &#39;go)      ; &#39;donuts
(get-next &#39;go)      ; &#39;()

; get-first
;
(define get-first
  (lambda (l)
    (call-with-current-continuation
      (lambda (here)
        (set! leave here)
        (waddle l)
        (leave &#39;())))))

; Examples of get-first and get-next
;
(get-first &#39;(fish (chips)))     ; &#39;fish
(get-next &#39;go)                  ; &#39;chips
(get-next &#39;go)                  ; &#39;()

; And now the two-in-a-row*?
;
(define two-in-a-row*?
  (letrec
    ((T? (lambda (a)
           (let ((n (get-next 0)))
             (if (atom? n)
               (or (eq? n a) (T? n))
               #f))))
     (get-next
       (lambda (x)
         (call-with-current-continuation
           (lambda (here-again)
             (set! leave here-again)
             (fill &#39;go)))))
     (fill (lambda (x) x))
     (waddle
       (lambda (l)
         (cond
           ((null? l) &#39;())
           ((atom? (car l))
            (begin              ; or (let() ...
              (call-with-current-continuation
                (lambda (rest)
                  (set! fill rest)
                  (leave (car l))))
              (waddle (cdr l))))
           (else
             (begin
               (waddle (car l))
               (waddle (cdr l)))))))
     (leave (lambda (x) x)))
    (lambda (l)
      (let ((fst (call-with-current-continuation
                   (lambda (here)
                     (set! leave here)
                     (waddle l)
                     (leave &#39;())))))
        (if (atom? fst) (T? fst) #f)))))

; Examples of two-in-a-row*?
;
(two-in-a-row*? &#39;(((food) ()) (((food)))))      ; #t
(two-in-a-row*? &#39;(a (b (c (d))) () () (d)))     ; #t
(two-in-a-row*? &#39;())                            ; #f
(two-in-a-row*? &#39;(((((a))))))                   ; #f


&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>从lambda到simple&#43;complex解释器再到树形抽象</title>
      <link>https://jueqingsizhe66.github.io/archives/cong-lambdadao-simple-plus-complexjie-shi-qi-zai-dao-shu-xing-chou-xiang/</link>
      <pubDate>Sun, 17 May 2015 11:32:07 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/archives/cong-lambdadao-simple-plus-complexjie-shi-qi-zai-dao-shu-xing-chou-xiang/</guid>
      <description>&lt;h2 id=&#34;定义一个eternity函数并尝试是否可以执行&#34;&gt;定义一个eternity函数，并尝试是否可以执行&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define eternity
(lambda (x)
   (eternity x)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其实eternity永远在执行着，无法退出&lt;/p&gt;
&lt;h3 id=&#34;1下面式子只能计算列表的长度0的且永远不会调用eternity&#34;&gt;1.下面式子只能计算列表的长度&amp;lt;=0的,且永远不会调用eternity&lt;/h3&gt;
&lt;p&gt;; Function to calculate length of just empty list.
;
((lambda (len)
(lambda (l)
(cond
((null? l) 0)
(else (+ 1 (len (cdr l)))))))
eternity)&lt;/p&gt;
&lt;h3 id=&#34;2下面式子只能计算列表的长度1的且永远不会调用eternity&#34;&gt;2.下面式子只能计算列表的长度&amp;lt;=1的,且永远不会调用eternity&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;; For lists with length &amp;lt;= 1
;
((lambda (mk-length)
  (mk-length mk-length))
 (lambda (mk-length)
   (lambda (l)
     (cond
       ((null? l) 0)
       (else (+ 1 ((mk-length eternity) (cdr l))))))))


&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3下面式子只能计算列表的长度2的且永远不会调用eternity&#34;&gt;3.下面式子只能计算列表的长度&amp;lt;=2的,且永远不会调用eternity&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;; For lists with length &amp;lt;= 2
;
((lambda (len)
  (lambda (l)
    (cond
      ((null? l) 0)
      (else (+ 1 (len (cdr l)))))))
 ((lambda (len)
   (lambda (l)
     (cond
       ((null? l) 0)
       (else (+ 1 (len (cdr l)))))))
  ((lambda (len)
    (lambda (l)
      (cond
        ((null? l) 0)
        (else (+ 1 (len (cdr l)))))))
   eternity)))
 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;如果我们进行一次变换&#34;&gt;如果我们进行一次变换&lt;/h2&gt;
&lt;h3 id=&#34;1把eternity替换成mk-length&#34;&gt;1.把eternity替换成mk-length&lt;/h3&gt;
&lt;p&gt;我们发现结果是它可以变成处理无限长度的列表了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(((lambda (mk-length)
  (mk-length mk-length))
 (lambda (mk-length)
   (lambda (l)
     (cond
       ((null? l) 0)
       (else (+ 1 ((mk-length mk-length) (cdr l))))))))
 &#39;(a b c 1 g))  ; 5

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;然而我们对他进一步提取发现报错了&#34;&gt;然而我们对他进一步提取发现报错了&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;((lambda (mk-length)
  (mk-length mk-length))
 (lambda (mk-length)
   ((lambda (len)
     (lambda (l)
       (cond
         ((null? l) 0)
         (else (+ 1 (len (cdr l)))))))
    (mk-length mk-length)))) ; Aborting!: maximum recursion depth exceeded

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;为什么不行&#34;&gt;为什么不行？&lt;/h3&gt;
&lt;p&gt;原因在于 我们需要的是lambda类型的procedure才可以，而函数调用形式则是不行。
然而有一种转换方式如下：&lt;/p&gt;
&lt;p&gt;(f x) ==&amp;gt; (lambda (arg) (f arg) x)&lt;/p&gt;
&lt;p&gt;于是我们得到新的升级版的mk-length&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;
((lambda (mk-length)
  (mk-length mk-length))
 (lambda (mk-length)
   ((lambda (len)
     (lambda (l)
       (cond
         ((null? l) 0)
         (else (+ 1 (len (cdr l)))))))
    (lambda (x) ((mk-length mk-length) x)))))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们发现还是不够满意，我们想把中间的一坨拿到后面去，于是再次抽象一层
也就是我们需要 把(lambda (len) &amp;hellip; (cdr l))部分 移到最外头&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;((lambda (le)
  ((lambda (mk-length)
    (mk-length mk-length))
   (lambda (mk-length)
     (le (lambda (x) ((mk-length mk-length) x))))))
 (lambda (len)
   (lambda (l)
     (cond
       ((null? l) 0)
       (else (+ 1 (len (cdr l))))))))

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然而如果我们把后面的(lambda (len))部分去掉&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(lambda (le)
  ((lambda (mk-length)
    (mk-length mk-length))
   (lambda (mk-length)
     (le (lambda (x) ((mk-length mk-length) x))))))

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;他其实就是下面的骨架：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(lambda (le)
  ((lambda ()
    ())
   (lambda ()
     (le (lambda (x) (() x))))))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果我们使用f来填加：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(lambda (le)
    ((lambda (f)
      (f f))
     (lambda (f)
       (le (lambda (x) ((f f) x))))))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;他其实就是Y-lambda. 我们所谓的define，let,set!都可以从lambda 推出来。&lt;/p&gt;
&lt;h3 id=&#34;let宏&#34;&gt;let宏&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;
(define-syntax
    (syntax-rules ()
        ((let ((var expr) ...) body ...) ((lambda (var ...) body ...) expr ...))))

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也就是我们以后完全可以用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;
(define Y
  (lambda (le)
    ((lambda (f) (f f))
     (lambda (f)
       (le (lambda (x) ((f f) x)))))))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Y-lambda 执行一个 代表lambda的函数子f。&lt;/p&gt;
&lt;p&gt;比如,求最大值(&lt;em&gt;注意：(lambda (func-arg) func-arg是可以不存在的部分,永远不会被执行&lt;/em&gt;)):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;;; 求个数

((Y (lambda (len)
   (lambda (l)
     (cond
       ((null? l) 0)
       (else (+ 1 (len (cdr l))))))))  &#39;(3 2 3  6 1))

;;; 求最大值
 ((Y (lambda (func-arg)
        (lambda (l)
          (cond
            ((null? l) &#39;no-list)
            ((null? (cdr l)) (car l))
            (else (max (car l) (func-arg (cdr l)))))))) &#39;(3 2 5 3 425))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另外我们发现y-lambda可以写成更优雅、对称的形式:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define Y
  (lambda (le)
    ((lambda (f)
      (le (f f))) ;;; 
     (lambda (f)
       (le (lambda (x) ((f f) x)))))))

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Add le()  is not necessay
But the code can be
More beautiful and symmetry&lt;/p&gt;
&lt;h3 id=&#34;然而其实我的想法只不过是他的复制&#34;&gt;然而其实我的想法只不过是他的复制&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define Y1
  (lambda (le)
    ((lambda (fun)
      (fun fun))  ;; 这是基于抽象的方式,也就是把后面的(lambda (f))  带入其中

     (lambda (f)
       (le (lambda (x) ((f f) x)))))))

((Y1 
 (lambda (fun-arg)
   (lambda (l)
     (cond
       ((null? l) 0)
       (else (+ 1 (fun-arg (cdr l)))))))) &#39;(3 5 2 42))
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;简单计算器解释器&#34;&gt;简单计算器解释器&lt;/h2&gt;
&lt;p&gt;来自&lt;a href=&#34;http://pythoner.org/wiki/774/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;wangyin&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;#lang racket
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; 以下三个定义 env0, ent-env, lookup 是对环境(environment)的基本操作:

;; 空环境
(define env0 &#39;())

;; 扩展。对环境 env 进行扩展，把 x 映射到 v，得到一个新的环境
(define ext-env
  (lambda (x v env)
    (cons `(,x . ,v) env)))

;; 查找。在环境中 env 中查找 x 的值
(define lookup
  (lambda (x env)
    (let ([p (assq x env)])
      (cond
       [(not p) x]
       [else (cdr p)]))))

;; 闭包的数据结构定义，包含一个函数定义 f 和它定义时所在的环境
(struct Closure (f env))

;; 解释器的递归定义（接受两个参数，表达式 exp 和环境 env）
;; 共 5 种情况（变量，函数，调用，数字，算术表达式）
(define interp1
  (lambda (exp env)
    (match exp                                          ; 模式匹配 exp 的以下情况（分支）
      [(? symbol? x) (lookup x env)]                    ; 变量
      [(? number? x) x]                                 ; 数字
      [`(lambda (,x) ,e)                                ; 函数
       (Closure exp env)]
      [`(,e1 ,e2)                                       ; 调用
       (let ([v1 (interp1 e1 env)]
             [v2 (interp1 e2 env)])
         (match v1
           [(Closure `(lambda (,x) ,e) env1)
            (interp1 e (ext-env x v2 env1))]))]
      [`(,op ,e1 ,e2)                                   ; 算术表达式
       (let ([v1 (interp1 e1 env)]
             [v2 (interp1 e2 env)])
         (match op
           [&#39;+ (+ v1 v2)]
           [&#39;- (- v1 v2)]
           [&#39;* (* v1 v2)]
           [&#39;/ (/ v1 v2)]))])))

;; 解释器的“用户界面”函数。它把 interp1 包装起来，掩盖第二个参数，初始值为 env0
(define interp
  (lambda (exp)
    (interp1 exp env0)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(interp (+ 2 65))
(interp (* 3 2))
(interp (/ 3 23))



&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;复杂解释器&#34;&gt;复杂解释器&lt;/h2&gt;
&lt;p&gt;分为五个部分&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;*const&lt;/li&gt;
&lt;li&gt;*cond&lt;/li&gt;
&lt;li&gt;*identifier(loop-up-evironment)&lt;/li&gt;
&lt;li&gt;*quote&lt;/li&gt;
&lt;li&gt;*lambda&lt;/li&gt;
&lt;li&gt;*Aplication(Not Promitive)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体可以看&lt;The little scheme&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;#lang racket
;;don&#39;t look down on it, it is the full interpretor!
;;Take care to read it!
(define atom?
  (lambda (x)
    (and (not (pair? x)) (not (null? x)))))
  
(define build
  (lambda (s1 s2)
    (cond
      (else (cons s1
                  (cons s2 (quote ())))))))
((lambda (nothing)
     (cond
       (nothing (quote something))
       (else (quote nothing))))
   #t)

(define lookup-in-entry
  (lambda (name entry entry-f)
    (lookup-in-entry-help name
                          (first entry)
                          (second entry)
                          (entry-f))))
(define lookup-in-entry-help
  (lambda (name names values entry-f)
    (cond
      ((null? names) (entry-f name))
      ((eq? (car names) name)
       (car values))
      (else (lookup-in-entry-help name
                                  (cdr names)
                                  (cdr values)
                                  entry-f)))))
(define lookup-in-table
  (lambda (name table table-f)
    (cond 
      ((null? table) (table-f name))
      (else (lookup-in-entry name
                             (car table)
                             (lambda (name)
                                                (cdr table)
                                                (table-f))))))))
(lambda (name table table-f)
    (lookup-in-table name
                     (cdr table)
                     (table-f)))
(define expression-to-action
  (lambda (e)
    (cond
      ((atom? e) (atom-to-action e))
      (else (list-to-action e)))))
(define *const
  (lambda (e table)
    (cond 
      ((number? e) e)
      ((eq? e #t) #t)
      ((eq? e #f) #f)
      (else (build (quote primitive) e)))))
(define atom-to-action
  (lambda (e)
    (cond
      ((number? e) *const)
      ((eq? e #t) *const)
      ((eq? e #f) *const)
      ((eq? e (quote cons)) *const)
      ((eq? e (quote car)) *const)
      ((eq? e (quote cdr)) *const)
      ((eq? e (quote null?)) *const)
      ((eq? e (quote eq?)) *const)
      ((eq? e (quote atom?)) *const)
      ((eq? e (quote zero?)) *const)
      ((eq? e (quote add1)) *const)
      ((eq? e (quote sub1)) *const)
      ((eq? e (quote number?)) *const)
      (else *identifier))))
(define list-to-action
  (lambda (e)
    (cond
      ((atom? (car e))
       (cond
         ((eq? (car e) (quote quote))
          *quote)
         ((eq? (car e) (quote lambda))
          *lambda)
         ((eq? (car e) (quote cond))
          *cond)
         (else *application)))
      (else *application))))

(define *quote
  (lambda (e table)
    (text-of e)))
(define first
  (lambda (p)
    (cond 
      (else (car p)))))
(define second
  (lambda (p)
    (cond
      (else car (cdr p)))))
(define third
  (lambda (p)
    (cond 
      (else car (cdr (cdr p))))))
(define text-of second)

(define table-of first)
(define formals-of second)
(define body-of third)
(define *identifier
  (lambda (e table)
    (lookup-in-table e table initial-table)))
(define initial-table
  (lambda (name)
    (car (quote ()))))
(define *lambda
  (lambda (e table)
    (build (quote non-primitive)
           (cons table (cdr e)))))

(define evcon
  (lambda (lines table)
    (cond 
      ((else? (question-of (car lines)))
       (meaning (answer-of (car lines))
                table))
      ((meaning (question-of (car lines))
                table)
       (meaning (answer-of (car lines))
                table))
      (else (evcon (cdr lines) table)))))

(define else?
  (lambda (x)
    (cond
      ((atom? x) (eq? x (quote else)))
      (else #f))))
(define question-of first)
(define answer-of second)

(define *cond
  (lambda (e table)
    (evcon (cond-lines-of e) table)))
(define cond-lines-of cdr)

(define evlis
  (lambda (args table)
    (cond
      ((null? args) (quote ()))
      (else
       (cons (meaning (car args) table)
             (evlis (cdr args) table))))))
(define *application
  (lambda (e table)
    (apply
     (meaning (function-of e) table)
     (evlis (arguments-of e) table))))
(define function-of car)
(define arguments-of cdr)
(define primitive?
  (lambda (l)
    (eq? (first l) (quote primitive))))
(define non-primitive?
  (lambda (l)
    (eq? (first l) (quote non-primitive))))
(define apply
  (lambda (fun vals)
    (cond
      ((primitive? fun)
       (apply-primitive
        (second fun) vals))
      ((non-primitive? fun)
       (apply-closure
        (second fun) vals)))))

(define apply-primitive
  (lambda (name vals)
    (cond
      ((eq? name (quote cons))
       (cons (first vals) (second vals)))
      ((eq? name (quote car))
       (car (first vals)))
      ((eq? name (quote cdr))
      ((eq? name (quote cdr))
       (cdr (first vals)))
      ((eq? name (quote null?))
       (null? (first vals)))
      ((eq? name (quote eq?))
       (eq? (first vals) (second vals)))
      ((eq? name (quote atom?))
       (:atom? (first vals)))
      ((eq? name (quote zero?))
       (zero? (first vals)))
      ((eq? name (quote add1))
       (add1 (first vals)))
      ((eq? name (quote sub1))
       (sub1 (first vals)))
      ((eq? name (quote number?))
       (number? (first vals))))))
(define :atom?
  (lambda (x)
    (cond
      ((atom? x) #t)
      ((null? x) #f)
      ((eq? (car x) (quote primitive))
       #t)
      ((eq? (car x) (quote non-primitive))
       #t)
      (else #f))))
(define apply-closure
  (lambda (closure vals)
    (meaning (body-of closure)
             (extend-table
              (new-entry
               (formals-of closure)
               vals)
              (table-of closure)))))
(define new-entry build)
(define extend-table cons)

(define value
  (lambda (e)
    (meaning e (quote ()))))
(define meaning
  (lambda (e table)
    ((expression-to-action e) e table)))

(value (+ 3 4 (* 3 1)))

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;树形抽象&#34;&gt;树形抽象&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;一个lat 中的一个删除&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;
(define rember3
  (lambda (s l)
    (cond 
      ((null? l) (quote ()))
      ((equal? (car l) s) (cdr l))
      (else (cons (car l)
                  (rember3 s (cdr l)))))))

&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;一个list中的一个删除&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;
(define multirember
  (lambda (a lat)
    (cond
      ((null? lat) (quote ()))
      (else
       (cond
         ((eq? (car lat) a)
          (multirember a (cdr lat)))
         (else (cons (car lat)
                     (multirember a (cdr lat)))))))))

&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;一个list中的全部删除&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;

(define rember*
  (lambda (a l)
    (cond
      ((null? l) (quote ()))
      ((atom? (car l))
       (cond 
         ((eq? (car l) a)
          (rember* a (cdr l)))
         (else (cons (car l)
                     (rember* a (cdr l))))))
     (else (cons (rember* a (car l))
           (rember* a (cdr l)))))))


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4 1中的rember升级
加入谓词表达式的参数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define rember-f
  (lambda (test? a l)
    (cond 
      ((null? l) (quote ()))
      (else
       (cond 
         ((test? (car l) a) (cdr l));;I think here needs atom2function
         (else (cons (car l)
                     (rember-f test? a 
                               (cdr l)))))))))

&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;2中的multirember升级&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;
(define multirember-f
  (lambda (test?)
    (lambda (a lat)
      (cond 
        ((null? lat) (quote ()))
        ((test? a (car lat))
         ((multirember-f test?) a
                               (cdr lat)))
        (else (cons (car lat)
                    ((multirember test?)  a 
                                          (cdr lat))))))))

(define multirember-eq? (multirember-f &#39;eq?))

&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;5中的multirember-f进一步升级&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;加入了可以处理的col,作为一个后处理小程序&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;

(define multiremberco
  (lambda (a lat col)
    (cond 
      ((null? lat)
       (col (quote ()) (quote ())))
      ((eq? (car lat) a)
       (multiremberco a 
                      (cdr lat)
                      (lambda (newlat seen) 
                        (col newlat (cons (car lat) seen)))))
      (else
       (multiremberco a 
                      (cdr lat)
                      (lambda (newlat seen)
                        (col (cons (car lat) newlat)
                             seen)))))))

(define a-friend
  (lambda (x y)
    (null? y)))
;(multiremberco &#39;tuna &#39;(sfds tuna fsd jif) a-friend)
;#f
;&amp;gt; (multiremberco &#39;tuna &#39;(sfds tuna1 fsd jif) a-friend)
;#t
;;how can  you get another value in the col
(define new-friend
  (lambda (newlat seen)
    (a-friend newlat
         (cons (quote tuna) seen))))

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;额外话题-insertleft-insertright-eventonly比较上面的rember理解col&#34;&gt;额外话题 insertleft insertright eventonly比较上面的rember,理解col&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;
(define multiinsertLR
  (lambda (new oldL oldR lat)
    (cond
      ((null? lat) (quote ()))
      ((eq? (car lat) oldL)
       (cons new 
             (cons oldL
                   (multiinsertLR new oldL oldR
                                  (cdr lat)))))
      ((eq? (car lat) oldR)
       (cons oldR
             (cons new
                   (multiinsertLR new oldL oldR
                                 (cdr lat))))))))

(define multiinsertLRco
  (lambda (new oldL oldR lat col)
    (cond
      ((null? lat)
       (col (quote ()) 0 0))
      ((eq? (car lat) oldL)
       (multiinsertLRco new oldL oldR
                        (cdr lat)
                        (lambda (newlat L R)
                          (col (cons new 
                                     (cons oldL newlat))
                               (+ 1 L) R))))
      ((eq? (car lat) oldR)
       (multiinsertLRco new oldL oldR
                        (cdr lat)
                        (lambda (newlat L R)
                          (col (cons oldR
                                     (cons new newlat))
                               L (+ 1 R)))))
      (else
       (multiinsertLRco new oldL oldR 
                        (cdr lat)
                        (lambda (newlat L R)
                          (col (cons (car lat) newlat)
                               L R)))))))


(define evens-only*co
  (lambda (l col)
    (cond
      ((null? l)
       (col (quote ()) 1 0))
      ((atom? (car l))
       (cond 
         ((even? (car l))
          (evens-only*co (cdr l)
                         (lambda (newl p s)
                           (col (cons (car l) newl);if it is evens ,so cons it into the newl
                                (* (car l) p) s))))
         (else (evens-only*co (cdr l)
                              (lambda (newl p s)
                                (col newl p (+ (car l) s)))))))
       (else (evens-only*co (car l)
                            (lambda (al ap as)
                              (evens-only*co (cdr l)
                                             (lambda (dl dp ds)
                                               (col (cons al dl)
                                                    (* ap dp)
                                                    (+ as ds))))))))))
;the fourth collector :: the last-last-friend
(define the-last-last-friend
  (lambda (newl product sum)
    (cons sum 
          (cons product 
                newl))))
;&amp;gt; (evens-only*co &#39;(45389 63 45 6 4 234  6 4 23 52 43) the-last-last-friend)
;&#39;(45563 7008768 6 4 234 6 4 52)


&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;进一步升级multirember 提取公共形式&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;insert-g可以变幻出 rember
insert-r insert-l  subset等&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;
(define rembern
  (lambda (a l)
    ((insert-g seqrem) #f a l)));;seqrem doesn&#39;t need (seqrem solve my ?.
(define seqrem
  (lambda (new old l) 
    l))

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;那么insert-g到底是什么?&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;
(define insert-g
  (lambda (seq)
    (lambda (new old l)
      (cond
        ((null? l) (quote ()))
        ((eq? (car l) old)
         (seq new old (cdr l)))
        (else (cons (car l)
                    ((insert-g seq) new old
                                    (cdr l))))))))

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以现在我们可以定义subst&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define seqS
  (lambda (new old l)
    (cons new l)))

(define seqL
    (lambda (new old l)
     (cons new (cons old l))))

(define seqR
    (lambda (new old l)
        (cons (old (cons new l)))))

(define subst1 (insert-g seqS))
(define insertL (insert-g seqL))
(define insertR (insert-g seqR))

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;经过这四个级别的抽象我们得到一般的具备公共模式的insert-g
当然该函数还可以继续抽象。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>语言抽象</title>
      <link>https://jueqingsizhe66.github.io/archives/yu-yan-chou-xiang/</link>
      <pubDate>Thu, 14 May 2015 10:21:48 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/archives/yu-yan-chou-xiang/</guid>
      <description>&lt;p&gt;我们每天都在做的事情
1.打开电脑，找到我们要做的事情，保存我们做完的事情，提交,我们可能挨训，也可能加班
2.我们可能去打球，我们可能跟朋友、亲人聊天
3.我们可能在周末的时候，跟女朋友、家人去看电影，去郊游
4.我们可能去参加一些团体活动……&lt;/p&gt;
&lt;p&gt;我们把我们要在电脑、生活上做的事情可以抽象化，虽然我们不知不觉的做着这些事情，
但是这是第一步叫做事件抽象（过程抽象）。随着发展，我们可以进行逻辑抽象，并最终达到&lt;a href=&#34;http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-25.html#%25_chap_4&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;语言抽象&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;我们会发现我们所使用的计算机语言包含着主要的东西是
1. 变量
2. 函数
3. 调用&lt;/p&gt;
&lt;p&gt;可以参看&lt;a href=&#34;http://developer.51cto.com/art/201208/352423_2.htm&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;王垠的计算器&lt;/a&gt;,里面第三节中提到Lambda Calculus是什么
1. 变量: x
2. 函数: (lambda (x) e)
3. 调用: (e1 e2)&lt;/p&gt;
&lt;p&gt;这是任何一门语言不可缺少的逻辑语言抽象部件，就好像数学家很早就认识到序列求和中的&lt;a href=&#34;http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-12.html#%25_sec_1.3.1&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;抽象模式&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;语言本身其实就是一个&lt;a href=&#34;http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-25.html#%25_chap_4&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;求值器&lt;/a&gt;
&amp;gt; The evaluator, which determines the meaning of expressions in a programming language, is just another program.
所以事实上，可以几乎把任何程序看作是某个语言的求值器，它本身不过就是另一个程序而已。&lt;/p&gt;
&lt;p&gt;而为了更好地操作这些语言的元素，进行大型的系统模块化设计，我们还需要引进&lt;a href=&#34;http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-19.html#%25_chap_3&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;两种模式&lt;/a&gt;
1.对象实现(以不变的世界坐标系来说，其实对象是不断变化的，比如位置；此时坐标系是全局的)
2.流实现(以变化固体的角度来说，其实他是不变的；此时坐标系是局部的)&lt;/p&gt;
&lt;p&gt;关于scheme的部分以后再补上。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>尾递归</title>
      <link>https://jueqingsizhe66.github.io/archives/wei-di-gui/</link>
      <pubDate>Wed, 13 May 2015 20:56:12 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/archives/wei-di-gui/</guid>
      <description>&lt;p&gt;尾递归的好处就是快速计算，尾递归实际上是在递归计算的过程中，
（印象中递归过程[表示语法形式-调用自己]和递归计算过程[表正线性方式 和非线性方式]是不一样的）, 加入了迭代的思想，不断的修改了product和counter的值，
不需要树形展开。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define (fact n)
  (cond
    ((= n 1) 1)
    (else (* n (fact (- n 1))))))

(define (fact1 n)
  (define (fact-iter product counter)
    (cond
      ((= counter 1) product)
      (else (fact-iter (* product counter) (- counter 1)))))
  (fact-iter 1 n))
;;;Solve 4!
(fact 4)
(fact1 4)

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;;;; 求幂&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define (expr b n)
  (if (= n 0)
     1
     (* b (expt b (- n 1)))))

;;;iter form
(define (expr1 b n)
  (define (expr-iter b counter product)
    (if (= counter 0)
       product
       (expr-iter b (- counter 1) (* b product))))
  (expr-iter b  n 1))

(expr 4 5)
(expr1 4 5)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;===&amp;gt;另外还有一种更快速的方法
;; b^n =(b^(n/2))^2, n is even
;; b^n =(b*b^(n-1)) , n is odd&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define (fast-iter b n)
 (cond 
  ((= n 0) 1)
  ((even? n) (square (fast)))
  (else (* b (fast-iter b (- n 1))))))

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;====&amp;gt;并最终得到尾递归的一般形式
结合&lt;a href=&#34;jueqingsizhe66.github.io/2015/05/13/qiu-ding-ji-fen/&#34;&gt;求定积分&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;===&amp;gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define (sum term a  next b)
    (define (sum-iter a result)
     (if &amp;lt;???&amp;gt;
       &amp;lt;???&amp;gt; 
       (iter &amp;lt;???&amp;gt; &amp;lt;???&amp;gt;)))
    (sum-iter &amp;lt;???&amp;gt; &amp;lt;???&amp;gt;)
)
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>求定积分</title>
      <link>https://jueqingsizhe66.github.io/archives/qiu-ding-ji-fen/</link>
      <pubDate>Wed, 13 May 2015 19:27:40 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/archives/qiu-ding-ji-fen/</guid>
      <description>&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://jueqingsizhe66.github.io/images/maths/dingjifen.jpg&#34; alt=&#34;定积分&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;

















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://jueqingsizhe66.github.io/images/maths/dingjifen3.jpg&#34; alt=&#34;定积分的数值计算&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;

















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://jueqingsizhe66.github.io/images/maths/dingjifen2.jpg&#34; alt=&#34;定积分的图形示意&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;
 (define (cube  x) (* x  x x))
 ;;;累加
(define (sum-integer a b)
  (if (&amp;gt; a b)
     0
     (+ a (sum-integer (+ a 1) b))))

(sum-integer 1 10)
;;;立方累加
(define (sum-cube a b)
  (if (&amp;gt; a b)
     0
     (+ (cube a) (sum-cube (+ a 1)  b))))
(sum-cube 1 3)
;;; 求Pi 值 分数累加
(define (sum-pi a b)
  (if (&amp;gt; a b)
     0
     (+ (/ 1.0 (* a (+ a 2))) (sum-pi (+ a 4) b))))
(sum-pi 1 9)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;观察上面的积分过程
##最终提取出公共的形式 Sum&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;
;; (define (&amp;lt;name&amp;gt; a b)
;;  (if (&amp;gt; a b)
;;  0
;;  (+ (&amp;lt;term&amp;gt; a) (&amp;lt;name&amp;gt; (&amp;lt;next&amp;gt;a) b))))

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;于是我们可以得到&#34;&gt;于是我们可以得到&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;
(define (sum term a next b)
  (if (&amp;gt;  a b)
     0
     (+ (term a) (sum term (next a)  next b))))

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;and-apply-the-sum--to-get-the-sum-integer2-sum-cube2-sum-pi2&#34;&gt;And Apply the sum  to get the sum-integer2 sum-cube2 sum-pi2&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define (sum-integer2 a b) (sum (lambda (x) x) ((lambda (x) (+ x 1)) a) (lambda (x) (+ x 1)) b)) ;;;--&amp;gt;There is some problems

;&amp;gt; (sum-integer2 1 10)
;54  ------------------------&amp;gt;Why
;&amp;gt; (sum-integer 1 10)
;55

(define (identity x) x)
(define (inc x) (+ x 1))
(define (sum-integer3 a b) (sum identity a inc b))
(sum-integer3 1 3)
(define (sum-cube2 a b) (sum cube a inc b))
(sum-cube2 1 3)
(define (sum-pi2 a b) 
  (define (pi-term x)
    (/ 1.0 (* x (+ x 2))))
  (define (pi-next x)
    (+ x 4))
  (sum pi-term a pi-next b))
(sum-pi2 1 9)
(* 8 (sum-pi2 1 1000))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也就是我们现在可以计算积分了！
我们的问题是求解下面的定积分：
















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://jueqingsizhe66.github.io/images/maths/integral.png&#34; alt=&#34;定积分&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;;;;; So now we can do the integrate computing

;;Because integrate will have the same function but different next function
;;;a-b 之间关于f函数的定积分的求法
(define (integral f a b dx)
  (define (add-dx x) (+ x dx))
  (define (update-a a dx) (+ a (/ dx 2.0)))
  (* (sum f (update-a a dx) add-dx b) dx))
(integral cube 0 1 0.01)
(integral cube 0 1 0.001)
(integral cube 0 1 0.0001)
(/ 1 4.0)
(/ (* 1 (cube 1)) 4.0)


;result:
;0.24998750000000042
;0.249999875000001
;0.24999999874993412
;0.25
;0.25

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为了更精确的求解积分，我们使用更为精妙的辛普森积分
















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://jueqingsizhe66.github.io/images/maths/xinpusen1.jpg&#34; alt=&#34;辛普森的抛物线积分方法&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;

















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://jueqingsizhe66.github.io/images/maths/xinpusen2.jpg&#34; alt=&#34;辛普森的数学公式&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;

















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://jueqingsizhe66.github.io/images/maths/xinpusen3.jpg&#34; alt=&#34;最终简化&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;

###包含奇数的两倍 和偶数的四倍，两边不加倍&lt;/p&gt;
&lt;ol start=&#34;0&#34;&gt;
&lt;li&gt;h = (b-a)/n&lt;/li&gt;
&lt;li&gt;yk= f(a+kh) &amp;mdash;&amp;gt; next&lt;/li&gt;
&lt;li&gt;(even? k)  (odd? k)&lt;/li&gt;
&lt;li&gt;y0 =a  yn= b&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;a. 设计的过程遇到的问题是 参数的问题 需要设置k？
b. 中间过程的问题，如何划分三种情况
b.1  k为0和n的情况
b.2  k为奇数的情况
b.3  k为偶数的情况&lt;/p&gt;
&lt;p&gt;最终, 利用Fact的思想 进行求积分&lt;/p&gt;
&lt;p&gt;;;; 下面是一个较为混乱的设计，且没有考虑使用sum&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define (simpson-integral f a b n)
(let ((h (/ (- b a) n))
      (k 0))
(define inc (+ a (* k h)))
(define inc2 (* 2 f(inc)))
(define inc4 (* 4 f(inc)))
  (cond
    ((= k 0) (f a))
    ((= k n) (f b))
    ((even? k) (+ (* 2 f((+ a (* k h))))  
)))

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;补充，好思想:保证最后一个为偶数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define (round-to-next-even x)
 (+ x (remainder x 2))
)

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;于是有了下面较好的版本，思考，之前的Sum其实是已经提供了inc递增的a
以及范围，我们主要的目的就是写好term即可！而
term其实就是涉及到你需要思考的三种情况
之前你之所以回想不清楚，因为你没有斩断念头，term只接受一个参数，
这个参数其实就是你一直想的k，所以simpson-term的一个参数就是k，利用它
开始做文章即可&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define (simpson-integral f a b n)
    (define (round-to-next-even x)  (+ x (remainder x 2)))
    (define fixed-n (round-to-next-even n))
    (define h (/ (- b a) fixed-n))
    (define (simpson-term k) 
      (define y (f (+ a (* k h))))
      (cond 
          ((or (= k 0) (= k fixed-n))
            (* 1 y))
          ((even? k) (* 2 y))
          (else (* 4 y))))
    (* (/ h 3) (sum simpson-term 0 inc fixed-n))
 ))

;(simpson-integral cube 0 1 10)
;1/4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另外还有几种变体，只不过总体思路都在上面类似。&lt;/p&gt;
&lt;p&gt;a1:breaking the problem into four parts: (f y0), (f yn) and two sums,one over even k and another over odd k&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define (another-simpson-integral f a b n) 
   (define h (/ (- b a) n))  
   (define (add-2h x) (+ x (* 2 h))) 
   (* (/ h 3.0) (+ (f a)  
                   (* 4.0 (sum f (+ a h) add-2h (- b h)))  
                   (* 2.0 (sum f (add-2h a) add-2h (- b h)))  
                   (f (+ a (* h n)))))) 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;a2:Here&amp;rsquo;s a version that sums over pairs of terms (2 y_k + 4 y_k+1). No conditionals or special cases are needed anywhere, but there&amp;rsquo;s an extra term [f(b) - f(a)] to be added to the final count.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt; (define (simpson f a b n) 
   (define h (/ (- b a) n)) 
    
   (define (y k) 
     (f (+ a (* k h)))) 
    
   (define (ypair k) 
     (+ (* 2 (y k)) 
        (* 4 (y (+ k 1))))) 
    
   (define (add-2 k) 
     (+ k 2)) 
    
   (* (/ h 3) (+ (sum ypair 0 add-2 (- n 1)) 
                 (- (f b) (f a))))) 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然也可以写成下面的格式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt; (define (sim-integral f a b n) 
     (define h (/ (- a b) n)) 
     (define (y k) (f (+ a (* k h)))) 
     (define (coeff k) (if (is-even? k) 2 4)) 
     (define (part-term k) (* (coeff k) (y k))) 
     (define part-value (sum part-term 1 inc (- n 1))) 
     (* (/ h 3) (+ (y 0) (y n) part-value))) 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;##下面是我重新写的一遍，包含一些计算问题的修正&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;加入了n的修正&lt;/li&gt;
&lt;li&gt;重新认识了simpson算法的，当然还有些问题没有理解，比如f(b)-f(a),
在simpson-anthother-integrate中&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;新的源码如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;
;;; (let &amp;lt;var&amp;gt; &amp;lt;bindings&amp;gt; &amp;lt;body&amp;gt;)

(define (cube x) (* x  x  x))
(define (sum-integer a b)
  (if (&amp;gt; a b)
     0
     (+ a (sum-integer (+ a 1) b))))
(sum-integer 1 10)

(define (sum-cube a b)
  (if (&amp;gt; a b)
     0
     (+ (cube a) (sum-cube (+ a 1) b))))
(sum-cube  1 3)

(define (sum-pi a b)
  (if (&amp;gt; a b)
     0 
     (+ (/ 1.0 (* a (+ a 2))) (sum-pi (+ a 4) b))))
(sum-pi 1 10)
(sum-pi 1 100)

(define (sum term a next b)
  (if (&amp;gt; a b)
     0
     (+ (term a) (sum term  (next a) next b))))

(define (sum-integer2 a b)
  (define (identity x) x)
  (define (inc x) (+ x 1))
  (sum identity a inc b))
(sum-integer2 1 10)

(define (sum-cube2  a b)
  (define (cube x) (* x x x))
  (define (inc x) (+ x 1))
  (sum cube a inc b))
(sum-cube2 1 3)

(define (sum-pi2 a b)
  (define (pi-term x) (/ 1.0 (* x (+ x 2))))
  (define (pi-next x) (+ x 4))
  (sum pi-term a pi-next b))
(sum-pi2 1 10)

(define (integral f a b dx)
  (define const_a (+ a (/ dx 2.0)))
  (define (add_dx x) (+ x dx))
  (* (sum f const_a add_dx b) dx))

(integral cube 0 1 0.001)

(define (simpson-integral f a b n)
  (define (round-to-next-even x) (+ x (remainder x 2)))
  (define fixed-n (round-to-next-even n))
  (define (inc x) (+ x 1))
  (define h (/ (- b a) fixed-n))
  (define (simpson-term k)
    (define y (f (+ a (* h k))))
    (cond 
      ((or (= k 0) (= k fixed-n))
       (*  1  y))
      ((even? k)
       (* 2  y))
      (else (* 4 y))))
 ; (* (/ h 3) (sum simpson-term 0 inc b))) ;;; 0的意思表示从k=0开始,不能写成b，如果写成b表示你没有理解，因为0 fixed-n都代表的是K
  ;;这是次数的说法，而不是代表着a-b之间的求值范围，而是指求职的次数！
 (* (/ h 3) (sum simpson-term 0 inc fixed-n)))
(simpson-integral cube 0 1 10)
(simpson-integral cube 0 1 11)


;;一种变体 思路同上
;; 比较有趣的地方是分为四个节点出
;; 1  f(a)  ----》 y0
;; 2  f(a+h) 奇数的开始地方   add-2h方式累加都是奇数 同时终点是b-h  为什么？因为b在下面被暂用--》把它看待是一个奇数累加的过程 y1 y3 y5
;; 3  f(a+2h) 偶数的开始地方 add-2h方式累加都是偶数 同时终点是b-h--》把它看待是一个偶数累加的过程 y2 y4 y6..
;; 4  f(b)    最后一部分  yn
(define (simpson-another-integral f  a b n)
  (define h (/ (- b a) n))
  (define (add-2h x) (+  x (* 2.0 h)))  ;;; 
  (* (/ h 3.0) (+ (f a)
                          (* 4.0 (sum f (+ a h) add-2h (- b h)))  ;;; (+a h)表示起始点  (- b h) 表示的是终点
                          (* 2.0 (sum f (add-2h a) add-2h (- b h))) ;; 注意这边的(add2h a)表示的是起始点
                          (f (+ a (* h n))))))  ;; 也可以是(f b) 

;&amp;gt; (simpson-another-integral cube 0 1 11)
;0.1782892789654623
;&amp;gt; (simpson-another-integral cube 0 1 12)
;0.2499999999999999&#39;

(define (simpson-another-integral-improve f  a b n)
  (define (round-to-next-even x) (+ x (remainder x 2)))
  (define fixed-n  (round-to-next-even n))
  (define h (/ (- b a) fixed-n))
  (define (add-2h x) (+  x (* 2.0 h)))  ;;; 
  (* (/ h 3.0) (+ (f a)
                          (* 4.0 (sum f (+ a h) add-2h (- b h)))  ;;; (+a h)表示起始点  (- b h) 表示的是终点
                          (* 2.0 (sum f (add-2h a) add-2h (- b h))) ;; 注意这边的(add2h a)表示的是起始点
                          (f (+ a (* h fixed-n)))))) ;;; (f b)的效果是一样  但是不正确！ 现在
  
  (simpson-another-integral cube 0 1 11)
   (simpson-another-integral cube 0 1 12)
    (simpson-another-integral cube 0 1 111);;; 如果是奇数的话，现在解决的办法就是多增加一些计算！
   ;;;;;过程没错！！！ 不知道哪边多加了！
   
    
 (define (simpson-pair-integral f a b n)
   (define (round-to-next-even x) (+ x (remainder x 2)))
   (define fixed-n  (round-to-next-even n))
   (define h (/ (- b a) fixed-n))
   (define (y k) ( f  (+ a (* k h))))
   (define (ypair k)
     (+ (* 2 (y k))
          (* 4 (y (+ k 1)))))
   (define (add-2 k)
     (+ k 2))
   (* (/ h 3) (+ (sum ypair 0 add-2 (- fixed-n 1))  
                (- (f b) (f a)))))  ;;; 为什么是减号  你可以看到这边的思想是抽出中间的偶数对的数据（奇数加上偶数 理当是加起来的)
                                          ;;;因为最后一个  为什么要计算 [f(b) - f(a)] 
 (simpson-pair-integral cube 1 3 1)
 (simpson-pair-integral cube 1 3 2)
 
 ;;;sim-integral 提高版  加入了 round-to-next-even使得计算准确，先前的sim-integral有问题
 (define (sim-integral f a b n)
   (define (round-to-next-even x) (+ x (remainder x 2))) ;;;得加上这个 才可以算准！！
   (define fixed-n  (round-to-next-even n))
   (define h (/ (- b a) fixed-n))
   (define (y k) (f (+ a (* k h))))
   (define (coeff k) (if (even? k) 2 4))
   (define (part-term k) (* (coeff k) (y k)))
   (define (inc x) (+ x 1))
   (define part-value (sum part-term 1 inc (- fixed-n 1)))
   (* (/ h 3) (+ (y 0) (y n) part-value)))
 (sim-integral cube 1 3 10)  ;;; 有问题 已解决
 (sim-integral cube 1 3 11) ;;; 有问题  已解决
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>找出函数的不动点--Navier-Stokes方程</title>
      <link>https://jueqingsizhe66.github.io/archives/zhao-chu-han-shu-de-bu-dong-dian-navier-stokesfang-cheng/</link>
      <pubDate>Tue, 12 May 2015 03:13:50 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/archives/zhao-chu-han-shu-de-bu-dong-dian-navier-stokesfang-cheng/</guid>
      <description>&lt;p&gt;##Beautiful code!&lt;/p&gt;
&lt;p&gt;数x为函数的f的不动点（f可以代表N-S方程），如果满足f(x)=x,则称x
为函数f的不动点。
性质 f(x),f(f(x)),f(f(f(x)))&amp;hellip;., change the x&amp;rsquo;s value if f(x)=x,then
you found!&lt;/p&gt;
&lt;h2 id=&#34;source-code&#34;&gt;Source code&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define tolerance 0.000001)
(define (fixed-point f first-guess)
  (define (close-enough? v1 v2)
    (&amp;lt; (abs (-  v1 v2)) tolerance))
  (define (try guess)
    (let ((next (f guess)))
      (if (close-enough? guess next)
         next
         (try next))))
  (try first-guess))

;;;solve cos(x)=x
(fixed-point cos 1.0)


;;(cos 0.7390855263619245)
;;0.7390848683867142
;;(abs (-  (cos 0.7390855263619245) 0.7390855263619245))
;;6.579752103164083e-07


;;;solve y=siny+cosy   x=f(x) ====&amp;gt; Navier Stokes equation
(fixed-point (lambda (y) (+ (sin y) (cos y))) 1.0)

;;It is what we want!!!
;;;(abs (- ((lambda (y) (+ (sin y) (cos y))) 1.2587277968014188) 1.2587277968014188)) 
;;6.26112570678572e-07


;;;;One method to calculate the square value
;;because x^2 = y  so x = y/x (x =f (x) next we  will use the fixed-point thinking) we should continue change the x&#39;s value!
(define (sqrt-iter guess x)
  (if (good-enough? guess x)
     guess
     (sqrt-iter (improve guess x)
               x)))

(define (square x)
  (* x x))
;;;good-enough? is similar to close-enough？
(define (good-enough? x y)
  (&amp;lt; (abs (- (square x) y)) 0.00001))

;;x^2=y   x=y/x   x+x=y/x+x  x=(y/x+x)/2
(define (improve guess x)
  (average guess (/ x guess)))

(define (mysqrt x)
  (sqrt-iter 1.0 x))


;;(mysqrt 4)
;;2.0000000929222947

;;;Use fixed-point thinking 

(define (mysqrt_death_fixed x)
  (fixed-point (lambda (y) (/ x y))
              1.0))

;;(mysqrt_death_fixed 4)
;;;wrong !!!  can not convenge!!!! why?

;;because   y2= x/y1  y3=x/y2=x/(x/y1)=y1 ====&amp;gt;death recycle===&amp;gt; so we use average

(define (mysqrt_fixed x)
  (fixed-point (lambda (y) (average y (/  x y)))
              1.0))

(mysqrt_fixed 4)

;;;ok fine
;;2.000000000000002====&amp;gt;这也叫做平均阻尼定义！常用于数值计算当中
;;在不动点的搜寻中，作为帮助收敛的手段！！！！
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>折半查找有条件</title>
      <link>https://jueqingsizhe66.github.io/archives/zhe-ban-chao-zhao-you-tiao-jian/</link>
      <pubDate>Tue, 12 May 2015 02:46:03 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/archives/zhe-ban-chao-zhao-you-tiao-jian/</guid>
      <description>&lt;p&gt;You want to solve F(x)=0,
if f(a)&amp;lt;0&amp;lt;f(b), so the value must be inside the [a,b].&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;#lang racket
(define (close-enough? x  y)
  (&amp;lt; (abs (-  x y)) 0.00001))

(define (average a b)
  (/ (+  a b) 2.0))
(define (search f neg-point pos-point)
   (let ((midpoint (average neg-point pos-point)))
     (if (close-enough? neg-point pos-point)
        midpoint
        (let ((test-value (f midpoint)))
          (cond ((positive? test-value)
                 (search f neg-point midpoint))
               ((negative? test-value) 
                (search f midpoint pos-point))
               (else midpoint))))))

;;必须判断一下，如果同号则无法使用折半查找
(define (half-interval-method f a b)
  (let ((a-value (f a))
          (b-value (f b)))
     (cond ((and (negative? a-value) (positive? b-value))
            (search f a b))
          ((and (negative? b-value) (positive? a-value))
           (search f  a b))
          (else
           (error &amp;quot;values are not of opposite sign&amp;quot; a b)))))

(half-interval-method (lambda (x) (- (* x x x) (* 2 x) 3))
                       1.0
                       2.0)
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>So beautiful code</title>
      <link>https://jueqingsizhe66.github.io/archives/so-beautiful-code/</link>
      <pubDate>Tue, 12 May 2015 02:29:11 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/archives/so-beautiful-code/</guid>
      <description>&lt;p&gt;So beautiful&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define (f x y)
(define (f-helper a b)
  (+ (* (square a))
      (* y b)
      (* a b)))
  (f-helper (+ 1 (* x y))
            (- 1 y)))

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;====&amp;gt; f(x,y)=x(1+xy)^2 + y(1-y)+(1+xy)(1-y)
==&amp;gt;  a= 1+xy
b= (1-y)
f(x,y)=xa^2+yb+ab&lt;/p&gt;
&lt;p&gt;====&amp;gt;Continue&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define (f x y)
  ((lambda (a b)
       (+ (* x (square a))
          (* y b)
          (* a b)))
    (+ 1 (* x y))
    (- 1 y)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;====&amp;gt;Use let to define the local variables&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define (f x y)
  (let ((a (+ 1 (* x y)))
         (b (- 1 y)))
       (+ (* x (square a))
          (* y b)
          (* a b))))

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;let is just the coat of the ((lambda (a b))&lt;/p&gt;
&lt;p&gt;Of course we can use define&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define (f x y)
   (define a (+ 1 (* x y)))
   (define b (- 1 y))
 (+ (* x (square a))
    (* y b)
    (* a b)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;SICP_P42&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
