<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>bash | 30年磨一剑</title>
    <link>https://jueqingsizhe66.github.io/tag/bash/</link>
      <atom:link href="https://jueqingsizhe66.github.io/tag/bash/index.xml" rel="self" type="application/rss+xml" />
    <description>bash</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><copyright>©2020</copyright><lastBuildDate>Wed, 05 Jul 2017 13:44:15 +0800</lastBuildDate>
    <image>
      <url>https://jueqingsizhe66.github.io/images/icon_hua2ec155b4296a9c9791d015323e16eb5_11927_512x512_fill_lanczos_center_2.png</url>
      <title>bash</title>
      <link>https://jueqingsizhe66.github.io/tag/bash/</link>
    </image>
    
    <item>
      <title>批量修改pdf文件名以及创建wiki Links</title>
      <link>https://jueqingsizhe66.github.io/blog/2017/07/05/pi-liang-xiu-gai-pdfwen-jian-ming-yi-ji-chuang-jian-wiki-links/</link>
      <pubDate>Wed, 05 Jul 2017 13:44:15 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/blog/2017/07/05/pi-liang-xiu-gai-pdfwen-jian-ming-yi-ji-chuang-jian-wiki-links/</guid>
      <description>&lt;p&gt;bash、awk、sed等的好处，就是可以专一的完成你的需求，但是也存在很多不足，借着批量重命令和批量导出链接到vimwiki的wiki中，形成[[local:文件名路径]]的过程，巩固学习linux命令, it is homework(learning process)。&lt;/p&gt;
&lt;h1 id=&#34;提取路径用于vimwiki中当作快速链接&#34;&gt;提取路径，用于vimwiki中，当作快速链接&lt;/h1&gt;
&lt;p&gt;如果IFS是”“，那么相当于一个文件名特别长会分成很多行显示，所以这边设置为 IFS=$‘\n’&lt;/p&gt;
&lt;p&gt;[a-z]star替换原先的star，目的是去除点号。
使用echo和管道命令传递信息给sed或者awk等
在sed中似乎用^$等位置字符进行替换,如果是文件夹则进行名字替换，并且遍历当前文件夹
使用双重for循环进行控制&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;IFS=$&#39;\n&#39;;
count=1;
countDir=1;
specialCharacter=&#39;pages&#39;;
generateChapter() # @Description : 对不同文件进行不同处理
                  # @usage       : generatechapter
{
    # 妙用find 得到当前目录的相对路径 不需要不断的进入目录
    for var2 in `find . -name &amp;quot;[a-z]*&amp;quot;`
    do
        if [[ -d  $var2 ]] # &amp;lt; cannot . Error
        then
            #echo &amp;quot;fuck&amp;quot;
            var=`echo $var2|sed &#39;s/^./F:\/ScienceBase.Attachments\/WindEnergy/g&#39;|sed &#39;s/^/[[local:/g&#39;|sed &#39;s/$/]]/g&#39;`
            printf &amp;quot;= $countDir. [ ] $var =\n&amp;quot; # 使用#号来删除之前的点号
            countDir=$(($countDir+1));

            for tempVar in `find $var2 -name &amp;quot;*.pdf&amp;quot;`
            do
                temp1=`echo $tempVar|sed &#39;s/^./F:\/ScienceBase.Attachments\/WindEnergy/g&#39;` 
    #            # echo ${var2} ${var2:0:$((${var2}-18))}.pdf  
                 varr=`echo $temp1|sed &#39;s/^/[[local:/g&#39;|sed &#39;s/$/]]/g&#39;`;
                #var=`echo $var2|sed &#39;s/^./F:\/ScienceBase.Attachments\/WindEnergy/g&#39;|sed &#39;s/^/[[local:/g&#39;|sed &#39;s/$/]]/g&#39;` 
                printf &amp;quot;\t$count. [ ] ${varr}\n&amp;quot; # 这边需要去除到第一个点号,这是才得到的处理方法
                count=$(($count+1));

            done
            count=1;
        fi
        

    done
}

generateChapter
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;删除不必要的名字特殊字符重命名&#34;&gt;删除不必要的名字特殊字符，重命名&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;删除文件pdf名字不必要的（pages 110—30）等信息。&lt;/li&gt;
&lt;li&gt;使用awk printf产生逗号分隔字符串，使用xargs -d, mv提取以逗号分隔的字段， 并且对文件名进行重命名（在我找的多种方法中，就他有效）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xargs -n 2&lt;/code&gt; 表示按照空格划分的方式 提取两个参数，逐个进行。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#!/bin/bash -
#===============================================================================
#
#          FILE: b.sh
#
#         USAGE: ./b.sh
#
#   DESCRIPTION: 
#
#       OPTIONS: ---
#  REQUIREMENTS: ---
#          BUGS: ---
#         NOTES: ---
#        AUTHOR: Ye Zhao Liang (Vimer), zhaoturkkey@163.com
#  ORGANIZATION: BrokenSun
#       CREATED: 2017/7/4 23:01:31
#      REVISION:  ---
#===============================================================================

IFS=$&#39;\n&#39;;
count=1;
countDir=1;
specialCharacter=&#39;pages&#39;;
generateChapter() # @Description : 对不同文件进行不同处理
                  # @usage       : generatechapter
{
    # 妙用find 得到当前目录的相对路径 不需要不断的进入目录
    #for var2 in `find . -name &amp;quot;*&amp;quot;`
    for var2 in `find . -name &amp;quot;windEnergy201*&amp;quot;`
    do
        if [[ -d  $var2 ]] # &amp;lt; cannot . Error
        then
                cd $var2;
                for var in `find . -name &amp;quot;*&amp;quot;`;do echo $var|awk &#39;/pages/{printf(&amp;quot;%s,%s&amp;quot;,$0,substr($0,0,length($0)-22)&amp;quot;.pdf&amp;quot;)|&amp;quot;xargs -d, mv &amp;quot;;}&#39;;done 
                cd ..;
        fi

    done
}

generateChapter

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意可以使用 ，学到技巧1中的检测工具，查看你的修改是否完全正确，如果出现文件名中有逗号的情况，通常pages没有删掉，原因是xargs也是按照，号进行分割，所以改进方法是使用分号输出&lt;/p&gt;
&lt;p&gt;改进代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;for var in `find . -name &amp;quot;*&amp;quot;`;do echo $var|awk &#39;/pages/{printf(&amp;quot;%s;%s&amp;quot;,$0,substr($0,0,length($0)-22)&amp;quot;.pdf&amp;quot;)|&amp;quot;xargs -d; mv &amp;quot;;}&#39;;done 
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;最终结果&#34;&gt;最终结果&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-org&#34;&gt;= 1. [ ] [[local:F:/ScienceBase.Attachments/WindEnergy/harmonic power system]] =
  1. [ ] [[local:F:/ScienceBase.Attachments/WindEnergy/harmonic power system/ch1.pdf]]
  2. [ ] [[local:F:/ScienceBase.Attachments/WindEnergy/harmonic power system/ch10.pdf]]
  3. [ ] [[local:F:/ScienceBase.Attachments/WindEnergy/harmonic power system/ch11.pdf]]
  4. [ ] [[local:F:/ScienceBase.Attachments/WindEnergy/harmonic power system/ch12.pdf]]
  5. [ ] [[local:F:/ScienceBase.Attachments/WindEnergy/harmonic power system/ch13.pdf]]
  6. [ ] [[local:F:/ScienceBase.Attachments/WindEnergy/harmonic power system/ch14.pdf]]
  7. [ ] [[local:F:/ScienceBase.Attachments/WindEnergy/harmonic power system/ch15.pdf]]
  8. [ ] [[local:F:/ScienceBase.Attachments/WindEnergy/harmonic power system/ch16.pdf]]
  9. [ ] [[local:F:/ScienceBase.Attachments/WindEnergy/harmonic power system/ch2.pdf]]
  10. [ ] [[local:F:/ScienceBase.Attachments/WindEnergy/harmonic power system/ch3.pdf]]
  11. [ ] [[local:F:/ScienceBase.Attachments/WindEnergy/harmonic power system/ch4.pdf]]
  12. [ ] [[local:F:/ScienceBase.Attachments/WindEnergy/harmonic power system/ch5.pdf]]
  13. [ ] [[local:F:/ScienceBase.Attachments/WindEnergy/harmonic power system/ch6.pdf]]
  14. [ ] [[local:F:/ScienceBase.Attachments/WindEnergy/harmonic power system/ch7.pdf]]
  15. [ ] [[local:F:/ScienceBase.Attachments/WindEnergy/harmonic power system/ch8.pdf]]
  16. [ ] [[local:F:/ScienceBase.Attachments/WindEnergy/harmonic power system/ch9.pdf]]
  17. [ ] [[local:F:/ScienceBase.Attachments/WindEnergy/harmonic power system/fmatter.pdf]]
  18. [ ] [[local:F:/ScienceBase.Attachments/WindEnergy/harmonic power system/index.pdf]]
  19. [ ] [[local:F:/ScienceBase.Attachments/WindEnergy/harmonic power system/scard.pdf]]
= 2. [ ] [[local:F:/ScienceBase.Attachments/WindEnergy/Offshore Wind Energy Generation Control, Protection, and Integration to Electrical Systems/offshoreWindEnergy]] =

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;#学到的技巧&lt;/p&gt;
&lt;p&gt;awk两种表示判断,if判断得用分号 &lt;a href=&#34;http://blog.csdn.net/qq_31382921/article/details/55094907&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt; 如果不用分号隔开会报错 &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注意分号！！&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-awk&#34;&gt;awk &#39;{if ($1==1) print &amp;quot;A&amp;quot;; else if ($1==2) print &amp;quot;B&amp;quot;; else print &amp;quot;C&amp;quot;}&#39;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对应的bash使用的是if,then,else,fi的形式，且不用分号间隔语句&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;
 for var in `find . -name &amp;quot;*&amp;quot;`
    do
        if [[ -d  $var ]] # &amp;lt; cannot . Error
        then
            printf &amp;quot;$var\n&amp;quot; # 使用#号来删除之前的点号
        else
            printf &amp;quot;\t${var}\n&amp;quot; # 这边需要去除到第一个点号,这是才得到的处理方法
        fi

    done
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;awk的’/page/{}‘等效于’if($0~/dfd/){}’
下面的命令，也是一种检查上述程序正确与否的一种工具,可以看出哪些pdf文件依然有pages的字段&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;YeZhao@DESKTOP-YeZhao /cygdrive/f/ScienceBase.Attachments/WindEnergy
$ find . -name &amp;quot;*&amp;quot;|awk &#39;{if($0~/pages/){print $0}}&#39;
./windEnergy2009-i6/Characterizing future large, rapid changes in aggregated wind power using Numerical Weather Prediction spatial fields (pages 542–555).pdf
./windEnergy2012-i1/Modeling wake effects in large wind farms in complex terrain the problem, the methods and the issues (pages 161–182).pdf
./windEnergy2012-i2/The Betz–Joukowsky limit on the contribution to rotor aerodynamics by the British, German and Russian scientific schools (pages 335–344).pdf
./windEnergy2012-i3/Computational fluid dynamics simulation of the aerodynamics of a high solidity, small-scale vertical axis wind turbine (pages 349–361).pdf
./windEnergy2012-i3/Correction factors for NRG #40 anemometers potentially affected by dry friction whip characterization, analysis, and validation (pages 489–502).pdf
./windEnergy2012-i4/Analysis of wake measurements from the ECN Wind Turbine Test Site Wieringermeer, EWTW (pages 575–591).pdf
./windEnergy2012-i5/Atmospheric stability and turbulence fluxes at Horns Rev—an intercomparison of sonic, bulk and WRF model data (pages 717–731).pdf
./windEnergy2013-11/Modeling, simulation and control of a wind turbine with a hydraulic transmission system (pages 1259–1276).pdf
./windEnergy2013-8/Indicial lift response function an empirical relation for finite-thickness airfoils, and effects on aeroelastic simulations (pages 681–693).pdf
./windEnergy2013-8/Simulating the dynamics of wind turbine blades part I, model development and verification (pages 694–710).pdf
./windEnergy2013-8/Simulating the dynamics of wind turbine blades part鈥塈I, model validation and uncertainty quantification (pages 741–758).pdf
..l
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;#2. awk的&lt;a href=&#34;http://blog.csdn.net/panpan639944806/article/details/19932543&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt; BEGIN &lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-awk&#34;&gt;function name()
{}

BEGIN{
}
{
    
}
END{

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;3-awk--gsub-3&#34;&gt;3. awk &lt;a href=&#34;http://blog.sina.com.cn/s/blog_67e34ceb0100ybvg.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt; gsub &lt;/a&gt;&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-awk&#34;&gt;echo &amp;quot;a b c 2011-11-22 a:d&amp;quot; | awk &#39;gsub(/-/,&amp;quot;&amp;quot;,$4)&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;#4. awk变量定义&lt;/p&gt;
&lt;p&gt;BEGIN中&lt;a href=&#34;http://blog.csdn.net/shangboerds/article/details/49449291&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt; 定义1 &lt;/a&gt; , &lt;a href=&#34;http://jingyan.baidu.com/article/d45ad148fb46f269552b80cf.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt; awk -v单行 &lt;/a&gt;定义变量&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.linuxidc.com/Linux/2015-04/115781.htm&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt; awk内置变量 &lt;/a&gt;, 包括FS,OFS,NR,NFR,NF,$0,$1,$2,ARGC,ARGV1等。&lt;/p&gt;
&lt;p&gt;#5.awk定义函数&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://bbs.chinaunix.net/thread-1424218-1-1.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt; awk的函数定义 &lt;/a&gt;是在BEGIN{},{},END{}之外的，和他们平级的关系&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-awk&#34;&gt;#!/usr/bin/awk -f
#===============================================================================
#
#          File:  func.awk
# 
#   Description:  awk -f func.awk file
#           file内容为400
# 
#   VIM Version:  7.0+
#        Author:  Ye Zhao Liang (Vimer), zhaoturkkey@163.com
#  Organization:  BrokenSun
#       Version:  1.0
#       Created:  2017/7/5 16:06:33
#      Revision:  ---
#       License:  Copyright (c) 2017, Ye Zhao Liang
#===============================================================================
# 
function b()
{
print &amp;quot;b.in.$1=&amp;quot;$1;
}
{
v=100; y=200
print &amp;quot;a.in.v=&amp;quot;v;
print &amp;quot;a.in.y=&amp;quot;y;

a(y);
b();
print &amp;quot;a.out.v=&amp;quot;v;
print &amp;quot;a.out.y=&amp;quot;y;
}


function a(y)
{
print &amp;quot;(a)v=&amp;quot;v;
v=v+$1+y;
y=300;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;6bash四种变量截取&#34;&gt;6.bash四种变量截取&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;${var#.*} 从左到右，满足#之后条件的最小长度
${var##.*} 从左到右，满足##之后条件的最大长度
${var%.*} 从右到左，满足%之后条件的最小长度
${var%%.*} 从右到左，满足%%之后条件的最小长度
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在awk中可以使用substr($1,0,length($1)–..)实现类似的功能。&lt;/p&gt;
&lt;p&gt;#7.bash中的包含关系&lt;/p&gt;
&lt;p&gt;包含： 即一个大的部分包含小的部分（member) 等价： 即两个东西等价(equal) 比较：一般是两个数，另外也可以是字符串。&lt;/p&gt;
&lt;p&gt;bash几种&lt;a href=&#34;http://www.cnblogs.com/ginsonwang/p/5525340.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt; 包含关系用法  &lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;strA=&amp;quot;helloworld&amp;quot;
strB=&amp;quot;low&amp;quot;
if [[ $strA =~ $strB ]]
then
    echo &amp;quot;包含&amp;quot;
else
    echo &amp;quot;不包含&amp;quot;
fi
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;#8.awk去除左右空格&lt;/p&gt;
&lt;p&gt;第5个知识点阐述了函数的定义方式,现在来运用一下， awk&lt;a href=&#34;http://www.cnblogs.com/ginsonwang/p/5525340.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt; 去除左右空格 &lt;/a&gt;，再一次使用中发现所有的文件名后缀中多了一个空格，于是尝试消掉空格，想着用awk实现。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-awk&#34;&gt;function ltrim(s) { sub(/^[ \t\r\n]+/, &amp;quot;&amp;quot;, s); return s }
function rtrim(s) { sub(/[ \t\r\n]+$/, &amp;quot;&amp;quot;, s); return s }
function trim(s) { return rtrim(ltrim(s)); }
BEGIN{
        FS=&amp;quot;,&amp;quot;
}

{
        $0 = rtrim($0);
        if($2!=&amp;quot;-&amp;quot; &amp;amp;&amp;amp; $3==&amp;quot;-&amp;quot;)
                a[$4]++;
        {
        if($4!=&amp;quot;-&amp;quot;)
                b[$4]++;
        else
                b[$5]++;
        }
}

END{
        print &amp;quot;   client    incr_num_day&amp;quot;;
        for(i in a) printf(&amp;quot;%10s   %d\n&amp;quot;,i,a[i])
        print &amp;quot;\n\n   client    all_num&amp;quot;;                                                                                                                                                     
        for(j in b) printf(&amp;quot;%10s   %d\n&amp;quot;,j,b[j]);
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;#9.awk调用系统命令&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://blog.csdn.net/cy_cai/article/details/41908921&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt; MEthod &lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ready:
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;touch c.txt
touch d.txt&lt;/p&gt;
&lt;p&gt;II. a.txt:&lt;/p&gt;
&lt;p&gt;c.txt
d.txt&lt;/p&gt;
&lt;p&gt;III. code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-awk&#34;&gt;awk &#39;{cmd=&amp;quot;rm &amp;quot;$0;system(cmd)}&#39; a.txt   
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;10awk重定向和管道&#34;&gt;10.awk重定向和管道&lt;/h1&gt;
&lt;p&gt;有时候直接可以在awk使用管道，提供给shell,比如print|Sort,&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-awk&#34;&gt;
awk &#39;{print $1, $2 | &amp;quot;sort&amp;quot; }&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;#11.windows下的cygwin使用脚本&lt;/p&gt;
&lt;p&gt;必须得使用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;dos2unix.exe *脚本名字
dos2unix.exe a.sh
dos2unix.exe func.awk


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样执行shell才有效。&lt;/p&gt;
&lt;h1 id=&#34;12awk性能比shell更高&#34;&gt;12.awk性能比shell更高&lt;/h1&gt;
&lt;p&gt;参考&lt;a href=&#34;http://www.cnblogs.com/chengmo/archive/2010/10/04/1842073.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt; 链接 &lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;
性能比较

[chengmo@localhost nginx]# time (awk &#39;BEGIN{ total=0;for(i=0;i&amp;lt;=10000;i++){total+=i;}print total;}&#39;)
50005000

real    0m0.003s
user    0m0.003s
sys     0m0.000s
[chengmo@localhost nginx]# time(total=0;for i in $(seq 10000);do total=$(($total+i));done;echo $total;)
50005000

real    0m0.141s
user    0m0.125s
sys     0m0.008s 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结论：在awk中执行算术运算，比在bash中执行更好一些。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>使用Ydiff工具生成文件差异比较文件</title>
      <link>https://jueqingsizhe66.github.io/blog/2016/02/22/shi-yong-ydiffgong-ju-sheng-cheng-wen-jian-chai-yi-bi-jiao-wen-jian/</link>
      <pubDate>Mon, 22 Feb 2016 19:24:53 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/blog/2016/02/22/shi-yong-ydiffgong-ju-sheng-cheng-wen-jian-chai-yi-bi-jiao-wen-jian/</guid>
      <description>&lt;p&gt;Ydiff是一个不错的lisp语法分析工具(&lt;a href=&#34;https://github.com/yinwang0/ydiff&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;王垠编制&lt;/a&gt;).下面是该工具简单用途和使用说明。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;用途
主要是js，cpp，和lisp的分析，现在也有&lt;a href=&#34;https://github.com/yinwang0/pysonar2&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;python&lt;/a&gt;,&lt;a href=&#34;https://github.com/yinwang0/pysonar2&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ruby&lt;/a&gt;的分析工具。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用说明&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;编译的时候仅仅在项目下载之后，make一下即可生成对应的diff-cpp,diff-js,diff-lisp分析工具.
文件分为单文件和文件夹两种。&lt;/p&gt;
&lt;h2 id=&#34;单文件使用说明&#34;&gt;单文件使用说明&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt; diff-lisp *.scm *1.scm 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;文件夹使用方式&#34;&gt;文件夹使用方式&lt;/h2&gt;
&lt;p&gt;保存下面源代码为process-lisp.sh&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;
dir1=let-lang
dir2=letrec-lang
for i in `ls ${dir1}/*.scm`
do
    export TestVari=$i
    /home/happycamp-of-lisp/wangying/ydiff/diff-lisp $i ${dir2}/${TestVari##*\/}
done


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然也可以改为&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;
dir1=let-lang
dir2=letrec-lang
for i in `ls ${dir1}/*.scm`
do
    /home/happycamp-of-lisp/wangying/ydiff/diff-lisp $i ${dir2}/${i##*\/}
done


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;只要修改对应的文件夹dir1,dir2,就可以分析对应文件夹的scm所有文件,然后运用下面命令行，即可生成
对应的html文件,方便阅读&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bash process-lisp.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;数组引入进一步修改处理程序&#34;&gt;数组引入进一步修改处理程序&lt;/h2&gt;
&lt;p&gt;数组的shell操作参考&lt;a href=&#34;http://blog.csdn.net/liufei_learning/article/details/8000570&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;如下&lt;/a&gt;,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定义的时候通过小括号包裹&lt;/li&gt;
&lt;li&gt;调用的时候通过${}&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意 &lt;a href=&#34;http://blog.csdn.net/flowingflying/article/details/5146160&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;数据运算&lt;/a&gt;和判断(&lt;strong&gt;注意只有在双括号的小于号才是小于号&lt;/strong&gt;)的两个中括号&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;seq 1 $((${#array1[@]}-1))

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试过很多错误的情况，比如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;array1=(`ls -l|grep ^d|awk &#39;{print $9}&#39;`); 
echo ${array1[@]:0:${#array1[@]}-1};
export length1=${!array1[@]}; 
for i in ${array1[@]:1:length1-1}; do 
    for j in ${array1[@]:$i:length1}; do 
        echo $i,$j;
    done;
done;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;原因在于,${!}操作并不是把它当作数组形式，所以改为数组即可，使用seq。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;length1=${!array1[@]}
echo $length1 
    0 1 2 3

echo ${#length1[@]}
    1

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;正确的过程(&lt;strong&gt;注意$i+1&lt;/strong&gt;)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;array1=(`ls -l|grep ^d|awk &#39;{print $9}&#39;`);  
for i in `seq 1 $((${#array1[@]}-1))`; do 
    for j in ${array1[@]:$i+1:${#array1[@]}}; do 
        echo ${array1[$i]},$j;
    done;
done;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果,满足组合公式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1,letrec-lang
1,lexaddr-lang
1,proc-lang
2,lexaddr-lang
2,proc-lang
3,proc-lang

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;批处理解析scm文件&#34;&gt;批处理解析scm文件&lt;/h2&gt;
&lt;p&gt;当文件夹下存在如下文件下，则可以进一步利用&lt;a href=&#34;#pi&#34;&gt;程序&lt;/a&gt;进行分析，注意拷贝nav.js和diff.css进行渲染&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ls┌─[root][canbetter-N53SM][±][master ?:10 ✗][2.2.1][/home/happycamp-of-lisp/EOPL2014/DF-eopl/chapter3/proc-lang/ds-rep]
└─➞ ls
compiled  data-structures.scm  drscheme-init.scm  environments.scm  interp.scm  lang.scm  tests.scm  top.scm

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;pi&#34;&gt;批处理程序&lt;/h3&gt;
```
array1=(`ls -l|grep ^d|awk &#39;{print $9}&#39;`); 
# 遍历所有文件夹 除了最后一个
for i in `seq 1 $((${#array1[@]}-1))`; do 
    #遍历从i之后的文件
    for j in ${array1[@]:$i:${#array1[@]}}; do 
        #echo ${array1[$i]},$j;
        dir1=${array1[$i]};
        dir2=$j;
        mkdir ${dir1}-${dir2}
        # 选取对应文件夹下的scm文件
        for k in `ls ${dir1}/*.scm`
        do
            #export TestVari=$i
            /home/happycamp-of-lisp/wangying/ydiff/diff-lisp $k ${dir2}/${k##*\/} 
        done
&lt;pre&gt;&lt;code&gt;    mv *.html ${dir1}-${dir2}
    cp ./nav.js ./diff.css ${dir1}-${dir2}
done;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;done;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
然后可以在terminal运行
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;python -m SimpleHTTPServer
Serving HTTP on 0.0.0.0 port 8000 &amp;hellip;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;在浏览器输入
    http://localhost:8000/ 


### 有问题的数组下标

数组下表是从0开始的！
``` sh

array1=(`ls -l|grep ^d|awk &#39;{print $9}&#39;`); 
# 遍历所有文件夹 除了最后一个
for i in `seq 0 $((${#array1[@]}-1))`; do 
    #遍历从i之后的文件
    for j in ${array1[@]:$i+1:${#array1[@]}}; do 
        #echo ${array1[$i]},$j;
        dir1=${array1[$i]};
        dir2=$j;
        mkdir ${dir1}-${dir2}
        # 选取对应文件夹下的scm文件
        for k in `ls ${dir1}/*.scm`
        do
            #export TestVari=$i
            /home/happycamp-of-lisp/wangying/ydiff/diff-lisp $k ${dir2}/${k##*\/} 
        done

        mv *.html ${dir1}-${dir2}
        cp ./nav.js ./diff.css ${dir1}-${dir2}
    done;
done;

mkdir final-result
for i in `seq 0 $((${#array1[@]}-1))`; do 
    #遍历从i之后的文件
    for j in ${array1[@]:$i+1:${#array1[@]}}; do 
        #echo ${array1[$i]},$j;
        dir1=${array1[$i]};
        dir2=$j;
        mv ${dir1}-${dir2} final-result
    done;
done;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样就完成了文件夹下所有的文件对比操作，当然得确保该文件夹下存在scm文件。&lt;/p&gt;
&lt;h2 id=&#34;进一步修改ydiff&#34;&gt;进一步修改YDiff？&lt;/h2&gt;</description>
    </item>
    
    <item>
      <title>Shell_Programming_with_fewer_bugs</title>
      <link>https://jueqingsizhe66.github.io/blog/2015/08/09/shell-programming-with-fewer-bugs/</link>
      <pubDate>Sun, 09 Aug 2015 14:37:30 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/blog/2015/08/09/shell-programming-with-fewer-bugs/</guid>
      <description>&lt;p&gt;shell的强大之处在于短小精悍，对于IO处理相当方便，当然也可以兼杂小型的数值计算（很少）。
shell脚本在编写过程中也会产生很多bug。本文借鉴《Pro-Bash-Programming》一书所提倡的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;comment  写上开头注释&lt;/li&gt;
&lt;li&gt;Initialization of variables 变量初始化&lt;/li&gt;
&lt;li&gt;Function definitions  函数定义&lt;/li&gt;
&lt;li&gt;Runtime configuration 解析选项，读取配置文件等&lt;/li&gt;
&lt;li&gt;Sanity Check  经过Runtime配置之后，可能修改某些值，比如shift操作，所以需要判断变量的合理性&lt;/li&gt;
&lt;li&gt;Process information   最后才是计算、IO等&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过这中编写框架，可以减少错误。&lt;/p&gt;
&lt;p&gt;a. 首先保存最后的shell代码到一个文件wfe.sh
b. 其次下载所需要的字典文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  mkdir ~/words
  cd ~/words
 wget http://cfaj.freeshell.org/wordfinder/Compounds
 wget http://cfaj.freeshell.org/wordfinder/singlewords

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;c. 运行脚本&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;
1. 获取帮助
  bash wfe.sh -h
2. 获取版本信息
  bash wfe.sh -v
3.单个单词查找  
  bash wfe.sh bro
4. 复合单词内查找（包含单个单词）
  bash wfe.sh -c bro 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;d. 源码文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;
#:    Title: wfe - List words ending with PATTERN
#: Synopsis: wfe [-c|-h|-v] REGEX
#:     Date: 2009-04-13
#:  Version: 1.0
#:   Author: Chris F.A. Johnson
#:  Options: -c - Include compound words
#:           -h - Print usage information
#:           -v - Print version number

set -x
export PS4=&#39;+ $LINENO : &#39;

## 变量初始化
## Script metadata
scriptname=${0##*/}
description=&amp;quot;List words ending with REGEX&amp;quot;
usage=&amp;quot;$scriptname [-c|-h|-v] REGEX&amp;quot;
date_of_creation=2009-04-13
version=1.0
author=&amp;quot;Chris F.A. Johnson&amp;quot;

## File locations
dict=$HOME/words
wordfile=$dict/singlewords
compoundfile=$dict/Compounds  # 源代码作者在这边设下陷阱1  con--&amp;gt;com

## Default is not to show compound words
compounds=

## Reular expression supplied on the command line
pattern=$1

## Function definitions 函数定义 

#提倡使用这样编写函数@ Description @Usage：
die() #@ DESCRIPTION: print error message and exit with supplied return code
{     #@ USAGE: die STATUS [MESSAGE]
  error=$1
  shift
  [ -n &amp;quot;$*&amp;quot; ] printf &amp;quot;%s\n&amp;quot; &amp;quot;$*&amp;quot; &amp;gt;&amp;amp;2
  exit &amp;quot;$error&amp;quot;
}

usage() #@ DESCRIPTION: print usage information
{       #@ USAGE: usage
        #@ REQUIRES: variable defined: $scriptname
  printf &amp;quot;%s - %s\n&amp;quot; &amp;quot;$scriptname&amp;quot; &amp;quot;$description&amp;quot;
  printf &amp;quot;USAGE: %s\n&amp;quot; &amp;quot;$usage&amp;quot;
}

version() #@ DESCRIPTION: print version information
{          #@ USAGE: version
           #@ REQUIRES: variables defined: $scriptname, $author and $version
  printf &amp;quot;%s version %s\n&amp;quot; &amp;quot;$scriptname&amp;quot; &amp;quot;$version&amp;quot;
  printf &amp;quot;by %s, %d\n&amp;quot; &amp;quot;$author&amp;quot; &amp;quot;${date_of_creation%%-*}&amp;quot;
  #printf &amp;quot;by %s, %d\n&amp;quot; &amp;quot;$author&amp;quot; &amp;quot;${date_of_creation%%-*&amp;quot;   指的那边错误不是真正的错误！一般需要往上找
}

## parse command-line options, -c, -h, and -v 解析

echo $(( $OPTIND ))
while getopts chv var
do
   case $var in
     c) compounds=$compoundfile ;;
     h) usage; exit ;;
     v) version; exit ;;
   esac
done
shift $(( $OPTIND - 1 ))  ## move out one parameter and then position to the right by one step
                          ## 右移操作
regex=$1           ## 设下陷阱2 没有注册regex变量，却直接调用$regex
echo $(( $regex ))

## sanity check   设下陷阱3 没有进行错误检查

if [ -z &amp;quot;$pattern&amp;quot; ]
then 
    {
        echo &amp;quot;Search term missing&amp;quot;
        usage
    } &amp;gt;&amp;amp;2
    exit 1
fi


## Search $wordfile and $compounds if it is defined
{
   cat &amp;quot;$wordfile&amp;quot;
   if [ -n &amp;quot;$compounds&amp;quot; ]  # not null  -n ~ -z   n :nonzero  z:zero
   then
      cut -f1 &amp;quot;$compounds&amp;quot;
   fi
#}| grep -i &amp;quot;.$regex$&amp;quot; |sort -fu   #errror
}| grep -i &amp;quot;.$regex$&amp;quot; |sort -fu 

## Case-insensitive sort; remove duplicates


&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
  </channel>
</rss>
