<!DOCTYPE html><html lang="en-us" >


<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  
  
    <meta name="generator" content="Wowchemy 5.4.0 for Hugo" />
  

  
  










  







  
  
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  

  
  
  
    
      
      <link rel="preload" as="style" href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap">
      <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap" media="print" onload="this.media='all'">
    
  

  
  
  
  
  
    
    
    
  
  

  <meta name="author" content="叶昭良" />

  
  
  
    
  
  <meta name="description" content="" />

  
  <link rel="alternate" hreflang="en-us" href="https://jueqingsizhe66.github.io/archives/ya-suo-wen-jian-ioliu-de-shi-yong-he-jian-dan-feng-zhuang-0213/" />

  
  
  
    <meta name="theme-color" content="#1565c0" />
  

  
  
    
    <script src="/js/mathjax-config.js"></script>
  

  

  <link rel="stylesheet" href="/css/vendor-bundle.min.f1ecf783c14edc00c9320c205831ad8e.css" media="print" onload="this.media='all'">

  
  
  
    
    
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha512-W0xM4mr6dEP9nREo7Z9z+9X70wytKvMGeDsj7ps2+xg5QPrEBXC8tAW1IFnzjR6eoJ90JmCnFzerQJTLzIEHjA==" crossorigin="anonymous" media="print" onload="this.media='all'">
    

    
    
    
    
      
      
    
    
    

    
    
    
      
    
    
      
      
        
          <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.2.1/build/styles/github.min.css" crossorigin="anonymous" title="hl-light" media="print" onload="this.media='all'">
          <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.2.1/build/styles/dracula.min.css" crossorigin="anonymous" title="hl-dark" media="print" onload="this.media='all'" disabled>
        
      
    

    
    
    

    

    
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js" integrity="" crossorigin="anonymous" async></script>
      
    
      
      

      
      

      
    
      
      

      
      

      
    
  

  
  
  
  
  
  <link rel="stylesheet" href="/css/wowchemy.2a9113cdaa287c8aabad4aa82208fdf3.css" />

  



  


  


  




  
  
  

  

  
    <link rel="manifest" href="/manifest.webmanifest" />
  

  <link rel="icon" type="image/png" href="/media/icon_hua2ec155b4296a9c9791d015323e16eb5_11927_32x32_fill_lanczos_center_3.png" />
  <link rel="apple-touch-icon" type="image/png" href="/media/icon_hua2ec155b4296a9c9791d015323e16eb5_11927_180x180_fill_lanczos_center_3.png" />

  <link rel="canonical" href="https://jueqingsizhe66.github.io/archives/ya-suo-wen-jian-ioliu-de-shi-yong-he-jian-dan-feng-zhuang-0213/" />

  
  
  
  
  
  
  
  
    
    
  
  

  
  
    
    
  
  <meta property="twitter:card" content="summary" />
  
    <meta property="twitter:site" content="@jueqingsihe66" />
    <meta property="twitter:creator" content="@jueqingsihe66" />
  
  <meta property="og:site_name" content="30年磨一剑" />
  <meta property="og:url" content="https://jueqingsizhe66.github.io/archives/ya-suo-wen-jian-ioliu-de-shi-yong-he-jian-dan-feng-zhuang-0213/" />
  <meta property="og:title" content="压缩文件IO流的使用和简单封装（0213） | 30年磨一剑" />
  <meta property="og:description" content="" /><meta property="og:image" content="https://jueqingsizhe66.github.io/media/icon_hua2ec155b4296a9c9791d015323e16eb5_11927_512x512_fill_lanczos_center_3.png" />
    <meta property="twitter:image" content="https://jueqingsizhe66.github.io/media/icon_hua2ec155b4296a9c9791d015323e16eb5_11927_512x512_fill_lanczos_center_3.png" /><meta property="og:locale" content="en-us" />
  
    
      <meta
        property="article:published_time"
        content="2015-05-11T14:58:47&#43;08:00"
      />
    
    <meta property="article:modified_time" content="2015-05-11T14:58:47&#43;08:00">
  

  



  

  

  





  <title>压缩文件IO流的使用和简单封装（0213） | 30年磨一剑</title>
</head>


<body id="top" data-spy="scroll" data-offset="70" data-target="#TableOfContents" class="page-wrapper   " data-wc-page-id="6a2b7831c1f1d39f79bd5d99e610a9b4" >

  
  
  
  
  
  
  
  
  
  <script src="/js/wowchemy-init.min.9e9fa4b2ccd29f9edfae161d14d2effd.js"></script>

  


<aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between mb-3">
        <div class="col-6">
          <h1>Search</h1>
        </div>
        <div class="col-6 col-search-close">
          <a class="js-search" href="#" aria-label="Close"><i class="fas fa-times-circle text-muted" aria-hidden="true"></i></a>
        </div>
      </div>

      <div id="search-box">
        
        <input name="q" id="search-query" placeholder="Search..." autocapitalize="off"
        autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control"
        aria-label="Search...">
        
      </div>

      
      

      

    </section>
    <section class="section-search-results">

      <div id="search-hits">
        
      </div>

    </section>
  </div>
</aside>



  <div class="page-header">
    












<header class="header--fixed">
  <nav class="navbar navbar-expand-lg navbar-light compensate-for-scrollbar" id="navbar-main">
    <div class="container-xl">

      
      <div class="d-none d-lg-inline-flex">
        <a class="navbar-brand" href="/">30年磨一剑</a>
      </div>
      

      
      <button type="button" class="navbar-toggler" data-toggle="collapse"
              data-target="#navbar-content" aria-controls="navbar-content" aria-expanded="false" aria-label="Toggle navigation">
      <span><i class="fas fa-bars"></i></span>
      </button>
      

      
      <div class="navbar-brand-mobile-wrapper d-inline-flex d-lg-none">
        <a class="navbar-brand" href="/">30年磨一剑</a>
      </div>
      

      
      
      <div class="navbar-collapse main-menu-item collapse justify-content-start" id="navbar-content">

        
        <ul class="navbar-nav d-md-inline-flex">
          

          

          
          
          
            
          

          

          
          
          
          

          
            
              
              
            
            
              
              
              
                
              
              
            
          

          <li class="nav-item">
            <a class="nav-link " href="/#hero"><span>概要</span></a>
          </li>

          
          

          

          
          
          
            
          

          

          
          
          
          

          
            
              
              
            
            
              
              
              
                
              
              
            
          

          <li class="nav-item">
            <a class="nav-link " href="/#posts"><span>博文</span></a>
          </li>

          
          

          

          
          
          
            
          

          

          
          
          
          

          
            
              
              
            
            
          

          <li class="nav-item">
            <a class="nav-link " href="/about/"><span>About</span></a>
          </li>

          
          

          

          
          
          
            
          

          

          
          
          
          

          
            
              
              
            
            
          

          <li class="nav-item">
            <a class="nav-link " href="/categories/"><span>分类</span></a>
          </li>

          
          

          

          
          
          
            
          

          

          
          
          
          

          
            
              
              
            
            
          

          <li class="nav-item">
            <a class="nav-link  active" href="/archives"><span>归档</span></a>
          </li>

          
          

          

          
          
          
            
          

          

          
          
          
          

          
            
              
              
            
            
              
              
              
                
              
              
            
          

          <li class="nav-item">
            <a class="nav-link " href="/#tags"><span>标签</span></a>
          </li>

          
          

        

          
        </ul>
      </div>

      <ul class="nav-icons navbar-nav flex-row ml-auto d-flex pl-md-2">

        
        
          
        

        
        
        <li class="nav-item">
          <a class="nav-link js-search" href="#" aria-label="Search"><i class="fas fa-search" aria-hidden="true"></i></a>
        </li>
        

        
        
        
        <li class="nav-item dropdown theme-dropdown">
          <a href="#" class="nav-link" data-toggle="dropdown" aria-haspopup="true" aria-label="Display preferences">
            <i class="fas fa-moon" aria-hidden="true"></i>
          </a>
          <div class="dropdown-menu">
            <a href="#" class="dropdown-item js-set-theme-light">
              <span>Light</span>
            </a>
            <a href="#" class="dropdown-item js-set-theme-dark">
              <span>Dark</span>
            </a>
            <a href="#" class="dropdown-item js-set-theme-auto">
              <span>Automatic</span>
            </a>
          </div>
        </li>
        

        
        

      </ul>

    </div>
  </nav>
</header>


  </div>

  <div class="page-body">
    
    
    

    <article class="article">

  








  
 <script async src="//cdn.busuanzi.ibruce.info/cdn/busuanzi/2.3/busuanzi.pure.mini.js"></script> 
 <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script> 
 <script> 
     $(document).ready(function() { 
         var int = setInterval(fixCount, 100); 
         var busuanziSiteOffset =  100000  
         function fixCount() { 
             if ($("#busuanzi_container_site_pv").css("display") != "none") { 
                 clearInterval(int); 
                 $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + busuanziSiteOffset); 
             } 
         } 
     }); 
 </script> 
  






  

  
  
  
<div class="article-container pt-3">
  <h1>压缩文件IO流的使用和简单封装（0213）</h1>

  

  
    


<div class="article-metadata">

  
  

  
  <span class="article-date">
    
    
      
    
    May 11, 2015
  </span>
  

  

  

  
  
  
  

  
  
  <span class="middot-divider"></span>
  <span class="article-categories">
    <i class="fas fa-folder mr-1"></i><a href="/category/programme/">programme</a></span>
  

</div>

    





  
</div>





<span class="article-metadata" >Reading time: 37 minutes and    48 seconds with 8317 words. 本文总阅读量<span id="busuanzi_value_page_pv"></span>次 </span>
    <aside>
        <nav id="TableOfContents"></nav>
    </aside>
  <div class="article-container">


    <div class="article-style">
      <p>分为三个部分：
第一部分 ，先是试用了zipinputstream的用法
第二部分， 是进一步试用了压缩流zipoutputStream和加密的方法
第三部分 ， 则是对上述过程封装为一个OOZip类</p>
<p>功能简述：  分为普通的压缩和加密的压缩，对应的解压缩 。普通的压缩：文件和文件夹都可以。 加密的压缩：文件和文件夹都可以，当加密的时候，则生成的zip文件里面的文件打开时乱码，必须用对应的unzipCrypto方法进行解压才有效。当然不会像winzip会提醒你输入密码，可以让你打开，只不过打开的是乱码。</p>
<p>1： 先从com.rupeng.gtk4j挖出了zipInputStream的用法，用于解压缩，测试只能针对zip文件。
于是就有了初始版本的解压缩流：</p>
<pre><code class="language-java">import java.io.Closeable;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

/**
* @author    叶昭良
* @time      2015年2月12日下午1:19:18
* @version   TestZipInputStream V1.0
*/
public class TestZipInputStream
{

        /**
         * @param args
         */
        public static void main(String[] args)
        {
                //unZipShared(&quot;e:\\test\\test.zip&quot;);
                //unZipShared(&quot;e:\\test\\test1.zip&quot;);
                //rar暂时无法解压出来，但是zip文件是可以的
                unZipShared(&quot;e:\\test\\test1.zip&quot;,&quot;e:\\testOutput&quot;);
        }
        
        /**
         *   解压缩 zip文件，只能限制为rar
         * @param zipName        待解压的zip文件
         * @param outputfolder   解压zip文件到outputFoler文件夹下
         */
        public static void unZipShared(String zipName,String outputfolder)
        {
                File gtkDir = new File(outputfolder);// *.dll放的文件夹
                if (!gtkDir.exists())
                {
                        gtkDir.mkdirs();
                }
                InputStream inStream = null;
                try
                {
                        inStream = new  FileInputStream(zipName);
                } catch (FileNotFoundException e1)
                {
                        // TODO Auto-generated catch block
                        e1.printStackTrace();
                }
                //InputStream inStream = Utils.class.getResourceAsStream(&quot;/gtkshare.zip&quot;);
                if (inStream == null)
                {
                        throw new UnsatisfiedLinkError(&quot;没找到&quot;+zipName);
                }
                try
                {                        
                        unZip(inStream, gtkDir.toString());
                        System.out.println(gtkDir.toString());
                } catch (IOException e)
                {
                        System.err.println(&quot;解压缩gtkshare.zip失败&quot; + toFullString(e));
                }
        }

        /**
         * 把streamToZip这个zip文件流解压到硬盘的destDir文件夹，支持多级目录
         * @param streamToZip
         * @param destDir
         * @throws IOException
         */
        public static void unZip(InputStream streamToZip,String destDir)throws IOException
        {  
                ZipInputStream zipStream = new ZipInputStream(streamToZip);
                try
                {
                        ZipEntry zipEntry = null;
                        //通过zipEntry方式支持多级目录
                        while((zipEntry=zipStream.getNextEntry())!=null)
                        {
        if(zipEntry.isDirectory())
        {
                File dir = new File(destDir,zipEntry.getName());
                if(!dir.exists())
                {
                        dir.mkdirs();
                }
        }
        else
        {
                FileOutputStream fileOutStream = new FileOutputStream(new File(destDir,zipEntry.getName()));
                try
                {
                        copy(zipStream, fileOutStream);
                }
                finally
                {
                        close(fileOutStream);
                }
        }
}
                }
                finally
                {
                        close(zipStream);
                }
                
    }
        /**
         *     从zip文件包中拷贝文件
         * @param inStream       zipEntry的某个文件
         * @param outStream      输出的某个文件流
         * @throws IOException
         */
        static void copy(InputStream inStream, OutputStream outStream)
                        throws IOException
        {
                byte[] buffer = new byte[512 * 1024];// 0.5MB 的缓冲区
                int len;
                while ((len = inStream.read(buffer)) &gt;= 0)
                {
                        outStream.write(buffer, 0, len);
                }
        }
        /**
         *    摘自rupeng.gtk4j   不明白具体的作用    非主要问题
         * @param throwable
         * @return
         */
        static String toFullString(Throwable throwable)
        {
                StringWriter sw = null;
                PrintWriter pw = null;
                try
                {
                        sw = new StringWriter();
                        pw = new PrintWriter(sw);
                        throwable.printStackTrace(pw);
                        return sw.toString();
                } finally
                {
                        close(sw);
                        close(pw);
                }
        }
        /**
         *     让文件流安静的关闭
         * @param closeable   关闭接口
         */
        static void close(Closeable closeable)
        {
                if (closeable != null)
                {
                        try
                        {
                                closeable.close();
                        } catch (IOException e)
                        {

                        }
                }
        }


}
</code></pre>
<p>2：后来想着有解压缩，必然也是有着压缩，于是就摆了一下，参考了一篇百度知道文章
2.1 首先加入了zip的方法
2.2 改进了zip方法的文件压缩流的写入过程，利用buffersize
2.3 常使用了文章中的加密过程，添加了加密压缩和加密解压缩的过程
2.4 想着实用命令流来进一步实现 压缩和解压缩的调用，后来弃用，改用封装一个OOZip类来实现</p>
<p>于是就有了下面的升级版的压缩和解压缩的程序：</p>
<pre><code class="language-java">import java.io.Closeable;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.spec.InvalidKeySpecException;
import java.util.Random;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;
import java.util.zip.ZipOutputStream;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.interfaces.PBEKey;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.PBEParameterSpec;
import javax.crypto.spec.SecretKeySpec;


/**
* @author    叶昭良
* @time      2015年2月12日下午5:22:31
* @version   TestZipInputStreamUpdate V1.0  增加了压缩 
*                              V2.0   ZipShared加入了 zosTemp.close(); 修复了 压缩的bug，删掉则无法压缩
*                              V3.0   升级了ZipShared 使用了copy函数。
*                              V4.0   增加了加密压缩 和解加密压缩
*/
public class TestZipInputStreamUpdate
{

        
        /**
         * @param args
         */
        private static final String ALGORITHM = &quot;PBEWithMD5AndDES&quot;;
        public static void main(String[] args)
        {
                // TODO Auto-generated method stub
                TestZipInputStreamUpdate tisu = new TestZipInputStreamUpdate();
                //不需要再次加入zip文件后缀了
                //tisu.ZipShared(&quot;e://test1222bak&quot;,&quot;e://test1222&quot;);
                
                tisu.ZipSharedCrypto(&quot;e://test1222bak&quot;, &quot;e://test1222passwdByZhao.zip&quot;, &quot;123456&quot;);
                tisu.unzipCrypto(&quot;e://test1222passwdByZhao.zip&quot;,&quot;c://laoliang&quot;,&quot;123456&quot;);
        //        tisu.unzipCrypto(&quot;e://test1222passwdByZhao.zip&quot;,&quot;c://laoliang&quot;,&quot;1234565&quot;);
                
                /*
                 *  你正在进入e:\test1222bak文件夹
                        你正在进入e:\test1222bak\test1222文件夹
                        你正在压缩a1.zip
                        你正在压缩test123.txt
                        你正在压缩test124.txt
                        
                        通过这个实验总结了：所有操作系统内部的文件都是文件，无论是普通的文件
                        还是文件夹文件，还是管道文件，还是索引文件，还是设备文件，本质上都是
                        文件，只不过是在文件的头上面增加了一些特殊的标记，比如说你需要在文件夹
                        的路径增加一个\路径标志 反斜杠的道理是一样的。
                 */
                
                /*  这是一个命令流的使用方式：：
                 *         if(args.length==2){ 
            String name = args[1]; 
            Zip zip = new Zip(); 

            if(args[0].equals(&quot;-zip&quot;)) 
            {
                    zipname = args[2];
                    zip.doZip(name); 
            }
                
            else if(args[0].equals(&quot;-unzip&quot;)) 
            {
                    outputfolder = args[2];
                     zip.unZip(name);          
            }     
        } 
        else{ 
            System.out.println(&quot;Usage:&quot;); 
            System.out.println(&quot;压缩:java Zip -zip directoryName  zipname&quot;); 
            System.out.println(&quot;解压:java Zip -unzip fileName.zip outputfolder&quot;); 
            throw new Exception(&quot;Arguments error!&quot;); 
        } 
                 */
        }
        public void ZipShared(String fileinput,String zos)
        {
                try
                {
                        //加入&quot;zip&quot;后缀！
                        ZipOutputStream zosTemp = new ZipOutputStream(new FileOutputStream(zos+&quot;zip&quot;));
                        File fApple = new File(fileinput);
                        ZipShared(fApple,zosTemp,&quot;&quot;);
                        try
                        {
                                /// 为什么加入这个就可以？？？？
                                //  不加入这有异常？？？？why   Tell me 
                                zosTemp.close();
                        } catch (IOException e)
                        {
                                // TODO Auto-generated catch block
                                e.printStackTrace();
                        }
                } catch (FileNotFoundException e)
                {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                }
                
        }
        public  void ZipShared(File fileinput,ZipOutputStream zos,String base)
        {
                //ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(outputZipName));
                
                //File fileinput = new File(outputZipName);
if(fileinput.isDirectory())
{
        System.out.println(&quot;你正在进入&quot;+fileinput+&quot;文件夹&quot;);
        File[] fBanana = fileinput.listFiles();
        try
        {
                //传进一个文件夹标志
                zos.putNextEntry(new ZipEntry(base+&quot;/&quot;));
                //让base加上一个/
                base = base.length()==0?&quot;&quot;:base+&quot;/&quot;;
                for(int i = 0; i &lt; fBanana.length; i++)
                {
                        ZipShared(fBanana[i],zos,base+fBanana[i].getName());
                }
        } catch (IOException e)
        {
                // TODO Auto-generated catch block
                System.out.println(&quot;压缩文件夹失败&quot;+e.getMessage());
        }
        
}else
{
        try
        {
                zos.putNextEntry(new ZipEntry(base));
                FileInputStream fis = new FileInputStream(fileinput);
                //改进写入的方式
                /*int b;
                while((b = fis.read())!= -1)
                {
                        zos.write(b); 
                        //效率很定不高  每一个字符  进行一次缓冲
                        //zos.flush();
                }*/
                copy(fis,zos); //利用汝鹏版的copy函数
                System.out.println(&quot;你正在压缩&quot;+fileinput.getName());
                //fis.close();
                
                //zos.close();
        } catch (IOException e)
        {
                // TODO Auto-generated catch block
                System.out.println(&quot;压缩文件失败&quot;+e.getMessage());
        } 
        //为什么加入则错误
        /*finally
        {
                try
                {
                        zos.close();
                }catch(IOException e)
                {
                        System.out.println(&quot;打开流错误！&quot;);
                }
        }*/
                }
        }
        public  void ZipSharedCrypto(String fileinput,String zosFile,String pwd)
        {
                
                try
                {        File f1 = new File(fileinput);
                //采用和ZipShared一样的FileOutputStream
                        ZipOutputStream zos  = null;
                        zos = new ZipOutputStream(new FileOutputStream(zosFile));
                        ZipSharedCrypto(f1,zos,&quot;&quot;, pwd);
                        try
                        {
                                zos.close();
                        } catch (IOException e)
                        {
                                // TODO Auto-generated catch block
                                e.printStackTrace();
                        }
                } catch (FileNotFoundException e)
                {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                }
                System.out.println(&quot;成了&quot;);
        }
        public  void ZipSharedCrypto(File fileinput,ZipOutputStream zos,String base,String pwd)
        {
if(fileinput.isDirectory())
{
        System.out.println(&quot;你正在进入&quot;+fileinput+&quot;文件夹&quot;);
File[] fApples = fileinput.listFiles();
//因为ZipEntry的isDirectory()方法中，目录以&quot;/&quot;结尾
try
{        
        zos.putNextEntry(new ZipEntry(base+&quot;/&quot;));
        base = base.length()==0?&quot;&quot;:(base+&quot;/&quot;);
        //一种比较新型的方式循环读写东西。
        for(File ftemp:fApples)
        {
                ZipSharedCrypto(ftemp,zos,base+ftemp.getName(),pwd);
        }
}catch(IOException e)
{
        System.out.println(&quot;文件夹加密压缩失败&quot;);
        }
}else
{        
        
        try
        {
                zos.putNextEntry(new ZipEntry(base));
                FileInputStream fis = new FileInputStream(fileinput);
                System.out.println(&quot;你正在开始加密压缩&quot;+fileinput+&quot;文件&quot;);
        PBEKeySpec keySpec = new PBEKeySpec(pwd.toCharArray());
        SecretKeyFactory keyFactory = null;
        try
        {
                keyFactory = SecretKeyFactory.getInstance(ALGORITHM);
        } catch (NoSuchAlgorithmException e)
        {
                // TODO Auto-generated catch block
                e.printStackTrace();
        }
        SecretKey passwordKey = keyFactory.generateSecret(keySpec);
        //生成一个炸弹 进行加密
        byte[] bomb =  new byte[8];
        Random rnd = new Random();
        rnd.nextBytes(bomb);
        int iterations = 100;
        PBEParameterSpec parameterSpec = new PBEParameterSpec(bomb, iterations);
        Cipher cipher = null;
        try
        {
                cipher = Cipher.getInstance(ALGORITHM);
        } catch (NoSuchAlgorithmException
                        | NoSuchPaddingException e)
        {
                // TODO Auto-generated catch block
                e.printStackTrace();
        }
        cipher.init(Cipher.ENCRYPT_MODE, passwordKey,parameterSpec);
        //往输出流 添加炸弹
        zos.write(bomb);
        
        //添加加密的主文件内容  1KB缓存区
        byte[] inputBuffer = new byte[1024];
        int bytesRead = 0;
        //如果没有读到信息则为-1
        while((bytesRead = fis.read(inputBuffer))!= -1)
        {
                //每个缓冲区 进行加密写入
                byte[] output = cipher.update(inputBuffer);
                if(output != null)
                {
                        zos.write(output);
                }
        }
        
        //加密结束语
        byte[] outputFinal =null;
        try
        {
                outputFinal = cipher.doFinal();
        } catch (IllegalBlockSizeException | BadPaddingException e)
        {
                // TODO Auto-generated catch block
                e.printStackTrace();
        }
        if(outputFinal != null)
        {
                zos.write(outputFinal);
        }
        
/*        fis.close();
        zos.flush();
        zos.close();*/
        
        
}catch(InvalidKeySpecException | InvalidKeyException | InvalidAlgorithmParameterException | IOException e)
{
        System.out.println(&quot;加密失败&quot;);
        }
}
        }
        /**
         *   解压缩 zip文件，只能限制为rar
         * @param zipName        待解压的zip文件
         * @param outputfolder   解压zip文件到outputFoler文件夹下
         */
        public static void unZipShared(String zipName,String outputfolder)
        {
                File gtkDir = new File(outputfolder);// *.dll放的文件夹
                //指定的目录不存在  则创建之
                if (!gtkDir.exists())
                {
                        gtkDir.mkdirs();
                }
                InputStream inStream = null;
                try
                {
                        inStream = new  FileInputStream(zipName);
                } catch (FileNotFoundException e1)
                {
                        // TODO Auto-generated catch block
                        e1.printStackTrace();
                }
                //InputStream inStream = Utils.class.getResourceAsStream(&quot;/gtkshare.zip&quot;);
                if (inStream == null)
                {
                        throw new UnsatisfiedLinkError(&quot;没找到&quot;+zipName);
                }
                try
                {                        
                        unZip(inStream, gtkDir.toString());
                        System.out.println(gtkDir.toString());
                } catch (IOException e)
                {
                        System.err.println(&quot;解压缩gtkshare.zip失败&quot; + toFullString(e));
                }
        }

        /**
         * 把streamToZip这个zip文件流解压到硬盘的destDir文件夹，支持多级目录
         * @param streamToZip
         * @param destDir
         * @throws IOException
         */
        public static void unZip(InputStream streamToZip,String destDir)throws IOException
        {  
                ZipInputStream zipStream = new ZipInputStream(streamToZip);
                try
                {
                        ZipEntry zipEntry = null;
                        //通过zipEntry方式支持多级目录
        while((zipEntry=zipStream.getNextEntry())!=null)
        {
                if(zipEntry.isDirectory())
                {
                        System.out.println(&quot;你正在创建文件夹文件 比较特殊&quot;);
                        File dir = new File(destDir,zipEntry.getName());
                        //如果指定的目录不存在 则创建之
                        if(!dir.exists())
                        {
                                dir.mkdirs();
                        }
                }
                else
                {
                        FileOutputStream fileOutStream = new FileOutputStream(new File(destDir,zipEntry.getName()));
                        try
                        {
                                copy(zipStream, fileOutStream);
                        }
                        finally
                        {
                                close(fileOutStream);
                        }
                        System.out.println(&quot;你正在解压缩压缩&quot;+zipEntry.getName());
                }
        }
}
finally
{
        close(zipStream);
}
                
    }
        /**
         *     从zip文件包中拷贝文件 ，按照0.5MB的缓冲写入文件(默认方式）
         * @param inStream       zipEntry的某个文件
         * @param outStream      输出的某个文件流
         * @throws IOException
         */
        static void copy(InputStream inStream, OutputStream outStream)
                        throws IOException
        {
                byte[] buffer = new byte[512 * 1024];// 0.5MB 的缓冲区
                int len;
                while ((len = inStream.read(buffer)) &gt;= 0)
                {
                        outStream.write(buffer, 0, len);
                }
        }
        /**
         *    摘自rupeng.gtk4j   不明白具体的作用    非主要问题
         * @param throwable
         * @return
         */
        static String toFullString(Throwable throwable)
        {
                StringWriter sw = null;
                PrintWriter pw = null;
                try
                {
                        sw = new StringWriter();
                        pw = new PrintWriter(sw);
                        throwable.printStackTrace(pw);
                        return sw.toString();
                } finally
                {
                        close(sw);
                        close(pw);
                }
        }
        /**
         *     让文件流安静的关闭
         * @param closeable   关闭接口
         */
        static void close(Closeable closeable)
        {
                if (closeable != null)
                {
                        try
                        {
                                closeable.close();
                        } catch (IOException e)
                        {

                        }
                }
        }
        
        // 加密解压缩

/**
         * 功能描述：将压缩文件解压到指定的文件目录下
         * @param zipFileName      压缩文件名称(带路径)
         * @param outputDirectory  指定解压目录
         * @return
         * @throws Exception
         */
        public  void unzipCrypto(String zipFileName, String outputDirectory, String pwd)
        {
                ZipInputStream inputStream;
                try
                {
                        inputStream = new ZipInputStream(new FileInputStream(zipFileName));
                        unzipCrypto(inputStream, outputDirectory, pwd);
                } catch (Exception e)
                {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                }
                
        }


        public  void unzipCrypto(ZipInputStream inputStream, String outputDirectory, String pwd) throws Exception
        {
                ZipEntry zipEntry = null;
                FileOutputStream outputStream = null;
                try{
                        while ((zipEntry = inputStream.getNextEntry()) != null) 
                        {
if (zipEntry.isDirectory())
{
        System.out.println(&quot;你正在进入&quot;+zipEntry.getName()+&quot;文件夹&quot;);
        String name = zipEntry.getName();
        name = name.substring(0, name.length() - 1);
        File file = new File(outputDirectory + File.separator + name);
        file.mkdir();
} 
else 
{
        File file = new File(outputDirectory + File.separator + zipEntry.getName());
        file.createNewFile();
        outputStream = new FileOutputStream(file);
        System.out.println(&quot;你正在解压缩&quot;+file.getName()+&quot;文件&quot;);
        PBEKeySpec keySpec = new PBEKeySpec(pwd.toCharArray());
    SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(ALGORITHM);
    SecretKey passwordKey = keyFactory.generateSecret(keySpec);
    byte[] salt = new byte[8];
    inputStream.read(salt);
    int iterations = 100;
    PBEParameterSpec parameterSpec = new PBEParameterSpec(salt, iterations);
    Cipher cipher = Cipher.getInstance(ALGORITHM);
    cipher.init(Cipher.DECRYPT_MODE, passwordKey, parameterSpec);
    byte[] input = new byte[1024];
    int bytesRead;
    while ((bytesRead = inputStream.read(input)) != -1) 
    {
            byte[] output = cipher.update(input, 0, bytesRead);
            if (output != null)
            {
                    outputStream.write(output);
            }
    }
    byte[] output = cipher.doFinal();
    if (output != null)
    {
            outputStream.write(output);
    }
/*                                    outputStream.flush();
                                    outputStream.close();*/
        
}
                        }
                        //inputStream.close();
                }
                catch(IOException ex)
                {
                        throw new Exception(&quot;解压读取文件失败&quot;);
                }
                catch(Exception ex)
                {
                        throw new Exception(&quot;解压文件密码不正确&quot;);
                }
/*                finally
                {
                        inputStream.close();
                        outputStream.flush();
                    outputStream.close();
                }*/
        }

}
</code></pre>
<p>3：进一步 实现先前的想法，封装一个OOZip类，
基本思想：
1：抽取常用变量，比如bufferSize 缓冲区大小     buf缓冲区； 本想着加入压缩和解压缩的流变量，后来删掉了
2：定义构造函数， 设置缓冲区大小
3：复制之前的方法，并利用buffersize和buf改写copy函数和 文件的复制的函数
4：进行简单地压缩和解压缩文件夹      加密压缩和解加密压缩文件夹   的测试。 并找到了压缩单个文件的bug
5：bug修复</p>
<p>完整代码如下：</p>
<pre><code class="language-java">import java.io.Closeable;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.spec.InvalidKeySpecException;
import java.util.Random;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;
import java.util.zip.ZipOutputStream;
import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.PBEParameterSpec;

/**
* @author    叶昭良
* @time      2015年2月12日下午9:51:11
* @version   OOZip    用于压缩和解压缩
*                   V1.0  增加了压缩 
*                   V2.0   ZipShared加入了 zosTemp.close(); 修复了 压缩的bug
*                   V3.0   改进了构造函数 利用具有缓冲区的压缩
*                   V4.0   升级了ZipShared 使用了copy函数。
*                   V5.0   增加了加密压缩 和解加密压缩
*                   V6.0   改用了面向对象方式修改了一番
*                   V7.0   加入了一些压缩和解压缩完成的的console标记
*                   V8.0   修复了单个文件无法加密的bug   new ZipEntry(base) 改为
*                    new ZipEntry(base+fileinput.getName())，未添入到zipentry的缘故
*                    而若是文件夹遍历的时候则是有加入文件名的标记！所以在单个文件的时候也需要加入文件名的
*                    标记
*                   V9.0   若有中文问题，可以进一步采用import org.apache.tools.zip.* 的zip包！ 更好的支持中文
*                          具体参看http://blog.csdn.net/liu149339750/article/details/7887701  
*                                 http://szhnet.iteye.com/blog/199059 ，这个链接当中提供了ant版本 
*                          当然此版本，不需要org.apache.tool.zip包也不需要ant包  附录了ant版本的代码，的确看起来
*                          是简单的。
*/
public class OOZip
{

/**
*  这几个私有变量的控制，主要体现在针对具体的文件的复制过程中
*/
        private int bufSize ; //压缩和解压缩会用到。 一次从压缩文件zip读取多少文件信息
                                                                 //或者一次写入多少文件信息到压缩流
        private byte[] buf;   //写入或者写出压缩流的字节数组
        private int readBytes = 0;  //实际写入或者写出文件流的大小。
        private static final String ALGORITHM = &quot;PBEWithMD5AndDES&quot;;
        
        //构造函数的定义
   public OOZip(){ 
           // 1025*512  //设置输入输出流的缓冲区的大小 ，统一设置
        this(1024*512); 
    } 

    public OOZip(int bufSize){ 
        this.bufSize = bufSize; 
        this.buf = new byte[this.bufSize]; 
    } 
        
        //常用的类中 内部函数
        
        public static void main(String[] args)
        {
                // TODO Auto-generated method stub
                OOZip oz = new OOZip();
                //单个文件加密和非加密测试暂时失败
                oz.ZipShared(&quot;e://student.txt&quot;, &quot;e://laoliang&quot;); 
                //oz.ZipSharedCrypto(&quot;e://student.txt&quot;, &quot;e://laoliang&quot;,&quot;1234&quot;);
                //输入文件夹路径则加密和非加密测试通过
                //oz.ZipShared(&quot;e://test1222bak&quot;, &quot;e://laoliang&quot;);  //已测试通过
                //oz.ZipSharedCrypto(&quot;e://test1222bak&quot;, &quot;e://laoliang&quot;, &quot;123456&quot;);
                
                //解压缩，不用输入.zip后缀，只需要输入文件名
                //oz.unzipCrypto(&quot;e://laoliang&quot;, &quot;c://laozi&quot;,&quot;123456&quot;);
                //测试成功
        }

        /**
         *     压缩名字为fileinput变量内容的文件夹
         * @param fileinput   文件夹名字
         * @param zos         zip文件夹名字
         */
        public void ZipShared(String fileinput,String zos)
        {
                try
                {
                        //加入&quot;zip&quot;后缀！
                        ZipOutputStream zosTemp = new ZipOutputStream(new FileOutputStream(zos+&quot;.zip&quot;));
                        File fApple = new File(fileinput);
                        ZipShared(fApple,zosTemp,&quot;&quot;);
                        try
                        {
                                /// 为什么加入这个就可以？？？？
                                //  不加入这有异常？？？？why   Tell me 
                                zosTemp.close();
                        } catch (IOException e)
                        {
                                // TODO Auto-generated catch block
                                e.printStackTrace();
                        }
                } catch (FileNotFoundException e)
                {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                }
                System.out.println(&quot;success to create&quot;+zos+&quot;.zip&quot;);
        }
        /**
         *     压缩文件夹的中间函数
         * @param fileinput    输入函数的文件对象
         * @param zos          压缩输出流对象
         * @param base         一般是&quot;&quot; 表示子目录的作用，在递归目录的时候会用到，在文件夹递归中，涉及到改变；
         */
        public  void ZipShared(File fileinput,ZipOutputStream zos,String base)
        {
if(fileinput.isDirectory())
{
        System.out.println(&quot;你正在进入&quot;+fileinput+&quot;文件夹&quot;);
        File[] fBanana = fileinput.listFiles();
        try
        {
                //传进一个文件夹标志
                zos.putNextEntry(new ZipEntry(base+&quot;/&quot;));
                //让base加上一个/
                base = base.length()==0?&quot;&quot;:base+&quot;/&quot;;
                for(int i = 0; i &lt; fBanana.length; i++)
                {
                        ZipShared(fBanana[i],zos,base+fBanana[i].getName());
                }
        } catch (IOException e)
        {
                System.out.println(&quot;压缩文件夹失败&quot;+e.getMessage());
        }
        
}else
{
        try
        {
                zos.putNextEntry(new ZipEntry(base+fileinput.getName()));
                FileInputStream fis = new FileInputStream(fileinput);
                //改进写入的方式
                /*int b;
                while((b = fis.read())!= -1)
                {
                        zos.write(b); 
                        //效率很定不高  每一个字符  进行一次缓冲
                        //zos.flush();
                }*/
                copy(fis,zos); //利用汝鹏版的copy函数
                System.out.println(&quot;你正在压缩&quot;+fileinput.getName());
        } catch (IOException e)
        {
                System.out.println(&quot;压缩文件失败&quot;+e.getMessage());
        } 
}
        }
        /**
         *     加密压缩文件夹
         * @param fileinput    文件夹字符串
         * @param zosFile      压缩字符串名字
         * @param pwd          加密的密码
         */
        public  void ZipSharedCrypto(String fileinput,String zosFile,String pwd)
        {
                
                try
                {        
                        File f1 = new File(fileinput);
                        //采用和ZipShared一样的FileOutputStream
                        ZipOutputStream zos  = null;
                        zos = new ZipOutputStream(new FileOutputStream(zosFile+&quot;.zip&quot;));
                        ZipSharedCrypto(f1,zos,&quot;&quot;, pwd);
                        try
                        {
                                zos.close();
                        } catch (IOException e)
                        {
                                e.printStackTrace();
                        }
                } catch (FileNotFoundException e)
                {
                        System.out.println(&quot;未找到文件&quot;+e.getMessage());
                }
                System.out.println(&quot;success to create crypto &quot;+zosFile+&quot;.zip&quot;);
        }
        /**
         *          加密压缩文件夹     
         * @param fileinput     压缩文件夹的File对象
         * @param zos           zip压缩输出流ZipOutputStream
         * @param base          一般是&quot;&quot;
         * @param pwd           压缩的密码
         */
        public  void ZipSharedCrypto(File fileinput,ZipOutputStream zos,String base,String pwd)
        {
if(fileinput.isDirectory())
{
        System.out.println(&quot;你正在进入&quot;+fileinput+&quot;文件夹&quot;);
        File[] fApples = fileinput.listFiles();
        //因为ZipEntry的isDirectory()方法中，目录以&quot;/&quot;结尾
        try
        {        
                zos.putNextEntry(new ZipEntry(base+&quot;/&quot;));
                base = base.length()==0?&quot;&quot;:(base+&quot;/&quot;);
                //一种比较新型的方式循环读写东西。
                for(File ftemp:fApples)
                {
                        ZipSharedCrypto(ftemp,zos,base+ftemp.getName(),pwd);
                }
        }catch(IOException e)
        {
                System.out.println(&quot;文件夹加密压缩失败&quot;);
        }
}else
{        
        
        try
        {
                zos.putNextEntry(new ZipEntry(base));
                FileInputStream fis = new FileInputStream(fileinput);
                System.out.println(&quot;你正在开始加密压缩&quot;+fileinput+&quot;文件&quot;);
                //加密过程的开始
                PBEKeySpec keySpec = new PBEKeySpec(pwd.toCharArray());
                SecretKeyFactory keyFactory = null;
                try
                {
                        keyFactory = SecretKeyFactory.getInstance(ALGORITHM);
                } catch (NoSuchAlgorithmException e)
                {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                }
                SecretKey passwordKey = keyFactory.generateSecret(keySpec);
                //生成一个炸弹 进行加密
                byte[] bomb =  new byte[8];
                Random rnd = new Random();
                rnd.nextBytes(bomb);
                int iterations = 100;
                PBEParameterSpec parameterSpec = new PBEParameterSpec(bomb, iterations);
                Cipher cipher = null;
                try
                {
                        cipher = Cipher.getInstance(ALGORITHM);
                } catch (NoSuchAlgorithmException
                                | NoSuchPaddingException e)
                {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                }
                cipher.init(Cipher.ENCRYPT_MODE, passwordKey,parameterSpec);
                //往输出流 添加炸弹
                zos.write(bomb);
                
                //添加加密的主文件内容  1KB缓存区
                //byte[] inputBuffer = new byte[1024];
                //int bytesRead = 0;
                //如果没有读到信息则为-1
                
                //改用 readBytes  buf在类头定义的私有变量，进行统一的buffer缓存区大小的控制
                while((this.readBytes = fis.read(this.buf))!= -1)
                {
                        //每个缓冲区 进行加密写入
                        byte[] output = cipher.update(this.buf);
                        if(output != null)
                        {
                                zos.write(output);
                        }
                }
                
                //加密结束语-------------加密结束
                byte[] outputFinal =null;
                try
                {
                        outputFinal = cipher.doFinal();
                } catch (IllegalBlockSizeException | BadPaddingException e)
                {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                }
                if(outputFinal != null)
                {
                        zos.write(outputFinal);
                }        
        }catch(InvalidKeySpecException | InvalidKeyException | InvalidAlgorithmParameterException | IOException e)
        {
                System.out.println(&quot;加密失败&quot;);
        }
}
        }
        /**
         *   解压缩 zip文件，只能限制为zip ,rar无法进行，利用如鹏版的
         * @param zipName        待解压的zip文件
         * @param outputfolder   解压zip文件到outputFoler文件夹下
         */
        public void unzip(String zipName,String outputfolder)
        {
                File gtkDir = new File(outputfolder);// *.dll放的文件夹
                //指定的目录不存在  则创建之
                if (!gtkDir.exists())
                {
                        gtkDir.mkdirs();
                }
                InputStream inStream = null;
                try
                {
                        //不用输入.zip后缀，只需要输入文件名
                        inStream = new  FileInputStream(zipName+&quot;.zip&quot;);
                } catch (FileNotFoundException e1)
                {
                        // TODO Auto-generated catch block
                        e1.printStackTrace();
                }
                //InputStream inStream = Utils.class.getResourceAsStream(&quot;/gtkshare.zip&quot;);
                if (inStream == null)
                {
                        throw new UnsatisfiedLinkError(&quot;没找到&quot;+zipName);
                }
                try
                {                        
                        unzip(inStream, gtkDir.toString());
                        //System.out.println(gtkDir.toString());
                        System.out.println(&quot;成功解压缩&quot;+zipName+&quot;.zip&quot;+&quot;文件 到&quot;+outputfolder+&quot;文件夹下&quot;);
                } catch (IOException e)
                {
                        System.err.println(&quot;解压缩&quot;+zipName+&quot;.zip失败&quot; + toFullString(e));
                }
        }

        /**
         * 把streamToZip这个zip文件流解压到硬盘的destDir文件夹，支持多级目录
         * @param streamToZip
         * @param destDir
         * @throws IOException
         */
        public  void unzip(InputStream streamToZip,String destDir)throws IOException
        {  
                ZipInputStream zipStream = new ZipInputStream(streamToZip);
try
{
        ZipEntry zipEntry = null;
        //通过zipEntry方式支持多级目录
while((zipEntry=zipStream.getNextEntry())!=null)
{
        if(zipEntry.isDirectory())
        {
                System.out.println(&quot;你正在创建文件夹文件 比较特殊&quot;);
                File dir = new File(destDir,zipEntry.getName());
                //如果指定的目录不存在 则创建之
                if(!dir.exists())
                {
                        dir.mkdirs();
                }
        }
        else
        {
                FileOutputStream fileOutStream = new FileOutputStream(new File(destDir,zipEntry.getName()));
                try
                {
                        copy(zipStream, fileOutStream);
                }
                finally
                {
                        close(fileOutStream);
                }
                System.out.println(&quot;你正在解压缩压缩&quot;+zipEntry.getName());
        }
}
                }
                finally
                {
                        close(zipStream);
                }
                
    }
        /**
         *     从zip文件包中拷贝文件 ，按照0.5MB的缓冲写入文件(默认方式）
         * @param inStream       zipEntry的某个文件
         * @param outStream      输出的某个文件流
         * @throws IOException
         */
        public void copy(InputStream inStream, OutputStream outStream)
                        throws IOException
        {
                //byte[] buffer = new byte[512 * 1024];// 0.5MB 的缓冲区
                //int len;
                while ((this.readBytes = inStream.read(this.buf)) &gt;= 0)
                {
                        outStream.write(this.buf, 0, this.readBytes);
                }
        }
        /**
         *    摘自rupeng.gtk4j   不明白具体的作用    非主要问题
         * @param throwable
         * @return
         */
        public String toFullString(Throwable throwable)
        {
                StringWriter sw = null;
                PrintWriter pw = null;
                try
                {
                        sw = new StringWriter();
                        pw = new PrintWriter(sw);
                        throwable.printStackTrace(pw);
                        return sw.toString();
                } finally
                {
                        close(sw);
                        close(pw);
                }
        }
        /**
         *     让文件流安静的关闭
         * @param closeable   关闭接口
         */
        public void close(Closeable closeable)
        {
                if (closeable != null)
                {
                        try
                        {
                                closeable.close();
                        } catch (IOException e)
                        {

                        }
                }
        }
        
        // 加密解压缩

/**
         * 功能描述：将压缩文件解压到指定的文件目录下
         * @param zipFileName      压缩文件名称(带路径)
         * @param outputDirectory  指定解压目录
         * @return
         * @throws Exception
         */
        public  void unzipCrypto(String zipFileName, String outputDirectory, String pwd)
        {
                ZipInputStream inputStream;
                File outputDir;
                try
                {
                        //不用输入.zip后缀，只需要输入文件名
                        inputStream = new ZipInputStream(new FileInputStream(zipFileName+&quot;.zip&quot;));
                        outputDir = new File(outputDirectory);
                        unzipCrypto(inputStream, outputDir, pwd);
                } catch (Exception e)
                {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                }
                System.out.println(&quot;成功解压缩&quot;+zipFileName+&quot;.zip&quot;+&quot;文件 到&quot;+outputDirectory+&quot;文件夹下&quot;);
                
        }


        public void unzipCrypto(ZipInputStream inputStream, File outputDir, String pwd) throws Exception
        {
                ZipEntry zipEntry = null;
                FileOutputStream outputStream = null;
                try{
while ((zipEntry = inputStream.getNextEntry()) != null) 
{
        //如果是文件夹  则遍历
        if (zipEntry.isDirectory())
        {
                System.out.println(&quot;你正在进入&quot;+zipEntry.getName()+&quot;文件夹&quot;);
                String name = zipEntry.getName();
                name = name.substring(0, name.length() - 1);
                File file = new File(outputDir + File.separator + name);
                file.mkdir();
        } 
        //对单个普通文件进行处理
        else 
        {
                File file = new File(outputDir + File.separator + zipEntry.getName());
                file.createNewFile();
                outputStream = new FileOutputStream(file);
                System.out.println(&quot;你正在解压缩&quot;+file.getName()+&quot;文件&quot;);
                //解压加密过程的开始
                PBEKeySpec keySpec = new PBEKeySpec(pwd.toCharArray());
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(ALGORITHM);
            SecretKey passwordKey = keyFactory.generateSecret(keySpec);
            //准备排除加密的炸弹头
            byte[] apple = new byte[8];
            //在zip输入流添加read
            inputStream.read(apple);
            int iterations = 100;
            PBEParameterSpec parameterSpec = new PBEParameterSpec(apple, iterations);
            Cipher cipher = Cipher.getInstance(ALGORITHM);
            cipher.init(Cipher.DECRYPT_MODE, passwordKey, parameterSpec);
            //byte[] input = new byte[1024];
            //int bytesRead;
            //利用全局的私有变量this.buf  this.readBytes ,已在类开头定义，统一控制
            while ((this.readBytes = inputStream.read(this.buf)) != -1) 
            {
                    byte[] output = cipher.update(this.buf, 0, this.readBytes);
                    if (output != null)
                    {
                            outputStream.write(output);
                    }
            }
            byte[] output = cipher.doFinal();
            if (output != null)
            {
                    outputStream.write(output);
            }
                
        }
}
                }
                catch(IOException ex)
                {
                        throw new Exception(&quot;解压读取文件失败&quot;);
                }
                catch(Exception ex)
                {
                        throw new Exception(&quot;解压文件密码不正确&quot;);
                }
        }

}
/*
*  附录ant版本的压缩实现http://szhnet.iteye.com/blog/199059
*  可以加入某些文件和删除某些文件
*  package net.szh.zip;

import java.io.File;

import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.Zip;
import org.apache.tools.ant.types.FileSet;

public class ZipCompressorByAnt {

        private File zipFile;

        public ZipCompressorByAnt(String pathName) {
                zipFile = new File(pathName);
        }
        
        public void compress(String srcPathName) {
                File srcdir = new File(srcPathName);
                if (!srcdir.exists())
                        throw new RuntimeException(srcPathName + &quot;不存在！&quot;);
                
                Project prj = new Project();
                Zip zip = new Zip();
                zip.setProject(prj);
                zip.setDestFile(zipFile);
                FileSet fileSet = new FileSet();
                fileSet.setProject(prj);
                fileSet.setDir(srcdir);
                //fileSet.setIncludes(&quot;**//*.java&quot;); 包括哪些文件或文件夹 eg:zip.setIncludes(&quot;*.java&quot;);
                //fileSet.setExcludes(...); 排除哪些文件或文件夹
                zip.addFileset(fileSet);
                
                zip.execute();
        }
}

ant版本的使用：
package net.szh.zip;

public class TestZip {
        public static void main(String[] args) {                
                ZipCompressorByAnt zca = new ZipCompressorByAnt(&quot;E:\\szhzipant.zip&quot;);
                zca.compress(&quot;E:\\test&quot;);
        }
}
*  
*/
</code></pre>
    </div>
 <div class="nav-links" style="padding:10;">
        
        <div align="left">
        <a href="https://jueqingsizhe66.github.io/archives/fan-she-ji-zhi-nei-sheng-zheng-ze/"><span class="arrow">←</span> <strong>上一篇:反射机制内省正则</strong></a>
        </div>
        
        


       <div align="right"> <a href="https://jueqingsizhe66.github.io/archives/so-beautiful-code/" ><strong>下一篇:So beautiful code </strong><span class="arrow">→</span></a></div>
        
      </div>

    <div class="pagination__title">
      <span class="pagination__title-h">Related</span>
      <hr />
    </div>

    






  
  
  
  
  
  
  
  
  



    

    




<div class="article-tags">
  
  <a class="badge badge-light" href="/tag/javabasic/">JavaBasic</a>
  
</div>











  
  



  
  
  
    
  
  
  
  <div class="media author-card content-widget-hr">
    
      
      <a href="https://jueqingsizhe66.github.io/"><img class="avatar mr-3 avatar-circle" src="/author/%E5%8F%B6%E6%98%AD%E8%89%AF/avatar_huc99f1f2e739130747140db298bdd1890_46492_270x270_fill_q75_lanczos_center.jpg" alt="叶昭良"></a>
    

    <div class="media-body">
      <h5 class="card-title"><a href="https://jueqingsizhe66.github.io/">叶昭良</a></h5>
      <h6 class="card-subtitle">Engineer of offshore wind turbine technique research</h6>
      <p class="card-text">My research interests include distributed energy, wind turbine power generation technique , Computational fluid dynamic and programmable matter.</p>
      <ul class="network-icon" aria-hidden="true">
  
    
    
    
      
    
    
    
    
    
      
    
    <li>
      <a href="/#contact" >
        <i class="fas fa-envelope"></i>
      </a>
    </li>
  
    
    
    
      
    
    
    
    
    
      
    
    <li>
      <a href="https://twitter.com/jueqingsizhe66" target="_blank" rel="noopener">
        <i class="fab fa-twitter"></i>
      </a>
    </li>
  
    
    
    
    
    
    
    
      
    
    <li>
      <a href="https://scholar.google.com/citations?user=7VyEMyQAAAAJ&amp;hl=zh-CN" target="_blank" rel="noopener">
        <i class="ai ai-google-scholar"></i>
      </a>
    </li>
  
    
    
    
      
    
    
    
    
    
      
    
    <li>
      <a href="https://github.com/jueqingsizhe66" target="_blank" rel="noopener">
        <i class="fab fa-github"></i>
      </a>
    </li>
  
</ul>

    </div>
  </div>














         
         
         
         
         
         
   </div>

  </div>

</article>
<script src="https://utteranc.es/client.js"
        repo="jueqingsizhe66/jueqingsizhe66.github.io"
        issue-term="pathname"
        theme="github-dark"
        crossorigin="anonymous"
        async>
</script>
  </div>

  <div class="page-footer">
    
    
    <div class="container">
      <footer class="site-footer">
  

  <p class="powered-by">
    ©2022 &middot; 

    ^-^ Ye Zhaoliang ^-^ Powered by the
    <a href="https://sourcethemes.com/academic/" target="_blank" rel="noopener">Academic theme</a> for
    <a href="https://gohugo.io" target="_blank" rel="noopener">Hugo</a>.

    
    <span class="float-right" aria-hidden="true">
      <a href="#" class="back-to-top">
        <span class="button_icon">
          <i class="fas fa-chevron-up fa-2x"></i>
        </span>
      </a>
    </span>
    
  </p>
</footer>

    </div>
    
  </div>

      

    
    <script src="/js/vendor-bundle.min.9592335d574f7a97010f99b90ad0f310.js"></script>

    
    
    
      
      
        <script src="https://cdn.jsdelivr.net/gh/desandro/imagesloaded@v4.1.4/imagesloaded.pkgd.min.js" integrity="sha512-S5PZ9GxJZO16tT9r3WJp/Safn31eu8uWrzglMahDT4dsmgqWonRY9grk3j+3tfuPr9WJNsfooOR7Gi7HL5W2jw==" crossorigin="anonymous"></script>
        <script src="https://cdn.jsdelivr.net/gh/metafizzy/isotope@v3.0.6/dist/isotope.pkgd.min.js" integrity="sha512-Zq2BOxyhvnRFXu0+WE6ojpZLOU2jdnqbrM1hmVdGzyeCa1DgM3X5Q4A/Is9xA1IkbUeDd7755dNNI/PzSf2Pew==" crossorigin="anonymous"></script>
      

      
      

      
        <script src="https://cdn.jsdelivr.net/gh/mermaid-js/mermaid@v8.8.4/dist/mermaid.min.js" integrity="sha512-+TNmhaRJf3jyYHTpzEq/5I6b+aGyhzWb21mGdHAjxSGSYwxN9Grug3Y3B9qVxWfKKY8MscE/6mr9walWvFLFvQ==" crossorigin="anonymous" title="mermaid"></script>
      

      
        
        <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.2.1/build/highlight.min.js" integrity="sha512-Ypjm0o7jOxAd4hpdoppSEN0TQOC19UtPAqD+4s5AlXmUvbmmS/YMxYqAqarQYyxTnB6/rqip9qcxlNB/3U9Wdg==" crossorigin="anonymous"></script>
        
        
        <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.2.1/build/languages/r.min.js" crossorigin="anonymous"></script>
        
        <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.2.1/build/languages/latex.min.js" crossorigin="anonymous"></script>
        
        <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.2.1/build/languages/python.min.js" crossorigin="anonymous"></script>
        
        <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.2.1/build/languages/matlab.min.js" crossorigin="anonymous"></script>
        
        <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.2.1/build/languages/java.min.js" crossorigin="anonymous"></script>
        
        <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.2.1/build/languages/go.min.js" crossorigin="anonymous"></script>
        
        <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.2.1/build/languages/rust.min.js" crossorigin="anonymous"></script>
        
        <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.2.1/build/languages/c.min.js" crossorigin="anonymous"></script>
        
        <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.2.1/build/languages/perl.min.js" crossorigin="anonymous"></script>
        
        <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.2.1/build/languages/scheme.min.js" crossorigin="anonymous"></script>
        
        <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.2.1/build/languages/lisp.min.js" crossorigin="anonymous"></script>
        
        <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.2.1/build/languages/racket.min.js" crossorigin="anonymous"></script>
        
        <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.2.1/build/languages/awk.min.js" crossorigin="anonymous"></script>
        
        <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.2.1/build/languages/sed.min.js" crossorigin="anonymous"></script>
        
        <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.2.1/build/languages/bash.min.js" crossorigin="anonymous"></script>
        
        <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.2.1/build/languages/sql.min.js" crossorigin="anonymous"></script>
        
        <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.2.1/build/languages/vim.min.js" crossorigin="anonymous"></script>
        
        <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.2.1/build/languages/clojure.min.js" crossorigin="anonymous"></script>
        
      

    

    
    
    

    
    

    
    
    
      
      <script id="search-hit-fuse-template" type="text/x-template">
        <div class="search-hit" id="summary-{{key}}">
          <div class="search-hit-content">
            <div class="search-hit-name">
              <a href="{{relpermalink}}">{{title}}</a>
              <div class="article-metadata search-hit-type">{{type}}</div>
              <p class="search-hit-description">{{snippet}}</p>
            </div>
          </div>
        </div>
      </script>
      
        <script src="https://cdn.jsdelivr.net/gh/krisk/Fuse@v3.2.1/dist/fuse.min.js" integrity="sha512-o38bmzBGX+hD3JHWUFCDA09btWaqrNmoJ3RXLlrysA7PP01Kgs4UlE4MhelE1v5dJR3+cxlR4qQlotsW7jKsnw==" crossorigin="anonymous"></script>
        <script src="https://cdn.jsdelivr.net/gh/julmot/mark.js@8.11.1/dist/jquery.mark.min.js" integrity="sha512-mhbv5DqBMgrWL+32MmsDOt/OAvqr/cHimk6B8y/bx/xS88MVkYGPiVv2ixKVrkywF2qHplNRUvFsAHUdxZ3Krg==" crossorigin="anonymous"></script>
      
    

    
    

    
    
    
    

    
    
      
      
      
      
      
      
      
    

    

    
    
    
    <script id="page-data" type="application/json">{"use_headroom":true}</script>

    
    
      <script src="/js/wowchemy-headroom.c251366b4128fd5e6b046d4c97a62a51.js" type="module"></script>
    
    
    
    
    
    
    
      
      
    
    
    <script src="/en/js/wowchemy.min.d8ba8ef9e70daa8a4497ddcdfeccb171.js"></script>

    
    
    
    
    
    
      
<div id="modal" class="modal fade" role="dialog">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Cite</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body">
        <pre><code class="tex hljs"></code></pre>
      </div>
      <div class="modal-footer">
        <a class="btn btn-outline-primary my-1 js-copy-cite" href="#" target="_blank">
          <i class="fas fa-copy"></i> Copy
        </a>
        <a class="btn btn-outline-primary my-1 js-download-cite" href="#" target="_blank">
          <i class="fas fa-download"></i> Download
        </a>
        <div id="modal-error"></div>
      </div>
    </div>
  </div>
</div>

      <script src="/js/wowchemy-publication.b0d291ed6d27eacec233e6cf5204f99a.js" type="module"></script>
  <script async defer src="https://buttons.github.io/buttons.js"></script>




</body>
</html>
