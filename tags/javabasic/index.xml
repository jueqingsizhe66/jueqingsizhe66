<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>JavaBasic | Macro Life</title>
    <link>https://jueqingsizhe66.github.io/tags/javabasic/</link>
      <atom:link href="https://jueqingsizhe66.github.io/tags/javabasic/index.xml" rel="self" type="application/rss+xml" />
    <description>JavaBasic</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><copyright>©2019</copyright><lastBuildDate>Fri, 10 Feb 2017 00:04:33 +0800</lastBuildDate>
    <image>
      <url>https://jueqingsizhe66.github.io/img/icon-192.png</url>
      <title>JavaBasic</title>
      <link>https://jueqingsizhe66.github.io/tags/javabasic/</link>
    </image>
    
    <item>
      <title>java开发nexus私服搭建</title>
      <link>https://jueqingsizhe66.github.io/blog/2017/02/10/javakai-fa-nexussi-fu-da-jian/</link>
      <pubDate>Fri, 10 Feb 2017 00:04:33 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/blog/2017/02/10/javakai-fa-nexussi-fu-da-jian/</guid>
      <description>&lt;p&gt;针对一台全新的电脑，安装java开发的maven私服，记录如下，并在IDEA中进行测试。&lt;/p&gt;

&lt;p&gt;涉及到javase安装，maven安装，nexus私服安装，nexus本地配置，nexus界面介绍&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;安装JAVA jdk ,下载&lt;a href=&#34;http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html&#34; target=&#34;_blank&#34;&gt;javaSE安装包&lt;/a&gt;,注意JDK和JRE不要放在同一文件夹下&lt;/li&gt;
&lt;li&gt;配置JAVA_HOME为JDk目录，并添加JDK的bin目录(%JAVA_HOME%\bin)到path中
&lt;img src=&#34;https://jueqingsizhe66.github.io/images/java/nexus/java.png&#34; alt=&#34;java&#34; /&gt;&lt;/li&gt;
&lt;li&gt;下载&lt;a href=&#34;http://maven.apache.org/&#34; target=&#34;_blank&#34;&gt;maven&lt;/a&gt;,并解压缩，配置MAVEN_HOME为maven的根目录，并添加%MAVEN_HOME%\bin到path
中
&lt;img src=&#34;https://jueqingsizhe66.github.io/images/java/nexus/home.png&#34; alt=&#34;home&#34; /&gt;
&lt;img src=&#34;https://jueqingsizhe66.github.io/images/java/nexus/bin.png&#34; alt=&#34;bin&#34; /&gt;
&lt;img src=&#34;https://jueqingsizhe66.github.io/images/java/nexus/java.png&#34; alt=&#34;mvn&#34; /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;显示了&lt;code&gt;mvn -v&lt;/code&gt;,也就表示装完了maven
4. 下载&lt;a href=&#34;https://www.sonatype.com/download-oss-sonatype&#34; target=&#34;_blank&#34;&gt;nexus2.14&lt;/a&gt;,在windows下使用管理员身份打开cmd，并cd到nexus的bin目录，进行安装&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nexus install
nexus start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意一定得配置bin\jsw\wrapper.conf的java bin信息，否则出错。
&lt;img src=&#34;https://jueqingsizhe66.github.io/images/java/nexus/wrapper.png&#34; alt=&#34;wrapper&#34; /&gt;&lt;/p&gt;

&lt;p&gt;出现的错误为无法启动，
&lt;img src=&#34;https://jueqingsizhe66.github.io/images/java/nexus/success.png&#34; alt=&#34;success&#34; /&gt;&lt;/p&gt;

&lt;hr/&gt;

&lt;p&gt;做完前面的几步之后只是，把配置环境弄完了，还得进行私服镜像配置。
首先打开nexus私服页面，使用&lt;code&gt;http://localhost:8089/nexus/#welcome&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://jueqingsizhe66.github.io/images/java/nexus/nexus.png&#34; alt=&#34;nexus&#34; /&gt;&lt;/p&gt;

&lt;p&gt;默认的登陆密码是
    账号：admin
    密码：admin123&lt;/p&gt;

&lt;p&gt;登陆完的界面
&lt;img src=&#34;https://jueqingsizhe66.github.io/images/java/nexus/repositories.png&#34; alt=&#34;login&#34; /&gt;&lt;/p&gt;

&lt;p&gt;配置中心仓库:&lt;/p&gt;

&lt;p&gt;中心仓库设置download remote indexes为真，为设置本地私服提供源。
&lt;img src=&#34;https://jueqingsizhe66.github.io/images/java/nexus/central.png&#34; alt=&#34;central&#34; /&gt;&lt;/p&gt;

&lt;p&gt;配置了release和snapshot仓库
&lt;img src=&#34;https://jueqingsizhe66.github.io/images/java/nexus/release.png&#34; alt=&#34;release&#34; /&gt;
&lt;img src=&#34;https://jueqingsizhe66.github.io/images/java/nexus/snapshot.png&#34; alt=&#34;snapshot&#34; /&gt;&lt;/p&gt;

&lt;p&gt;然后配置了第三方插件
&lt;img src=&#34;https://jueqingsizhe66.github.io/images/java/nexus/third.png&#34; alt=&#34;third&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;进入最关键的public Repositories设置&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://jueqingsizhe66.github.io/images/java/nexus/public.png&#34; alt=&#34;public&#34; /&gt;&lt;/p&gt;

&lt;p&gt;有时候可以使用试用Scheduled Tasks观看库的index是否正常进行。
&lt;img src=&#34;https://jueqingsizhe66.github.io/images/java/nexus/schedule.png&#34; alt=&#34;scheduled&#34; /&gt;&lt;/p&gt;

&lt;hr/&gt;

&lt;h2 id=&#34;imp&#34;&gt;镜像私服配置&lt;/h2&gt;

&lt;p&gt;maven中的settings.xml登陆私服的账户密码设置
&lt;img src=&#34;https://jueqingsizhe66.github.io/images/java/nexus/user.png&#34; alt=&#34;user&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;servers&amp;gt;
    &amp;lt;server&amp;gt; 
        &amp;lt;id&amp;gt;nexus-release&amp;lt;/id&amp;gt;
        &amp;lt;username&amp;gt;admin&amp;lt;/username&amp;gt;
        &amp;lt;password&amp;gt;admin123&amp;lt;/password&amp;gt;
    &amp;lt;/server&amp;gt; 


    &amp;lt;server&amp;gt; 
        &amp;lt;id&amp;gt;nexus-snapshot&amp;lt;/id&amp;gt;
        &amp;lt;username&amp;gt;admin&amp;lt;/username&amp;gt;
        &amp;lt;password&amp;gt;admin123&amp;lt;/password&amp;gt;
    &amp;lt;/server&amp;gt; 


    &amp;lt;server&amp;gt; 
        &amp;lt;id&amp;gt;nexus&amp;lt;/id&amp;gt;
        &amp;lt;username&amp;gt;admin&amp;lt;/username&amp;gt;
        &amp;lt;password&amp;gt;admin123&amp;lt;/password&amp;gt;
    &amp;lt;/server&amp;gt; 
      &amp;lt;!-- server
     | Specifies the authentication information to use when connecting to a particular server, identified by
     | a unique name within the system (referred to by the &#39;id&#39; attribute below).
     |
     | NOTE: You should either specify username/password OR privateKey/passphrase, since these pairings are
     |       used together.
     |
    &amp;lt;server&amp;gt;
      &amp;lt;id&amp;gt;deploymentRepo&amp;lt;/id&amp;gt;
      &amp;lt;username&amp;gt;repouser&amp;lt;/username&amp;gt;
      &amp;lt;password&amp;gt;repopwd&amp;lt;/password&amp;gt;
    &amp;lt;/server&amp;gt;
    --&amp;gt;

    &amp;lt;!-- Another sample, using keys to authenticate.
    &amp;lt;server&amp;gt;
      &amp;lt;id&amp;gt;siteServer&amp;lt;/id&amp;gt;
      &amp;lt;privateKey&amp;gt;/path/to/private/key&amp;lt;/privateKey&amp;gt;
      &amp;lt;passphrase&amp;gt;optional; leave empty if not used.&amp;lt;/passphrase&amp;gt;
    &amp;lt;/server&amp;gt;
    --&amp;gt;
  &amp;lt;/servers&amp;gt;


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;镜像配置&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;注意url链接的端口设置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
&amp;lt;mirrors&amp;gt;
&amp;lt;mirror&amp;gt;
    &amp;lt;id&amp;gt;nexus&amp;lt;/id&amp;gt;
    &amp;lt;mirrorOf&amp;gt;*&amp;lt;/mirrorOf&amp;gt;
    &amp;lt;url&amp;gt;http://localhost:8089/nexus/content/groups/public/&amp;lt;/url&amp;gt;
&amp;lt;/mirror&amp;gt;
&amp;lt;/mirrors&amp;gt;
&amp;lt;profiles&amp;gt;
&amp;lt;profile&amp;gt;
    &amp;lt;id&amp;gt;nexus&amp;lt;/id&amp;gt;
&amp;lt;repositories&amp;gt;
    &amp;lt;repository&amp;gt;
        &amp;lt;id&amp;gt;central&amp;lt;/id&amp;gt;
        &amp;lt;url&amp;gt;http://central&amp;lt;/url&amp;gt;
        &amp;lt;releases&amp;gt;&amp;lt;enabled&amp;gt;true&amp;lt;/enabled&amp;gt;&amp;lt;/releases&amp;gt;
        &amp;lt;snapshots&amp;gt;&amp;lt;enabled&amp;gt;true&amp;lt;/enabled&amp;gt;&amp;lt;/snapshots&amp;gt;
    &amp;lt;/repository&amp;gt;
&amp;lt;/repositories&amp;gt;
&amp;lt;pluginRepositories&amp;gt;
    &amp;lt;pluginRepository&amp;gt;
        &amp;lt;id&amp;gt;central&amp;lt;/id&amp;gt;
        &amp;lt;url&amp;gt;http://central&amp;lt;/url&amp;gt;
        &amp;lt;releases&amp;gt;&amp;lt;enabled&amp;gt;true&amp;lt;/enabled&amp;gt;&amp;lt;/releases&amp;gt;
        &amp;lt;snapshots&amp;gt;&amp;lt;enabled&amp;gt;true&amp;lt;/enabled&amp;gt;&amp;lt;/snapshots&amp;gt;
    &amp;lt;/pluginRepository&amp;gt;
&amp;lt;/pluginRepositories&amp;gt;
&amp;lt;/profile&amp;gt;
&amp;lt;/profiles&amp;gt;
&amp;lt;activeProfiles&amp;gt;
    &amp;lt;activeProfile&amp;gt;nexus&amp;lt;/activeProfile&amp;gt;
&amp;lt;/activeProfiles&amp;gt;



&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在maven中一般是需要设置下载控件jar包放在哪里,在没有私服的情况下，我一般
可以在setting.xml中设置localRepository&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   | Default: ${user.home}/.m2/repository
  &amp;lt;localRepository&amp;gt;/path/to/local/repo&amp;lt;/localRepository&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然IDEA在导入项目或者新建项目的时候都会提醒Environment Variable,设置一下setting和local repository
(类似的思路需要在myeclipse配置)
&lt;img src=&#34;https://jueqingsizhe66.github.io/images/java/nexus/setting.png&#34; alt=&#34;impo&#34; /&gt;
而私服nexus的存放地点，在nexus界面的时候就已经设置好了，所以也得在每台电脑操作一遍(&lt;font color=&#34;red&#34;&gt;一定不能错&lt;/font&gt;)。&lt;/p&gt;

&lt;p&gt;镜像的话，就不会执行maven的&lt;code&gt;mvn install&lt;/code&gt;等命令还一直向外部仓库访问链接，结果是访问的链接
都是本地的，可看下节测试。&lt;/p&gt;

&lt;h2 id=&#34;ida&#34;&gt;IDEA测试镜像私服&lt;/h2&gt;
现在只能通过这个激活了，下载license server
![license][20]

测试结果如下:
`mvn site`

![idea][23]

```
INFO] artifact org.springframework:spring-beans: checking for updates from nexus
[INFO] artifact org.springframework:spring-context: checking for updates from nexus
[INFO] artifact org.springframework:spring-context-support: checking for updates from nexus
[INFO] artifact org.springframework:spring-core: checking for updates from nexus
[INFO] artifact org.springframework:spring-expression: checking for updates from nexus
[INFO] artifact org.springframework:spring-instrument: checking for updates from nexus
[INFO] artifact org.springframework:spring-instrument-tomcat: checking for updates from nexus
[INFO] artifact org.springframework:spring-jdbc: checking for updates from nexus
[INFO] artifact org.springframework:spring-jms: checking for updates from nexus
[INFO] artifact org.springframework:spring-orm: checking for updates from nexus
[INFO] artifact org.springframework:spring-oxm: checking for updates from nexus
```

&lt;h2 id=&#34;result&#34;&gt;结论&lt;/h2&gt;

&lt;p&gt;整个配置过程有效，测试通过，进一步可以参考&lt;a href=&#34;http://vdisk.weibo.com/s/za2TN71LdL1tl&#34; target=&#34;_blank&#34;&gt;maven实战 许晓斌&lt;/a&gt;,里面包含了maven的坐标空间概念等，详细介绍了
maven系统的各个组成和集成测试环境的搭建。&lt;/p&gt;

&lt;p&gt;可以拓展阅读&lt;a href=&#34;http://blog.csdn.net/c1481118216/article/category/6250182&#34; target=&#34;_blank&#34;&gt;java blog&lt;/a&gt;
三个有用工具包:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/venusdrogon/feilong-platform&#34; target=&#34;_blank&#34;&gt;飞龙 javase javaee(国产)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://feilong-core.mydoc.io/?t=149471&#34; target=&#34;_blank&#34;&gt;飞龙特别用心的手册&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/venusdrogon/feilong-core/wiki/install&#34; target=&#34;_blank&#34;&gt;可以玩玩feilong-platform平台的安装 以及mvn site产生好看的javadoc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/looly/hutool&#34; target=&#34;_blank&#34;&gt;Hutool javase(国产)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.hutool.cn/apidocs/&#34; target=&#34;_blank&#34;&gt;hutool API手册&lt;/a&gt;  &lt;a href=&#34;http://hutool.mydoc.io/&#34; target=&#34;_blank&#34;&gt;Hutool Wiki&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://ibeetl.com/guide/#beetl&#34; target=&#34;_blank&#34;&gt;闲大赋 beetl 好用的模板引擎(国产)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://cn.vuejs.org/&#34; target=&#34;_blank&#34;&gt;vue.js火热的前端js框架(国产)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>a little java note</title>
      <link>https://jueqingsizhe66.github.io/blog/2016/10/09/a-little-java-note/</link>
      <pubDate>Sun, 09 Oct 2016 01:58:39 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/blog/2016/10/09/a-little-java-note/</guid>
      <description>&lt;div align=&#34;center&#34;&gt;目录&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1&#34;&gt;1. 基础部分&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2&#34;&gt;2. 通过构造函数，构造出Natural recursion&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3&#34;&gt;3. 重新设计RemAV RemFishV RemIntV&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4&#34;&gt;4. 下一步把PieD的字段放入到对应的参数当中&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5&#34;&gt;5. 引入 this 关键字，指代访问者本身，同步修改对应的访问者类&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6&#34;&gt;6. 需要进一步提取出visitor部分的函数  &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#7&#34;&gt;7. 统一bTreeVisitorI itreevisitori ttreevisitori&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#8&#34;&gt;8. 重新设计RemAV RemFishV  RemIntV 为RemV(用Object替换）  &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#9&#34;&gt;9. 然后现在把Remv 和Subst重新放入PieD&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#10&#34;&gt;10. 紧接着 我们还想着把Remv  SubstV放入参数的位置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#11&#34;&gt;11. 紧接着我们可以进行下一步抽象   &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#12&#34;&gt;12. 紧接着我们发现rem和subst代码类似 &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#13&#34;&gt;13. 然后再实现Set集合类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#14&#34;&gt;14. SetEvalV直接继承IntEvalV不合理? &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#15&#34;&gt;15. IntEvalD 和SetEvalD很多相似之处 &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#16&#34;&gt;16. 根据extends使用Override增加函数的丰富性  &lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;视角没想到可以分成不同的classes，并在此基础上进行extends和implement，最终new通过constructors创造不同的value。两级在于基础元件和功能元件两部分。两级也可以分为extends和implements。集于一个class。&lt;/p&gt;

&lt;p&gt;学完&lt;a href=&#34;http://www.ccs.neu.edu/home/matthias/BALJ/&#34; target=&#34;_blank&#34;&gt;《a little java》&lt;/a&gt;的心得,&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;构造函数：new通过构造函数，产生了datatype的值；构造函数由此进行了natural recursion， 并通过一个基类退出循环（详见PieD).new create values.&lt;/li&gt;
&lt;li&gt;This,一般指向当前对象，但是在函数式编程中，this可能指代的是当前对象之后的所有剩余对象
&amp;ldquo;this&amp;rdquo;指代的是自指对象 也就是函数某某的实例化对象，并且是一直不变的。Just self-referential，because this is a RemV, and it is exactly what we need to complete the job. 所以this指代函数莫某的对象&lt;/li&gt;
&lt;li&gt;Top某某函数询问某种来自函数某某的forTop功能 ，并传递构造函数的fields值(properties）以及该某某函数comsumes的objects（arguments)&lt;/li&gt;
&lt;li&gt;升级版本 the method accepts a visitor(该visitor接口包含了forTop forBot抽象方法，该接口统一了不同的函数某某，所以所有函数某某统称为accept函数某某）and ask for its services， so we call it accept， 而该接口的通常实例化对象也被叫做ask， ask for services.&lt;/li&gt;
&lt;li&gt;Object类型可以抽象int boolean 其他类型&lt;/li&gt;
&lt;li&gt;函数的抽象大体表现为参数数据类型，返回值数据类型和函数body的具体实现。
a.  参数数据类型
b.  返回值数据类型
c.  body具体实现&lt;/li&gt;
&lt;li&gt;简化（简洁）、拓展性、方便&lt;/li&gt;
&lt;li&gt;当我们的参数值从method变到fields，我们就没必要在反复调用对象的方法的时候 需要不断地comsume，而同时又保证了this对象，也就是不断地自指（期间不产生新的fields）所以也就是使得计算加快了。这也是this存在的原因（并且该this对象只用在访问者对象中）&lt;/li&gt;
&lt;li&gt;We know that a visitorI contains one method each for the Circle, Square, and Trans variants,. And each of these methods
Consumes the fields of the respective kinds of objects(objects of types)
某某对象的某某函数，（携带函数某某和字段） 询问函数某某的for对象某某功能，（携带对象某某）
某某对象的accept携带ask并内部由 ask 的for对象某某携带对象某某组成，而for对象某某携带对象某某并内部由对象某某的accept携带当前ask对象构成。
某某对象的accept携带ask并内部由 ask 的for对象某某组成，而for对象某某携带对象某某并内部由对象某某的accept组成。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在对象内部，某某对象的accept携带ask并内部由 ask 的for对象某某携带对象某某组成，而在visitor内部，for对象某某携带对象某某并内部由对象某某（也就是consumes the fields of the respective kinds of objects 占据对象类型的字段属性）的accept携带当前ask对象构成。
We don&amp;rsquo;t specify fields in interfaces. And in 7 W hatever.
any case, we don&amp;rsquo;t want anybody else to
see p.
This and that在对象间传递，而consume在函数间传递（Hangs over back and forth(fields 在对象间传递，而consume在函数间传递)
10. 该书包含着TLS TSS 和prolog编程的思想(因为你要理解new Top new Bot等需要有fact and rule的意识)（仔细去品尝 go to absorb) 还有就是skeleton and techniques技术
11. Extends interface,this extension produces an interface that contains all the obligations(i.e. names of methods and what they consume and produce) of shapeVisitorI and the additional one named forUnion(所以换个角度说，one class can implement many interfaces.
12. 重载override 相同的名字带着不同的输入类型
13. 点号可以读作 from   点号之前叫做from who  点号之后叫做service
14. 解释的重点是什么？？？ 要点是什么&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://jueqingsizhe66.github.io/images/alittlejava/duichen.png&#34; alt=&#34;duichen&#34; /&gt;&lt;/p&gt;

&lt;p&gt;什么是思考力的三要素，讲这个问题之前我们先来了解一下什么是思考思维，首先思考是思维的一种探索活动，而在思维过程中产生的一种具有积极性和创造性的作用力这种就是思考力。据物理学理解，思考力具有三个基本要素：分别为大小、方向、作用点。思考力同样也离不开三个基本要素：分别为大小、方向、作用点。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;大小 ——思考力首先取决于思考者掌握的关于思考对象的知识和信息量（大小），如果没有相关的知识和信息，就不可能产生相关的思考活动。一般情况下，知识量和信息量越大，思考就越加具体、全面和完整，从而决定了思考的维度。&lt;/li&gt;
&lt;li&gt;方向 ——我们这里所说的思考有别于妄想和幻想，而是一种有目的性和有计划性的思维活动，因此，这种思考需要有一定的价值导向，也就是思路——体现为目的性、方向性和一致性。漫无目的地思考难以发挥强有力的思考力，常常会把思考引进死胡同，导致思路夭折和无果而终。目的性、方向性、一致性和价值导向，决定着思考的角度和向度。&lt;/li&gt;
&lt;li&gt;作用点 ——必须把思考集中在特定的对象上，并把握其中的关键点，这样的思考就会势如破竹。如果找不准思考的着力点，就会精力分散、思维紊乱、胡思乱想，出现东一榔头西一棒的现象。思考就会停留在事物的表面上浮光掠影，无法深刻认识事物的本质。思考在作用点上的集中性程度，决定着思考的强度和力度(广度和深度）。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;1&#34;&gt;基础部分&lt;/h3&gt;

&lt;p&gt;理解分层。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;KebabD(chapter2) 烤肉
    isVeggie();
    whatHolder();
        Holder 烤肉摆放工具
            Object;
            Holder(Object);
            isVeggie();
            whatHolder();
        Shallot  葱
            KebabD;
            Shallot(KebabD);
            isVeggie();
            whatHolder();
         
        Shrimp 虾
            KebabD;
            Shrimp (KebabD);
            isVeggie();
            whatHolder();
             
        Radish 萝卜
            KebabD;
            Radish (KebabD);
            isVeggie();
            whatHolder();
         
        Pepper 胡椒粉
            KebabD;
            Pepper (KebabD);
            isVeggie();
            whatHolder();
             
        Zucchini 西葫芦
            KebabD;
            Zucchini (KebabD);
            isVeggie();
            whatHolder();
         
 
RodD(chapter2) 杆  将烤肉串起来工具(烤肉摆放方式1）
    Dagger 匕首
    Sabre 军刀
    Sword 剑
     
PlateD(chapter2) 盘子  （烤肉摆放方式2)
    Gold 金盘子
    Silver
    Brass 黄铜盘子
    Copper 镀铜盘子
    Wood   木盘子
 
PointD(chapter1,2) 点
    distanceTo0(int,int); //可以把它们移入到构造函数中
    closerTo0();
        CartesianPt 笛卡尔坐标
            Int
            Int
            CartesianPt(int,int);
            distanceTo0();
            Closeto0();
        ManhattenPt 曼哈顿坐标
            Int
            Int
            ManhattenPt(int,int);
            distanceTo0();
            Closeto0();
         
        圆柱坐标系
        球坐标系
 
PieD
 
 
PizzaD（chapter3,4）
    remA 去除比萨饼的凤尾鱼订料（防止过咸）
    topAwC() 在凤尾鱼顶料加上奶酪顶料（盖住咸味）
    subAbC() 将所有的凤尾鱼顶料换成奶酪顶料
        Crust 面包皮
            remA();
            topAwC();
            subAbC();
        Cheese  奶酪
            pizzaD
            Cheese(PizzaD)
            remA();
            topAwC();
            subAbC();
         
        Olive   橄榄
            pizzaD
            Olive(PizzaD)
            remA();
            topAwC();
            subAbC();
             
        Anchovy 凤尾鱼
            pizzaD
            Anchovy(PizzaD)
            remA();
            topAwC();
            subAbC();
             
        Sausage 香肠
            pizzaD
            Sausage(PizzaD)
            remA();
            topAwC();
            subAbC();
        Spinach 菠菜
            pizzaD
            Spinach(PizzaD)
            remA();
            topAwC();
            subAbC();
         
 
 
 
Shape
 
Shish(chapter2，4) 羊肉串
    onlyOnions(); 
    isVegetarian();
        Skew 架子 烤肉叉子
        Onion 洋葱
        Lamb  羔羊肉
        Tomato 西红柿
         
 
Tree


SeasoningD (chapter1) 调味品
    Sage(鼠尾草)
    Pepper
    Salt
    Thyme(百里香)
 
NumD (chapter1)
    Zero
    OneMoreThan
 
LayerD
    Base
    Slice
 
FruitD

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;第二条建议&lt;/strong&gt;
    When writing a function over a datatype,
    place a method in each of the variants that make up the datatype.
    If a field of a variant belongs to the same datatype,
    the method may call the corresponding method of the field in
    computing the function.（疑问子类 每继承一次父类 都得重写三个父类的抽象函数 有点费事。。 &amp;mdash;-那么访问者模式到底是如何解决的？）
&lt;strong&gt;第八条建议&lt;/strong&gt;
    When extending a class, use overriding
    to enrich its functionality.&lt;/p&gt;

&lt;p&gt;根据以上建议， LtdSubstV 可以直接在 SubstV 类上进行继承和扩展。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Shish(chapter2，4) 羊肉串
   OnlyOnionsV
   IsVegetarianV
   onlyOnions(); 
   isVegetarian();
        Skew 架子 烤肉叉子
            onlyOnions();
            isVegetarian();
        Onion 洋葱
            ShishD
            Onion(ShishD);
            onlyOnions();
            isVegetarian();
        Lamb  羔羊肉
            ShishD
            Lamb(ShishD);
            onlyOnions();
            isVegetarian();
             
        Tomato 西红柿
            ShishD
            Tomato(ShishD);
            onlyOnions();
            isVegetarian();


OnlyOnionsV 
    forSkew();
    forOnion(ShishD);
    forLamb(ShishD);
    forTomato(ShishD);
 
isVegetatianV
    forSkew();
    forOnion(ShishD);
    forLamb(ShishD);
    forTomato(ShishD);
     
 
ShishD
   OnlyOionsV ooFn
   IsVegeterian ivFn
   onlyOnions()a;
   isVegetarian()a;
        Skew
            onlyOnions();
            isVegetarian();
        Onion
            onlyOnions();
            isVegetarian();
        Lamb
            onlyOnions();
            isVegetarian();
        Tomato
            onlyOnions();
            isVegetarian();
         
 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2&#34;&gt;通过构造函数，构造出Natural recursion部分，形成递归，递归出口为skew&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;RemAV
    forCurst();
    forCheese(PizzaD);
    forOlive(PizzaD);
    forAnchovy(PizzaD);
    forSausage(PizzaD);

TopAwCV
    forCurst();
    forCheese(PizzaD);
    forOlive(PizzaD);
    forAnchovy(PizzaD);
    forSausage(PizzaD);

SubAbCV
    forCurst();
    forCheese(PizzaD);
    forOlive(PizzaD);
    forAnchovy(PizzaD);
    forSausage(PizzaD);
 
 
PizzaD 
   RemAV remFn
   TopAwCV topFn
   SubAbCV  subFn
   remA()a;
   topAwC()a;
   subAbC()a;
        Crust
            remA();
            topAwC();
            subAwC();
        Cheese
            PizzaD
            Cheese(PizzaD)
            remA();
            topAwC();
            subAwC();
        Olive
            PizzaD
            Olive(PizzaD)
            remA();
            topAwC();
            subAwC();
        Anchovy
            PizzaD
            Anchovy(PizzaD)
            remA();
            topAwC();
            subAwC();
        Sausage
            PizzaD
            Sausage(PizzaD
            remA();
            topAwC();
            subAwC();


PieD
    RemAV raFn
    RemFish rfFn
    remA()a;
    remFish(FishD)a;
        Bot
            remA();
            remFish(FishD);
        Top
            Object
            PieD
            Top(Object, PieD)
            remA();
            remFish(FishD);
             
FishD
    Salmon 鲑鱼
    Equals(Object);
    Anchovy 凤尾鱼
    Equals(Object);
    Tuna  金枪鱼
    Equals(Object);
 
RemAV
    forBot
    fotTop(Object, PieD)
RemFishV
    forBot(FishD)
    forTop(Object, PieD,  FishD)
 
RemIntV
    forBot(int)
    forTop(Object, pieD, Integer)
     
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3&#34;&gt;重新设计RemAV RemFishV  RemIntV 为RemV(用Object替换）&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;RemV
    forBot(Object)
    forTop(Object, pieD, Object)

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;4&#34;&gt;下一步把PieD的字段放入到对应的参数当中&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
abstract class PieD {
    abstract PieD rem(RemV remFn, Object o);
    abstract PieD subst(SubstV substFn, Object n, Object o);
}
 
PieD 
    Rem()a;
    Subst()a;
        Top
            Top(Object,Object)
            Rem();
            Subst();
        Bot
            Bot(Object,Object)
            Rem();
            Subst();

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;5&#34;&gt;引入 this 关键字，指代访问者本身，同步修改对应的访问者类。&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;PieD 
    Rem(Remv)a;
    Subst(Subst)a;
        Top
            Top
            Rem
            Subst
        Bot
            Bot
            Rem
            Subst

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;6&#34;&gt;需要进一步提取出visitor部分的函数&lt;/h3&gt;
 

&lt;p&gt;这样就可以把所有&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;PieVisitorI 
    forBot();
    forTop();
        Remv
            forBot();
            forTop();
        SubstV
            forBot();
            forTop();
     
pieD
    Accept(PieVisitorI)
        Bot
            Accept(pieVisitorI);
        Top
            Accept(pieVisitorI);
 
 
 
 
FruitD
    Peach
    Apple
    Pear
    Lemon
    Fig 无花果
 
TreeD
    Accept(bTreeVisitorI)
    Accept(iTreeVisitorI)
    Accept(tTreeVisitorI)
        Bub 芽
            Accept(bTreeVisitorI)
            Accept(iTreeVisitorI)
            Accept(tTreeVisitorI)
        Flat 平顶
            FruitD
            TreeD
            Flat(FruitD, TreeD)
            Accept(bTreeVisitorI)
            Accept(iTreeVisitorI)
            Accept(tTreeVisitorI)
        Split 分枝
            TreeD
            TreeD
            Split(TreeD, TreeD)
            Accept(bTreeVisitorI)
            Accept(iTreeVisitorI)
            Accept(tTreeVisitorI)
 
bTreeVisitorI
    forBud();
    forFlat(FruitD, TreeD);
    forSplit(TreeD, TreeD);
        bIsFlatV implements bTreeVisitorI
            forBud();
            forFlat(FruitD, TreeD);
            forSplit(TreeD, TreeD);
        bIsSplitV implements bTreeVisitorI
            forBud();
            forFlat(FruitD, TreeD);
            forSplit(TreeD, TreeD);
        bHasFruitV implements bTreeVisitorI
            forBud();
            forFlat(FruitD, TreeD);
            forSplit(TreeD, TreeD);

 
iTreeVisitorI
    forBud();
    forFlat(FruitD, TreeD);
    forSplit(TreeD, TreeD);
        iHeightV implements iTreeVisitorI
            forBud();
            forFlat(FruitD, TreeD);
            forSplit(TreeD, TreeD);
        iOccursV implements iTreeVisitorI
            FruitD
            iOccursV(FruitD)
            forBud();
            forFlat(FruitD, TreeD);
            forSplit(TreeD, TreeD);

       
 
tTreeVisitorI
    forBud();
    forFlat(FruitD, TreeD);
    forSplit(TreeD, TreeD);
        tSubstV implements tTreeVisitorI
            FruitD
            FruitD
            tSubstV(FruitD, FruitD)
            forBud();
            forFlat(FruitD, TreeD);
            forSplit(TreeD, TreeD);
         iOccursV implements tTreeVisitorI
            forBud();
            forFlat(FruitD, TreeD);
            forSplit(TreeD, TreeD);
  
 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;7&#34;&gt;为了统一bTreeVisitorI 和 iTreeVisitorI   tTreeVisitorI&lt;/h3&gt;
（三个的不同就在于返回值分别为 boolean   int   treeD)

``` java
TreeVisitorI
    forBud();
    forFlat(FruitD, TreeD);
    forSplit(TreeD, TreeD);
         IsFlatV implements TreeVisitorI
            forBud();
            forFlat(FruitD, TreeD)
            forSplit(TreeD, TreeD)
         
         
        OccursV implements TreeVisitorI
            FruitD
            OccursV(FruitD)
            forBud();
            forFlat(FruitD, TreeD)
            forSplit(TreeD, TreeD)
         
         
        class OccursV implements TreeVisitorI {
            FruitD a;
            OccursV(FruitD _a) {
                a = _a;
            }
            public Object forBud() {
                return new Integer(0);
            }
            public Object forFlat(FruitD f, TreeD t) {
                if (f.equals(a))
                    return new Integer(((Integer)(t.accept(this))).intValue() + 1);
                else
                    return t.accept(this);
            }
            public int forSplit(TreeD l, TreeD r) {
                return new Integer(((Integer)(l.accept(this))).intValue()
                                   +
                                   ((Integer)(r.accept(this))).intValue());
            }
        }


TreeD
    Accept(TreeVisitorI)
        Bub 芽
            Accept(TreeVisitorI)
        Flat 平顶
            FruitD
            TreeD
            Flat(FruitD, TreeD)
            Accept(TreeVisitorI)
        Split 分枝
            TreeD
            TreeD
            Split(TreeD, TreeD)
            Accept(tTreeVisitorI)
         


PieD
    RemAV raFn
    RemFish rfFn
    remA()a;
    remFish(FishD)a;
        Bot
            remA();
            remFish(FishD);
        Top
            Object
            PieD
            Top(Object, PieD)
            remA();
            remFish(FishD);
 
FishD
    Salmon 鲑鱼
    Equals(Object);
    Anchovy 凤尾鱼
    Equals(Object);
    Tuna  金枪鱼
    Equals(Object);
 
RemAV
    forBot
    fotTop(Object, PieD)
RemFishV
    forBot(FishD)
    forTop(Object, PieD,  FishD)
     
RemIntV
    forBot(int)
    forTop(Object, pieD, Integer)
     
```
 
&lt;h3 id=&#34;8&#34;&gt;重新设计RemAV RemFishV  RemIntV 为RemV(用Object替换）&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;RemV
    forBot(Object)
    forTop(Object, pieD, Object)
PieD
    RemV
    Rem(Object)
        Bot
            Rem(Object)
        Top
            Object
            PieD
            Top(Object, PieD)
            Rem(Object)
 
SubstFishV
    forBot(FishD, FishD)
    forTop(Object , PieD, FishD, FishO)
 
SubstIntV
    forBot(Int, Int)
    forTop(Object , PieD, Int, Int)
 
SubstV
    forBot(Object, Object)
    forTop(Object , PieD, Object, Object)
     
 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;9&#34;&gt;然后现在把Remv 和Subst重新放入PieD&lt;/h3&gt;
 

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;PieD
    Remv
    SubstV
    Rem(Object)
    Subst(Object, Object)
        Bot
            Rem(Object)
            Subst(Object,Object)
        Top
            Object
            PieD
            Top(Object,PieD)
            Rem(Object)
            Subst(Object,Object)
 

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;9&#34;&gt;紧接着 我们还想着把Remv  SubstV放入参数的位置&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;PieD
    Rem(Remv,Object)
    Subst(SubstV,Object, Object)
        Bot
            Rem(Renv,Object)
            Subst(Substv,Object,Object)
        Top
            Object
            PieD
            Top(Object,PieD)
            Rem(RemV,Object)
            Subst(Substv,Object,Object)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;10&#34;&gt;紧接着我们进一步比较RemV SubstV的实现(我们就得重新修改rem和subst了)&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
class RemV {
    Object o;
    RemV(Object _o) {
        o = _o;
    }
    PieD forBot(Object o){
        return new Bot();
    }
    PieD forTop(Object t, PieD r){
        if (o.equals(t))
            return r.rem(this);
        else
            return new Top(t, r.rem(this));
    }


class RemV {
    PieD forBot(Object o) {
        return new Bot();
    }
    PieD forTop(Object t, PieD r, Object o) {
        if (o.equals(t))
            return r.rem(o);
        else
            return new Top(t, r.rem(o));
    }
}

class SubstV {
    PieD forBot(Object n, Object o) {
        return new Bot();
    }
    PieD forTop (Object t, PieD r, Object n, Object o) {
        if (o.equals(t))
            return new Top(n, r.subst(n, o));
        else
            return new Top(t, r.subst(n, 0));
    }
}
class SubstV {
    Object n;
    Object o;
    SubstV(Object _n, Object _o){
        n = _n;
        o = _o;
    }
    PieD forBot(Object n, Object o){
            return new Bot();
        }
    PieD forTop(Object t, PieD r){
        if (o.equals(t))
            return new Top(n, r.subst(this));
        else
            return new Top(t, r.subst(this));
    }
}

 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;11&#34;&gt;紧接着我们可以进行下一步抽象&lt;/h3&gt;
 

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;PieD
    Rem(RemV)
    Subst(SubstV)
        Top
            Object
            PieD
            Top(Object, PieD)
            Rem(RemV)
            Subst(SubstV)
        Bot
            Object
            PieD
            Bot(Object, PieD)
            Rem(RemV)
            Subst(SubstV)
 
 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;12&#34;&gt;紧接着我们发现rem和subst代码类似&lt;/h3&gt;
 

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;PieVisitorI
    forBot
    forTop
        RemV implement PieVisitorI
            Object
            RemV(Object)
            forBot();
            forTop(Object,PieD）
        SubstV implement PieVisitorI
            Object
            Object
            SubstV(Object, Object)
            forBot();
            forTop(Object,PieD）
        LtdSubstV implement PieVisitorI
            int
            Object
            Object
            LtdSubstV(int, Object, Object)
            forBot();
            forTop(Object,PieD）
         
PieD
    Accept(PieVisitorI)
        Bob
            Accept(pieVisitorI)
        Top
            Object
            PieD
            Top(Object,PieD)
            Accept(PieVisitorI)
 


ExprVisitorI

ExprVisitorI
    forPlus(ExprD, ExprD);
    forDiff(ExprD, ExprD);
    forProd(ExprD, ExprD);
    forConst(ExprD, ExprD);
        IntEvalV implements  ExprVisitorI
            forPlus(ExprD, ExprD);
            forDiff(ExprD, ExprD);
            forProd(ExprD, ExprD);
            forConst(Object);
            Plus(Object, Object)
            Diff(Object, Object)
            Prod(Object, Object)
 

ExprD
    Accept(ExprVisitorI);
        Plus
            ExprD
            ExprD
            Plus(ExprD, ExprD);
            Accept(ExprVisitorI);
        Diff
            ExprD
            ExprD
            Diff(ExprD, ExprD);
            Accept(ExprVisitorI);
        Prod
            ExprD
            ExprD
            Prod(ExprD, ExprD);
            Accept(ExprVisitorI);
        ConstD
            Object
            ConstD(Object);
            Accept(ExprVisitorI);
 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;13&#34;&gt;然后再实现Set集合的类型&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;SetD 
    Add(integer i);
    Mem(integer i);
    Plus(SetD);
    Diff(SetD);
    Prod(SetD);
        Empty
            Mem(integer i);
            Plus(SetD);
            Diff(SetD);
            Prod(SetD);
         
        Add
            Integer;
            SetD;
            Add(Integer, Integer)
            Mem(integer i);
            Plus(SetD);
            Diff(SetD);
            Prod(SetD);
 
ExprVisitorI
    forPlus(ExprD, ExprD);
    forDiff(ExprD, ExprD);
    forProd(ExprD, ExprD);
    forConst(ExprD, ExprD);
        IntEvalV implements  ExprVisitorI
            forPlus(ExprD, ExprD);
            forDiff(ExprD, ExprD);
            forProd(ExprD, ExprD);
            forConst(Object);
            Plus(Object, Object)
            Diff(Object, Object)
            Prod(Object, Object)
                SetEvalV implements IntEvalV
                    Plus(Object, Object)
                    Diff(Object, Object)
                    Prod(Object, Object)
                 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;14&#34;&gt;SetEvalV 直接集成IntEvalV不合理？&lt;/h3&gt;

&lt;p&gt;从SetEvalV 和IntEvalV抽取出一个基类&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;EvalD implements ExprVisitorI
    forPlus(ExprD, ExprD);
    forDiff(ExprD, ExprD);
    forProd(ExprD, ExprD);
    forConst(ExprD, ExprD);
    Plus(Object, Object)
    Diff(Object, Object)
    Prod(Object, Object)
        IntEvalD
            Plus(Object, 	Object)
            Diff(Object, Object)
            Prod(Object, Object)
            SetEvalD
            Plus(Object, Object)
            Diff(Object, Object)
            Prod(Object, Object)
         
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;15&#34;&gt;IntEvalD 和SetEvalD很多相似之处&lt;/h3&gt;
于是我们进一步提取

``` java
SubstD implements pieVisitorI
    Object
    Object
    SubstD(Object, Object)
    forBot();
    forTop(Object,PieD)
SubstV
    SubstV(Object, Object)
    forTop(Object, Object)
LtdSubstV
    int
    LtdSubstV(int,Object, Object)
    forTop(Object, Object)
``` 
 
 
&lt;h3 id=&#34;16&#34;&gt;根据extends使用override增加函数的丰富性&lt;/h3&gt;
 

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;SubstV implements PieVisitorI
    Object
    Object
    SubstV(Object, Object)
    forBot()
    forTop(Object, PieD)
 
LtdSubstV
    Int
    Object
    Object
    LtdSubstV(int, Object, Object)
    forTop(Object, PieD)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;原来，抽象类可以有构造方法.抽象类只要有一个abstract函数就可以叫做抽象类
抽象类可以有构造方法，构造方法不可继承，但是可以供子类用super（）或者super（参数，参数。。。。）调用。
构造函数是对象的基本，没有构造函数就没有对象。
若果在父类中（这里就是你的抽象类）中显示的写了又参数的构造函数，在子类继承是就必须写一个构造函数来调用父类的构造函数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;PointD
PointD(chapter1,2) 点
    distanceTo0(int,int); //可以把它们移入到构造函数中
    closerTo0();
    PointD minus(PointD)
    int moveBy(int ,int)
        CartesianPt 笛卡尔坐标
            Int
            Int
            CartesianPt(int,int);
            distanceTo0();
            Closeto0();
        ManhattenPt 曼哈顿坐标
            Int
            Int
            ManhattenPt(int,int);
            distanceTo0();
            Closeto0();
        圆柱坐标系
        球坐标系



ShadowedCartesia 
    Int
    Int
    ShadowedCartesia(int, int, int, int)
    distanceTo0()
 
shapeVisitorI
    forCircle(int)
    forSquare(int)
    forTrans(pointD, ShapeD)
    UnionVisitorI
    forUnion(ShapeD, ShapeD)
        HasPtV implements ShapeVisitorI
            PointD
            HasPt(PointD)
            forCircle(int)
            forSquare(int)
            forTrans(PointD, ShapeD)
        UnionHasPtV implements ShapeVisitorI
            UnionHasPtV(PointD)
            forUnion(ShapeD, ShapeD)
            return s.accept(new HasPtV(p.minus(q)));
        HasPtV implements ShapeVisitorI
            PointD
            HasPt(PointD)
            ShapeVisitorI newHasPt(PointD)
            forCircle(int)
            forSquare(int)
            forTrans(PointD, ShapeD)
        UnionHasPtV implements unionVisitorI
            UnionHasPtV(PointD)
            ShapeVisitorI newHasPt(PointD)_o
            forUnion(ShapeD, ShapeD)
            return s.accept(newHasPtV(p.minus(q)));
 
 
ShapeD
    Accept(ShapeVisitorI)
        Circle
            Int
            Circle(int)
            Accept(ShapeVisitorI)_o
        Square
            Int
            Square(int)
            Accept(ShapeVisitorI)_o
        Trans
            PointD
            ShapeD
            Trans(int)
            Accept(ShapeVisitorI)_o
        Union
            ShapeD
            ShapeD
            Union(ShapeD, ShapeD)
            Accetp(ShapeVisitorI)_o
         
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;16&#34;&gt;newHasPt和HasPtV are eta reduction&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;PieManI
    Int addTop(Object)
    Int remTop(Object)
    Int substTop(Object,Object)
    Int occTop(Object)
 
PieManM implements PieManI
    PieD
    addTop(Object) _o
    remTop(Object)_o
    substTop(Object,Object)_o
    occTop(Object)
 
 
PieVisitorI
    forBot();
    forTop(Object, Object)
        OccursV
            Object
            OccursV(Object)
            forBot()_o
            forTop(Object,PieD)_o
        SubstV
            Object
            Object
            SubstV(Object, Object)
            forBot();
            forTop(Object,PieD)_o
        RemV
            Object
            RemV(Object)
            forBot(Object)
            forTop(Object,PieD)
     
 
PieD
    Accept(PieVisitorI)
        Bot
            Accept(PieVisitorI)_o
        Top
            Object
            PieD
            Top(Object, PieD)
            Accept(PieVisitorI)_o
 
PieVisitorI
    forBot(Bot)
    foTop(Top)
        OccursV
            Object
            OccursV(Object)
            forBot(Bot that)
            forTop(Top that)
        SubstV
            Object
            Object
            SubstV(Object,Object)
            forBot(Bot that)
            forTop(Top That)
        RemV
            Object
            RemV(Object)
            forBot(Bot that)
            fotTop(Top that)
 
PieD
    Accept(PieVisitorI)
        Bot
            Accept(PieVisitorI)_o
        Top
            Object
            Object
            Top(Object, Objct)
            Accept(PieVisitor)_o
 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;每天你只能不断去思考 事情的要点和第一步和第二步 才能取得进步.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;What’s the point of the visitor pattern? What’s the point of the software design?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;亮点&lt;/li&gt;
&lt;li&gt;突破点，并按照一定的方向。。&lt;/li&gt;
&lt;li&gt;关键点&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://jueqingsizhe66.github.io/images/alittlejava/closure.png&#34; alt=&#34;closure&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Closure(Closure(this))&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;具体java源代码参考&lt;a href=&#34;https://github.com/jueqingsizhe66/ALittleJava&#34; target=&#34;_blank&#34;&gt;the little java&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>java小结</title>
      <link>https://jueqingsizhe66.github.io/blog/2016/07/19/javaxiao-jie/</link>
      <pubDate>Tue, 19 Jul 2016 18:42:25 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/blog/2016/07/19/javaxiao-jie/</guid>
      <description>&lt;p&gt;很长没有做java小结，把最近浏览的几个链接添上去。&lt;/p&gt;

&lt;p&gt;java小结&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/JpressProjects/jpress&#34; target=&#34;_blank&#34;&gt;Jpress&lt;/a&gt; 是一个不错的cms开源平台，慢慢可以取代wordpress,且速度较快。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://luxiaolei.com/&#34; target=&#34;_blank&#34;&gt;路小磊&lt;/a&gt;的工具包&lt;a href=&#34;https://github.com/looly/hutool&#34; target=&#34;_blank&#34;&gt;Hutools utility&lt;/a&gt;有在更新中。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;sourceTree可以用来做软件开发跟踪，内核当然是git。
&lt;img src=&#34;https://jueqingsizhe66.github.io/images/java/javaSourceTree.png&#34; alt=&#34;sourcetree&#34; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>压缩文件IO流的使用和简单封装（0213）</title>
      <link>https://jueqingsizhe66.github.io/blog/2015/05/11/ya-suo-wen-jian-ioliu-de-shi-yong-he-jian-dan-feng-zhuang-0213/</link>
      <pubDate>Mon, 11 May 2015 14:58:47 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/blog/2015/05/11/ya-suo-wen-jian-ioliu-de-shi-yong-he-jian-dan-feng-zhuang-0213/</guid>
      <description>&lt;p&gt;分为三个部分：
第一部分 ，先是试用了zipinputstream的用法
第二部分， 是进一步试用了压缩流zipoutputStream和加密的方法
第三部分 ， 则是对上述过程封装为一个OOZip类&lt;/p&gt;

&lt;p&gt;功能简述：  分为普通的压缩和加密的压缩，对应的解压缩 。普通的压缩：文件和文件夹都可以。 加密的压缩：文件和文件夹都可以，当加密的时候，则生成的zip文件里面的文件打开时乱码，必须用对应的unzipCrypto方法进行解压才有效。当然不会像winzip会提醒你输入密码，可以让你打开，只不过打开的是乱码。&lt;/p&gt;

&lt;p&gt;1： 先从com.rupeng.gtk4j挖出了zipInputStream的用法，用于解压缩，测试只能针对zip文件。
于是就有了初始版本的解压缩流：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.io.Closeable;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

/**
* @author    叶昭良
* @time      2015年2月12日下午1:19:18
* @version   TestZipInputStream V1.0
*/
public class TestZipInputStream
{

        /**
         * @param args
         */
        public static void main(String[] args)
        {
                //unZipShared(&amp;quot;e:\\test\\test.zip&amp;quot;);
                //unZipShared(&amp;quot;e:\\test\\test1.zip&amp;quot;);
                //rar暂时无法解压出来，但是zip文件是可以的
                unZipShared(&amp;quot;e:\\test\\test1.zip&amp;quot;,&amp;quot;e:\\testOutput&amp;quot;);
        }
        
        /**
         *   解压缩 zip文件，只能限制为rar
         * @param zipName        待解压的zip文件
         * @param outputfolder   解压zip文件到outputFoler文件夹下
         */
        public static void unZipShared(String zipName,String outputfolder)
        {
                File gtkDir = new File(outputfolder);// *.dll放的文件夹
                if (!gtkDir.exists())
                {
                        gtkDir.mkdirs();
                }
                InputStream inStream = null;
                try
                {
                        inStream = new  FileInputStream(zipName);
                } catch (FileNotFoundException e1)
                {
                        // TODO Auto-generated catch block
                        e1.printStackTrace();
                }
                //InputStream inStream = Utils.class.getResourceAsStream(&amp;quot;/gtkshare.zip&amp;quot;);
                if (inStream == null)
                {
                        throw new UnsatisfiedLinkError(&amp;quot;没找到&amp;quot;+zipName);
                }
                try
                {                        
                        unZip(inStream, gtkDir.toString());
                        System.out.println(gtkDir.toString());
                } catch (IOException e)
                {
                        System.err.println(&amp;quot;解压缩gtkshare.zip失败&amp;quot; + toFullString(e));
                }
        }

        /**
         * 把streamToZip这个zip文件流解压到硬盘的destDir文件夹，支持多级目录
         * @param streamToZip
         * @param destDir
         * @throws IOException
         */
        public static void unZip(InputStream streamToZip,String destDir)throws IOException
        {  
                ZipInputStream zipStream = new ZipInputStream(streamToZip);
                try
                {
                        ZipEntry zipEntry = null;
                        //通过zipEntry方式支持多级目录
                        while((zipEntry=zipStream.getNextEntry())!=null)
                        {
        if(zipEntry.isDirectory())
        {
                File dir = new File(destDir,zipEntry.getName());
                if(!dir.exists())
                {
                        dir.mkdirs();
                }
        }
        else
        {
                FileOutputStream fileOutStream = new FileOutputStream(new File(destDir,zipEntry.getName()));
                try
                {
                        copy(zipStream, fileOutStream);
                }
                finally
                {
                        close(fileOutStream);
                }
        }
}
                }
                finally
                {
                        close(zipStream);
                }
                
    }
        /**
         *     从zip文件包中拷贝文件
         * @param inStream       zipEntry的某个文件
         * @param outStream      输出的某个文件流
         * @throws IOException
         */
        static void copy(InputStream inStream, OutputStream outStream)
                        throws IOException
        {
                byte[] buffer = new byte[512 * 1024];// 0.5MB 的缓冲区
                int len;
                while ((len = inStream.read(buffer)) &amp;gt;= 0)
                {
                        outStream.write(buffer, 0, len);
                }
        }
        /**
         *    摘自rupeng.gtk4j   不明白具体的作用    非主要问题
         * @param throwable
         * @return
         */
        static String toFullString(Throwable throwable)
        {
                StringWriter sw = null;
                PrintWriter pw = null;
                try
                {
                        sw = new StringWriter();
                        pw = new PrintWriter(sw);
                        throwable.printStackTrace(pw);
                        return sw.toString();
                } finally
                {
                        close(sw);
                        close(pw);
                }
        }
        /**
         *     让文件流安静的关闭
         * @param closeable   关闭接口
         */
        static void close(Closeable closeable)
        {
                if (closeable != null)
                {
                        try
                        {
                                closeable.close();
                        } catch (IOException e)
                        {

                        }
                }
        }


}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2：后来想着有解压缩，必然也是有着压缩，于是就摆了一下，参考了一篇百度知道文章
    2.1 首先加入了zip的方法
    2.2 改进了zip方法的文件压缩流的写入过程，利用buffersize
    2.3 常使用了文章中的加密过程，添加了加密压缩和加密解压缩的过程
    2.4 想着实用命令流来进一步实现 压缩和解压缩的调用，后来弃用，改用封装一个OOZip类来实现&lt;/p&gt;

&lt;p&gt;于是就有了下面的升级版的压缩和解压缩的程序：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.io.Closeable;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.spec.InvalidKeySpecException;
import java.util.Random;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;
import java.util.zip.ZipOutputStream;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.interfaces.PBEKey;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.PBEParameterSpec;
import javax.crypto.spec.SecretKeySpec;


/**
* @author    叶昭良
* @time      2015年2月12日下午5:22:31
* @version   TestZipInputStreamUpdate V1.0  增加了压缩 
*                              V2.0   ZipShared加入了 zosTemp.close(); 修复了 压缩的bug，删掉则无法压缩
*                              V3.0   升级了ZipShared 使用了copy函数。
*                              V4.0   增加了加密压缩 和解加密压缩
*/
public class TestZipInputStreamUpdate
{

        
        /**
         * @param args
         */
        private static final String ALGORITHM = &amp;quot;PBEWithMD5AndDES&amp;quot;;
        public static void main(String[] args)
        {
                // TODO Auto-generated method stub
                TestZipInputStreamUpdate tisu = new TestZipInputStreamUpdate();
                //不需要再次加入zip文件后缀了
                //tisu.ZipShared(&amp;quot;e://test1222bak&amp;quot;,&amp;quot;e://test1222&amp;quot;);
                
                tisu.ZipSharedCrypto(&amp;quot;e://test1222bak&amp;quot;, &amp;quot;e://test1222passwdByZhao.zip&amp;quot;, &amp;quot;123456&amp;quot;);
                tisu.unzipCrypto(&amp;quot;e://test1222passwdByZhao.zip&amp;quot;,&amp;quot;c://laoliang&amp;quot;,&amp;quot;123456&amp;quot;);
        //        tisu.unzipCrypto(&amp;quot;e://test1222passwdByZhao.zip&amp;quot;,&amp;quot;c://laoliang&amp;quot;,&amp;quot;1234565&amp;quot;);
                
                /*
                 *  你正在进入e:\test1222bak文件夹
                        你正在进入e:\test1222bak\test1222文件夹
                        你正在压缩a1.zip
                        你正在压缩test123.txt
                        你正在压缩test124.txt
                        
                        通过这个实验总结了：所有操作系统内部的文件都是文件，无论是普通的文件
                        还是文件夹文件，还是管道文件，还是索引文件，还是设备文件，本质上都是
                        文件，只不过是在文件的头上面增加了一些特殊的标记，比如说你需要在文件夹
                        的路径增加一个\路径标志 反斜杠的道理是一样的。
                 */
                
                /*  这是一个命令流的使用方式：：
                 *         if(args.length==2){ 
            String name = args[1]; 
            Zip zip = new Zip(); 

            if(args[0].equals(&amp;quot;-zip&amp;quot;)) 
            {
                    zipname = args[2];
                    zip.doZip(name); 
            }
                
            else if(args[0].equals(&amp;quot;-unzip&amp;quot;)) 
            {
                    outputfolder = args[2];
                     zip.unZip(name);          
            }     
        } 
        else{ 
            System.out.println(&amp;quot;Usage:&amp;quot;); 
            System.out.println(&amp;quot;压缩:java Zip -zip directoryName  zipname&amp;quot;); 
            System.out.println(&amp;quot;解压:java Zip -unzip fileName.zip outputfolder&amp;quot;); 
            throw new Exception(&amp;quot;Arguments error!&amp;quot;); 
        } 
                 */
        }
        public void ZipShared(String fileinput,String zos)
        {
                try
                {
                        //加入&amp;quot;zip&amp;quot;后缀！
                        ZipOutputStream zosTemp = new ZipOutputStream(new FileOutputStream(zos+&amp;quot;zip&amp;quot;));
                        File fApple = new File(fileinput);
                        ZipShared(fApple,zosTemp,&amp;quot;&amp;quot;);
                        try
                        {
                                /// 为什么加入这个就可以？？？？
                                //  不加入这有异常？？？？why   Tell me 
                                zosTemp.close();
                        } catch (IOException e)
                        {
                                // TODO Auto-generated catch block
                                e.printStackTrace();
                        }
                } catch (FileNotFoundException e)
                {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                }
                
        }
        public  void ZipShared(File fileinput,ZipOutputStream zos,String base)
        {
                //ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(outputZipName));
                
                //File fileinput = new File(outputZipName);
if(fileinput.isDirectory())
{
        System.out.println(&amp;quot;你正在进入&amp;quot;+fileinput+&amp;quot;文件夹&amp;quot;);
        File[] fBanana = fileinput.listFiles();
        try
        {
                //传进一个文件夹标志
                zos.putNextEntry(new ZipEntry(base+&amp;quot;/&amp;quot;));
                //让base加上一个/
                base = base.length()==0?&amp;quot;&amp;quot;:base+&amp;quot;/&amp;quot;;
                for(int i = 0; i &amp;lt; fBanana.length; i++)
                {
                        ZipShared(fBanana[i],zos,base+fBanana[i].getName());
                }
        } catch (IOException e)
        {
                // TODO Auto-generated catch block
                System.out.println(&amp;quot;压缩文件夹失败&amp;quot;+e.getMessage());
        }
        
}else
{
        try
        {
                zos.putNextEntry(new ZipEntry(base));
                FileInputStream fis = new FileInputStream(fileinput);
                //改进写入的方式
                /*int b;
                while((b = fis.read())!= -1)
                {
                        zos.write(b); 
                        //效率很定不高  每一个字符  进行一次缓冲
                        //zos.flush();
                }*/
                copy(fis,zos); //利用汝鹏版的copy函数
                System.out.println(&amp;quot;你正在压缩&amp;quot;+fileinput.getName());
                //fis.close();
                
                //zos.close();
        } catch (IOException e)
        {
                // TODO Auto-generated catch block
                System.out.println(&amp;quot;压缩文件失败&amp;quot;+e.getMessage());
        } 
        //为什么加入则错误
        /*finally
        {
                try
                {
                        zos.close();
                }catch(IOException e)
                {
                        System.out.println(&amp;quot;打开流错误！&amp;quot;);
                }
        }*/
                }
        }
        public  void ZipSharedCrypto(String fileinput,String zosFile,String pwd)
        {
                
                try
                {        File f1 = new File(fileinput);
                //采用和ZipShared一样的FileOutputStream
                        ZipOutputStream zos  = null;
                        zos = new ZipOutputStream(new FileOutputStream(zosFile));
                        ZipSharedCrypto(f1,zos,&amp;quot;&amp;quot;, pwd);
                        try
                        {
                                zos.close();
                        } catch (IOException e)
                        {
                                // TODO Auto-generated catch block
                                e.printStackTrace();
                        }
                } catch (FileNotFoundException e)
                {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                }
                System.out.println(&amp;quot;成了&amp;quot;);
        }
        public  void ZipSharedCrypto(File fileinput,ZipOutputStream zos,String base,String pwd)
        {
if(fileinput.isDirectory())
{
        System.out.println(&amp;quot;你正在进入&amp;quot;+fileinput+&amp;quot;文件夹&amp;quot;);
File[] fApples = fileinput.listFiles();
//因为ZipEntry的isDirectory()方法中，目录以&amp;quot;/&amp;quot;结尾
try
{        
        zos.putNextEntry(new ZipEntry(base+&amp;quot;/&amp;quot;));
        base = base.length()==0?&amp;quot;&amp;quot;:(base+&amp;quot;/&amp;quot;);
        //一种比较新型的方式循环读写东西。
        for(File ftemp:fApples)
        {
                ZipSharedCrypto(ftemp,zos,base+ftemp.getName(),pwd);
        }
}catch(IOException e)
{
        System.out.println(&amp;quot;文件夹加密压缩失败&amp;quot;);
        }
}else
{        
        
        try
        {
                zos.putNextEntry(new ZipEntry(base));
                FileInputStream fis = new FileInputStream(fileinput);
                System.out.println(&amp;quot;你正在开始加密压缩&amp;quot;+fileinput+&amp;quot;文件&amp;quot;);
        PBEKeySpec keySpec = new PBEKeySpec(pwd.toCharArray());
        SecretKeyFactory keyFactory = null;
        try
        {
                keyFactory = SecretKeyFactory.getInstance(ALGORITHM);
        } catch (NoSuchAlgorithmException e)
        {
                // TODO Auto-generated catch block
                e.printStackTrace();
        }
        SecretKey passwordKey = keyFactory.generateSecret(keySpec);
        //生成一个炸弹 进行加密
        byte[] bomb =  new byte[8];
        Random rnd = new Random();
        rnd.nextBytes(bomb);
        int iterations = 100;
        PBEParameterSpec parameterSpec = new PBEParameterSpec(bomb, iterations);
        Cipher cipher = null;
        try
        {
                cipher = Cipher.getInstance(ALGORITHM);
        } catch (NoSuchAlgorithmException
                        | NoSuchPaddingException e)
        {
                // TODO Auto-generated catch block
                e.printStackTrace();
        }
        cipher.init(Cipher.ENCRYPT_MODE, passwordKey,parameterSpec);
        //往输出流 添加炸弹
        zos.write(bomb);
        
        //添加加密的主文件内容  1KB缓存区
        byte[] inputBuffer = new byte[1024];
        int bytesRead = 0;
        //如果没有读到信息则为-1
        while((bytesRead = fis.read(inputBuffer))!= -1)
        {
                //每个缓冲区 进行加密写入
                byte[] output = cipher.update(inputBuffer);
                if(output != null)
                {
                        zos.write(output);
                }
        }
        
        //加密结束语
        byte[] outputFinal =null;
        try
        {
                outputFinal = cipher.doFinal();
        } catch (IllegalBlockSizeException | BadPaddingException e)
        {
                // TODO Auto-generated catch block
                e.printStackTrace();
        }
        if(outputFinal != null)
        {
                zos.write(outputFinal);
        }
        
/*        fis.close();
        zos.flush();
        zos.close();*/
        
        
}catch(InvalidKeySpecException | InvalidKeyException | InvalidAlgorithmParameterException | IOException e)
{
        System.out.println(&amp;quot;加密失败&amp;quot;);
        }
}
        }
        /**
         *   解压缩 zip文件，只能限制为rar
         * @param zipName        待解压的zip文件
         * @param outputfolder   解压zip文件到outputFoler文件夹下
         */
        public static void unZipShared(String zipName,String outputfolder)
        {
                File gtkDir = new File(outputfolder);// *.dll放的文件夹
                //指定的目录不存在  则创建之
                if (!gtkDir.exists())
                {
                        gtkDir.mkdirs();
                }
                InputStream inStream = null;
                try
                {
                        inStream = new  FileInputStream(zipName);
                } catch (FileNotFoundException e1)
                {
                        // TODO Auto-generated catch block
                        e1.printStackTrace();
                }
                //InputStream inStream = Utils.class.getResourceAsStream(&amp;quot;/gtkshare.zip&amp;quot;);
                if (inStream == null)
                {
                        throw new UnsatisfiedLinkError(&amp;quot;没找到&amp;quot;+zipName);
                }
                try
                {                        
                        unZip(inStream, gtkDir.toString());
                        System.out.println(gtkDir.toString());
                } catch (IOException e)
                {
                        System.err.println(&amp;quot;解压缩gtkshare.zip失败&amp;quot; + toFullString(e));
                }
        }

        /**
         * 把streamToZip这个zip文件流解压到硬盘的destDir文件夹，支持多级目录
         * @param streamToZip
         * @param destDir
         * @throws IOException
         */
        public static void unZip(InputStream streamToZip,String destDir)throws IOException
        {  
                ZipInputStream zipStream = new ZipInputStream(streamToZip);
                try
                {
                        ZipEntry zipEntry = null;
                        //通过zipEntry方式支持多级目录
        while((zipEntry=zipStream.getNextEntry())!=null)
        {
                if(zipEntry.isDirectory())
                {
                        System.out.println(&amp;quot;你正在创建文件夹文件 比较特殊&amp;quot;);
                        File dir = new File(destDir,zipEntry.getName());
                        //如果指定的目录不存在 则创建之
                        if(!dir.exists())
                        {
                                dir.mkdirs();
                        }
                }
                else
                {
                        FileOutputStream fileOutStream = new FileOutputStream(new File(destDir,zipEntry.getName()));
                        try
                        {
                                copy(zipStream, fileOutStream);
                        }
                        finally
                        {
                                close(fileOutStream);
                        }
                        System.out.println(&amp;quot;你正在解压缩压缩&amp;quot;+zipEntry.getName());
                }
        }
}
finally
{
        close(zipStream);
}
                
    }
        /**
         *     从zip文件包中拷贝文件 ，按照0.5MB的缓冲写入文件(默认方式）
         * @param inStream       zipEntry的某个文件
         * @param outStream      输出的某个文件流
         * @throws IOException
         */
        static void copy(InputStream inStream, OutputStream outStream)
                        throws IOException
        {
                byte[] buffer = new byte[512 * 1024];// 0.5MB 的缓冲区
                int len;
                while ((len = inStream.read(buffer)) &amp;gt;= 0)
                {
                        outStream.write(buffer, 0, len);
                }
        }
        /**
         *    摘自rupeng.gtk4j   不明白具体的作用    非主要问题
         * @param throwable
         * @return
         */
        static String toFullString(Throwable throwable)
        {
                StringWriter sw = null;
                PrintWriter pw = null;
                try
                {
                        sw = new StringWriter();
                        pw = new PrintWriter(sw);
                        throwable.printStackTrace(pw);
                        return sw.toString();
                } finally
                {
                        close(sw);
                        close(pw);
                }
        }
        /**
         *     让文件流安静的关闭
         * @param closeable   关闭接口
         */
        static void close(Closeable closeable)
        {
                if (closeable != null)
                {
                        try
                        {
                                closeable.close();
                        } catch (IOException e)
                        {

                        }
                }
        }
        
        // 加密解压缩

/**
         * 功能描述：将压缩文件解压到指定的文件目录下
         * @param zipFileName      压缩文件名称(带路径)
         * @param outputDirectory  指定解压目录
         * @return
         * @throws Exception
         */
        public  void unzipCrypto(String zipFileName, String outputDirectory, String pwd)
        {
                ZipInputStream inputStream;
                try
                {
                        inputStream = new ZipInputStream(new FileInputStream(zipFileName));
                        unzipCrypto(inputStream, outputDirectory, pwd);
                } catch (Exception e)
                {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                }
                
        }


        public  void unzipCrypto(ZipInputStream inputStream, String outputDirectory, String pwd) throws Exception
        {
                ZipEntry zipEntry = null;
                FileOutputStream outputStream = null;
                try{
                        while ((zipEntry = inputStream.getNextEntry()) != null) 
                        {
if (zipEntry.isDirectory())
{
        System.out.println(&amp;quot;你正在进入&amp;quot;+zipEntry.getName()+&amp;quot;文件夹&amp;quot;);
        String name = zipEntry.getName();
        name = name.substring(0, name.length() - 1);
        File file = new File(outputDirectory + File.separator + name);
        file.mkdir();
} 
else 
{
        File file = new File(outputDirectory + File.separator + zipEntry.getName());
        file.createNewFile();
        outputStream = new FileOutputStream(file);
        System.out.println(&amp;quot;你正在解压缩&amp;quot;+file.getName()+&amp;quot;文件&amp;quot;);
        PBEKeySpec keySpec = new PBEKeySpec(pwd.toCharArray());
    SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(ALGORITHM);
    SecretKey passwordKey = keyFactory.generateSecret(keySpec);
    byte[] salt = new byte[8];
    inputStream.read(salt);
    int iterations = 100;
    PBEParameterSpec parameterSpec = new PBEParameterSpec(salt, iterations);
    Cipher cipher = Cipher.getInstance(ALGORITHM);
    cipher.init(Cipher.DECRYPT_MODE, passwordKey, parameterSpec);
    byte[] input = new byte[1024];
    int bytesRead;
    while ((bytesRead = inputStream.read(input)) != -1) 
    {
            byte[] output = cipher.update(input, 0, bytesRead);
            if (output != null)
            {
                    outputStream.write(output);
            }
    }
    byte[] output = cipher.doFinal();
    if (output != null)
    {
            outputStream.write(output);
    }
/*                                    outputStream.flush();
                                    outputStream.close();*/
        
}
                        }
                        //inputStream.close();
                }
                catch(IOException ex)
                {
                        throw new Exception(&amp;quot;解压读取文件失败&amp;quot;);
                }
                catch(Exception ex)
                {
                        throw new Exception(&amp;quot;解压文件密码不正确&amp;quot;);
                }
/*                finally
                {
                        inputStream.close();
                        outputStream.flush();
                    outputStream.close();
                }*/
        }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3：进一步 实现先前的想法，封装一个OOZip类，
    基本思想：
         1：抽取常用变量，比如bufferSize 缓冲区大小     buf缓冲区； 本想着加入压缩和解压缩的流变量，后来删掉了
         2：定义构造函数， 设置缓冲区大小
         3：复制之前的方法，并利用buffersize和buf改写copy函数和 文件的复制的函数
         4：进行简单地压缩和解压缩文件夹      加密压缩和解加密压缩文件夹   的测试。 并找到了压缩单个文件的bug
         5：bug修复&lt;/p&gt;

&lt;p&gt;完整代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.io.Closeable;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.spec.InvalidKeySpecException;
import java.util.Random;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;
import java.util.zip.ZipOutputStream;
import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.PBEParameterSpec;

/**
* @author    叶昭良
* @time      2015年2月12日下午9:51:11
* @version   OOZip    用于压缩和解压缩
*                   V1.0  增加了压缩 
*                   V2.0   ZipShared加入了 zosTemp.close(); 修复了 压缩的bug
*                   V3.0   改进了构造函数 利用具有缓冲区的压缩
*                   V4.0   升级了ZipShared 使用了copy函数。
*                   V5.0   增加了加密压缩 和解加密压缩
*                   V6.0   改用了面向对象方式修改了一番
*                   V7.0   加入了一些压缩和解压缩完成的的console标记
*                   V8.0   修复了单个文件无法加密的bug   new ZipEntry(base) 改为
*                    new ZipEntry(base+fileinput.getName())，未添入到zipentry的缘故
*                    而若是文件夹遍历的时候则是有加入文件名的标记！所以在单个文件的时候也需要加入文件名的
*                    标记
*                   V9.0   若有中文问题，可以进一步采用import org.apache.tools.zip.* 的zip包！ 更好的支持中文
*                          具体参看http://blog.csdn.net/liu149339750/article/details/7887701  
*                                 http://szhnet.iteye.com/blog/199059 ，这个链接当中提供了ant版本 
*                          当然此版本，不需要org.apache.tool.zip包也不需要ant包  附录了ant版本的代码，的确看起来
*                          是简单的。
*/
public class OOZip
{

/**
*  这几个私有变量的控制，主要体现在针对具体的文件的复制过程中
*/
        private int bufSize ; //压缩和解压缩会用到。 一次从压缩文件zip读取多少文件信息
                                                                 //或者一次写入多少文件信息到压缩流
        private byte[] buf;   //写入或者写出压缩流的字节数组
        private int readBytes = 0;  //实际写入或者写出文件流的大小。
        private static final String ALGORITHM = &amp;quot;PBEWithMD5AndDES&amp;quot;;
        
        //构造函数的定义
   public OOZip(){ 
           // 1025*512  //设置输入输出流的缓冲区的大小 ，统一设置
        this(1024*512); 
    } 

    public OOZip(int bufSize){ 
        this.bufSize = bufSize; 
        this.buf = new byte[this.bufSize]; 
    } 
        
        //常用的类中 内部函数
        
        public static void main(String[] args)
        {
                // TODO Auto-generated method stub
                OOZip oz = new OOZip();
                //单个文件加密和非加密测试暂时失败
                oz.ZipShared(&amp;quot;e://student.txt&amp;quot;, &amp;quot;e://laoliang&amp;quot;); 
                //oz.ZipSharedCrypto(&amp;quot;e://student.txt&amp;quot;, &amp;quot;e://laoliang&amp;quot;,&amp;quot;1234&amp;quot;);
                //输入文件夹路径则加密和非加密测试通过
                //oz.ZipShared(&amp;quot;e://test1222bak&amp;quot;, &amp;quot;e://laoliang&amp;quot;);  //已测试通过
                //oz.ZipSharedCrypto(&amp;quot;e://test1222bak&amp;quot;, &amp;quot;e://laoliang&amp;quot;, &amp;quot;123456&amp;quot;);
                
                //解压缩，不用输入.zip后缀，只需要输入文件名
                //oz.unzipCrypto(&amp;quot;e://laoliang&amp;quot;, &amp;quot;c://laozi&amp;quot;,&amp;quot;123456&amp;quot;);
                //测试成功
        }

        /**
         *     压缩名字为fileinput变量内容的文件夹
         * @param fileinput   文件夹名字
         * @param zos         zip文件夹名字
         */
        public void ZipShared(String fileinput,String zos)
        {
                try
                {
                        //加入&amp;quot;zip&amp;quot;后缀！
                        ZipOutputStream zosTemp = new ZipOutputStream(new FileOutputStream(zos+&amp;quot;.zip&amp;quot;));
                        File fApple = new File(fileinput);
                        ZipShared(fApple,zosTemp,&amp;quot;&amp;quot;);
                        try
                        {
                                /// 为什么加入这个就可以？？？？
                                //  不加入这有异常？？？？why   Tell me 
                                zosTemp.close();
                        } catch (IOException e)
                        {
                                // TODO Auto-generated catch block
                                e.printStackTrace();
                        }
                } catch (FileNotFoundException e)
                {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                }
                System.out.println(&amp;quot;success to create&amp;quot;+zos+&amp;quot;.zip&amp;quot;);
        }
        /**
         *     压缩文件夹的中间函数
         * @param fileinput    输入函数的文件对象
         * @param zos          压缩输出流对象
         * @param base         一般是&amp;quot;&amp;quot; 表示子目录的作用，在递归目录的时候会用到，在文件夹递归中，涉及到改变；
         */
        public  void ZipShared(File fileinput,ZipOutputStream zos,String base)
        {
if(fileinput.isDirectory())
{
        System.out.println(&amp;quot;你正在进入&amp;quot;+fileinput+&amp;quot;文件夹&amp;quot;);
        File[] fBanana = fileinput.listFiles();
        try
        {
                //传进一个文件夹标志
                zos.putNextEntry(new ZipEntry(base+&amp;quot;/&amp;quot;));
                //让base加上一个/
                base = base.length()==0?&amp;quot;&amp;quot;:base+&amp;quot;/&amp;quot;;
                for(int i = 0; i &amp;lt; fBanana.length; i++)
                {
                        ZipShared(fBanana[i],zos,base+fBanana[i].getName());
                }
        } catch (IOException e)
        {
                System.out.println(&amp;quot;压缩文件夹失败&amp;quot;+e.getMessage());
        }
        
}else
{
        try
        {
                zos.putNextEntry(new ZipEntry(base+fileinput.getName()));
                FileInputStream fis = new FileInputStream(fileinput);
                //改进写入的方式
                /*int b;
                while((b = fis.read())!= -1)
                {
                        zos.write(b); 
                        //效率很定不高  每一个字符  进行一次缓冲
                        //zos.flush();
                }*/
                copy(fis,zos); //利用汝鹏版的copy函数
                System.out.println(&amp;quot;你正在压缩&amp;quot;+fileinput.getName());
        } catch (IOException e)
        {
                System.out.println(&amp;quot;压缩文件失败&amp;quot;+e.getMessage());
        } 
}
        }
        /**
         *     加密压缩文件夹
         * @param fileinput    文件夹字符串
         * @param zosFile      压缩字符串名字
         * @param pwd          加密的密码
         */
        public  void ZipSharedCrypto(String fileinput,String zosFile,String pwd)
        {
                
                try
                {        
                        File f1 = new File(fileinput);
                        //采用和ZipShared一样的FileOutputStream
                        ZipOutputStream zos  = null;
                        zos = new ZipOutputStream(new FileOutputStream(zosFile+&amp;quot;.zip&amp;quot;));
                        ZipSharedCrypto(f1,zos,&amp;quot;&amp;quot;, pwd);
                        try
                        {
                                zos.close();
                        } catch (IOException e)
                        {
                                e.printStackTrace();
                        }
                } catch (FileNotFoundException e)
                {
                        System.out.println(&amp;quot;未找到文件&amp;quot;+e.getMessage());
                }
                System.out.println(&amp;quot;success to create crypto &amp;quot;+zosFile+&amp;quot;.zip&amp;quot;);
        }
        /**
         *          加密压缩文件夹     
         * @param fileinput     压缩文件夹的File对象
         * @param zos           zip压缩输出流ZipOutputStream
         * @param base          一般是&amp;quot;&amp;quot;
         * @param pwd           压缩的密码
         */
        public  void ZipSharedCrypto(File fileinput,ZipOutputStream zos,String base,String pwd)
        {
if(fileinput.isDirectory())
{
        System.out.println(&amp;quot;你正在进入&amp;quot;+fileinput+&amp;quot;文件夹&amp;quot;);
        File[] fApples = fileinput.listFiles();
        //因为ZipEntry的isDirectory()方法中，目录以&amp;quot;/&amp;quot;结尾
        try
        {        
                zos.putNextEntry(new ZipEntry(base+&amp;quot;/&amp;quot;));
                base = base.length()==0?&amp;quot;&amp;quot;:(base+&amp;quot;/&amp;quot;);
                //一种比较新型的方式循环读写东西。
                for(File ftemp:fApples)
                {
                        ZipSharedCrypto(ftemp,zos,base+ftemp.getName(),pwd);
                }
        }catch(IOException e)
        {
                System.out.println(&amp;quot;文件夹加密压缩失败&amp;quot;);
        }
}else
{        
        
        try
        {
                zos.putNextEntry(new ZipEntry(base));
                FileInputStream fis = new FileInputStream(fileinput);
                System.out.println(&amp;quot;你正在开始加密压缩&amp;quot;+fileinput+&amp;quot;文件&amp;quot;);
                //加密过程的开始
                PBEKeySpec keySpec = new PBEKeySpec(pwd.toCharArray());
                SecretKeyFactory keyFactory = null;
                try
                {
                        keyFactory = SecretKeyFactory.getInstance(ALGORITHM);
                } catch (NoSuchAlgorithmException e)
                {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                }
                SecretKey passwordKey = keyFactory.generateSecret(keySpec);
                //生成一个炸弹 进行加密
                byte[] bomb =  new byte[8];
                Random rnd = new Random();
                rnd.nextBytes(bomb);
                int iterations = 100;
                PBEParameterSpec parameterSpec = new PBEParameterSpec(bomb, iterations);
                Cipher cipher = null;
                try
                {
                        cipher = Cipher.getInstance(ALGORITHM);
                } catch (NoSuchAlgorithmException
                                | NoSuchPaddingException e)
                {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                }
                cipher.init(Cipher.ENCRYPT_MODE, passwordKey,parameterSpec);
                //往输出流 添加炸弹
                zos.write(bomb);
                
                //添加加密的主文件内容  1KB缓存区
                //byte[] inputBuffer = new byte[1024];
                //int bytesRead = 0;
                //如果没有读到信息则为-1
                
                //改用 readBytes  buf在类头定义的私有变量，进行统一的buffer缓存区大小的控制
                while((this.readBytes = fis.read(this.buf))!= -1)
                {
                        //每个缓冲区 进行加密写入
                        byte[] output = cipher.update(this.buf);
                        if(output != null)
                        {
                                zos.write(output);
                        }
                }
                
                //加密结束语-------------加密结束
                byte[] outputFinal =null;
                try
                {
                        outputFinal = cipher.doFinal();
                } catch (IllegalBlockSizeException | BadPaddingException e)
                {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                }
                if(outputFinal != null)
                {
                        zos.write(outputFinal);
                }        
        }catch(InvalidKeySpecException | InvalidKeyException | InvalidAlgorithmParameterException | IOException e)
        {
                System.out.println(&amp;quot;加密失败&amp;quot;);
        }
}
        }
        /**
         *   解压缩 zip文件，只能限制为zip ,rar无法进行，利用如鹏版的
         * @param zipName        待解压的zip文件
         * @param outputfolder   解压zip文件到outputFoler文件夹下
         */
        public void unzip(String zipName,String outputfolder)
        {
                File gtkDir = new File(outputfolder);// *.dll放的文件夹
                //指定的目录不存在  则创建之
                if (!gtkDir.exists())
                {
                        gtkDir.mkdirs();
                }
                InputStream inStream = null;
                try
                {
                        //不用输入.zip后缀，只需要输入文件名
                        inStream = new  FileInputStream(zipName+&amp;quot;.zip&amp;quot;);
                } catch (FileNotFoundException e1)
                {
                        // TODO Auto-generated catch block
                        e1.printStackTrace();
                }
                //InputStream inStream = Utils.class.getResourceAsStream(&amp;quot;/gtkshare.zip&amp;quot;);
                if (inStream == null)
                {
                        throw new UnsatisfiedLinkError(&amp;quot;没找到&amp;quot;+zipName);
                }
                try
                {                        
                        unzip(inStream, gtkDir.toString());
                        //System.out.println(gtkDir.toString());
                        System.out.println(&amp;quot;成功解压缩&amp;quot;+zipName+&amp;quot;.zip&amp;quot;+&amp;quot;文件 到&amp;quot;+outputfolder+&amp;quot;文件夹下&amp;quot;);
                } catch (IOException e)
                {
                        System.err.println(&amp;quot;解压缩&amp;quot;+zipName+&amp;quot;.zip失败&amp;quot; + toFullString(e));
                }
        }

        /**
         * 把streamToZip这个zip文件流解压到硬盘的destDir文件夹，支持多级目录
         * @param streamToZip
         * @param destDir
         * @throws IOException
         */
        public  void unzip(InputStream streamToZip,String destDir)throws IOException
        {  
                ZipInputStream zipStream = new ZipInputStream(streamToZip);
try
{
        ZipEntry zipEntry = null;
        //通过zipEntry方式支持多级目录
while((zipEntry=zipStream.getNextEntry())!=null)
{
        if(zipEntry.isDirectory())
        {
                System.out.println(&amp;quot;你正在创建文件夹文件 比较特殊&amp;quot;);
                File dir = new File(destDir,zipEntry.getName());
                //如果指定的目录不存在 则创建之
                if(!dir.exists())
                {
                        dir.mkdirs();
                }
        }
        else
        {
                FileOutputStream fileOutStream = new FileOutputStream(new File(destDir,zipEntry.getName()));
                try
                {
                        copy(zipStream, fileOutStream);
                }
                finally
                {
                        close(fileOutStream);
                }
                System.out.println(&amp;quot;你正在解压缩压缩&amp;quot;+zipEntry.getName());
        }
}
                }
                finally
                {
                        close(zipStream);
                }
                
    }
        /**
         *     从zip文件包中拷贝文件 ，按照0.5MB的缓冲写入文件(默认方式）
         * @param inStream       zipEntry的某个文件
         * @param outStream      输出的某个文件流
         * @throws IOException
         */
        public void copy(InputStream inStream, OutputStream outStream)
                        throws IOException
        {
                //byte[] buffer = new byte[512 * 1024];// 0.5MB 的缓冲区
                //int len;
                while ((this.readBytes = inStream.read(this.buf)) &amp;gt;= 0)
                {
                        outStream.write(this.buf, 0, this.readBytes);
                }
        }
        /**
         *    摘自rupeng.gtk4j   不明白具体的作用    非主要问题
         * @param throwable
         * @return
         */
        public String toFullString(Throwable throwable)
        {
                StringWriter sw = null;
                PrintWriter pw = null;
                try
                {
                        sw = new StringWriter();
                        pw = new PrintWriter(sw);
                        throwable.printStackTrace(pw);
                        return sw.toString();
                } finally
                {
                        close(sw);
                        close(pw);
                }
        }
        /**
         *     让文件流安静的关闭
         * @param closeable   关闭接口
         */
        public void close(Closeable closeable)
        {
                if (closeable != null)
                {
                        try
                        {
                                closeable.close();
                        } catch (IOException e)
                        {

                        }
                }
        }
        
        // 加密解压缩

/**
         * 功能描述：将压缩文件解压到指定的文件目录下
         * @param zipFileName      压缩文件名称(带路径)
         * @param outputDirectory  指定解压目录
         * @return
         * @throws Exception
         */
        public  void unzipCrypto(String zipFileName, String outputDirectory, String pwd)
        {
                ZipInputStream inputStream;
                File outputDir;
                try
                {
                        //不用输入.zip后缀，只需要输入文件名
                        inputStream = new ZipInputStream(new FileInputStream(zipFileName+&amp;quot;.zip&amp;quot;));
                        outputDir = new File(outputDirectory);
                        unzipCrypto(inputStream, outputDir, pwd);
                } catch (Exception e)
                {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                }
                System.out.println(&amp;quot;成功解压缩&amp;quot;+zipFileName+&amp;quot;.zip&amp;quot;+&amp;quot;文件 到&amp;quot;+outputDirectory+&amp;quot;文件夹下&amp;quot;);
                
        }


        public void unzipCrypto(ZipInputStream inputStream, File outputDir, String pwd) throws Exception
        {
                ZipEntry zipEntry = null;
                FileOutputStream outputStream = null;
                try{
while ((zipEntry = inputStream.getNextEntry()) != null) 
{
        //如果是文件夹  则遍历
        if (zipEntry.isDirectory())
        {
                System.out.println(&amp;quot;你正在进入&amp;quot;+zipEntry.getName()+&amp;quot;文件夹&amp;quot;);
                String name = zipEntry.getName();
                name = name.substring(0, name.length() - 1);
                File file = new File(outputDir + File.separator + name);
                file.mkdir();
        } 
        //对单个普通文件进行处理
        else 
        {
                File file = new File(outputDir + File.separator + zipEntry.getName());
                file.createNewFile();
                outputStream = new FileOutputStream(file);
                System.out.println(&amp;quot;你正在解压缩&amp;quot;+file.getName()+&amp;quot;文件&amp;quot;);
                //解压加密过程的开始
                PBEKeySpec keySpec = new PBEKeySpec(pwd.toCharArray());
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(ALGORITHM);
            SecretKey passwordKey = keyFactory.generateSecret(keySpec);
            //准备排除加密的炸弹头
            byte[] apple = new byte[8];
            //在zip输入流添加read
            inputStream.read(apple);
            int iterations = 100;
            PBEParameterSpec parameterSpec = new PBEParameterSpec(apple, iterations);
            Cipher cipher = Cipher.getInstance(ALGORITHM);
            cipher.init(Cipher.DECRYPT_MODE, passwordKey, parameterSpec);
            //byte[] input = new byte[1024];
            //int bytesRead;
            //利用全局的私有变量this.buf  this.readBytes ,已在类开头定义，统一控制
            while ((this.readBytes = inputStream.read(this.buf)) != -1) 
            {
                    byte[] output = cipher.update(this.buf, 0, this.readBytes);
                    if (output != null)
                    {
                            outputStream.write(output);
                    }
            }
            byte[] output = cipher.doFinal();
            if (output != null)
            {
                    outputStream.write(output);
            }
                
        }
}
                }
                catch(IOException ex)
                {
                        throw new Exception(&amp;quot;解压读取文件失败&amp;quot;);
                }
                catch(Exception ex)
                {
                        throw new Exception(&amp;quot;解压文件密码不正确&amp;quot;);
                }
        }

}
/*
*  附录ant版本的压缩实现http://szhnet.iteye.com/blog/199059
*  可以加入某些文件和删除某些文件
*  package net.szh.zip;

import java.io.File;

import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.Zip;
import org.apache.tools.ant.types.FileSet;

public class ZipCompressorByAnt {

        private File zipFile;

        public ZipCompressorByAnt(String pathName) {
                zipFile = new File(pathName);
        }
        
        public void compress(String srcPathName) {
                File srcdir = new File(srcPathName);
                if (!srcdir.exists())
                        throw new RuntimeException(srcPathName + &amp;quot;不存在！&amp;quot;);
                
                Project prj = new Project();
                Zip zip = new Zip();
                zip.setProject(prj);
                zip.setDestFile(zipFile);
                FileSet fileSet = new FileSet();
                fileSet.setProject(prj);
                fileSet.setDir(srcdir);
                //fileSet.setIncludes(&amp;quot;**//*.java&amp;quot;); 包括哪些文件或文件夹 eg:zip.setIncludes(&amp;quot;*.java&amp;quot;);
                //fileSet.setExcludes(...); 排除哪些文件或文件夹
                zip.addFileset(fileSet);
                
                zip.execute();
        }
}

ant版本的使用：
package net.szh.zip;

public class TestZip {
        public static void main(String[] args) {                
                ZipCompressorByAnt zca = new ZipCompressorByAnt(&amp;quot;E:\\szhzipant.zip&amp;quot;);
                zca.compress(&amp;quot;E:\\test&amp;quot;);
        }
}
*  
*/
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>反射机制内省正则</title>
      <link>https://jueqingsizhe66.github.io/blog/2015/05/11/fan-she-ji-zhi-nei-sheng-zheng-ze/</link>
      <pubDate>Mon, 11 May 2015 14:58:46 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/blog/2015/05/11/fan-she-ji-zhi-nei-sheng-zheng-ze/</guid>
      <description>&lt;p&gt;2：反射机制
不行，则逆着来.
类（Class）
三种方式&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//Test class
                //*************************************************************
                //第一种方式获得类
                System.out.println(&amp;quot;//*************************************************************&amp;quot;);
                Class clazz1 = Person.class;
                //第二种方式获得类
                System.out.println(&amp;quot;第一种方式获得类&amp;quot;+clazz1.getName());
                Person personClass = new Person();
                Class clazz2 = personClass.getClass();
                System.out.println(&amp;quot;第二种方式获得类&amp;quot;+clazz1.getName());
                //第三种方式获得类
                try
                {
                        Class clazz3 = Class.forName(&amp;quot;com.reflect.test.Person&amp;quot;);
                        System.out.println(&amp;quot;第三种方式获得类&amp;quot;+clazz1.getName());
                        System.out.println(&amp;quot;三种类方式都是同一个类！因为类只加载一次&amp;quot;+(clazz2==clazz1)+(clazz2==clazz3));
                        System.out.println(&amp;quot;包的名字&amp;quot;+clazz3.getPackage().getName());
                        System.out.println(&amp;quot;简单类名字（不带包）&amp;quot;+clazz3.getSimpleName());

                        System.out
                                        .println(&amp;quot;------------------------------通过Class对象获得类的构造函数---------------------&amp;quot;);
                        Constructor[] constructors = clazz3.getConstructors();
                        for (Constructor constructor : constructors) {
                                System.out.println(constructor);
                        }

                        System.out.println(&amp;quot;------------------通过Class对象获得类的字段----------------&amp;quot;);
                        Field[] fields = clazz3.getDeclaredFields();
                        for (Field field : fields) {
                                System.out.println(field);
                        }

                        System.out.println(&amp;quot;--------通过Class对象获得类的方法----------&amp;quot;);

                        Method[] methods = clazz3.getMethods();// 返回所有的public 方法,包括父类声明的public方法
                        for (Method method : methods) {
                                System.out.println(method);
                        }

                } catch (ClassNotFoundException e1)
                {
                        // TODO Auto-generated catch block
                        e1.printStackTrace();
                }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java
最主要的是Class.forName();&lt;/p&gt;

&lt;p&gt;字段&lt;/p&gt;

&lt;p&gt;设置字段的属性，并使用创建的对象调用方法.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//*************************************************************
                //TestField  测试字段开始
                //*************************************************************
                System.out.println(&amp;quot;//*************************************************************&amp;quot;);
                try
                {
                        /**
                         *  打印出所有字段
                         *  
                         *  字段类的一个特点设置
                         */
                        Field[] fields = clazz.getDeclaredFields();
                        for(Field temp : fields)
                        {
                                System.out.println(temp);
                        }
                        Person personLiMing = (Person) clazz.newInstance();
                        /**
                         * 测试添加一个名字的字段
                         */
                        //Field nameField = clazz.getField(&amp;quot;Name&amp;quot;); //会报异常
                        //Field nameField = clazz.getDeclaredField(&amp;quot;name&amp;quot;); //注意区分大小写
                        Field nameField = clazz.getDeclaredField(&amp;quot;Name&amp;quot;);
                        //一定得设置？
                        nameField.setAccessible(true);
                        nameField.set(personLiMing,&amp;quot;李明&amp;quot;);
                        
                        Object o = nameField.get(personLiMing);
                        System.out.println(o);
                        personLiMing.sayHi();
                } catch (InstantiationException | IllegalAccessException e)
                {
                        // TODO Auto-generated catch block
                        System.out.println(&amp;quot;创建新的实例异常&amp;quot;);
                }catch( NoSuchFieldException | SecurityException e)
                {
                        System.out.println(&amp;quot;没有那个字段&amp;quot;);
                }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java&lt;/p&gt;

&lt;p&gt;构造函数&lt;/p&gt;

&lt;p&gt;主要作用：产生对象&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
                 *  分为两个部分测试构造函数 
                 *  1：  有参的 ，注意有参的时候String.class int.class
                 *  2：  无参的
                 */
                //TestConstructor
                /**
                 * 打印所有的类的构造函数
                 */
                try
                {
                        Constructor con1 = clazzConstructor.getDeclaredConstructor();
                        
                        Object o = con1.newInstance();
                        
                        Person personWanghao = (Person)o;
                        personWanghao.sayHi();
                        
                        System.out.println(&amp;quot;------------------------&amp;quot;);
                        
                        Constructor&amp;lt;Person&amp;gt; con2 = clazzConstructor.getDeclaredConstructor(String.class,int.class);
                        Object o2 = con2.newInstance(&amp;quot;汪峰&amp;quot;,22);
                        //很浅显的道理  只有构造函数可以新建对象！！上面的代码正是
                        //体现如此！        
                        Person personWangfeng = (Person)o2;
                        personWangfeng.sayHi();
                        
                } catch (NoSuchMethodException | SecurityException e)
                {
                        // TODO Auto-generated catch block
                        System.out.println(&amp;quot;获取构造函数异常&amp;quot;);
                }catch (InstantiationException | IllegalAccessException
                                | IllegalArgumentException | InvocationTargetException e)
                {
                        // TODO Auto-generated catch block
                        System.out.println(&amp;quot;通过构造函数创建实例异常&amp;quot;);
                }
               
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java&lt;/p&gt;

&lt;p&gt;方法&lt;/p&gt;

&lt;p&gt;Invoke函数，调用对象的方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//*************************************************************
                //TestMethod
                /**
                 *  开始测试 所有Person类的普通方法
                 *  
                 *  方法类的一个特点，方法对应具体的参数！类似于构造函数
                 *  都需要考虑重载的问题
                 */
                System.out.println(&amp;quot;//*************************************************************&amp;quot;);
                System.out.println(&amp;quot;开始测试 所有Person类的普通方法---------&amp;quot;);
                Method[] methods = clazzMethod.getDeclaredMethods();
                
                for(Method temp: methods)
                {
                        System.out.println(temp);
                }
                
                //测试Person的sayHi方法
                try
                {
                        Method sayHi = clazzMethod.getDeclaredMethod(&amp;quot;sayHi&amp;quot;);
                        //Method singSong = clazz.getDeclaredMethod(&amp;quot;singSong&amp;quot;);
                        
                        Object o = clazzMethod.newInstance();
                        
                        Person personPig = (Person)o;
                        personPig.sayHi();
                        System.out.println(&amp;quot;通过普通方法1 进行Invoke1！！！&amp;quot;);

                        sayHi.invoke(o);
                        System.out.println(&amp;quot;通过普通方法1 进行Invoke2！！！&amp;quot;);
                        //反射的感觉有点像，逆着来的感觉
                        //通过方法调用对象！！并执行某个动作！
                        //而不是通过对象调用方法执行某个动作
                        sayHi.invoke(personPig);

                        Class returnType = sayHi.getReturnType();
                        System.out.println(&amp;quot;Person类 sayHi的返回值类型&amp;quot;+returnType);
                        
                        int modifies = sayHi.getModifiers();
                        //private 的值为0   public的值为1
                        System.out.println(&amp;quot;是private?:&amp;quot;+Modifier.isPrivate(modifies));
                        System.out.println(modifies);
                        
                        /**
                         *  必须隐藏 ！否则下面的无法执行！ 有对应的参数  需要设置上 参数才可以
                         *  否则找不到 singSong() 无参的函数
                         */
                /*        Method singSong = clazzMethod.getDeclaredMethod(&amp;quot;singSong&amp;quot;);
                        System.out.println(singSong);*/
                        
                        Method singSong2 = clazzMethod.getDeclaredMethod(&amp;quot;singSong&amp;quot;, String.class);
                        Person personDandan = new Person(&amp;quot;淡淡&amp;quot;,22);
                        singSong2.invoke(personDandan, &amp;quot;好汉歌&amp;quot;);
                        System.out.println(singSong2.getReturnType());
                        
                        //System.out.println(&amp;quot;Person类singSong的返回值类型&amp;quot;+clazz.getDeclaredMethod(&amp;quot;singSong&amp;quot;).getReturnType());
                } catch (NoSuchMethodException | SecurityException e)
                {
                        // TODO Auto-generated catch block
                        System.out.println(&amp;quot;没有对应的方法&amp;quot;+e.getMessage());
                }catch (InstantiationException | IllegalAccessException e)
                {
                        // TODO Auto-generated catch block
                        System.out.println(&amp;quot;获取实例异常&amp;quot;+e.getMessage());
                }catch (IllegalArgumentException | InvocationTargetException e)
                {
                        // TODO Auto-generated catch block
                        System.out.println(&amp;quot;Invoke异常&amp;quot;+e.getMessage());
                }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个餐厅的菜单实例：&lt;/p&gt;

&lt;p&gt;通过一个food接口，创建多样菜单，并且易于拓展性。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Food.properties:
Apple=com.reflect.test.food.Apple
Banana=com.reflect.test.food.Banana
HongShaoRou=com.reflect.test.food.HongShaoRou
QingJiaoRouSi=com.reflect.test.food.QingJiaoRouSi
SuanTaiChaoRou=com.reflect.test.food.SuanTaiChaoRou
TangCuLiYu=com.reflect.test.food.TangCuLiYu
XiaoChaoRou=com.reflect.test.food.XiaoChaoRou
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Food接口：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.reflect.test.food;

public interface Food {

        String getFoodName();

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;依次创建各个食物：（类似方法）
红烧肉：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.reflect.test.food;

public class HongShaoRou implements Food {

        public static final String foodName = &amp;quot;红烧肉&amp;quot;;

        @Override
        public String getFoodName() {
        return foodName;
        }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;青椒肉丝：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.reflect.test.food;

public class QingJiaoRouSi implements Food {

        public static final String foodName = &amp;quot;青椒肉丝&amp;quot;;

        @Override
        public String getFoodName() {
                return foodName;
        }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;。。。。
餐厅类的实现：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
* 情景 : 有一家餐厅,时常更换菜品 , 客人进店时向客人展示所有的菜品,
* 要求开发一个扩充性好的程序,就是更换菜品时只需要做一些简单的配置就可以
* 
* 反射基本上 自己自学 看的    视频没怎么听

*/
package com.reflect.test;

import java.util.ArrayList;


/**
*  通过下面的餐厅类  很方便的通过Food接口 
*  添加更多的新菜！ 只要你有新定义一个  食物.java 然后在
*  food.properties添加一个键值对即可
*/



/**
* @author    叶昭良
* @time      2015年3月3日下午4:44:15
* @version   com.reflect.testRestaurant V1.0
*/
import com.reflect.test.food.*;

import java.util.*;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;


public class Restaurant 
{

        /**
         * @param args
         */
        //没有想到用list表来接数据（一定要有集合的概念）
        private List&amp;lt;Food&amp;gt;  foods = new ArrayList&amp;lt;Food&amp;gt;();
        
        //定义一个init函数 用于在构造函数内部 调用，并初始化菜单！准备开张 开店铺
        public Restaurant()
        {
        }
        public void init()
        {
                try
                {
                        InputStream is = Restaurant.class.getResourceAsStream(&amp;quot;food.properties&amp;quot;);
                        Properties prop = new Properties();
                        /**
                         *  要知道 food.properties 的key-value的写法
                         *  Prop对象就是一个map对象
                         *  先前只写上一个值是错误的！ 必须写上
                         *  Apple=com.reflect.test.food.Apple
                         */
                        //必须加在src底下
                        //prop.load(new FileInputStream(&amp;quot;food.properties&amp;quot;));
                        try
                        {
                                prop.load(is);
                        } catch (IOException e)
                        {
                                // TODO Auto-generated catch block
                                e.printStackTrace();
                        }
                        Collection  coll1 = prop.values();
                        for(Object foodClassName:coll1)
                        {
                                Class temp;
                        
                                temp = Class.forName((String)(foodClassName));
                                
                                Food food = (Food)temp.newInstance();
                                foods.add(food);
                        }
                }catch (ClassNotFoundException e)
                {
                        // TODO Auto-generated catch block
                        System.out.println(&amp;quot;未找到对应的类&amp;quot;);
                }catch (InstantiationException e)
                {
                        // TODO Auto-generated catch block
                        System.out.println(&amp;quot;产生实例的异常&amp;quot;);
                } catch (IllegalAccessException e)
                {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                }
                
        }
        public void showFoods()
        {
                for(Food temp:foods)
                {
                        //Food接口创建的一个唯一接口方法
                        System.out.println(temp.getFoodName());
                }
        }
        public static void main(String[] args)
        {
                // TODO Auto-generated method stub
                //开了一家店
                Restaurant res = new Restaurant();
                System.out.println(&amp;quot;欢饮各位宾客的到来-- 鞭炮响起&amp;quot;);
                System.out.println(&amp;quot;******************************&amp;quot;);
                res.showFoods();
        }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3：内省&lt;/p&gt;

&lt;p&gt;在满足javaBean规范的类中，在不清楚字段的前提下，通过getter &amp;amp;setter获得所有的字段，一般和反射联合使用。&lt;/p&gt;

&lt;p&gt;Javabean 其实就是满足规范，具体规范是有&lt;/p&gt;

&lt;p&gt;私有变量
Getter andsetter方法
至少有一个无参构造函数&lt;/p&gt;

&lt;p&gt;然后可以通过 类 Introspector 来获取某个对象的 BeanInfo 信息，然后通过 BeanInfo 来获取属性的描述器（ PropertyDescriptor ），通过这个属性描述器就可以获取某个属性对应的 getter/setter 方法，然后我们就可以通过反射机制来调用这些方法。javabean的实例对象称之为值对象（ValueObject）,因为这些bean中通常只有一些信息字段和存储方法，没有功能性方法。
分为两种情况，只是设置或者得到某个具体的字段&lt;/p&gt;

&lt;p&gt;两外一种是获得所有的字段。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
* 
*/
package com.introspect.test;

import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

/**
* @author    叶昭良
* @time      2015年3月3日下午6:34:08
* @version   com.introspect.testTestStudentIntrospect V1.0
*/
public class TestStudentIntrospect
{

        /**
         * @param args
         */
        public static void main(String[] args)
        {
                // TODO Auto-generated method stub
                Student wangxiuyan = new Student();//new Student(&amp;quot;001&amp;quot;,&amp;quot;王秀艳&amp;quot;,30);
                String fieldName=&amp;quot;Age&amp;quot;;
                //通过javabeans--&amp;gt;具体某个属性---&amp;gt; 通过反射获取方法！ --&amp;gt;再调用方法
                getProperty(wangxiuyan, fieldName);
                setProperty(wangxiuyan, fieldName);
                getProperties(wangxiuyan, fieldName);
        
        }
        private static void getProperties(Student stu,String fieldName)
        {
                try
                {
                        BeanInfo  beanInfo = Introspector.getBeanInfo(stu.getClass());
                        PropertyDescriptor[] pro = beanInfo.getPropertyDescriptors();
                        for(PropertyDescriptor temp : pro)
                        {
                                if(temp.getName().equals(fieldName))
                                {
                                        Method methodx = temp.getReadMethod();

                                        System.out.println(methodx.invoke(stu)); 
                                        
                                }
                        }
                } catch (IntrospectionException e)
                {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                }catch (IllegalAccessException | IllegalArgumentException
                                | InvocationTargetException e)
                {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                }
                
        }
        
        private static void getProperty(Student stu,String fieldName)
        {
                try
                {
                        PropertyDescriptor pro = new PropertyDescriptor(fieldName, Student.class);
                        Method methodx = pro.getReadMethod(); //
                        Object ojx = methodx.invoke(stu);
                        System.out.println(ojx);
                } catch (IntrospectionException  e)
                {
                        // TODO Auto-generated catch block
                        System.out.println(&amp;quot;属性描述获取失败&amp;quot;);
                }catch(IllegalAccessException | IllegalArgumentException | InvocationTargetException e)
                {
                        System.out.println(&amp;quot;invoke调用失败！&amp;quot;);
                }
                
        }
        private static void setProperty(Student stu,String fieldName)
        {
                try
                {
                        PropertyDescriptor pro = new PropertyDescriptor(fieldName, Student.class);
                        Method methodx = pro.getWriteMethod(); //
                        methodx.invoke(stu,8);
                        System.out.println(stu.getAge());
                } catch (IntrospectionException  e)
                {
                        // TODO Auto-generated catch block
                        System.out.println(&amp;quot;属性描述获取失败&amp;quot;);
                }catch(IllegalAccessException | IllegalArgumentException | InvocationTargetException e)
                {
                        System.out.println(&amp;quot;invoke调用失败！&amp;quot;);
                }        
        }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ORM的实现在：&lt;a href=&#34;http://www.rupeng.com/forum/thread-44526-1-1.html&#34; target=&#34;_blank&#34;&gt;http://www.rupeng.com/forum/thread-44526-1-1.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;4：正则表达式&lt;/p&gt;

&lt;p&gt;字符串内置函数：&lt;/p&gt;

&lt;p&gt;String的split、replace、replaceAll函数。&lt;/p&gt;

&lt;p&gt;在正则表达式中$表示在另一个字符串中获取正则表达式字符串匹配的小组号，$1表示第一个。。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;          \1 表示在同一个匹配正则表达式获得第一个匹配项(\2则表示在同一个匹配正则表达式获得第二个引用的匹配项)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//字符串测试
System.out.println(&amp;quot;fdasfsd&amp;quot;.indexOf(&#39;d&#39;));

        System.out.println(&amp;quot;fdasfsd&amp;quot;.lastIndexOf(&#39;d&#39;));

        String[] temp =&amp;quot;sdfddfdsgsdfddg&amp;quot;.split(&amp;quot;([a-z])\\1+&amp;quot;);
        for(String p : temp)
        {
        System.out.println(p);
        }

        System.out.println(&amp;quot;sdfddfdsgsdfddg&amp;quot;.replaceAll(&amp;quot;([a-z])\\1+&amp;quot;,&amp;quot;*&amp;quot;));

        System.out.println(&amp;quot;sdfddfdsgsdfddg&amp;quot;.replaceAll(&amp;quot;([a-z])\\1+&amp;quot;,&amp;quot;$1&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Pattern&amp;amp;Matcher组合&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//工作中的  正则获取方式
                System.out.println(&amp;quot;2020&amp;quot;.matches(&amp;quot;\\d{3,10}&amp;quot;));
                
                String pat = &amp;quot;Welcome to china to have a pinny lunch ! Start the lesson&amp;quot;;
                Pattern p = Pattern.compile(&amp;quot;\\b[a-z]{5}\\b&amp;quot;);
                Matcher m = p.matcher(pat);
                while(m.find())
                {
                        System.out.println(m.group());
                }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;常见的存储结构：&lt;/p&gt;

&lt;p&gt;|&amp;mdash;&amp;ndash;顺序存储结构 特点是借助于数据元素的相对存储位置来表示数据元素之间的逻辑结构；
|&amp;mdash;&amp;ndash;链式存储结构 特点是借助于指示数据元素地址的指针表示数据元素之间的逻辑结构。
|&amp;mdash;&amp;ndash;散列存储结构 顺序+算列。
|&amp;mdash;&amp;ndash;索引存储结构 顺序+索引。&lt;/p&gt;

&lt;p&gt;常见的逻辑结构：
对数据及其关系的抽象逻辑描述，对立与计算机，与机器实现无关。
根据定义的关系不同，数据的逻辑结构分为四种：
|&amp;mdash;&amp;ndash;集合结构。数据元素之间未定义任何关的松散集合。
|&amp;mdash;&amp;ndash;线性结构。数据元素之间定义了次序关系的集合（全序集合），描述的是1对1关系。
|&amp;mdash;&amp;ndash;树形结构。数据元素之间定义了层次关系的集合（偏序集合），描述的是1对多关系。
|&amp;mdash;&amp;ndash;图状结构。数据元素之间定义了网状关系的集合，描述的是多对多关系。&lt;/p&gt;

&lt;p&gt;数据结构，就是相互之间存在一种或多种特定关系的数据元素的集合。可以简单表示为：数据结构 = 数据 + 关系。同一数据元素集合，所定一的关系不同，构成不同的数据结构。 数据结构包括逻辑结构和存储结构两个方面&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>简易的代码运行模拟窗口</title>
      <link>https://jueqingsizhe66.github.io/blog/2015/05/11/jian-yi-de-dai-ma-yun-xing-mo-ni-chuang-kou/</link>
      <pubDate>Mon, 11 May 2015 14:58:46 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/blog/2015/05/11/jian-yi-de-dai-ma-yun-xing-mo-ni-chuang-kou/</guid>
      <description>&lt;p&gt;有时候，可能需要做一个动态的代码演示的窗口，当然用ppt也可以做，用其他的相关软件也可以做。然而自己写代码也是可以的。相信大家在听杨老师讲解treeview的时候，老杨秀的代码分析小程序，凭着印象，自己也琢磨着写了这一个简易的代码运行模拟窗口。代码涉及到的主要是treeview和textview以及按钮事件控制，另外加上cairo的画图处理，当然也可以直接利用GtkImage载入图片（可能需要隐藏控件，达到箭头下移的目的）
这边的缺点是，暂时不知道怎么销毁掉Cairo之前绘制的图形，其他还有很多缺点.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import com.rupeng.gtk4j.Cairo;
import com.rupeng.gtk4j.GTK;
import com.rupeng.gtk4j.IGCallBack;

/**
* @author    叶昭良
* @time      2015年2月3日上午10:24:23
* @version   TestTeacher V1.0   一个简易的代码运行模拟窗口，未加入代码的高亮，采用图片控制
*                               主要采用textview  treeview    cairo三个技术关键点
*/
public class TestTeacher
{

        /**
         * @param args
         */
        //部分类变量的定义
        static int window;
        static int gridHouse;

        static int liststore;
        static int listiter;
        static int treeViewApple;
        static int imagePosition = 0;
        static int rowPosition = 0;
        //static int dan ;
        static int start = 0;
        static int circlePointx = 200;
        static int circlePointy = 45;
        
        static int circleRectangex = 200;
        static int circleRectangey = 0;
        
        static int EndCirclex = 0;
        static int EndCircley = 0;
        static String note = &amp;quot;指针下移&amp;quot;;
        static int labelResult;
        
        //static String loveWords;
        public static void main(String[] args)
        {
                // TODO Auto-generated method stub
                //GTK初始化
                GTK.gtk_init();
                //窗口对象标识的创建
                window= GTK.gtk_window_new(GTK.GTK_WINDOW_TOPLEVEL);
                //显示窗口
                GTK.gtk_widget_show(window);
                //安静关闭窗口
                GTK.g_signal_connect(window, &amp;quot;destroy&amp;quot;, new IGCallBack()
                {
                        
                        @Override
                        public void execute(int instance, int eventData, Object object)
                        {
                                // TODO Auto-generated method stub
                                GTK.gtk_main_quit();
                        }
                }, null);
                
                //设置网格布局
                gridHouse = GTK.gtk_grid_new();
                GTK.gtk_widget_show(gridHouse);
                //添加网格布局到window中
                GTK.gtk_container_add(window, gridHouse);
                
                //定义一些常用的控件
                
                //创建一个treeview 用于显示用户信息
                createSingleTreeView(gridHouse,start);
                //创建一个笑脸
                createDrawLaughFace(window,gridHouse,start,circlePointx,circlePointy);
                
                start = 3;
                //创建一个标签
                createLabel(&amp;quot;源代码------&amp;gt;&amp;quot;,gridHouse,start);
                start = 4;
                //创建一个源码的textview窗口，不可编辑
                createSingleTextView(window,gridHouse,start);
                createRectangleFace(window,gridHouse,3,circlePointx,circlePointy);

                start = 4;
                //创建一个按钮
                int textViewOutput = GTK.gtk_text_view_new();
                createNextButton(gridHouse,textViewOutput,start);
                
                start =3;
                //创建一个标签
                labelResult = GTK.gtk_label_new(&amp;quot;输出结果：&amp;quot;);
                GTK.gtk_widget_show(labelResult);
                GTK.gtk_grid_attach(gridHouse, labelResult,7, start, 1, 1);
                start = 4;

                //创建一个输出界面，用于显示源码输出地结果
                createOutputTextView(window,gridHouse,start,textViewOutput);
                //启动循环
                GTK.gtk_main();
        }
        /**
         * 
         * @param labelName  标签显示的字符串
         * @param gridHouse  网格对象标识
         * @param start      标签在网格对象标识的起始位置
         * @purpose          创建一个标签对象表示，并显示在窗口中
         */
        public static void createLabel(String labelName,int gridHouse,int start)
        {
                int labelTitle = GTK.gtk_label_new(labelName);
                GTK.gtk_widget_show(labelTitle);
                GTK.gtk_grid_attach(gridHouse, labelTitle, 0, start, 1, 1);

        }
        /**
         * 
         * @param scrolledBar    滚动条对象标识
         * @param textview        textview的对象标识
         * @param gridHouse       网格对象的对象标识
         * @param start          textview在网格对象布局的起始位置
         * @purpose              创建textView的滚动条
         */
        public static void createTextviewScrollBar(int scrolledBar,int textview,int gridHouse,int start)
        {
                scrolledBar = GTK.gtk_scrolled_window_new();
                GTK.gtk_widget_show(scrolledBar);
                GTK.gtk_grid_attach(gridHouse, scrolledBar, 0, start, 2, 2);
                GTK.gtk_widget_set_size_request(scrolledBar, 400, 400);
                GTK.gtk_container_add(scrolledBar,textview);
        }
        /**
         * 
         * @param scrolledBar     滚动条对象标识
         * @param textview        textview的对象标识
         * @param gridHouse       网格对象的对象标识
         * @param start          textview在网格对象布局的起始位置
         * @purpose               创建带滚动条的treeview对象标识,用于输出信息
         */
        public static void createTreeviewScrollBar(int scrolledBar,int textview,int gridHouse,int start)
        {
                scrolledBar = GTK.gtk_scrolled_window_new();
                GTK.gtk_widget_show(scrolledBar);
                GTK.gtk_grid_attach(gridHouse, scrolledBar, 0, start, 2, 3);
                GTK.gtk_widget_set_size_request(scrolledBar, 200, 200);
                GTK.gtk_container_add(scrolledBar,textview);
        }
        /**
         * 
         * @param scrolledBar    滚动条对象标识
         * @param textview       textview的对象标识
         * @param gridHouse      网格对象的对象标识
         * @param start          textview在网格对象布局的起始位置
         * @purpose              创建带滚动条的treeview对象标识，用于显示信息
         */
        public static void createTreeviewOutputScrollBar(int scrolledBar,int textview,int gridHouse,int start)
        {
                scrolledBar = GTK.gtk_scrolled_window_new();
                GTK.gtk_widget_show(scrolledBar);
                GTK.gtk_grid_attach(gridHouse, scrolledBar,8, start, 2, 3);
                GTK.gtk_widget_set_size_request(scrolledBar, 200, 200);
                GTK.gtk_container_add(scrolledBar,textview);
        }
        /**
         * 
         * @param window     窗口对象标识
         * @param gridHouse  网格布局对象标识
         * @param start       textview对象在网格布局对象中的起始位置
         * @purpose          创建一个textview的源代码窗口对象
         */
        public static void createSingleTextView(int window, int gridHouse, int start)
        {

                final int tvGirl = GTK.gtk_text_view_new();
                GTK.gtk_text_view_set_wrap_mode(tvGirl, GTK.GTK_WRAP_WORD);
                int scrollBar = 0 ;
                //添加控件
                GTK.gtk_text_view_set_editable(tvGirl, false);
                createTextviewScrollBar(scrollBar,tvGirl,gridHouse,start);
                //GTK.gtk_grid_attach(gridHouse, tvGirl, 0, start+1, 1, 1);

                //显示控件

                GTK.gtk_widget_show(tvGirl);

                String loveWords = &amp;quot;if(!GTK.gtk_tree_model_get_iter_first(liststore.listiter))&amp;quot;
                                + &amp;quot;\n{\n\tSystem.out.println(\&amp;quot;100块钱都不给，真坏！\&amp;quot;);\n}\nelse\n{\n\tdo&amp;quot;
                                + &amp;quot;\n\t{\n\t\tSystem.out.println(\&amp;quot;我在do循环里面\&amp;quot;);\n\t}while(GTK.gtk_tree_model_iter_next(liststore, iter));&amp;quot;
                                + &amp;quot;\n}\nGTK.gtk_text_iter_free(iter);&amp;quot;;
                //读取文本框里面的内容 ，只适用小量的文本，一般用迭代器
                //方法1   先从TextView获取int TextBuffer 
                    //    然后再从TextBuffer获取text
                final int textbuffer= GTK.gtk_text_view_get_buffer(tvGirl);

                
                //可以直接通过缓冲区编号  设置信息
                GTK.gtk_text_buffer_set_text(textbuffer, loveWords);
                
                
        }
        /**
         * 
         * @param window     窗口对象标识（可省略）
         * @param gridHouse  网格对象标识
         * @param start      网格对象的起始位置标识
         * @param tvGirl     treeview对象标识
         * @purpose          创建一个TextView对象标识，加入滚动条，并显示。
         */
        public static void createOutputTextView(int window, int gridHouse, int start,int tvGirl)
        {

                //tvGirl = GTK.gtk_text_view_new();
                GTK.gtk_text_view_set_wrap_mode(tvGirl, GTK.GTK_WRAP_WORD);
                int scrollBar = 0 ;
                //添加控件
                GTK.gtk_text_view_set_editable(tvGirl, false);
                createTreeviewOutputScrollBar(scrollBar,tvGirl,gridHouse,start);
                //GTK.gtk_grid_attach(gridHouse, tvGirl, 0, start+1, 1, 1);

                //显示控件

                GTK.gtk_widget_show(tvGirl);

                String loveWords = &amp;quot;&amp;quot;;
                //读取文本框里面的内容 ，只适用小量的文本，一般用迭代器
                //方法1   先从TextView获取int TextBuffer 
                    //    然后再从TextBuffer获取text
                final int textbuffer= GTK.gtk_text_view_get_buffer(tvGirl);

                
                //可以直接通过缓冲区编号  设置信息
                GTK.gtk_text_buffer_set_text(textbuffer, loveWords);
                
                
        }
        /**
         * 
         * @param gridHouse  网格对象标识
         * @param start      网格对象的起始位置标识
         * @purpose          创建一个TreeView对象标识，写入字段，添加记录，加入滚动条，并显示。
         */
        public static void createSingleTreeView(int gridHouse,int start)
        {
                //3  treeview   是一个界面，相当于是一个淘宝前台， V  V的作用
                                treeViewApple = GTK.gtk_tree_view_new();
                                //4 建立字段  比较费劲
                                //4.1创建字段
                                int columnID = GTK.gtk_tree_view_column_new_with_attributes(&amp;quot;ID&amp;quot;, GTK.gtk_cell_renderer_text_new(), 0);
                                //4.2添加字段
                                GTK.gtk_tree_view_append_column(treeViewApple, columnID);
                                //4.3创建字段
                                int columnName = GTK.gtk_tree_view_column_new_with_attributes(&amp;quot;Names&amp;quot;,GTK.gtk_cell_renderer_text_new(),1);
                                //4.4添加字段
                                GTK.gtk_tree_view_append_column(treeViewApple,columnName);
                                //4.5创建字段
                                int  columnAge = GTK.gtk_tree_view_column_new_with_attributes(&amp;quot;Ages&amp;quot;,GTK.gtk_cell_renderer_text_new(),2);
                                GTK.gtk_tree_view_append_column(treeViewApple,columnAge);
                                
                                //创建控件
                                //1  list_store  是一个数据结构库，相当于一个仓库  M model的作用
                                liststore = GTK.gtk_list_store_new(3); //3代表三个字段：ID  Names   Age
                        //        GTK.gtk_list_store_append(list_store, iter);
                                //2  list_iter,list_iter是一个内部的数据迭代的控制过程，不需要显示 C的作用，控制
                                listiter = GTK.gtk_tree_iter_new();

                                //5  第五步 把 iter和listStore联系起来
                                          //GTK.gtk_text_buffer_get_end_iter 类似于treeview的buffer和iter联系起来
                                           // 以后就可以通过GTK.gtk_text_buffer_insert默认是一个一个iter的执行。
                                GTK.gtk_list_store_append(liststore, listiter); //指针开始指到第一个位置
                                // 6 逐个iter添加数据到liststore当中:每个iter的意思，就是逐行或者逐个记录。
                                GTK.gtk_list_store_set_value(liststore, listiter, 0, &amp;quot;001&amp;quot;);
                                GTK.gtk_list_store_set_value(liststore, listiter, 1, &amp;quot;YinMuHuaDao&amp;quot;);
                                GTK.gtk_list_store_set_value(liststore, listiter, 2, &amp;quot;35&amp;quot;);
                                GTK.gtk_list_store_append(liststore, listiter); //如果不加入，指针不下移，只会覆盖掉前面的数据
                                GTK.gtk_list_store_set_value(liststore, listiter, 0, &amp;quot;002&amp;quot;);
                                GTK.gtk_list_store_set_value(liststore, listiter, 1, &amp;quot;Taiyanghua&amp;quot;);
                                GTK.gtk_list_store_set_value(liststore, listiter, 2, &amp;quot;29&amp;quot;);
                                GTK.gtk_list_store_append(liststore, listiter);
                                GTK.gtk_list_store_set_value(liststore, listiter, 0 ,&amp;quot;003&amp;quot;);
                                GTK.gtk_list_store_set_value(liststore, listiter, 1 ,&amp;quot;Xiaojun&amp;quot;);
                                GTK.gtk_list_store_set_value(liststore, listiter, 2 ,&amp;quot;10&amp;quot;);
                                // 之所以添加9次是因为  3个字段*3条记录 == 9
                                
                                //7  使用完iter之后一定要记得 关掉它
                                GTK.gtk_tree_iter_free(listiter);
                                
                                //8 关键的一步，把数字显示出来
                                GTK.gtk_tree_view_set_model(treeViewApple, liststore);

                                //并同时把它显示出来，前台必须显示
                                GTK.gtk_widget_show(treeViewApple);
                                
                                //添加到滚动条中
                                int scrolledbar2 = 0;
                                createTreeviewScrollBar(scrolledbar2,treeViewApple,gridHouse,start);
                                
                                //设置部分参数
                                int column =GTK.gtk_tree_view_get_column(treeViewApple, 1);
                                GTK.gtk_tree_view_column_set_sort_column_id(column, 1);
                                GTK.gtk_tree_view_column_set_resizable(column, true);
                                GTK.gtk_tree_view_column_set_reorderable(column, true);
        }
        
        /**
         * 
         * @param window          窗口的对象标识
         * @param gridHouse       网格布局的对象标识
         * @param start           对象所在的网格布局起始位置
         * @param circlePointx    画笔的x轴位置
         * @param circlePointy    画笔的y轴位置
         * @purpose               绘制一个笑脸
         */
        public static void createDrawLaughFace(int window,int gridHouse,int start,final int circlePointx,final int circlePointy) 
        {
                //创建画图板 或者叫画布
                int dan  = GTK.gtk_drawing_area_new();
                
                //创建源
                //添加控件
                start = 0;
                GTK.gtk_grid_attach(gridHouse, dan, 1, start, 1, 1);
                //显示画布
                GTK.gtk_widget_show(dan);
                

                
                //设置画布的大小
                GTK.gtk_widget_set_size_request(dan, 300, 300);
                
                
                //开始绘制  利用事件draw 来不断的绘制
                
                GTK.g_signal_connect(dan, &amp;quot;draw&amp;quot;,new IGCallBack() 
                {
                        @Override
                        public void execute(int instance, int eventData, Object object)
                        {
                                // TODO 自动生成的方法存根
                                //eventDate才是画布源
                                //设置画笔的颜色
                                //Cairo.cairo_destroy(eventData);
                                Cairo.cairo_set_source_rgb(eventData, 1, 0, 0);
                                //设置画笔的大小
                                Cairo.cairo_set_line_width(eventData, 3);                        
                                Cairo.cairo_move_to(eventData, circlePointx-20, circlePointy);
                                Cairo.cairo_line_to(eventData, circlePointx-70, circlePointy);
                                Cairo.cairo_line_to(eventData, circlePointx-60, circlePointy-5);
                                Cairo.cairo_move_to(eventData, circlePointx-70, circlePointy);
                                Cairo.cairo_line_to(eventData, circlePointx-60, circlePointy+5);
                                Cairo.cairo_stroke(eventData);
                                
                                //画一个圆
                                Cairo.cairo_arc(eventData, circlePointx, circlePointy, 10, 0, 2*3.1415926);
                                //画一个圆弧
                                //Cairo.cairo_arc(eventData, 200, 200, 70,1.5*3.1415925, 2*3.1415926);
                                //显示画笔
                                Cairo.cairo_stroke(eventData); //Cairo.cairo_fill(eventData)不同的效果
                                
                                
                                //画一个圆弧  有下面实验知道是从x轴沿顺时针开始画图

                                //嘴巴的绘制
                                double Pi = 3.1415926;
                                Cairo.cairo_arc(eventData, circlePointx, circlePointy, 5, 0.25*Pi, 0.75*Pi);
                                Cairo.cairo_fill(eventData);
                                
                                //绘制两只眼睛
                                Cairo.cairo_arc(eventData, circlePointx-5, circlePointy-5, 3, 0, 2*Pi);
                                Cairo.cairo_arc(eventData, circlePointx+5, circlePointy-5, 3, 0, 2*Pi);
                                Cairo.cairo_fill(eventData);
                                
                                

                                //画文字
                                Cairo.cairo_move_to(eventData, circlePointx+10, circlePointy+5);
                                Cairo.cairo_set_source_rgb(eventData, 0.4, 0.3, 0.2);
                                Cairo.cairo_set_font_size(eventData, 16);
                                //选择文字类型
                                Cairo.cairo_select_font_face(eventData, &amp;quot;宋体&amp;quot;, Cairo.CAIRO_FONT_SLANT_ITALIC, Cairo.CAIRO_FONT_WEIGHT_BOLD);
                                Cairo.cairo_show_text(eventData,note);
                                //Cairo.cairo_stroke(eventData);  //不需要这句话也可以
                                
                        }
                }, null);
                
                
        }
        /**
         * 
         * @param window          窗口的对象标识
         * @param gridHouse       网格布局的对象标识
         * @param start           矩形对象所在的网格布局起始位置
         * @param circlePointx    画笔的x轴位置
         * @param circlePointy    画笔的y轴位置
         * @purpose               绘制一个矩形图像
         */
        public static void createRectangleFace(int window,int gridHouse,int start,final int circlePointx,final int circlePointy) 
        {
                //创建画图板 或者叫画布
                int dan  = GTK.gtk_drawing_area_new();
                
                //创建源
                //添加控件
                start = 4;
                GTK.gtk_grid_attach(gridHouse, dan, 0, start, 1, 1);
                //显示画布
                GTK.gtk_widget_show(dan);
                

                
                //设置画布的大小
                GTK.gtk_widget_set_size_request(dan, 300, 300);
                
                
                //开始绘制  利用事件draw 来不断的绘制
                
                GTK.g_signal_connect(dan, &amp;quot;draw&amp;quot;,new IGCallBack() 
                {
                        @Override
                        public void execute(int instance, int eventData, Object object)
                        {
                                // TODO 自动生成的方法存根
                                //eventDate才是画布源
                                //设置画笔的颜色
                                //Cairo.cairo_destroy(eventData);
                                Cairo.cairo_set_source_rgb(eventData, 0, 1, 0);
                                //设置画笔的大小
                                Cairo.cairo_set_line_width(eventData, 3);                        
                                //Cairo.cairo_move_to(eventData, circlePointx-20, circlePointy);

                                
                                //画一个矩形
                                Cairo.cairo_rectangle(eventData, circleRectangex-150, circleRectangey+120, 250, 20);
                                Cairo.cairo_stroke(eventData);
                                //画文字
                                Cairo.cairo_move_to(eventData, circleRectangex+10, circleRectangey+100);
                                Cairo.cairo_set_source_rgb(eventData, 0, 0, 1);
                                Cairo.cairo_set_font_size(eventData, 18);
                                //选择文字类型
                                Cairo.cairo_select_font_face(eventData, &amp;quot;宋体&amp;quot;, Cairo.CAIRO_FONT_SLANT_NORMAL, Cairo.CAIRO_FONT_WEIGHT_BOLD);
                                Cairo.cairo_show_text(eventData,&amp;quot;循环第&amp;quot;+Integer.toString(rowPosition)+&amp;quot;次&amp;quot;);//
                                //Cairo.cairo_stroke(eventData);  //不需要这句话也可以
                                
                        }
                }, null);
                
                
        }
        /**
         * 
         * @param window          窗口的对象标识
         * @param gridHouse       网格布局的对象标识
         * @param start           矩形对象所在的网格布局起始位置
         * @param circlePointx    画笔的x轴位置
         * @param circlePointy    画笔的y轴位置
         * @purpose               绘制一个圆圈图像 + 终止表示！
         */
        public static void createCircleFace(int window,int gridHouse,int start,final int circlePointx,final int circlePointy) 
        {
                //创建画图板 或者叫画布
                int dan  = GTK.gtk_drawing_area_new();
                
                //创建源
                //添加控件
                start = 4;
                GTK.gtk_grid_attach(gridHouse, dan, 0, start, 1, 1);
                //显示画布
                GTK.gtk_widget_show(dan);
                

                
                //设置画布的大小
                GTK.gtk_widget_set_size_request(dan, 300, 300);
                
                
                //开始绘制  利用事件draw 来不断的绘制
                
                GTK.g_signal_connect(dan, &amp;quot;draw&amp;quot;,new IGCallBack() 
                {
                        @Override
                        public void execute(int instance, int eventData, Object object)
                        {
                                // TODO 自动生成的方法存根
                                //eventDate才是画布源
                                //设置画笔的颜色
                                //Cairo.cairo_destroy(eventData);
                                Cairo.cairo_set_source_rgb(eventData, 1, 0, 1);
                                //设置画笔的大小
                                Cairo.cairo_set_line_width(eventData, 3);                        
                                //Cairo.cairo_move_to(eventData, circlePointx-20, circlePointy);

                                
                                //画一个矩形
                                Cairo.cairo_arc(eventData, EndCirclex+150, EndCircley+200, 100, 0, 6.28);
                                Cairo.cairo_stroke(eventData);
                                //画文字
                                Cairo.cairo_move_to(eventData, EndCirclex+50, EndCircley+200);
                                Cairo.cairo_set_source_rgb(eventData, 1, 0, 1);
                                Cairo.cairo_set_font_size(eventData, 18);
                                //选择文字类型
                                Cairo.cairo_select_font_face(eventData, &amp;quot;宋体&amp;quot;, Cairo.CAIRO_FONT_SLANT_NORMAL, Cairo.CAIRO_FONT_WEIGHT_BOLD);
                                Cairo.cairo_show_text(eventData,&amp;quot;循环第&amp;quot;+Integer.toString(rowPosition+1)+&amp;quot;次,程序终止退出！&amp;quot;);//
                                //Cairo.cairo_stroke(eventData);  //不需要这句话也可以
                                
                        }
                }, null);
                
                
        }
        /**
         * 
         * @param gridHouse         网格布局对象标识
         * @param textViewOutput    textview的对象标识
         * @param start             textview对象在网格布局的起始位置
         * @purpose                 创建一个下一步button，并添加事件监听
         */
        public static void createNextButton(int gridHouse,int textViewOutput,int start)
        {
                int btnApple = GTK.gtk_button_new_with_label(&amp;quot;下一步&amp;quot;);
                GTK.gtk_widget_show(btnApple);
                GTK.gtk_grid_attach(gridHouse, btnApple, 6, start, 1, 1);
                insertNextEvent(btnApple,textViewOutput);
        }
        /**
         * 
         * @param btnSin            button下一步的对象标识
         * @param textViewOutput    textview的对象标识
         * @purpose                 建立button下一步的事件监听
         */
        public static void insertNextEvent(final int btnSin,final int textViewOutput)
        {
                GTK.g_signal_connect(btnSin, &amp;quot;clicked&amp;quot;,new IGCallBack()
                {
                        @Override
                        public void execute(int instance, int eventData, Object object)
                        {
                                
                                // TODO 自动生成的方法存根
                                //double sbValue = GTK.gtk_spin_button_get_value(spinbox);
                                if(rowPosition &amp;lt; getNumberOfListstore(liststore))
                                {
                                        circlePointy = circlePointy+20;
                                        //创建笑脸
                                        createDrawLaughFace(window,gridHouse,start,circlePointx,circlePointy);
                                        //创建矩形框
                                        createRectangleFace(window,gridHouse,start+1,circleRectangex,circleRectangey);
                                        printRecord(liststore);
                                        InsertStringToTextViewFunction(textViewOutput,&amp;quot;我在do循环里面  \n&amp;quot;);
                                        rowPosition =  rowPosition +1;
                                }
                                else 
                                {
                                        
                                        //note = &amp;quot;指针无法下移&amp;quot;;
                                        circlePointy = circlePointy+20;
                                        if(rowPosition &amp;gt; getNumberOfListstore(liststore))
                                        {
                                                createDrawLaughFace(window,gridHouse,start,circlePointx,circlePointy);
                                        }
                                        
                                        createRectangleFace(window,gridHouse,start+1,circleRectangex,circleRectangey);
                                        createCircleFace(window,gridHouse,start,EndCirclex,EndCircley);
                                        InsertStringToTextViewFunction(textViewOutput,&amp;quot;别嗯了！程序没有数据了\n&amp;quot;);
                                        showInfo(&amp;quot;没有数据了&amp;quot;,&amp;quot;指针无法下移&amp;quot;);
                                }

                        }
                }, null);
        }
        /**
         * 
         * @param liststore   liststore是treeview的原始数据
         * @return            返回liststore的记录个数
         */
        public static int getNumberOfListstore(int liststore)
        {
                int sum = 0;
                int iter = GTK.gtk_tree_iter_new();
                if(!GTK.gtk_tree_model_get_iter_first(liststore, iter))
                {
                        return sum;
                }
                do
                {
                        sum++;
                }while(GTK.gtk_tree_model_iter_next(liststore, iter));
                return sum;
        }
        /**
         * 
         * @param liststore   liststore是treeview的原始数据
         * @purpose           打印liststore的所有内容
         */
        public static void printRecord(int liststore)
        {
                //必须新建，不能利用原先的listiter,哪边需要用控制，就需要建一个控件。！！！否则报错！！不能用全局的 listiter
                int iter = GTK.gtk_tree_iter_new();
                int i  =0;
/*                if(GTK.gtk_tree_model_get_iter_first(liststore, listiter))
                {
                        do
                        {
                                String ID = GTK.gtk_tree_model_get_value(liststore, listiter, 0);
                                String Names = GTK.gtk_tree_model_get_value(liststore, listiter, 1);
                                String Ages = GTK.gtk_tree_model_get_value(liststore, listiter, 2);
                                //showInfo(&amp;quot;这个员工的ID是&amp;quot;+ID+&amp;quot;,他的名字是&amp;quot;+Names+&amp;quot;,并且它的年龄是&amp;quot;+Ages,&amp;quot;显示员工信息&amp;quot;);
                                System.out.println(&amp;quot;这个员工的ID是&amp;quot;+ID+&amp;quot;,他的名字是&amp;quot;+Names+&amp;quot;,并且它的年龄是&amp;quot;+Ages);
                                
                        }while(GTK.gtk_tree_model_iter_next(liststore,listiter));
                }else
                {
                        System.out.println(&amp;quot;表中无数据&amp;quot;);
                }*/
                // 减少代码的深度。
                if(!GTK.gtk_tree_model_get_iter_first(liststore, iter))
                {
                        System.out.println(&amp;quot;treeview没有数据  请添加记录&amp;quot;);
                        return;
                }
                do
                {
                        if(rowPosition == i)
                        {
                                String ID = GTK.gtk_tree_model_get_value(liststore, iter, 0);
                                String Names = GTK.gtk_tree_model_get_value(liststore, iter, 1);
                                String Ages = GTK.gtk_tree_model_get_value(liststore, iter, 2);
                                showInfo(&amp;quot;这个员工的ID是&amp;quot;+ID+&amp;quot;,他的名字是&amp;quot;+Names+&amp;quot;,并且它的年龄是&amp;quot;+Ages,&amp;quot;显示员工信息&amp;quot;);
                                //System.out.println(&amp;quot;这个员工的ID是&amp;quot;+ID+&amp;quot;,他的名字是&amp;quot;+Names+&amp;quot;,并且它的年龄是&amp;quot;+Ages);
                                return;
                        }
                        i++;
                        
                }while(GTK.gtk_tree_model_iter_next(liststore,iter));
                
                GTK.gtk_tree_iter_free(iter);//释放了 还是有错误。。。
        }
        /**
         * 
         * @param message    输入一个消息，显示在消息框
         * @param title      消息框的标题
         * @purpose          创建一个消息提示对话框
         */
        public static void showInfo(  String  message,String title)
        {
                int msgDlg = GTK.gtk_message_dialog_new(0, GTK.GTK_DIALOG_DESTROY_WITH_PARENT|
                                GTK.GTK_DIALOG_MODAL,GTK.GTK_MESSAGE_INFO, GTK.GTK_BUTTONS_OK,message);
                GTK.gtk_window_set_title(msgDlg, title);
                int ret = GTK.gtk_dialog_run(msgDlg);
                 
                if( ret == GTK.GTK_RESPONSE_OK)
                {
                        GTK.gtk_widget_destroy(msgDlg);
                }else
                {
                        GTK.gtk_widget_destroy(msgDlg);
                }

        }
        
        public static void createSelection(int gridHouse,int start)
        {
                
        }
        /**
         * 
         * @param textview   textview对象标识
         * @param temp       待插入textview的字符串
         * @purpose          插入一行数据岛textview当中
         */
        public static void InsertStringToTextViewFunction(int textview,String temp)
        {
                //TextIter是一个TextView的迭代器。
                int textBuffer =  GTK.gtk_text_view_get_buffer(textview);
                int textIter = GTK.gtk_text_iter_new();  //这是一个空的iter，需要用textBuffer进行赋值
                //GTK.gtk_text_iter_forward_to_end(textIter);
                GTK.gtk_text_buffer_get_end_iter(textBuffer, textIter);// 或者textview的textBuffer的末尾！
                GTK.gtk_text_buffer_insert(textBuffer, textIter, temp);
                
                //GTK.gtk_text_buffer_g
                GTK.gtk_text_iter_free(textIter);
                
        }
        
        
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;复制代码&lt;/p&gt;

&lt;p&gt;有什么意见，欢迎交流，有什么想法，欢迎交流。~-~&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://jueqingsizhe66.github.io/images/java/chushi.gif&#34; alt=&#34;初始时刻&#34; /&gt;
&lt;img src=&#34;https://jueqingsizhe66.github.io/images/java/diyici.gif&#34; alt=&#34;运行第一次&#34; /&gt;
&lt;img src=&#34;https://jueqingsizhe66.github.io/images/java/chengxujiesu.gif&#34; alt=&#34;程序结束&#34; /&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>网络编程8-12节笔记代码March18th</title>
      <link>https://jueqingsizhe66.github.io/blog/2015/05/11/wang-luo-bian-cheng-8-12jie-bi-ji-dai-ma-march18th/</link>
      <pubDate>Mon, 11 May 2015 14:58:46 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/blog/2015/05/11/wang-luo-bian-cheng-8-12jie-bi-ji-dai-ma-march18th/</guid>
      <description>&lt;p&gt;复习目录
1集合框架&amp;hellip; 2
ArrayList: 2
栈的实现（先进后出）&amp;hellip; 3
队列的实现（先进先出）&amp;hellip; 5
LinkedList: 8
小结：&amp;hellip; 10
HashSet: 10
TreeSet. 14
LinkedHashSet: 22
HashMap: 23
1.位运算符&amp;hellip; 25
2.字节的截断工具：&amp;hellip; 29
3.理解重新调整大小&amp;hellip; 39
4.理解添加&amp;hellip; 41
5.理解说明：&amp;hellip; 44
6.HashMap和HashSet的区别&amp;hellip; 44
7.理解Hash算法&amp;hellip; 45
TreeMap: 45
LinkedHashMap: 45
Iterator: 45
泛型&amp;hellip; 45
Arrays: 46
Collections: 46
多重数据结构的实现：&amp;hellip; 48
ToString. 49
2：反射机制&amp;hellip; 49
类（Class）&amp;hellip; 50
字段&amp;hellip; 51
构造函数&amp;hellip; 52
方法&amp;hellip; 53
3：内省&amp;hellip; 58
4：正则表达式&amp;hellip; 61
字符串内置函数：&amp;hellip; 61
Pattern&amp;amp;Matcher组合：&amp;hellip; 62&lt;/p&gt;

&lt;p&gt;1集合框架
集合是存储对象的对象。
用于存储数据的数据结构，重要！进行源码分析。
要求：熟练掌握增删查改（针对每一种数据结构）！块增删查改等等。并掌握每一种数据结构的本质，优缺点&lt;/p&gt;

&lt;p&gt;|&amp;ndash;Collection
|&amp;mdash;List
|&amp;mdash;&amp;mdash;-ArrayList
|&amp;mdash;&amp;mdash;-LinkedList
|&amp;mdash;&amp;mdash;-HashLinkedList
|&amp;mdash;Set
  |&amp;mdash;&amp;mdash;-HashSet
  |&amp;mdash;&amp;mdash;-TreeSet
|&amp;ndash;Map
|&amp;mdash;&amp;mdash;-HashMap
|&amp;mdash;&amp;mdash;-TreeMap
|&amp;mdash;&amp;mdash;-LinkedHashMap
两个工具类(默认是静态类static 方法)：
|&amp;mdash;Arrays
|&amp;mdash;Collections&lt;/p&gt;

&lt;p&gt;重点：ArrayList , LinkedList, HashMap,进行HashMap的源码追踪。&lt;/p&gt;

&lt;p&gt;ArrayList:
本质：数组，元素有序，可以重复
优点：查找(或者叫做获取get方法效率极高)和遍历
缺点：增加和删除
ArrayList和LinkedList替换掉Vector,Vector在长度不足时候是百分百增长，而前面两个是50%。至于线程的独立性可以让ArrayList和LinkedList接续Serializable&lt;/p&gt;

&lt;p&gt;Vector的方法都是同步的(Synchronized),是线程安全的(thread-safe)，而ArrayList的方法不是，由于线程的同步必然要影响性能，因此,ArrayList的性能比Vector好。
当Vector或ArrayList中的元素超过它的初始大小时,Vector会将它的容量翻倍,而ArrayList只增加50%的大小，这样,ArrayList就有利于节约内存空间
栈的实现（先进后出）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;  			
/**
*  堆栈是先进后出
*/
package com.collections.test;

/**
* @author    叶昭良
* @time      2015年2月23日下午7:47:29
* @version   com.collections.testTestStack V1.0
*/
import java.util.*;
public class TestStack
{

         /**
          * @param args
          */
         private static List&amp;lt;String&amp;gt; list1 = new ArrayList&amp;lt;String&amp;gt;();
         /**
          *
          * @param apple  添加字符串到堆栈中
          */
         public void push(String apple)
         {
                   //list1.addLast(apple);
                   //list1.addOffer(apple);
                  
                   list1.add(apple);
         }
         /**
          *
          * @return  返回待删除的字符串
          */
         public String pop()
         {
                   int length = getListLength(); //笨蛋 直接用 list1.size()就可以了
                   //System.out.println(&amp;quot;长度为：&amp;quot;+length);
                   String apple = list1.get(length-1);
                   //String apple = list1.get(length-1);
                   //第一种方法
                   //return list1.removeLast() 更方便IE
                   //第二种方法
                   //return list1.pollLast();
                   list1.remove(length-1);
                   return apple;
         }
         /**
          *  得到堆栈的长度
          * @return
          */
         private static int getListLength()
         {
                   int sum =0;
                   Iterator&amp;lt;String&amp;gt; it = list1.iterator();
                   while(it.hasNext())
                   {
                            sum++;
                            it.next();
                   }
                   return sum;
         }
        
         public  void sayStatck()
         {
                   Iterator&amp;lt;String&amp;gt; it = list1.iterator();
                   while(it.hasNext())
                   {
                            System.out.println(it.next());
                   }
         }
         public static void main(String[] args)
         {
                   // TODO Auto-generated method stub
                   TestStack ts = new TestStack();
                   ts.push(&amp;quot;apple&amp;quot;);
                   ts.push(&amp;quot;banana&amp;quot;);
                   ts.push(&amp;quot;orange&amp;quot;);
                  
                  
                   ts.sayStatck();
                   String text = ts.pop();
                   ts.sayStatck();
         }

}


  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java
队列的实现（先进先出）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
*
*/
package com.collections.test;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

/**
* @author    叶昭良
* @time      2015年2月23日下午8:07:29
* @version   com.collections.testTestQueue V1.0
*/
public class TestQueue
{

         /**
          * @param args
          */
         private static List&amp;lt;String&amp;gt; list1 = new ArrayList&amp;lt;String&amp;gt;();
         /**
          *
          * @param apple  添加字符串到堆栈中
          */
         public void push(String apple)
         {
                   list1.add(apple);
         }
         /**
          *
          * @return  返回待删除的字符串
          */
         public String pop()
         {
                   //System.out.println(&amp;quot;长度为：&amp;quot;+length);
                   String apple = list1.get(0);
                   //String apple = list1.get(length-1);
                   list1.remove(0);
                   return apple;
         }

        
         public  void sayStatck()
         {
                   Iterator&amp;lt;String&amp;gt; it = list1.iterator();
                   while(it.hasNext())
                   {
                            System.out.println(it.next());
                   }
         }
         /**
          * @param args
          */
         public static void main(String[] args)
         {
                   // TODO Auto-generated method stub
                   // TODO Auto-generated method stub
                   TestQueue ts = new TestQueue();
                   ts.push(&amp;quot;apple&amp;quot;);
                   ts.push(&amp;quot;banana&amp;quot;);
                   ts.push(&amp;quot;orange&amp;quot;);
                  
                  
                   ts.sayStatck();
                   String text = ts.pop();
                   System.out.println(&amp;quot;Pop值：&amp;quot;+text);
                   ts.sayStatck();
                  
                   String text1 = ts.pop();
                   System.out.println(&amp;quot;Pop值：&amp;quot;+text1);
                   ts.sayStatck();
         }

}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ArrayList源码追踪部分：&lt;/p&gt;

&lt;p&gt;调查ArrayList发现了LastIndexOf的一个秒的地方，倒着过来找&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public int lastIndexOf(Object o) {
        if (o == null) {
            for (int i = size-1; i &amp;gt;= 0; i--)
                if (elementData==null)
                    return i;
        } else {
            for (int i = size-1; i &amp;gt;= 0; i--) //秒！
                if (o.equals(elementData))
                    return i;
        }
        return -1;
    }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面的ArrayList.this.add真的是值得学习&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void add(E e) {
            checkForComodification();

            try {
                int i = cursor;
                ArrayList.this.add(i, e);
                cursor = i + 1;
                lastRet = -1;
                expectedModCount = modCount;
            } catch (IndexOutOfBoundsException ex) {
                throw new ConcurrentModificationException();
            }
        }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样的话 会直接定义到本类的add方法，而不会是别的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    
public void add(int index, E element) {
        rangeCheckForAdd(index);

        ensureCapacityInternal(size + 1);  // Increments modCount!!
        System.arraycopy(elementData, index, elementData, index + 1,
                         size - index);
        elementData[index] = element;
        size++;
    }


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;LinkedList:
本质：链表，有序，可以重复
优点：增加和删除
缺点：查找（获取）&lt;/p&gt;

&lt;p&gt;ListIterator的常用方法：&lt;/p&gt;

&lt;p&gt;boolean    hasNext( )   //判断是否还要下一个元素&lt;/p&gt;

&lt;p&gt;Object      next( )   //取出下一个元素,并把指针移动到下一个元素&lt;/p&gt;

&lt;p&gt;int           nextIndex( )   //下一个元素的索引&lt;/p&gt;

&lt;p&gt;boolean    hasPrevious()   //判断是否有前一个元素&lt;/p&gt;

&lt;p&gt;Object      previous( )   //取出前一个元素,并把指针移动到前一个元素&lt;/p&gt;

&lt;p&gt;int           previousIndex( )   //前一个元素的索引&lt;/p&gt;

&lt;p&gt;void        add(Object   o)    //添加一个元素&lt;/p&gt;

&lt;p&gt;void        remove( )   //删除指针指向的当前元素&lt;/p&gt;

&lt;p&gt;void        set(Object   o)    //修改指针指向的当前元素&lt;/p&gt;

&lt;p&gt;package com.collections.test;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.util.*;

/**
* @author    叶昭良
* @time      2015年2月23日下午12:15:42
* @version   com.collections.testListTest V1.0
*/
public class ListTest
{

         /**
          * @param args
          */
         public static void main(String[] args)
         {
                   // TODO Auto-generated method stub
//               Collection c = new LinkedList();
                   /**
                    *   测试list内部有别于Collection的特有的方法
                    */
                   List&amp;lt;String&amp;gt; list1 = new ArrayList&amp;lt;String&amp;gt;();
                   list1.add(&amp;quot;abc0&amp;quot;);
                   list1.add(&amp;quot;abc1&amp;quot;);
                   list1.add(&amp;quot;abc2&amp;quot;);
                   System.out.println(list1);
                  
                   list1.add(1, &amp;quot;abchaha&amp;quot;);
                   System.out.println(list1);
                  
                   for(int i = 0 ; i &amp;lt; list1.size(); i++)
                   {
                            System.out.println(&amp;quot;list1[&amp;quot;+i+&amp;quot;]=&amp;quot;+list1.get(i));
                   }
                   for(Object o:list1)
                   {
                            System.out.println(o);
                   }
                  
                   list1.set(3, &amp;quot;fdsf&amp;quot;);
                   System.out.println(list1);
                  
                   System.out.println(&amp;quot;fdsf在list1的第&amp;quot;+list1.indexOf(&amp;quot;fdsf&amp;quot;)+&amp;quot;位&amp;quot;);
                   //最后一次abc1出现的位置
                   System.out.println(list1.lastIndexOf(&amp;quot;abc1&amp;quot;));
                   List list2 = list1.subList(1, 4);
                   System.out.println(&amp;quot;list2:&amp;quot;+list2);
                  
                   ListIterator lit = list1.listIterator();
                   while(lit.hasNext())
                   {
                            Object  o = lit.next();
                            System.out.println(&amp;quot;List:&amp;quot;+o);
                   }
         }
}


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;小结：
1：只想遍历  就会ArrayList
2：希望不断添加   最好就是LinkedList
3：可以使用Collections.synchronizedList()获得一个线程安全的ArrayList and LinkedList&lt;/p&gt;

&lt;p&gt;HashSet:
本质：数组+链表，由entry链构成的数组，无序，不可重复。本质是HashMap
优点：添加和删除效率高
缺点：获取慢（遍历都一样）,只能遍历一遍，Set集合无法直接获取某个元素&lt;/p&gt;

&lt;p&gt;添加：1 计算hashcode
     2. 根据hashcode定位到某一索引处（数组）
     3. 添加值到索引处的链表（判断是否重复）&lt;/p&gt;

&lt;p&gt;所以hashset == 数组（存放hashcode）+链表（存值）（其实就是为了提高大链表的添加和遍历的速度）
HashSet的源码内部其实是HashMap&lt;/p&gt;

&lt;p&gt;1:重写hashCode and equals&lt;/p&gt;

&lt;p&gt;注意：hashCode  and equals的生成方式： 右键―&amp;gt;source&amp;mdash;&amp;gt;hashCode and equals即可自动
     生成。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.collections.test;

import java.util.HashSet;
import java.util.Iterator;

/**
* @author    叶昭良
* @time      2015年2月23日下午8:35:46
* @version   com.collections.testTestHashSet V1.0
*/
public class TestHashSet
{

         /**
          * @param args
          */
         public static void main(String[] args)
         {
                   // TODO Auto-generated method stub
                   HashSet&amp;lt;String&amp;gt; hs = new HashSet&amp;lt;String&amp;gt;();
                   hs.add(&amp;quot;abc0&amp;quot;);
                   hs.add(&amp;quot;abc1&amp;quot;);
                   hs.add(&amp;quot;abc2&amp;quot;);
                   hs.add(&amp;quot;abc3&amp;quot;);
                   hs.add(&amp;quot;abc4&amp;quot;);
                   hs.add(&amp;quot;abc0&amp;quot;);
                  
                   System.out.println(hs);
                  
                   //set集合没有索引 index  所以必须用iterator
                   Iterator it = hs.iterator();
                   while(it.hasNext())
                   {
                            System.out.println(it.next());
                   }
                  
                   /**
                    * Person类的hashCode被执行
                            Person类的hashCode被执行
                            Person类的hashCode被执行
                            Person类的hashCode被执行
                            Person类的hashCode被执行
                            Person类的equals方法被执行
                    */
                   Person p1 = new Person(&amp;quot;zhao&amp;quot;,32);
                   Person p2 = new Person(&amp;quot;zhao1&amp;quot;,34);
                   Person p5 = new Person(&amp;quot;zhao1&amp;quot;,34);
                   Person p3 = new Person(&amp;quot;zhao2&amp;quot;,35);
                   Person p4 = new Person(&amp;quot;zhao3&amp;quot;,36);
                  
                   HashSet&amp;lt;Person&amp;gt; hs1 = new HashSet&amp;lt;Person&amp;gt;();
                   hs1.add(p1);
                   hs1.add(p2);
                   hs1.add(p3);
                   hs1.add(p4);
                   hs1.add(p5);
                  
                   Iterator it1 = hs1.iterator();
                   while(it1.hasNext())
                   {
                            Person p11 = (Person)it1.next();
                            //System.out.println(p11.getName()+&amp;quot;:&amp;quot;+p11.getAge());
                            System.out.println(p11);
                   }
         }

}

//自定类中加入set需要重写hashCode和equals方法   集合的不可重复性！！所以必须
//添加hashcode和equals这种比较低级的！如果是TreeSet还得考虑大小！必须是
///Comparable
class Person
{
        
         /*public int compareTo(String anotherString)
         {
                   return Name.compareTo(anotherString);
         }*/
         private int Age;
         private String Name;
        
         public Person( String name,int age)
         {
                   //super();
                   this.Age = age;
                   this.Name = name;
         }
         public int getAge()
         {
                   return this.Age;
         }
         public void setAge(int age)
         {
                   this.Age = age;
         }
         public String getName()
         {
                   return this.Name;
         }
         public void setName(String name)
         {
                   this.Name = name;
         }
         /// 右键source---》 generate equals and hashcode method
         @Override
         public int hashCode()
         {
                   System.out.println(&amp;quot;Person类的hashCode被执行&amp;quot;);
                   final int prime = 31;
                   int result = 1;
                   result = prime * result + Age;
                   result = prime * result + ((Name == null) ? 0 : Name.hashCode());
                   return result;
         }
         @Override
         public boolean equals(Object obj)
         {
                   System.out.println(&amp;quot;Person类的equals方法被执行&amp;quot;);
                   if (this == obj)
                            return true;
                   if (obj == null)
                            return false;
                   if (getClass() != obj.getClass())
                            return false;
                   Person other = (Person) obj;
                   if (Age != other.Age)
                            return false;
                   if (Name == null)
                   {
                            if (other.Name != null)
                                     return false;
                   } else if (!Name.equals(other.Name))
                            return false;
                   return true;
         }
         @Override
         public String toString()
         {
                   return &amp;quot;Person [Age=&amp;quot; + Age + &amp;quot;, Name=&amp;quot; + Name + &amp;quot;]&amp;quot;;
         }                
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;TreeSet&lt;/p&gt;

&lt;p&gt;本质：二叉树，注意查看root节点（这是二叉树结构的标志）  TreeSet关键是排序！（不是插入 和获取元素）
优点：增加和删除
缺点：获取&lt;/p&gt;

&lt;p&gt;TreeSet右节点值大于父节点    左节点值小于父节点,根据这种推断，最小的是存在于左边的最下边！ 利用递归推断。&lt;/p&gt;

&lt;p&gt;1:重写equals  and  hashcode
2:实现一个comparable接口或者一个Comparator类&lt;/p&gt;

&lt;p&gt;第一种方法：实现comparable接口&lt;/p&gt;

&lt;p&gt;只需要在Person类中增加implements comparable并重写compareTo(Object o)接口即可：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Person implements Comparable
{
   
    /*public int compareTo(String anotherString)
    {
       return Name.compareTo(anotherString);
    }*/
    private int Age;
    private String Name;
   
    public Person( String name,int age)
    {
       //super();
       this.Age = age;
       this.Name = name;
    }
    public int getAge()
    {
       return this.Age;
    }
    public void setAge(int age)
    {
       this.Age = age;
    }
    public String getName()
    {
       return this.Name;
    }
    public void setName(String name)
    {
       this.Name = name;
    }
    /// 右键source---》 generate equals and hashcode method
    @Override
    public int hashCode()
    {
       System.out.println(&amp;quot;Person类的hashCode被执行&amp;quot;);
       final int prime = 31;
       int result = 1;
       result = prime * result + Age;
       result = prime * result + ((Name == null) ? 0 : Name.hashCode());
       return result;
    }
    @Override
    public boolean equals(Object obj)
    {
       System.out.println(&amp;quot;Person类的equals方法被执行&amp;quot;);
       if (this == obj)
           return true;
       if (obj == null)
           return false;
       if (getClass() != obj.getClass())
           return false;
       Person other = (Person) obj;
       if (Age != other.Age)
           return false;
       if (Name == null)
       {
           if (other.Name != null)
              return false;
       } else if (!Name.equals(other.Name))
           return false;
       return true;
    }
    @Override
    public String toString()
    {
       return &amp;quot;Person [Age=&amp;quot; + Age + &amp;quot;, Name=&amp;quot; + Name + &amp;quot;]&amp;quot;;
    }
    @Override
    public int compareTo(Object o)
    {
       // TODO Auto-generated method stub
       //按照年龄进行排序
       if(this == o)
       {
           return 0;
       }
       if(this == null)
       {
           return -1;
       }
       if(!(o instanceof Person))
       {
           return -1;
       }
      
       Person p1 = (Person)o;
       //先按照年龄排序
       int temp = p1.Age - this.Age;
      
       if(temp ==0)
       {
           if(this.Name == null)
           {
              if(p1.Name == null)
              {
                  return 0;
              }else
              {
                  return -1;
              }
           }else
           {
              return this.Name.compareTo(p1.Name);
           }
       }
       return 0;
    }
      
}


//第二种方法创建一个比较类，并返回一个比较器，在TreeSet的对象定义中使用

  
class Comparators
{
    public Comparator getComparator()
    {
       return new Comparator()
       {

           // 0 表示  o1  o2相等
           // 负数 表示  o1 &amp;lt; o2
           // 整数 表示  o1 &amp;gt; o2
           @Override
           public int compare(Object o1, Object o2)
           {
              if(o1 instanceof String)
              {
                  //字符串的比较
                  return compare((String) o1,(String) o2);
              }else if(o1 instanceof Integer)
              {
                  //整数的比较
                  return compare((Integer) o1,(Integer) o2);
              }else if(o1 instanceof Boolean)
              {
                  //布尔类型的比较
                  return compare((Boolean) o1,(Boolean) o2);
              }else if(o1 instanceof Person)
              {
                  //布尔类型的比较
                  return compare((Person) o1,(Person) o2);
              }else
              {
                  System.out.println(&amp;quot;未找到合适的比较器  &amp;quot;);
                  return 1; //默认大于0
              }
           }
           //用于比较字符串
           public int compare(String o1, String o2)
           {
              //暂时备份一下 字符串
              String s1 = (String)o1;
              String s2 = (String)o2;
              //获取字符串的长度
              int len1 = s1.length();
              int len2 = s2.length();
              //获取最小值
              int n = Math.min(len1, len2);
              //转化为字符数组
              char[] v1 = s1.toCharArray();
              char[] v2 = s2.toCharArray();
             
              //设置位置参数
              int pos = 0;
             
              //从未到头  按照index下表从头到尾进行判断
              while(n-- != 0)
              {
                  char c1 = v1[pos];
                  char c2 = v2[pos];
                  if(c1 != c2)
                  {
                     return c1 - c2;
                  }
                  pos++;
              }
              return len1-len2; //相反则是反序 降序
           }
           //用于比较整数
           public int compare(Integer o1, Integer o2)
           {
              int val1 = o1.intValue();
              int val2 = o2.intValue();
              //return (val1 &amp;lt; val2 ? -1 :(val1 == val2 ? 0 : 1));
//            return (val1 &amp;gt; val2 ? 1 :(val1 == val2 ? 0 : -1));
              //升序
              //return (val2 &amp;gt; val1 ? -1 :(val1 == val2 ? 0 : 1));
              //降序
              return (val2 &amp;gt; val1 ? 1 :(val1 == val2 ? 0 : -1));
           }
           //用于比较布尔值
           public int compare(Boolean o1,Boolean o2)
           {
              return (o1.equals(o2)? 0: (o1.booleanValue()==true)?1:-1);
           }
          
           public int compare(final Person o1, final Person o2)
           {
              String Name1 = o1.getName();
              String Name2 = o2.getName();
              int Age1 = o1.getAge();
              int Age2 = o2.getAge();
              Boolean sex1 = o1.getSex();
              Boolean sex2 = o2.getSex();
              /*//第一次 线比较年龄
              return (compare(Age1,Age2)==0?
                     //第二次比较名字
                     (compare(Name1,Name2)==0?
                            //第三次比较性别
                            (compare(sex1,sex2)==0? 0 :compare(sex1,sex2)):
                                compare(Name1,Name2)):
                                   compare(Age1,Age2));*/
              //第一次  比较年龄
              return (compare(Name1,Name2)==0?
                     //第二次比较 岁数
                     (compare(Age1,Age2)==0?
                            //第三次比较岁数
                            (compare(sex1,sex2)==0?0:compare(sex1,sex2)):
                                compare(Age1,Age2)):
                                   compare(Name1,Name2));
                    
           }
       };
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;并在TreeSet定义对象时候，采用如下方式：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//TreeSet&amp;lt;Person&amp;gt; ts2 = new TreeSet&amp;lt;Person&amp;gt;(); //找到解决办法了
       TreeSet&amp;lt;Person&amp;gt; ts2 = new TreeSet&amp;lt;Person&amp;gt;(new Comparators().getComparator());

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;比较之前的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;TreeSet&amp;lt;Person1&amp;gt; ts1 = new TreeSet&amp;lt;Person1&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外此种方法也运用在Arrays.Sort当中：其中pdian 是一个person的数组&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Person[] pdian = new Person[]
              {
                  new Person(&amp;quot;yezhao&amp;quot;,34,Boolean.TRUE),
                  new Person(&amp;quot;xinran&amp;quot;,10,Boolean.FALSE),
                  new Person(&amp;quot;zhaoliang&amp;quot;,33,Boolean.TRUE),
                  new Person(&amp;quot;zhaidc&amp;quot;,30,Boolean.FALSE),
                  new Person(&amp;quot;zhaidc&amp;quot;,31,Boolean.FALSE),
              };
Arrays.sort(pdian, new Comparators().getComparator());

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外的可以通过匿名类来实现：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Arrays.sort(pdian, new Comparator&amp;lt;Object&amp;gt;()
       {
           // 0 表示  o1  o2相等
           // 负数 表示  o1 &amp;lt; o2
           // 整数 表示  o1 &amp;gt; o2
           @Override
           public int compare(Object o1, Object o2)
           {
              if(o1 instanceof String)
              {
                  //字符串的比较
                  return compare((String) o1,(String) o2);
              }else if(o1 instanceof Integer)
              {
                  //整数的比较
                  return compare((Integer) o1,(Integer) o2);
              }else if(o1 instanceof Boolean)
              {
                  //布尔类型的比较
                  return compare((Boolean) o1,(Boolean) o2);
              }else if(o1 instanceof PersonMan)
              {
                  //布尔类型的比较
                  return compare((PersonMan) o1,(PersonMan) o2);
              }else
              {
                  System.out.println(&amp;quot;未找到合适的比较器  &amp;quot;);
                  return 1; //默认大于0
              }
           }
           //用于比较字符串
           public int compare(String o1, String o2)
           {
              //暂时备份一下 字符串
              String s1 = (String)o1;
              String s2 = (String)o2;
              //获取字符串的长度
              int len1 = s1.length();
              int len2 = s2.length();
              //获取最小值
              int n = Math.min(len1, len2);
              //转化为字符数组
              char[] v1 = s1.toCharArray();
              char[] v2 = s2.toCharArray();
             
              //设置位置参数
              int pos = 0;
             
              //从未到头  按照index下表从头到尾进行判断
              while(n-- != 0)
              {
                  char c1 = v1[pos];
                  char c2 = v2[pos];
                  if(c1 != c2)
                  {
                     return c1 - c2;
                  }
                  pos++;
              }
              return len1-len2; //相反则是反序 降序
           }
           //用于比较整数
           public int compare(Integer o1, Integer o2)
           {
              int val1 = o1.intValue();
              int val2 = o2.intValue();
              //return (val1 &amp;lt; val2 ? -1 :(val1 == val2 ? 0 : 1));
//                       return (val1 &amp;gt; val2 ? 1 :(val1 == val2 ? 0 : -1));
              //升序
              //return (val2 &amp;gt; val1 ? -1 :(val1 == val2 ? 0 : 1));
              //降序
              return (val2 &amp;gt; val1 ? -1 :(val1 == val2 ? 0 : 1));
           }
           //用于比较布尔值
           public int compare(Boolean o1,Boolean o2)
           {
              return (o1.equals(o2)? 0: (o1.booleanValue()==true)?1:-1);
           }
          
           public int compare(final PersonMan o1, final PersonMan o2)
           {
              String Name1 = o1.getName();
              String Name2 = o2.getName();
              int Age1 = o1.getAge();
              int Age2 = o2.getAge();
              Boolean sex1 = o1.getSex();
              Boolean sex2 = o2.getSex();
              /*//第一次 线比较年龄
              return (compare(Age1,Age2)==0?
                     //第二次比较名字
                     (compare(Name1,Name2)==0?
                            //第三次比较性别
                            (compare(sex1,sex2)==0? 0 :compare(sex1,sex2)):
                                compare(Name1,Name2)):
                                   compare(Age1,Age2));*/
              //第一次  比较年龄
              return (compare(Name1,Name2)==0?
                     //第二次比较 岁数
                     (compare(Age1,Age2)==0?
                            //第三次比较岁数
                            (compare(sex1,sex2)==0?0:compare(sex1,sex2)):
                                compare(Age1,Age2)):
                                   compare(Name1,Name2));
                    
           }
       });


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;LinkedHashSet:
本质：链表+ 有序
优点：增加和删除
缺点：查找（获取）
Linkedlist也是有序但是可重复
LinkedHashSet 不可重复！
hashSet的高效率，但是无须！
LinkedHashSet可以当做HashSet来使用&lt;/p&gt;

&lt;p&gt;Map集合基本操作：&lt;/p&gt;

&lt;p&gt;l   添加&lt;/p&gt;

&lt;p&gt;V         put(K key, V value)  //把一个键值对存入map集合中&lt;/p&gt;

&lt;p&gt;void    putAll(Map&amp;lt;? extends K,? extends V&amp;gt; m) //把一组键值对存入到map集合中&lt;/p&gt;

&lt;p&gt;l   删除&lt;/p&gt;

&lt;p&gt;V         remove(Object key)  //删除key为指定对象的键值对&lt;/p&gt;

&lt;p&gt;void    clear()    //情况map中的所有元素&lt;/p&gt;

&lt;p&gt;l   判断&lt;/p&gt;

&lt;p&gt;boolean     containsKey(Object key)  //判断是否包含key为指定对象的键值对&lt;/p&gt;

&lt;p&gt;boolean     containsValue(Object value) //判断是否包含value为指定对象的元素&lt;/p&gt;

&lt;p&gt;boolean     isEmpty() //判断map集合是否包含元素&lt;/p&gt;

&lt;p&gt;l   获取&lt;/p&gt;

&lt;p&gt;V                                        get(Object key) //获得指定key对应的value&lt;/p&gt;

&lt;p&gt;Set&lt;K&gt;                              keySet() //获得所有key组成的Set集合&lt;/p&gt;

&lt;p&gt;Collection&lt;V&gt;                   values()  //获得所有value组成的Set集合&lt;/p&gt;

&lt;p&gt;Set&lt;Map.Entry&lt;K,V&gt;&amp;gt;     entrySet() //获得所有键值对对象组成的Set集合&lt;/p&gt;

&lt;p&gt;int                                     size()  //获得map集合的大小(存了多少元素)&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>多线程March18th</title>
      <link>https://jueqingsizhe66.github.io/blog/2015/05/11/duo-xian-cheng-march18th/</link>
      <pubDate>Mon, 11 May 2015 14:58:45 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/blog/2015/05/11/duo-xian-cheng-march18th/</guid>
      <description>&lt;p&gt;4:java多线程&lt;/p&gt;

&lt;p&gt;新建状态(start)
可运行状态(runnable)
运行状态(run)
阻塞装填(sleep)
死亡状态（stop,dead）&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;start&amp;mdash;&amp;gt;Runnable&amp;mdash;-&amp;gt; Running&amp;mdash;&amp;gt;Dead
   |               |
   |               |&lt;/p&gt;

&lt;h2 id=&#34;threads-implements&#34;&gt;Threads    implements&lt;/h2&gt;

&lt;h2 id=&#34;running-wait-blocked-notify-runnable&#34;&gt;Running&amp;mdash;&amp;gt;Wait&amp;mdash;&amp;gt;Blocked&amp;mdash;&amp;gt;notify&amp;mdash;-&amp;gt;Runnable&lt;/h2&gt;

&lt;h2 id=&#34;running-sleep-runnable&#34;&gt;Running&amp;mdash;&amp;gt;sleep&amp;mdash;&amp;gt;Runnable&lt;/h2&gt;

&lt;p&gt;线程和进程的区别？
一个进程占用实际的内存资源，线程依赖于进程，一个进程可以有多个线程
进程大，线程小
每一个程序运行都运行在一个进程内，而不是线程
一个进程可分为多个线程&lt;/p&gt;

&lt;p&gt;售票案例
问题： 第70张票还没售完不能售第73张的票，但是实际却是销售了？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
* 解释：
*/
package TestMultiThreads;

/**
* @author 叶昭良
* @time 2015年3月18日下午9:09:27
* @version TestMultiThreadsTestPesonThread V1.0
* 功能： 
步骤：
* 注意：
* 掌握：
思考：
* 回顾：
*/
public class TestPesonThread
{

/**
* @param args 
* 原因：
* 解决：
* 功能：
* 思考： 
* 步骤：
*/
public static void main(String[] args)
{
// TODO Auto-generated method stub

A aa = new A();
Thread t1 = new Thread(aa);
Thread t2 = new Thread(aa);
Thread t3 = new Thread(aa);

/*        B bb = new B();
Thread t1 = new Thread(bb);
Thread t2 = new Thread(bb);
Thread t3 = new Thread(bb);*/

t1.start();
t2.start();
t3.start();
}

}

class A implements Runnable
{
private static int tickets = 0;
@Override
public void run()
{
// TODO Auto-generated method stub
while(true)
{
//synchronized(&amp;quot;aaa&amp;quot;)
{
if(tickets &amp;lt; 10)
{
System.out.println(Thread.currentThread().getName()+tickets);
tickets++;
}else
{
break;
}
}

}
}

}


class B implements Runnable
{
private static int tickets = 0;
@Override
public synchronized void run()
{
// TODO Auto-generated method stub
while(true)
{
if(tickets &amp;lt; 10)
{
System.out.println(Thread.currentThread().getName()+tickets);
tickets++;
}else
{
break;
}
}
}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解决方案1： 采用synchronized(&amp;ldquo;aaa&amp;rdquo;) 或者 synchronized(TestPesonThread.class) 都是可以的，  相当于在一扇门中
塞入了口香糖，得拿走了才能打开！一个坑的作用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
public void run()
{
// TODO Auto-generated method stub
while(true)
{
//synchronized(&amp;quot;aaa&amp;quot;)
synchronized(TestPesonThread.class)
{
if(tickets &amp;lt; 10)
{
System.out.println(Thread.currentThread().getName()+tickets);
tickets++;
}else
{
break;
}
}

}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果：（注意加入Thread.sleep(1000）不然都会在thread0 或者thread1 thread2中执行，因为少）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Thread-0正在售10
Thread-2正在售9
Thread-1正在售8
Thread-2正在售7
Thread-2正在售6
Thread-2正在售5
Thread-0正在售4
Thread-2正在售3
Thread-2正在售2
Thread-2正在售1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解决方案2 ：  采用synchronized的run方法也是可以的！ 相当于锁定函数代码块，霸占着 直到用完！ 但是这个方法仅仅针对一个线程，执行完！一个对象霸占一个方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
* 解释：
*/
package TestMultiThreads;

/**
* @author 叶昭良
* @time 2015年3月18日下午9:09:27
* @version TestMultiThreadsTestPesonThread V1.0
* 功能： 
步骤：
* 注意：
* 掌握：
思考：
* 回顾：
*/
public class TestPesonThread
{

/**
* @param args 
* 原因：
* 解决：
* 功能：
* 思考： 
* 步骤：
*/
public static void main(String[] args)
{
// TODO Auto-generated method stub

A aa = new A();
Thread t1 = new Thread(aa);
Thread t2 = new Thread(aa);
Thread t3 = new Thread(aa);

/*        B bb = new B();
Thread t1 = new Thread(bb);
Thread t2 = new Thread(bb);
Thread t3 = new Thread(bb);*/

t1.start();
t2.start();
t3.start();
}

}

class A implements Runnable
{
private static int tickets = 0;
@Override
public synchronized void run()
{
// TODO Auto-generated method stub
while(true)
{
//synchronized(&amp;quot;aaa&amp;quot;)
//synchronized(TestPesonThread.class)
{
if(tickets &amp;lt; 10)
{
System.out.println(Thread.currentThread().getName()+&amp;quot;正在售&amp;quot;+tickets);
tickets++;
}else
{
break;
}
}

}
}

}


class B implements Runnable
{
private static int tickets = 0;
@Override
public synchronized void run()
{
// TODO Auto-generated method stub
while(true)
{
if(tickets &amp;lt; 10)
{
System.out.println(Thread.currentThread().getName()+tickets);
tickets++;
}else
{
break;
}
}
}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Thread-0正在售10
Thread-0正在售9
Thread-0正在售8
Thread-0正在售7
Thread-0正在售6
Thread-0正在售5
Thread-0正在售4
Thread-0正在售3
Thread-0正在售2
Thread-0正在售1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由此我们可以得知：
方法的霸占解决掉乱序，但是其实仅仅只是一个线程再执行，不能达到目的；
而采用synchronized对象 比如字符串对象&amp;rdquo;aaa&amp;rdquo;,不然类的class :TestPesonThread.class 放在循环快中都能够很好的解决多线程共用一个模块，必须执行一块完毕，才能执行下一块的问题！！perfect&lt;/p&gt;

&lt;p&gt;案例2：生产和消费&lt;/p&gt;

&lt;p&gt;目的：通过线程模拟一个在生产  一个在消费，并且当量小于三的时候，必须再生产，在量&lt;/p&gt;

&lt;p&gt;wait方法的作用是使得当前调用wait方法所在部分（代码块）的线程（当前线程）停止执行，并释放当前获得的调用wait所在的代码块的锁，并在其他线程调用notify或者notifyAll方法时恢复到竞争锁状态（一旦获得锁就恢复执行）。
有点类似巫医的弹弹乐效果，你被弹了，就停止，当别人被弹了，你就可以运动了&lt;/p&gt;

&lt;p&gt;注意：
wait被调用的时候必须在拥有锁（即synchronized修饰的）的代码块中。
恢复执行后，从wait的下一条语句开始执行，因而wait方法总是应当在while循环中调用，以免出现恢复执行后继续执行的条件不满足却继续执行的情况。
notify方法通知调用了wait方法，但是尚未激活的一个线程进入线程调度队列（即进入锁竞争），注意不是立即执行。并且具体是哪一个线程不能保证。另外一点就是被唤醒的这个线程一定是在等待wait所释放的锁。
notifyAll方法则唤醒所有调用了wait方法，尚未激活的进程进入竞争队列。&lt;/p&gt;

&lt;p&gt;有一个wait框，同时有一个监工notify,负责叫醒被暂停的waiter,去继续做他的被中断的工作
synstack 类定义了synchronized的push和pop方法
producer 进行push调用（可以被中断，当达到生产线程的上限时 就中断）
customer 进行pop调用（可以被中断，当没有产品的时候  并在产品数为3的时候通知生产）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
* 解释：
*/
package TestMultiThreads;

/**
* @author 叶昭良
* @time 2015年3月18日下午9:54:48
* @version TestMultiThreadsTestProducerCustomer V1.0
* 功能： 
步骤：
* 注意：
* 掌握：
思考：
* 回顾：
*/
public class TestProducerCustomer
{

/**
* @param args 
* 原因：
* 解决：
* 功能：
* 思考： 
* 步骤：
*/
public static void main(String[] args)
{
// TODO Auto-generated method stub
SynStack ss = new SynStack();
Producer pro = new Producer(ss);
Customer custom = new Customer(ss);

//Thread tt = new Thread();
/*        pro.run();
custom.run();*/

Thread t1 = new Thread(pro);
t1.start();
Thread t2 = new Thread(custom);
t2.start();

}

}


class SynStack
{
private char[] ss = new char[6];
//private static int count = 0;
private int count = 0;
public synchronized void push(char c)
{
try
{
Thread.sleep(500);
} catch (InterruptedException e1)
{
// TODO Auto-generated catch block
e1.printStackTrace();
}
//if(count == ss.length)
while(count == ss.length)
{
try
{
System.out.println(&amp;quot;生产已达上限，再生产容易造成供需不平衡&amp;quot;);
this.wait();
} catch (InterruptedException e)
{
// TODO Auto-generated catch block
e.printStackTrace();
}
}
/*        if(count == 3)
{
this.notify(); //如果达到3的时候通知他们进行生产
}*/
if(count &amp;gt; 1)
{
System.out.println(count+&amp;quot;大家可以来消费了&amp;quot;);
this.notify(); //一有则通知大家进行消费
}


System.out.printf(&amp;quot;It generates %d product.It is %c\n&amp;quot;,count,c);
ss[count] = c;
count++;
}
//synchronized 如果不加，则报错
public synchronized char pop()
{
try
{
Thread.sleep(100);
} catch (InterruptedException e1)
{
// TODO Auto-generated catch block
e1.printStackTrace();
}
//if(count == 0)
while(count == 0)
{
//this.notify();//通知push线程进行生产
try
{
System.out.println(&amp;quot;产品已售空，请联系生产商&amp;quot;);
this.wait();
} catch (InterruptedException e)
{
// TODO Auto-generated catch block
e.printStackTrace();
}
}
if(count == 3)
{
System.out.println(&amp;quot;该督促生产了，并且可以继续销售&amp;quot;);
this.notify(); //如果达到3的时候通知他们进行生产（push）

}
//this.notify();

count--;
//必须放在count--之后 才可以调用ss[count]
System.out.printf(&amp;quot;It ate %d product.It is %c\n&amp;quot;,count,ss[count]);
return ss[count];

}
}

class Producer implements Runnable
{
private SynStack ss = null;

public Producer(SynStack ss)
{
this.ss =ss;
}
@Override
public void run()        
{
// TODO Auto-generated method stub
//        ss.push(&#39;a&#39;);
/*        try
{
Thread.sleep(1000);
} catch (InterruptedException e)
{
// TODO Auto-generated catch block
e.printStackTrace();
}*/
char ch ;
for(int i =0 ; i &amp;lt; 20 ; i++)
{
ch = (char)(&#39;a&#39;+i);
ss.push(ch);
}
}

}
class Customer implements Runnable
{
private SynStack ss = null;
public Customer(SynStack ss)
{
this.ss = ss;
}
@Override
public void run()
{

// TODO Auto-generated method stub
//        System.out.println(ss.pop());
/*        try
{
Thread.sleep(1000);
} catch (InterruptedException e)
{
// TODO Auto-generated catch block
e.printStackTrace();
}*/
for(int i = 0; i &amp;lt; 20 ; i++)
{
System.out.println(ss.pop());
}
}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;It generates 0 product.It is a
It generates 1 product.It is b
2大家可以来消费了
It generates 2 product.It is c
该督促生产了，并且可以继续销售
It ate 2 product.It is c
c
2大家可以来消费了
It generates 2 product.It is d
该督促生产了，并且可以继续销售
It ate 2 product.It is d
d
It ate 1 product.It is b
b
It generates 1 product.It is e
It ate 1 product.It is e
e
It generates 1 product.It is f
2大家可以来消费了
It generates 2 product.It is g
该督促生产了，并且可以继续销售
It ate 2 product.It is g
g
2大家可以来消费了
It generates 2 product.It is h
3大家可以来消费了
It generates 3 product.It is i
It ate 3 product.It is i
i
3大家可以来消费了
It generates 3 product.It is j
4大家可以来消费了
It generates 4 product.It is k
5大家可以来消费了
It generates 5 product.It is l
生产已达上限，再生产容易造成供需不平衡
It ate 5 product.It is l
l
It ate 4 product.It is k
k
It ate 3 product.It is j
j
该督促生产了，并且可以继续销售
It ate 2 product.It is h
2大家可以来消费了
It generates 2 product.It is m
h
3大家可以来消费了
It generates 3 product.It is n
It ate 3 product.It is n
n
3大家可以来消费了
It generates 3 product.It is o
It ate 3 product.It is o
o
3大家可以来消费了
It generates 3 product.It is p
4大家可以来消费了
It generates 4 product.It is q
It ate 4 product.It is q
q
4大家可以来消费了
It generates 4 product.It is r
It ate 4 product.It is r
r
4大家可以来消费了
It generates 4 product.It is s
5大家可以来消费了
It generates 5 product.It is t
It ate 5 product.It is t
t
It ate 4 product.It is s
s
It ate 3 product.It is p
p
该督促生产了，并且可以继续销售
It ate 2 product.It is m
m
It ate 1 product.It is f
f
It ate 0 product.It is a
a


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：至于notify放置在代码的哪个地方，有待进一步的比较。&lt;/p&gt;

&lt;p&gt;5.网络编程&lt;/p&gt;

&lt;p&gt;一个网络程序需要考虑协议，IP，端口号。&lt;/p&gt;

&lt;p&gt;协议：
用于网络传输的规则、准则。在不同的计算机传输层中（7层架构） 有不同的数据包，
不同
层封包的不同方法&lt;/p&gt;

&lt;p&gt;IP:  唯一标识互联网中的计算机
端口号：qq有自己的端口  mysql的3306端口   smtp的23端口等&lt;/p&gt;

&lt;p&gt;协议分为UDP,TCP
UDP的特点：无需等待对方确认，比如写信 有可能收不到。
TCP的特点：需要等待 对方连接，比如QQ视频聊天，打电话。三重连接&lt;/p&gt;

&lt;p&gt;UDP编程：
知识点：
DatagramSocket 是一艘轮船（传递数据包）
DatagramPacket 是一个轮船上的货物（获取数据包）&lt;/p&gt;

&lt;p&gt;ByteArrayInputStream and  DataInputStream 用于打包港口货物
ByteArrayOutputStream and  DataOutputStream 也用于打包港口货物&lt;/p&gt;

&lt;p&gt;案例1：简单实现一个UDP的传输过程，服务器开启，客户端发送数据（暂时未实现服务器的发送  客户端的接受，实现简单，dos对应的dis  dis对应的dos)
Server:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
* 解释：
*/
package TestNetwork;

import java.io.ByteArrayInputStream;
import java.io.DataInputStream;
import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.SocketException;

/**
* @author 叶昭良
* @time 2015年3月19日下午1:49:36
* @version TestNetworkTestDatagramSocket V1.0
* 功能： 测试UDP
步骤：
* 注意：
* 掌握：
思考：
* 回顾：
*/
public class TestDatagramSocket
{

/**
* @param args 
* 原因：
* 解决：
* 功能：
* 思考： 
* 步骤：
*/
public static void main(String[] args)
{
// TODO Auto-generated method stub
DatagramSocket ds = null;
DatagramPacket dp = null;

try
{
ds = new DatagramSocket(5566);
byte[] apple = new byte[1025];
/*for(int i =0 ; i &amp;lt; 20; i++)
{
apple = (byte) ((byte)&#39;a&#39;+i);
}*/
dp = new DatagramPacket(apple, apple.length);
while(true)
{
try
{
ds.receive(dp);
ByteArrayInputStream bais = new ByteArrayInputStream(dp.getData());
DataInputStream dis = new DataInputStream(bais);
System.out.println(dis.readLong());

} catch (IOException e)
{
// TODO Auto-generated catch block
e.printStackTrace();
}

}
} catch (SocketException e)
{
// TODO Auto-generated catch block
e.printStackTrace();
}

}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Client&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
* 解释：
*/
package TestNetwork;
import java.io.*;
import java.net.*;
/**
* @author 叶昭良
* @time 2015年3月21日上午1:39:22
* @version TestNetworkTestDatagramClient V1.0
* 功能： 
步骤：
* 注意：
* 掌握：
思考：
* 回顾：
*/
public class TestDatagramClient
{

/**
* @param args 
* 原因：
* 解决：
* 功能：
* 思考： 
* 步骤：
*/
public static void main(String[] args)
{
// TODO Auto-generated method stub
DatagramSocket ds = null;
DatagramPacket dp = null;
try
{
ds = new DatagramSocket();
long m = 1000l;
ByteArrayOutputStream baos = new ByteArrayOutputStream();
DataOutputStream dos = new DataOutputStream(baos);

dos.writeLong(m);

byte[] apple = baos.toByteArray();
dp = new DatagramPacket(apple, apple.length,new
InetSocketAddress(&amp;quot;127.0.0.1&amp;quot;,5566));
ds.send(dp);
}catch(IOException e)
{

}
}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;先开启Server,再运行Client
1000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;TCP编程：
知识点：
1.通过ServerSocket产生一个运行的所需的端口号
2.利用Socket进行编程，Socket源自于unix操作系统&lt;/p&gt;

&lt;p&gt;案例1： 模拟UDP的类似程序，即服务器端等待数据 进行读取   客户端发送数据&lt;/p&gt;

&lt;p&gt;Server:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
* 解释：
*/
package TestNetwork;
import java.io.*;
import java.net.*;
/**
* @author 叶昭良
* @time 2015年3月19日下午2:30:08
* @version TestNetworkTestServer1 V1.0
* 功能： 
步骤：
* 注意：
* 掌握：
思考：
* 回顾：
*/
public class TestServer1
{

/**
* @param args 
* 原因：
* 解决：
* 功能：
* 思考： 
* 步骤：
*/
public static void main(String[] args)
{
// TODO Auto-generated method stub
try
{
ServerSocket ss = new ServerSocket(5566);
while(true)
{
Socket s1 =ss.accept();
DataInputStream dis = new DataInputStream(s1.getInputStream());
System.out.println(dis.readUTF());
dis.close();
}
} catch (IOException e)
{
// TODO Auto-generated catch block
e.printStackTrace();
}

}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Client:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
* 解释：
*/
package TestNetwork;
import java.io.*;
import java.net.*;
/**
* @author 叶昭良
* @time 2015年3月19日下午2:30:23
* @version TestNetworkTestClient1 V1.0
* 功能： 
步骤：
* 注意：
* 掌握：
思考：
* 回顾：
*/
public class TestClient1
{

/**
* @param args 
* 原因：
* 解决：
* 功能：
* 思考： 
* 步骤：
*/
public static void main(String[] args)
{
// TODO Auto-generated method stub
Socket s1 =null;
OutputStream os = null;
DataOutputStream dos = null;
try
{
s1 = new Socket(&amp;quot;127.0.0.1&amp;quot;,5566);
os = s1.getOutputStream();
dos = new DataOutputStream(os);
dos.writeUTF(&amp;quot;I am coming ,Sir&amp;quot;);
dos.flush();


} catch (IOException e)
{
// TODO Auto-generated catch block
e.printStackTrace();
}finally
{
try
{
dos.close();
os.close();
s1.close();
} catch (IOException e)
{
// TODO Auto-generated catch block
e.printStackTrace();
}

}

}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;案例2：改进案例1  是的服务器端也能够发送  客户端也能接受数据&lt;/p&gt;

&lt;p&gt;Server:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
&amp;lt;font size=&amp;quot;3&amp;quot;&amp;gt;/**
* 解释：
*/
package TestNetwork;
import java.io.*;
import java.net.*;
/**
* @author 叶昭良
* @time 2015年3月19日下午2:38:37
* @version TestNetworkTestServer2 V1.0
* 功能： 
步骤：
* 注意：
* 掌握：
思考：
* 回顾：
*/
public class TestServer2
{

/**
* @param args 
* 原因：
* 解决：
* 功能：
* 思考： 
* 步骤：
*/
public static void main(String[] args)
{
// TODO Auto-generated method stub
Socket s1 = null ;
DataOutputStream dos = null;
DataInputStream dis = null;
BufferedReader br = null;
try
{
ServerSocket ss = new ServerSocket(5566);
s1 = ss.accept();

dis = new DataInputStream(s1.getInputStream());
dos = new DataOutputStream(s1.getOutputStream());
br = new BufferedReader(new InputStreamReader(System.in));

while(true)
{
String apple = dis.readUTF();
System.out.println(&amp;quot;客户端：&amp;quot;+dis.readUTF());
if(apple.equals(&amp;quot;bye&amp;quot;))
{
break;
}
apple = br.readLine();
dos.writeUTF(apple);
}
} catch (IOException e)
{
// TODO Auto-generated catch block
e.printStackTrace();
}finally
{
try
{
dos.close();
dis.close();
s1.close();
} catch (IOException e)
{
// TODO Auto-generated catch block
e.printStackTrace();
}
}

}

}
&amp;lt;/font&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Client:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
* 解释：
*/
package TestNetwork;
import java.io.*;
import java.net.*;
/**
* @author 叶昭良
* @time 2015年3月19日下午2:38:52
* @version TestNetworkTestClient2 V1.0
* 功能： 
步骤：
* 注意：
* 掌握：
思考：
* 回顾：
*/
public class TestClient2
{

/**
* @param args 
* 原因：
* 解决：
* 功能：
* 思考： 
* 步骤：
*/
public static void main(String[] args)
{
// TODO Auto-generated method stub
Socket s1 = null;
OutputStream os = null;
InputStream is = null;
DataOutputStream dos = null;
DataInputStream dis = null;
BufferedReader br = null;
try
{
s1 = new Socket(&amp;quot;127.0.0.1&amp;quot;,5566);
os = s1.getOutputStream();
is = s1.getInputStream();
dos = new DataOutputStream(os);
dis = new DataInputStream(is);

dos.writeUTF(&amp;quot;Come to the world of net server&amp;quot;);
dos.flush();

br = new BufferedReader(new InputStreamReader(System.in));
while(true)
{
String str = br.readLine();
dos.writeUTF(str);
if(str.equalsIgnoreCase(&amp;quot;byebye&amp;quot;))
break;
str = dis.readUTF();
System.out.println(&amp;quot;服务器 said that&amp;quot; + str+&amp;quot;\n&amp;quot;);
if(str.equalsIgnoreCase(&amp;quot;byebye&amp;quot;))
break;

}
} catch (IOException e)
{
// TODO Auto-generated catch block
e.printStackTrace();
}
}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果：可以在字符界面下进行对话
客户端：hi
hi
服务器 said thathi too,smida&lt;/p&gt;

&lt;p&gt;出现的问题是，无法独立的切换客户端和服务器，client接受信息后，一直存在于while循环中,于是使用了线程，让他们自己对话吧！！&lt;/p&gt;

&lt;p&gt;Server的实现：
一定要注意无论是Server还是Client的实现，try&amp;mdash;catch之后不能有finally关闭，否则异常，socket中止&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
* 解释：
*/
package TestNetwork;

/**
* @author 叶昭良
* @time 2015年3月21日下午12:43:24
* @version TestNetworkTestServer3 V1.0
* 功能： 
步骤：
* 注意：
* 掌握：
思考：
* 回顾：
*/
import java.io.*;
import java.net.*;
public class TestServer3 //throws Exception
{

/**
* @param args 
* 原因：
* 解决：
* 功能：
* 思考： 
* 步骤：
*/
public static void main(String[] args) 
{
// TODO Auto-generated method stub
ServerSocket ss = null;
Socket s = null;
DataOutputStream dos = null;
DataInputStream dis = null;
try
{
ss = new ServerSocket(8888);
s = ss.accept();
dos = new DataOutputStream(s.getOutputStream());

dis = new DataInputStream(s.getInputStream());

new ServerRead(dis).start();
new ServerWrite(dos).start();
} catch (IOException e)
{
// TODO Auto-generated catch block
e.printStackTrace();
}

}

}


class ServerRead extends Thread
{
private DataInputStream dis = null;
public ServerRead(DataInputStream dis)
{
this.dis = dis;
}

public void run()
{
while(true)
{
try{
String str = dis.readUTF();
System.out.println(&amp;quot;客户端说:&amp;quot;+str);
if(str.equalsIgnoreCase(&amp;quot;byebye&amp;quot;))
break;
}catch(Exception e)
{
e.printStackTrace();
}
}
}
}
class ServerWrite extends Thread
{
private DataOutputStream dos = null;
public ServerWrite(DataOutputStream dos)
{
this.dos = dos;
}

public void run()
{
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
while(true)
{
try{
String str = br.readLine();
dos.writeUTF(str);
if(str.equalsIgnoreCase(&amp;quot;byebye&amp;quot;))
break;
}catch(Exception e)
{
e.printStackTrace();
}//加入finally 关闭  dos.close()则异常。。。于是删掉Client &amp;amp; Server的四个finally即可！！！问题解决  原因未知！！！
}
}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Client的实现：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
* 解释：
*/
package TestNetwork;
import java.io.*;
import java.net.*;
/**
* @author 叶昭良
* @time 2015年3月21日下午12:47:03
* @version TestNetworkTestClient3 V1.0
* 功能： 
步骤：
* 注意：
* 掌握：
思考：
* 回顾：
*/
public class TestClient3
{

/**
* @param args 
* 原因：
* 解决：
* 功能：
* 思考： 
* 步骤：
*/
public static void main(String[] args) throws Exception
{
// TODO Auto-generated method stub
Socket s = new Socket(&amp;quot;127.0.0.1&amp;quot;,8888);
DataOutputStream dos = new DataOutputStream(s.getOutputStream());

DataInputStream dis = new DataInputStream(s.getInputStream());

new ClientRead(dis).start();
new ClientWrite(dos).start();
}

}

class ClientRead extends Thread
{
private DataInputStream dis = null;
public ClientRead(DataInputStream dis)
{
this.dis = dis;
}

public void run()
{
while(true)
{
try{
String str = dis.readUTF();
System.out.println(&amp;quot;服务器说:&amp;quot;+str);
if(str.equalsIgnoreCase(&amp;quot;byebye&amp;quot;))
break;
}catch(Exception e)
{
e.printStackTrace();
}
}
}
}
class ClientWrite extends Thread
{
private DataOutputStream dos = null;
public ClientWrite(DataOutputStream dos)
{
this.dos = dos;
}

public void run()
{
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
while(true)
{
try{
String str = br.readLine();
dos.writeUTF(str);
if(str.equalsIgnoreCase(&amp;quot;byebye&amp;quot;))
break;
}catch(Exception e)
{
e.printStackTrace();
}
}
}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;客户端的控制台：

--------------------------------------------------------
客户端说:fs
fsdf
客户端说:heihei
吃了吗
客户端说:我吃了啊，下午去哪里玩？
----------------------------------------------------------


服务器端的控制台：
----------------------------------------------------------

fs

服务器说:fsdf

heihei
服务器说:吃了吗
我吃了啊，下午去哪里玩？
服务器说:不然咱们去闯红灯吧

----------------------------------------------------------
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;问题：这里面的线程切换，没有生产和消费的明显，还需要进一步理解线程的切换，为什么就能够从Server的读线程，然后写入信息给client就可以切换到Client的读线程？
          仅仅加入了extends thread?&lt;/p&gt;

&lt;p&gt;案例4： 在原先的基础上 加入了窗体，并进一步抽象到TCPClient  &amp;amp; TCPServer两个类下，通过TCPClient.launch  TCPServer.launch进行启动
美化效果操作：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Font font = new Font(&amp;quot;Dialog&amp;quot;, Font.PLAIN, 12); //一下是改变默认的组建上显示的字体，这样更加美观一些
UIManager.put(&amp;quot;MenuBar.font&amp;quot;, font);
UIManager.put(&amp;quot;MenuItem.font&amp;quot;, font);
UIManager.put(&amp;quot;Menu.font&amp;quot;, font);
UIManager.put(&amp;quot;PopupMenu.font&amp;quot;, font);
UIManager.put(&amp;quot;ToolBar.font&amp;quot;, font);
UIManager.put(&amp;quot;ToolTip.font&amp;quot;, font);
UIManager.put(&amp;quot;TabbedPane.font&amp;quot;, font);
UIManager.put(&amp;quot;Label.font&amp;quot;, font);
UIManager.put(&amp;quot;List.font&amp;quot;, font);
UIManager.put(&amp;quot;ComboBox.font&amp;quot;, font);
UIManager.put(&amp;quot;Button.font&amp;quot;, font);
UIManager.put(&amp;quot;Table.font&amp;quot;, font);
UIManager.put(&amp;quot;TableHeader.font&amp;quot;, font);
UIManager.put(&amp;quot;Tree.font&amp;quot;, font);
UIManager.put(&amp;quot;TextField.font&amp;quot;, font);
UIManager.put(&amp;quot;TextArea.font&amp;quot;, font);
UIManager.put(&amp;quot;TitledBorder.font&amp;quot;, font);
UIManager.put(&amp;quot;OptionPane.font&amp;quot;, font);
UIManager.put(&amp;quot;RadioButton.font&amp;quot;, font);
UIManager.put(&amp;quot;CheckBox.font&amp;quot;, font);
UIManager.put(&amp;quot;ToggleButton.font&amp;quot;, font);
UIManager.put(&amp;quot;Dialog.font&amp;quot;, font);
UIManager.put(&amp;quot;Panel.font&amp;quot;, font);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Server的实现：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
* 解释：
*/
package TestNetwork;
import java.io.*;
import java.net.ServerSocket;
import java.net.Socket;


//some error swing : controler
import javax.swing.*;

import java.awt.*;
import java.awt.event.*;
/**
* @author 叶昭良
* @time 2015年3月19日下午3:20:34
* @version TestNetworkTestServer4 V1.0
* 功能： 
步骤：
* 注意：
* 掌握：
思考：
* 回顾：
*/
public class TestServer4
{

/**
* @param args 
* 原因：
* 解决：
* 功能：
* 思考： 
* 步骤：
*/
public static void main(String[] args)
{
// TODO Auto-generated method stub
Font font = new Font(&amp;quot;Dialog&amp;quot;, Font.PLAIN, 12); //一下是改变默认的组建上显示的字体，这样更加美观一些
UIManager.put(&amp;quot;MenuBar.font&amp;quot;, font);
UIManager.put(&amp;quot;MenuItem.font&amp;quot;, font);
UIManager.put(&amp;quot;Menu.font&amp;quot;, font);
UIManager.put(&amp;quot;PopupMenu.font&amp;quot;, font);
UIManager.put(&amp;quot;ToolBar.font&amp;quot;, font);
UIManager.put(&amp;quot;ToolTip.font&amp;quot;, font);
UIManager.put(&amp;quot;TabbedPane.font&amp;quot;, font);
UIManager.put(&amp;quot;Label.font&amp;quot;, font);
UIManager.put(&amp;quot;List.font&amp;quot;, font);
UIManager.put(&amp;quot;ComboBox.font&amp;quot;, font);
UIManager.put(&amp;quot;Button.font&amp;quot;, font);
UIManager.put(&amp;quot;Table.font&amp;quot;, font);
UIManager.put(&amp;quot;TableHeader.font&amp;quot;, font);
UIManager.put(&amp;quot;Tree.font&amp;quot;, font);
UIManager.put(&amp;quot;TextField.font&amp;quot;, font);
UIManager.put(&amp;quot;TextArea.font&amp;quot;, font);
UIManager.put(&amp;quot;TitledBorder.font&amp;quot;, font);
UIManager.put(&amp;quot;OptionPane.font&amp;quot;, font);
UIManager.put(&amp;quot;RadioButton.font&amp;quot;, font);
UIManager.put(&amp;quot;CheckBox.font&amp;quot;, font);
UIManager.put(&amp;quot;ToggleButton.font&amp;quot;, font);
UIManager.put(&amp;quot;Dialog.font&amp;quot;, font);
UIManager.put(&amp;quot;Panel.font&amp;quot;, font);
new TCPServer().launch();
}

}


class TCPServer
{
// class variables
// class variables
// connect
private ServerSocket ss = null;
private Socket s = null;
// data flow
private DataOutputStream dos = null;
private DataInputStream dis = null;
// UI
private Frame f = null;
private TextArea ta = null;
private TextField tf = null;
private Button bn = null;


public void launch()
{
createUI();
connect();
new ServerRead().start();
new ServerWrite().start();
}
// construct member
/*
public TCPServer()
{

}
*/
public void createUI()
{
Frame f = new Frame(&amp;quot;服务器&amp;quot;);
ta = new TextArea();
tf = new TextField();
Panel p = new Panel(new BorderLayout());
bn = new Button(&amp;quot;发送&amp;quot;);
p.add(tf,BorderLayout.CENTER);
p.add(bn,BorderLayout.EAST);

f.add(ta,BorderLayout.CENTER);
f.add(p,BorderLayout.SOUTH);

f.setSize(400,200);
f.setVisible(true);
//f.setVisable(true);
f.addWindowListener(new WindowAdapter()
{
public void windowClosing(WindowEvent e)
{
System.exit(0);
}
});
}
public void connect()
{
try{
ss = new ServerSocket(5599);
s = ss.accept();
dis = new DataInputStream(s.getInputStream());
dos = new DataOutputStream(s.getOutputStream());
}catch(Exception e)
{
System.exit(0);
}
}
public void close()
{
try{
dis.close();
dos.close();
ss.close();
s.close();
}catch(Exception e)
{
System.exit(0);
}
}

class ServerRead extends Thread
{
public void run()
{
while(true)
{
try{
String str = dis.readUTF();
// System.out.println(&amp;quot;对方说:&amp;quot;+str);
ta.append(&amp;quot;客户端说：&amp;quot;+str+&amp;quot;\n&amp;quot;);
if(str.equalsIgnoreCase(&amp;quot;再见&amp;quot;))
{
close();
System.exit(0);
}
}catch(Exception e)
{
JOptionPane.showMessageDialog(f,&amp;quot;客户端已离开&amp;quot;);
return;
// e.printStackTrace();
}
}
}
}
class ServerWrite extends Thread
{
public void run()
{
tf.addActionListener(new TCPServerListener());
bn.addActionListener(new TCPServerListener());
}
}
class TCPServerListener implements ActionListener
{
@Override
public void actionPerformed(ActionEvent e)
{
try{
String str = tf.getText();
tf.setText(&amp;quot;&amp;quot;);
ta.append(&amp;quot;服务器说:&amp;quot;+str+&amp;quot;\n&amp;quot;);
dos.writeUTF(str);
if(str.equalsIgnoreCase(&amp;quot;再见&amp;quot;))
{
close();
System.exit(0);
}
}catch(Exception e1)
{
// e.printStackTrace();
System.exit(0);
} 
}
}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Client的实现：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
* 解释：
*/
package TestNetwork;
import java.net.*;
import java.io.*;

// some error swing : controler
import javax.swing.*;

import java.awt.*;
import java.awt.event.*;
/**
* @author 叶昭良
* @time 2015年3月19日下午3:22:27
* @version TestNetworkTestClient4 V1.0
* 功能： 
步骤：
* 注意：
* 掌握：
思考：
* 回顾：
*/
public class TestClient4
{

/**
* @param args 
* 原因：
* 解决：
* 功能：
* 思考： 
* 步骤：
*/
public static void main(String[] args)
{
// TODO Auto-generated method stub
Font font = new Font(&amp;quot;Dialog&amp;quot;, Font.PLAIN, 12); //一下是改变默认的组建上显示的字体，这样更加美观一些
UIManager.put(&amp;quot;MenuBar.font&amp;quot;, font);
UIManager.put(&amp;quot;MenuItem.font&amp;quot;, font);
UIManager.put(&amp;quot;Menu.font&amp;quot;, font);
UIManager.put(&amp;quot;PopupMenu.font&amp;quot;, font);
UIManager.put(&amp;quot;ToolBar.font&amp;quot;, font);
UIManager.put(&amp;quot;ToolTip.font&amp;quot;, font);
UIManager.put(&amp;quot;TabbedPane.font&amp;quot;, font);
UIManager.put(&amp;quot;Label.font&amp;quot;, font);
UIManager.put(&amp;quot;List.font&amp;quot;, font);
UIManager.put(&amp;quot;ComboBox.font&amp;quot;, font);
UIManager.put(&amp;quot;Button.font&amp;quot;, font);
UIManager.put(&amp;quot;Table.font&amp;quot;, font);
UIManager.put(&amp;quot;TableHeader.font&amp;quot;, font);
UIManager.put(&amp;quot;Tree.font&amp;quot;, font);
UIManager.put(&amp;quot;TextField.font&amp;quot;, font);
UIManager.put(&amp;quot;TextArea.font&amp;quot;, font);
UIManager.put(&amp;quot;TitledBorder.font&amp;quot;, font);
UIManager.put(&amp;quot;OptionPane.font&amp;quot;, font);
UIManager.put(&amp;quot;RadioButton.font&amp;quot;, font);
UIManager.put(&amp;quot;CheckBox.font&amp;quot;, font);
UIManager.put(&amp;quot;ToggleButton.font&amp;quot;, font);
UIManager.put(&amp;quot;Dialog.font&amp;quot;, font);
UIManager.put(&amp;quot;Panel.font&amp;quot;, font);
new TCPClient().launch();
}

}
class TCPClient
{
// class variables
// class variables
// connect
private Socket s = null;
// data flow
private DataOutputStream dos = null;
private DataInputStream dis = null;
// UI
private Frame f = null;
private TextArea ta = null;
private TextField tf = null;
private Button bn = null;


public void launch()
{
createUI();
connect();
new ClientRead().start();
new ClientWrite().start();
}
// construct member
/*
public TCPClient()
{

}
*/
public void createUI()
{
Frame f = new Frame(&amp;quot;客户端&amp;quot;);
ta = new TextArea();
tf = new TextField();
Panel p = new Panel(new BorderLayout());
bn = new Button(&amp;quot;发送&amp;quot;);
p.add(tf,BorderLayout.CENTER);
p.add(bn,BorderLayout.EAST);

f.add(ta,BorderLayout.CENTER);
f.add(p,BorderLayout.SOUTH);

f.setSize(400,200);
f.setVisible(true);
//f.setVisable(true);
f.addWindowListener(new WindowAdapter()
{
public void windowClosing(WindowEvent e)
{
System.exit(0);
}
});
}
public void connect()
{
try{
s = new Socket(&amp;quot;127.0.0.1&amp;quot;,5599);
dis = new DataInputStream(s.getInputStream());
dos = new DataOutputStream(s.getOutputStream());
}catch(Exception e)
{
System.exit(0);
}
}
public void close()
{
try{
dis.close();
dos.close();
s.close();
}catch(Exception e)
{
System.exit(0);
}
}

class ClientRead extends Thread
{
public void run()
{
while(true)
{
try{
String str = dis.readUTF();
// System.out.println(&amp;quot;对方说:&amp;quot;+str);
ta.append(&amp;quot;服务器说:&amp;quot;+str+&amp;quot;\n&amp;quot;);
if(str.equalsIgnoreCase(&amp;quot;再见&amp;quot;))
{
close();
System.exit(0);
}
}catch(Exception e)
{
JOptionPane.showMessageDialog(f,&amp;quot;客户端已离开&amp;quot;);
return;
// e.printStackTrace();
}
}
}
}
class ClientWrite extends Thread
{
public void run()
{
tf.addActionListener(new TCPClientListener());
bn.addActionListener(new TCPClientListener());
}
}
class TCPClientListener implements ActionListener
{
@Override
public void actionPerformed(ActionEvent e)
{
try{
String str = tf.getText();
tf.setText(&amp;quot;&amp;quot;);
ta.append(&amp;quot;客户端说:&amp;quot;+str+&amp;quot;\n&amp;quot;);
dos.writeUTF(str);
if(str.equalsIgnoreCase(&amp;quot;再见&amp;quot;))
{
close();
System.exit(0);
}
}catch(Exception e1)
{
// e.printStackTrace();
System.exit(0);
} 
}
}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://jueqingsizhe66.github.io/images/java/客户端服务端.png&#34; alt=&#34;服务器端和客户端的对话窗口&#34; /&gt;&lt;/p&gt;

&lt;p&gt;##重写TCPServer1 &amp;amp; TCPClient1 并加入了  String ip = s.getInetAddress().getHostAddress();
并且调整了编写风格，把所有类使用的变量都放在类中，并把socket创建和连接  接受和发送都放在构造函数中。类似于OOGTK的编写风格&lt;a href=&#34;http://www.rupeng.com/forum/forum.php?mod=viewthread&amp;amp;tid=44377。&#34; target=&#34;_blank&#34;&gt;http://www.rupeng.com/forum/forum.php?mod=viewthread&amp;amp;tid=44377。&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
* 解释：
*/
package TestNetwork;

/**
* @author    叶昭良
* @time      2015年3月22日下午3:49:11
* @version   TestNetworkRewriteTestServer1 V1.0
* 功能： 
                步骤：
                1: Server绑定端口
                2：接受
                3：循环接收
* 注意：  socket的主要作用就是   getOutputStream  和getInputStream来确定
*       表明socket交流的方向
* 掌握：
                思考：
* 回顾：
*/
import java.io.*;
import java.net.*;
public class RewriteTestServer1
{

        /**
         * @param args 
         * 原因：
         * 解决：
         * 功能：
         *       思考：        
         *       步骤：
         */
        ServerSocket ss = null;
        Socket s = null;
        DataInputStream dis = null;
        public RewriteTestServer1()
        {
                try
                {
                        ss = new ServerSocket(5566);
                        s = ss.accept();
                        String ip = s.getInetAddress().getHostAddress();
                        dis = new DataInputStream(s.getInputStream());
                        System.out.println(&amp;quot;客户端&amp;quot;+ip+&amp;quot; said: &amp;quot;+dis.readUTF());
                } catch (IOException e)
                {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                }finally
                {
                        try
                        {
                                dis.close();
                                s.close();
                        }catch(IOException e)
                        {
                                
                        }                
                }
                
        }
        public static void main(String[] args)
        {
                // TODO Auto-generated method stub
                new RewriteTestServer1();
        }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;TCPClient1:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
* 解释：
*/
package TestNetwork;

/**
* @author    叶昭良
* @time      2015年3月22日下午3:54:39
* @version   TestNetworkRewriteTestClient1 V1.0
* 功能： 
                步骤：  
                1: Socket的建立
                2： 发送数据
                3：。。
* 注意：
* 掌握：
                思考：
* 回顾：
*/
import java.io.*;
import java.net.*;
public class RewriteTestClient1
{

        /**
         * @param args 
         * 原因：
         * 解决：
         * 功能：
         *       思考：        
         *       步骤：
         */
        Socket s = null;
        DataOutputStream dos = null;
        public RewriteTestClient1()
        {
                try
                {
                        s = new Socket(&amp;quot;127.0.0.1&amp;quot;,5566);
                        dos = new DataOutputStream(s.getOutputStream());
                        dos.writeUTF(&amp;quot;Hello&amp;quot;);
                        dos.flush();
                } catch (IOException e)
                {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                }
        }
        public static void main(String[] args)
        {
                // TODO Auto-generated method stub
                new RewriteTestClient1();
        }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重写了TestServer2
功能：   在第一版本服务器的基础上  修正了客户端的只发送 不接受
*         以及服务器端的只接受不发送&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;并用BufferedReader获取System.in的内容输送到客户端
当客户端 也就是ss.accept之后，服务器来了一声“欢迎，ohni sang 光临”
紧接着客户端做了动作，接收到了服务器来的欢迎词，然后开始写入 一些话提交给服务器
反复执行这个过程&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
* 解释：
*/
package TestNetwork;

/**
* @author    叶昭良
* @time      2015年3月22日下午4:08:24
* @version   TestNetworkRewriteTestServer2 V1.0
* 功能： 
*              在第一版本服务器的基础上  修正了客户端的只发送 不接受
*         以及服务器端的只接受不发送
*         并用BufferedReader获取System.in的内容输送到客户端
            步骤：
* 注意：
* 掌握：
            思考：
* 回顾： 回顾了第一版本的ServerSocket   ss.accept()  以及DataInputStream(s.getInputStream());
*/
import java.io.*;
import java.net.*;
public class RewriteTestServer2
{

    /**
     * @param args 
     * 原因：
     * 解决：
     * 功能：
     *       思考：        
     *       步骤：
     */
    ServerSocket ss = null;
    Socket s = null;
    DataInputStream dis = null;
    DataOutputStream dos = null;
    BufferedReader br = null;
    String wordsFromClient  =null;
    String wordsFromServer  =null;
    public RewriteTestServer2()
    {
            createConnection();
            String ip = s.getInetAddress().getHostAddress();

            while(true)
            {
                    try
                    {
                                
                            wordsFromClient = dis.readUTF();
                            System.out.println(&amp;quot;客户端IP:&amp;quot;+ip+&amp;quot; said:&amp;quot;+wordsFromClient);
                            if(wordsFromClient.equalsIgnoreCase(&amp;quot;bye*&amp;quot;))
                            {
                                    break;
                            }
                            System.out.println(&amp;quot;服务器，请您输入你想对客户端说什么：&amp;quot;);
                            wordsFromServer = br.readLine();
                            dos.writeUTF(wordsFromServer);
                    } catch (IOException e)
                    {
                            // TODO Auto-generated catch block
                            e.printStackTrace();
                    }finally
                    {
                            try
                            {
                                    dos.close();
                                    dis.close();
                                    s.close();
                            } catch (IOException e)
                            {
                                    // TODO Auto-generated catch block
                                    e.printStackTrace();
                            }
                    }
                        
            }
    }
    /**
     * 功能： 创建一个读的连接，用于读取客户端的socket数据
     *       创建一个写的连接，通过BufferedReader进行缓冲读取System.in的数据
     *       并通过DataOutputStream发送出去
     *       思考：        
     *       步骤：
     */
    private void createConnection()
    {
            try
            {
                    ss = new ServerSocket(5566);
                    s =  ss.accept();
                    dis = new DataInputStream(s.getInputStream());
                    dos = new DataOutputStream(s.getOutputStream());
                    //增加了下面两句
                    dos.writeUTF(&amp;quot;您好！我是服务器想要聊些什么:&amp;quot;);
                    dos.flush();
                    br = new BufferedReader(new InputStreamReader(System.in));
            }catch(IOException e)
            {
                    System.out.println(&amp;quot;创建连接问题&amp;quot;);
            }
    }
    public static void main(String[] args)
    {
            // TODO Auto-generated method stub
            new RewriteTestServer2();
    }

}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;RewriteTestClient2:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
* 解释：
*/
package TestNetwork;
import java.io.*;
import java.net.*;
/**
* @author    叶昭良
* @time      2015年3月19日下午2:38:52
* @version   TestNetworkTestClient2 V1.0
* 功能： 
                步骤：
* 注意：
* 掌握：
                思考：
* 回顾：
*/
public class TestClient2
{

        /**
         * @param args 
         * 原因：
         * 解决：
         * 功能：
         *       思考：        
         *       步骤：
         */
        public static void main(String[] args)
        {
                // TODO Auto-generated method stub
                Socket s1 = null;
                OutputStream os = null;
                InputStream is = null;
                DataOutputStream dos = null;
                DataInputStream dis = null;
                BufferedReader br = null;
                try
                {
                        s1 = new Socket(&amp;quot;127.0.0.1&amp;quot;,5566);
                        os = s1.getOutputStream();
                        is = s1.getInputStream();
                        dos = new DataOutputStream(os);
                        dis = new DataInputStream(is);
                        
                        dos.writeUTF(&amp;quot;Come to the world of net server&amp;quot;);
                        dos.flush();
                        
                        br = new BufferedReader(new InputStreamReader(System.in));
                        while(true)
                        {
                                String str = br.readLine();
                                dos.writeUTF(str);
                                if(str.equalsIgnoreCase(&amp;quot;byebye&amp;quot;))
                    break;
                str = dis.readUTF();
                System.out.println(&amp;quot;服务器 said that&amp;quot; + str+&amp;quot;\n&amp;quot;);
                                if(str.equalsIgnoreCase(&amp;quot;byebye&amp;quot;))
                    break;

                        }
                } catch (IOException e)
                {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                }
        }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我遇到了一个问题：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;java.net.SocketException: socket closed
        at java.net.SocketInputStream.socketRead0(Native Method)
        at java.net.SocketInputStream.read(SocketInputStream.java:150)
        at java.net.SocketInputStream.read(SocketInputStream.java:121)
        at java.net.SocketInputStream.read(SocketInputStream.java:203)
        at java.io.DataInputStream.readUnsignedShort(DataInputStream.java:337)
        at java.io.DataInputStream.readUTF(DataInputStream.java:589)
        at java.io.DataInputStream.readUTF(DataInputStream.java:564)
        at TestNetwork.RewriteTestClient2.&amp;lt;init&amp;gt;(RewriteTestClient2.java:52)
        at TestNetwork.RewriteTestClient2.main(RewriteTestClient2.java:100)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;于是我删掉了两个finally解决了问题，但是我不明白为什么？&lt;/p&gt;

&lt;p&gt;重写了RewriteTestServer3 &amp;amp; RewriteTestClient3 ：
出现的问题： 在客户端连接上后，客户端发送数据可以到服务器端，接着切换到服务器端，但是服务器的输入出现了问题，无论你输入一个字还是n个字都无法切换回客户端了
主要不同点：
*         1: 把读和写的过程 从while中脱离出来 变成线程的形式(采用了implements形式出现而不是 extends threads)
*      即读线程和写线程
*  2：把BufferedReader放入到写出线程中 ，因为只有在那边读取控制台的输入字符
3:   把线程的开启部分放在了构造函数中  而不是  main函数中。
                步骤：
测试了： 把implements Runnable 该回到extends threads结果一样&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;          把线程的定义和开启放在main函数，并让dos dis变为static变量，也不能解决问题，依旧是卡在服务器中，无法切回到客户端
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个有趣的问题：（是不是跟synchronized有关系，没关系，加进去也没什么效果）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class ServerReWrite21 extends Thread
{
        private DataOutputStream dos = null;
        private BufferedReader br = null;
        private String wordsFromServer = null;
        public ServerReWrite21(DataOutputStream dos)
        {
                this.dos = dos;
        }
        
        @Override
        public void run()
        {
                //System.out.println(&amp;quot;dos=&amp;quot;+dos);  如果在ServerReWrite21中加入了这句话，则运行客户端之后 直接跳到这边  为什么？？？？？？？
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有问题的RewriteTestServer3&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
* 解释：
*/
package TestNetwork;

/**
* @author    叶昭良
* @time      2015年3月22日下午4:49:25
* @version   TestNetworkRewriteTestServer3 V1.0
* 功能：  
*         1: 把读和写的过程 从while中脱离出来 变成线程的形式
*      即读线程和写线程
*  2：把BufferedReader放入到写出线程中 ，因为只有在那边读取控制台的输入字符
                步骤：
* 注意：
* 掌握：
                思考：
* 回顾：
*/
import java.io.*;
import java.net.*;
public class RewriteTestServer31
{

        /**
         * @param args 
         * 原因：
         * 解决：
         * 功能：
         *       思考：        
         *       步骤：
         */
        ServerSocket ss = null;
        Socket s = null;
         DataInputStream dis = null;
         DataOutputStream dos = null;
         
        public RewriteTestServer31()
        {
                createConnection();
                ServerReRead21 sr= new ServerReRead21(dis);
                ServerReWrite21 sw = new ServerReWrite21(dos);
                sr.start();
                sw.start();
        }
        
        /**
         * 功能： 创建一个读的连接，用于读取客户端的socket数据
         *       创建一个写的连接，通过BufferedReader进行缓冲读取System.in的数据
         *       并通过DataOutputStream发送出去
         *       思考：        
         *       步骤：
         */
        private void createConnection()
        {
                try
                {
                        ss = new ServerSocket(5566);
                        s =  ss.accept();
                        dis = new DataInputStream(s.getInputStream());
                        dos = new DataOutputStream(s.getOutputStream());
                        //增加了下面两句
                        dos.writeUTF(&amp;quot;您好！我是服务器想要聊些什么:&amp;quot;);
                        dos.flush();
                }catch(IOException e)
                {
                        System.out.println(&amp;quot;创建连接问题&amp;quot;);
                }
        }
        public static void main(String[] args)
        {
                // TODO Auto-generated method stub
                new RewriteTestServer31();
        }

}

class ServerReRead21 extends Thread
{
        private DataInputStream dis = null;
        private String wordsFromClient = null;
        public ServerReRead21(DataInputStream dis)
        {
                this.dis = dis;
        }
        @Override
        public void run()
        {
                // TODO Auto-generated method stub
                try
                {
                        wordsFromClient = dis.readUTF();
                        System.out.println(&amp;quot;客户端对你说：&amp;quot;+wordsFromClient);  
                } catch (IOException e)
                {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                } 
        }
        
}

class ServerReWrite21 extends Thread
{
        private DataOutputStream dos = null;
        private BufferedReader br = null;
        private String wordsFromServer = null;
        public ServerReWrite21(DataOutputStream dos)
        {
                this.dos = dos;
        }
        
        @Override
        public void run()
        {
                //System.out.println(&amp;quot;dos=&amp;quot;+dos);
                // TODO Auto-generated method stub
                br = new BufferedReader(new InputStreamReader(System.in));
                while(true)
                {
                        try
                        {
                                wordsFromServer = br.readLine();
                                dos.writeUTF(wordsFromServer);
                                //要不要break????? if(bye){break}
                        }catch(IOException e)
                        {
                                
                        }
                }
        }
        
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有问题的RewriteTestClient31:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
* 解释：
*/
package TestNetwork;

import java.io.BufferedReader;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.ServerSocket;
import java.net.Socket;

/**
* @author    叶昭良
* @time      2015年3月22日下午5:12:56
* @version   TestNetworkRewriteTestClient3 V1.0
* 功能： 
                步骤：
* 注意：
* 掌握：
                思考：
* 回顾：
*/
public class RewriteTestClient31
{

        Socket s = null;
        DataInputStream dis = null;
    DataOutputStream dos = null;
        
        public RewriteTestClient31()
        {
                createConnection();
                ClientReRead31 sr = new ClientReRead31(dis);
                ClientReWrite31 sw = new ClientReWrite31(dos);
                sr.start();
                sw.start();        
        }
        
        /**
         * 功能： 创建一个读的连接，用于读取客户端的socket数据
         *       创建一个写的连接，通过BufferedReader进行缓冲读取System.in的数据
         *       并通过DataOutputStream发送出去
         *       思考：        
         *       步骤：
         */
        private void createConnection()
        {
                try
                {
                        s= new Socket(&amp;quot;127.0.0.1&amp;quot;,5566);
                        dis = new DataInputStream(s.getInputStream());
                        dos = new DataOutputStream(s.getOutputStream());
                        //增加了下面两句
                        
                }catch(IOException e)
                {
                        System.out.println(&amp;quot;创建连接问题&amp;quot;);
                }
        }
        public static void main(String[] args)
        {
                // TODO Auto-generated method stub
                new RewriteTestClient31();

        }

}
//主要更换地方 wordsFromServer  和服务器的不同地方
class ClientReRead31 extends Thread
{
        private DataInputStream dis = null;
        private String wordsFromServer  = null;
        public ClientReRead31(DataInputStream dis)
        {
                this.dis = dis;
        }
        @Override
        public void run()
        {
                // TODO Auto-generated method stub
                try
                {
                        wordsFromServer = dis.readUTF();
                        System.out.println(&amp;quot;服务器端对你说：&amp;quot;+wordsFromServer);  
                } catch (IOException e)
                {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                } 
        }
        
}
//主要更换地方 wordsFromClient  和服务器的不同地方
class ClientReWrite31 extends Thread
{
        private DataOutputStream dos = null;
        private BufferedReader br = null;
        private String  wordsFromClient= null;
        public ClientReWrite31(DataOutputStream dos)
        {
                this.dos = dos;
        }
        @Override
        public void run()
        {
                // TODO Auto-generated method stub
                br = new BufferedReader(new InputStreamReader(System.in));
                while(true)
                {
                        try
                        {
                                wordsFromClient = br.readLine();
                                dos.writeUTF(wordsFromClient);
                                //要不要break????? if(bye){break}
                        }catch(IOException e)
                        {
                                
                        }
                }
        }
        
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果我把所有的变量定义在main当中则是没有问题的（在implements Runnable)&lt;/p&gt;

&lt;p&gt;没问题的版本
RewriteTestServer3extends&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
* 解释：
*/
package TestNetwork;

import java.io.BufferedReader;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.ServerSocket;
import java.net.Socket;

/**
* @author    叶昭良
* @time      2015年3月22日下午5:57:16
* @version   TestNetworkRewriteTestServer3extends V1.0
* 功能： 
                步骤：
* 注意：
* 掌握：
                思考：
* 回顾：
*/
public class RewriteTestServer3extends
{

        /**
         * @param args 
         * 原因：
         * 解决：
         * 功能：
         *       思考：        
         *       步骤：
         */
        public static void main(String[] args)
        {
                // TODO Auto-generated method stub
                // TODO Auto-generated method stub
        ServerSocket ss = null;
        Socket s = null;
        DataOutputStream dos  = null;
        DataInputStream dis = null;
                try
                {
                        ss = new ServerSocket(8888);
                        s = ss.accept();
                        dos = new DataOutputStream(s.getOutputStream());

                        dis  = new DataInputStream(s.getInputStream());
                       

                new Thread(new ServerReadImp(dis)).start();
                new Thread(new ServerWriteImp(dos)).start();
                } catch (IOException e)
                {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                }

        }

}
class ServerReadImp implements Runnable
{
    private DataInputStream dis = null;
    public ServerReadImp(DataInputStream dis)
    {
        this.dis = dis;
    }

    public void run()
    {
        while(true)
        {
           try{
                String str = dis.readUTF();
                System.out.println(&amp;quot;客户端说:&amp;quot;+str);
                if(str.equalsIgnoreCase(&amp;quot;byebye&amp;quot;))
                    break;
           }catch(Exception e)
           {
               e.printStackTrace();
           }
        }
    }
}
class ServerWriteImp implements Runnable
{
    private DataOutputStream dos = null;
    public ServerWriteImp(DataOutputStream dos)
    {
        this.dos = dos;
    }

    public void run()
    {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        while(true)
        {
           try{
                String str = br.readLine();
                dos.writeUTF(str);
                if(str.equalsIgnoreCase(&amp;quot;byebye&amp;quot;))
                    break;
           }catch(Exception e)
           {
               e.printStackTrace();
           }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;问题较少的RewriteTestClient3extends&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
* 解释：
*/
package TestNetwork;

import java.io.BufferedReader;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.InputStreamReader;
import java.net.Socket;

/**
* @author    叶昭良
* @time      2015年3月22日下午5:57:44
* @version   TestNetworkRewriteTestClient3extends V1.0
* 功能： 
                步骤：
* 注意：
* 掌握：
                思考：
* 回顾：
*/
public class RewriteTestClient3extends 
{

        /**
         * @param args 
         * 原因：
         * 解决：
         * 功能：
         *       思考：        
         *       步骤：
         */

        public static void main(String[] args) throws Exception
        {
                // TODO Auto-generated method stub
        Socket s = new Socket(&amp;quot;127.0.0.1&amp;quot;,8888);
        DataOutputStream dos = new DataOutputStream(s.getOutputStream());

        DataInputStream dis = new DataInputStream(s.getInputStream());

        new Thread(new ClientReadImp(dis)).start();
        new Thread(new ClientWriteImp(dos)).start();

        }

}
class ClientReadImp implements Runnable
{
    private DataInputStream dis = null;
    public ClientReadImp(DataInputStream dis)
    {
        this.dis = dis;
    }

    public void run()
    {
        while(true)
        {
           try{
                String str = dis.readUTF();
                System.out.println(&amp;quot;服务器说:&amp;quot;+str);
                if(str.equalsIgnoreCase(&amp;quot;byebye&amp;quot;))
                    break;
           }catch(Exception e)
           {
               e.printStackTrace();
           }
        }
    }
}
class ClientWriteImp implements Runnable
{
    private DataOutputStream dos = null;
    public ClientWriteImp(DataOutputStream dos)
    {
        this.dos = dos;
    }

    public void run()
    {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        while(true)
        {
           try{
                String str = br.readLine();
                dos.writeUTF(str);
                if(str.equalsIgnoreCase(&amp;quot;byebye&amp;quot;))
                    break;
           }catch(Exception e)
           {
               e.printStackTrace();
           }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到的确是和变量放在哪里有着很大的关系，但是暂时不知道怎么解释？
还有网络编程，当服务器发送过后，是如何切换控制权的？（服务器的run处于while循环中，如何切换，有notify?(在生产和消费当中有wait and notify进行通知）&lt;/p&gt;

&lt;p&gt;另外前两个版本（RewriteTCPServer1 RewriteTCPServer2)我进行重新改写则是没有问题，第三个版本(RewriteTCPServer3)加入了线程则是有问题,
所以程序线程+程序变量肯定有一个存在问题，具体不清楚&lt;/p&gt;

&lt;p&gt;通过学习第十五节的网络编程，了解到while(true){ss.accept() ;  new线程的作用} 之前TCPServer3和RewriteServer3并没有多线程的效果，得在
服务器当中添加如下代码：增加一个while(true) 让服务器一直在等待连接（不然再ctrl+F11 并没有新的客户端连接服务器）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private void createConnection()
        {
                try
                {
                        ss = new ServerSocket(5566);
                        while(true)
                        {
                                s =  ss.accept();
                                ServerReRead2 sr = new ServerReRead2(dis);
                                ServerReWrite2 sw = new ServerReWrite2(dos);
                                Thread t1 = new Thread(sr);
                                Thread t2 = new Thread(sw);
                                t1.start();
                                t2.start();
                                dis = new DataInputStream(s.getInputStream());
                                dos = new DataOutputStream(s.getOutputStream());
                                //增加了下面两句
                                dos.writeUTF(&amp;quot;您好！我是服务器想要聊些什么:&amp;quot;);
                                dos.flush();
                        }
                                

                }catch(IOException e)
                {
                        System.out.println(&amp;quot;创建连接问题&amp;quot;);
                }
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有了这个意识之后，我发现之前的所谓的多线程的UI版本的TCPServer4 &amp;amp;  TCPClient4也是lier,根本没有实现。
具体是： 一个服务器端对应一个客户端，虽然你写着extends thread，也start了，但是在ss.accept
那边根本就没有循环的接收，暂时进行修改未通过，这是另一个问题。&lt;/p&gt;

&lt;p&gt;有进步了。改进了TCPServer4
1：客户端可以新建多个（但是这个多个还是有问题)&amp;mdash;&amp;gt;具体分析socket的while循环放的有问题（有待进一步测试）&lt;/p&gt;

&lt;p&gt;问题1：服务器无法发送出去数据
问题2：客户端不切换 还好可以，一切换之后发送一条就卡死了&lt;/p&gt;

&lt;p&gt;有问题的
RewriteServer4:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
* 解释：
*/
package TestNetwork;

/**
* @author    叶昭良
* @time      2015年3月22日下午10:08:18
* @version   TestNetworkRewriteTestServer4 V1.0
* 功能： 
                步骤：
* 注意：
* 掌握：
                思考：
* 回顾：
*/
import java.awt.BorderLayout;
import java.awt.Button;
import java.awt.Frame;
import java.awt.Panel;
import java.awt.TextArea;
import java.awt.TextField;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.io.*;
import java.net.*;

import javax.swing.JOptionPane;


public class RewriteTestServer4
{

        /**
         * @param args 
         * 原因：
         * 解决：
         * 功能：
         *       思考：        
         *       步骤：
         */
        public static void main(String[] args)
        {
                // TODO Auto-generated method stub
                new TCPServer1().launch();
        }

}


class TCPServer1
{
        // class variables
        // class variables
        // connect
         private ServerSocket ss = null;
         private Socket s = null;
         // data flow
         private DataOutputStream dos = null;
         private DataInputStream dis = null;
         // UI
         private Frame f = null;
         private TextArea ta = null;
         private TextField tf = null;
         private Button  bn = null;

       
         public void launch()
         {
             createUI();
             connect();

         }
        // construct member
        /*
        public TCPServer()
        {

        }
        */
        public void createUI()
        {
            Frame f = new Frame(&amp;quot;服务器&amp;quot;);
            ta = new TextArea();
            tf = new TextField();
            Panel p = new Panel(new BorderLayout());
            bn = new Button(&amp;quot;发送&amp;quot;);
            p.add(tf,BorderLayout.CENTER);
            p.add(bn,BorderLayout.EAST);

            f.add(ta,BorderLayout.CENTER);
            f.add(p,BorderLayout.SOUTH);

            f.setSize(400,200);
            f.setVisible(true);
            //f.setVisable(true);
/*            tf.addActionListener(new TCPServerListener());
            bn.addActionListener(new TCPServerListener());*/
            f.addWindowListener(new WindowAdapter()
                    {
                        public void windowClosing(WindowEvent e)
                        {
                            System.exit(0);
                        }
                    });
        }
        public void connect()
        {
                
            try
            {
                    ss = new ServerSocket(5599);
                    while(true)
                    {
                            //阻塞这边 等待客户端的连接
                        s = ss.accept();
                        dis = new DataInputStream(s.getInputStream());
                        dos = new DataOutputStream(s.getOutputStream());
                        dos.writeUTF(&amp;quot;欢迎你的到来&amp;quot;+s.getInetAddress().getHostAddress());
                        new UserReadThread().start();
                        new UserWriteThread().start();
                        System.out.println(Thread.currentThread().getName()+&amp;quot;已开启&amp;quot;);
                    }
                
            }catch(Exception e)
            {
                    System.out.println(&amp;quot;服务器端异常&amp;quot;);
               // System.exit(0);
            }
        }
        public void close()
        {
            try{
                ss.close();
                s.close();
            }catch(Exception e)
            {
                System.exit(0);
            }
        }
        
        class UserReadThread extends Thread
        {
                @Override
                public void run()
                {
                        while(true)
                {
                   try{
                        String str = dis.readUTF();
              //          System.out.println(&amp;quot;对方说:&amp;quot;+str);
                        ta.append(&amp;quot;客户端说：&amp;quot;+str+&amp;quot;\n&amp;quot;);
                        if(str.equalsIgnoreCase(&amp;quot;再见&amp;quot;))
                        {
                            close();
                            System.exit(0);
                        }
                   }catch(Exception e)
                   {
                       JOptionPane.showMessageDialog(f,&amp;quot;客户端已离开&amp;quot;);
                       return;
                   //    e.printStackTrace();
                   }
                }
                }
        }
        class UserWriteThread extends Thread
        {
                @Override
                public void run()
                {
                tf.addActionListener(new TCPServerListener());
                bn.addActionListener(new TCPServerListener());
                }
        }
        class TCPServerListener implements ActionListener
        {
            @Override
            public void actionPerformed(ActionEvent e)
            {
                   try{
                           String str = tf.getText();
                       if(!str.isEmpty())
                       {
                               tf.setText(&amp;quot;&amp;quot;);
                                ta.append(&amp;quot;服务器说:&amp;quot;+str+&amp;quot;\n&amp;quot;);
                                dos.writeUTF(str);
                                if(str.equalsIgnoreCase(&amp;quot;再见&amp;quot;))
                                {
                                    close();
                                    System.exit(0);
                                }
                       }
                   }catch(Exception e1)
                   {
                      // e.printStackTrace();
                      System.exit(0);
                   } 
            }
        }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;RewriteTestClient4:
/**
* 解释：
*/
package TestNetwork;&lt;/p&gt;

&lt;p&gt;import java.awt.BorderLayout;
import java.awt.Button;
import java.awt.Frame;
import java.awt.Panel;
import java.awt.TextArea;
import java.awt.TextField;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.net.Socket;&lt;/p&gt;

&lt;p&gt;import javax.swing.JOptionPane;&lt;/p&gt;

&lt;p&gt;import TestNetwork.TCPClient.TCPClientListener;&lt;/p&gt;

&lt;p&gt;/**
* @author    叶昭良
* @time      2015年3月22日下午10:08:37
* @version   TestNetworkRewriteTestClient4 V1.0
* 功能：
                步骤：
* 注意：
* 掌握：
                思考：
* 回顾：
*/
public class RewriteTestClient4
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /**
     * @param args 
     * 原因：
     * 解决：
     * 功能：
     *       思考：        
     *       步骤：
     */
    public static void main(String[] args)
    {
            // TODO Auto-generated method stub
             new TCPClient1().launch();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;class TCPClient1
{
        // class variables
        // class variables
        // connect
         private Socket s = null;
         // data flow
         private DataOutputStream dos = null;
         private DataInputStream dis = null;
         // UI
         private Frame f = null;
         private TextArea ta = null;
         private TextField tf = null;
         private Button  bn = null;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     public void launch()
     {
         createUI();
         connect();
       //  new ClientRead().start();
        // new ClientWrite().start();
     }
    // construct member
    /*
    public TCPClient()
    {

    }
    */
    public void createUI()
    {
        Frame f = new Frame(&amp;quot;客户端&amp;quot;);
        ta = new TextArea();
        tf = new TextField();
        Panel p = new Panel(new BorderLayout());
        bn = new Button(&amp;quot;发送&amp;quot;);
        p.add(tf,BorderLayout.CENTER);
        p.add(bn,BorderLayout.EAST);

        f.add(ta,BorderLayout.CENTER);
        f.add(p,BorderLayout.SOUTH);

        f.setSize(400,200);
        f.setVisible(true);
        //f.setVisable(true);
            tf.addActionListener(new TCPClientListener());
            bn.addActionListener(new TCPClientListener());
        f.addWindowListener(new WindowAdapter()
                {
                    public void windowClosing(WindowEvent e)
                    {
                        System.exit(0);
                    }
                });
    }
    public void connect()
    {
        try{
            s = new Socket(&amp;quot;127.0.0.2&amp;quot;,5599);
            dis = new DataInputStream(s.getInputStream());
            dos = new DataOutputStream(s.getOutputStream());
                try{
                        //少了这个while不行！则不能循环接收
                        while(true)
                        {
                                      String str = dis.readUTF();
                                   //System.out.println(&amp;quot;对方说:&amp;quot;+str);
                                   ta.append(&amp;quot;服务器说:&amp;quot;+str+&amp;quot;\n&amp;quot;);
                                   if(str.equalsIgnoreCase(&amp;quot;再见&amp;quot;))
                                   {
                                       close();
                                       System.exit(0);
                                   }
                        }

                  }catch(Exception e)
                  {
                      JOptionPane.showMessageDialog(f,&amp;quot;客户端已离开&amp;quot;);
                      return;
                  }

        }catch(Exception e)
        {
                System.out.println(&amp;quot;客户端异常&amp;quot;);
            //System.exit(0);
        }
    }
    public void close()
    {
        try{
            dis.close();
            dos.close();
            s.close();
        }catch(Exception e)
        {
            System.exit(0);
        }
    }


    class TCPClientListener implements ActionListener
    {
        @Override
        public void actionPerformed(ActionEvent e)
        {
               try{
                    String str = tf.getText();
                    tf.setText(&amp;quot;&amp;quot;);
                    ta.append(&amp;quot;客户端说:&amp;quot;+str+&amp;quot;\n&amp;quot;);
                    dos.writeUTF(str);
                    if(str.equalsIgnoreCase(&amp;quot;再见&amp;quot;))
                    {
                        close();
                        System.exit(0);
                    }
               }catch(Exception e1)
               {
                  // e.printStackTrace();
                  System.exit(0);
               } 
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;结果：
![有问题的Server和Client图](/images/java/结果.png)


1： 改用在main方法中定义循环的socket等待试试，即
     ServerSocket ss = new ServerSocket(5599);
        
            while(true)
            {
                    new TCPServer1(ss.accept()).launch();
            }
复制代码
去掉ServerRead那边的一种Connection函数中的循环的socket.accept:

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java
public void connect()
        {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        try
        {
                //while(true)
                //{
                        //阻塞这边 等待客户端的连接
                    dis = new DataInputStream(s.getInputStream());
                    dos = new DataOutputStream(s.getOutputStream());
                    dos.writeUTF(&amp;quot;欢迎你的到来&amp;quot;+s.getInetAddress().getHostAddress());
                    new UserReadThread().start();
                    new UserWriteThread().start();
                    System.out.println(Thread.currentThread().getName()+&amp;quot;已开启&amp;quot;);
                //}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;2: 使用静态代码段的方法，只创建一个UI界面，不再把createUI放在launch当中，否则 只有在连接上客户端会创建客户端的同时也创建了服务器
   服务器一直在增加，这不是我们所想的，只要一个服务器，于是采用static方法

至少在这边已经开始注意一个问题： 到底Client的read &amp;amp; write要不要加入线程？ 这边是没有，仅仅是服务器的read &amp;amp; write加入了线程？ 



具体的RewreiteTestServer4:

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java
/**
* 解释：
*/
package TestNetwork;&lt;/p&gt;

&lt;p&gt;/**
* @author    叶昭良
* @time      2015年3月22日下午10:08:18
* @version   TestNetworkRewriteTestServer4 V1.0
* 功能：
                步骤：
* 注意：
* 掌握：
                思考：
* 回顾：
&lt;em&gt;/
import java.awt.BorderLayout;
import java.awt.Button;
import java.awt.Frame;
import java.awt.Panel;
import java.awt.TextArea;
import java.awt.TextField;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.io.&lt;/em&gt;;
import java.net.*;&lt;/p&gt;

&lt;p&gt;import javax.swing.JOptionPane;&lt;/p&gt;

&lt;p&gt;public class RewriteTestServer4
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /**
     * @param args 
     * 原因：
     * 解决：
     * 功能：
     *       思考：        
     *       步骤：
     */
    public static void main(String[] args) throws Exception
    {
            // TODO Auto-generated method stub
        ServerSocket ss = new ServerSocket(5599);

        while(true)
        {
                new TCPServer1(ss.accept()).launch();
        }

    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;class TCPServer1
{
        // class variables
        // class variables
        // connect&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     private Socket s = null;
     // data flow
     private DataOutputStream dos = null;
     private DataInputStream dis = null;
     // UI
     private static Frame f = null;
     private static TextArea ta = null;
     private static TextField tf = null;
     private static Button  bn = null;
     static
     {
             createUI();
     }
     public  TCPServer1(Socket s)
     {
             this.s = s;
     }

     public void launch()
     {

         connect();

     }
    // construct member
    /*
    public TCPServer()
    {

    }
    */
    public static void createUI()
    {
        Frame f = new Frame(&amp;quot;服务器&amp;quot;);
        ta = new TextArea();
        tf = new TextField();
        Panel p = new Panel(new BorderLayout());
        bn = new Button(&amp;quot;发送&amp;quot;);
        p.add(tf,BorderLayout.CENTER);
        p.add(bn,BorderLayout.EAST);

        f.add(ta,BorderLayout.CENTER);
        f.add(p,BorderLayout.SOUTH);

        f.setSize(400,200);
        f.setVisible(true);
        //f.setVisable(true);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;/*            tf.addActionListener(new TCPServerListener());
            bn.addActionListener(new TCPServerListener());*/
            f.addWindowListener(new WindowAdapter()
                    {
                        public void windowClosing(WindowEvent e)
                        {
                            System.exit(0);
                        }
                    });
        }
        public void connect()
        {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        try
        {
                //while(true)
                //{
                        //阻塞这边 等待客户端的连接
                    dis = new DataInputStream(s.getInputStream());
                    dos = new DataOutputStream(s.getOutputStream());
                    dos.writeUTF(&amp;quot;欢迎你的到来&amp;quot;+s.getInetAddress().getHostAddress());
                    new UserReadThread().start();
                    new UserWriteThread().start();
                    System.out.println(Thread.currentThread().getName()+&amp;quot;已开启&amp;quot;);
                //}

        }catch(Exception e)
        {
                System.out.println(&amp;quot;服务器端异常&amp;quot;);
           // System.exit(0);
        }
    }
    public void close()
    {
        try{
            s.close();
        }catch(Exception e)
        {
            System.exit(0);
        }
    }

    class UserReadThread extends Thread
    {
            @Override
            public void run()
            {
                    while(true)
            {
               try{
                    String str = dis.readUTF();
          //          System.out.println(&amp;quot;对方说:&amp;quot;+str);
                    ta.append(&amp;quot;客户端说：&amp;quot;+str+&amp;quot;\n&amp;quot;);
                    if(str.equalsIgnoreCase(&amp;quot;再见&amp;quot;))
                    {
                        close();
                        System.exit(0);
                    }
               }catch(Exception e)
               {
                   JOptionPane.showMessageDialog(f,&amp;quot;客户端已离开&amp;quot;);
                   return;
               //    e.printStackTrace();
               }
            }
            }
    }
    class UserWriteThread extends Thread
    {
            @Override
            public void run()
            {
            tf.addActionListener(new TCPServerListener());
            bn.addActionListener(new TCPServerListener());
            }
    }
    class TCPServerListener implements ActionListener
    {
        @Override
        public void actionPerformed(ActionEvent e)
        {
               try{
                       String str = tf.getText();
                   if(!str.isEmpty())
                   {
                           tf.setText(&amp;quot;&amp;quot;);
                            ta.append(&amp;quot;服务器说:&amp;quot;+str+&amp;quot;\n&amp;quot;);
                            dos.writeUTF(str);
                            if(str.equalsIgnoreCase(&amp;quot;再见&amp;quot;))
                            {
                                close();
                                System.exit(0);
                            }
                   }
               }catch(Exception e1)
               {
                  // e.printStackTrace();
                  System.exit(0);
               } 
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;RewriteClient4:


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java
/**
* 解释：
*/
package TestNetwork;&lt;/p&gt;

&lt;p&gt;import java.awt.BorderLayout;
import java.awt.Button;
import java.awt.Frame;
import java.awt.Panel;
import java.awt.TextArea;
import java.awt.TextField;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.net.Socket;&lt;/p&gt;

&lt;p&gt;import javax.swing.JOptionPane;&lt;/p&gt;

&lt;p&gt;import TestNetwork.TCPClient.TCPClientListener;&lt;/p&gt;

&lt;p&gt;/**
* @author    叶昭良
* @time      2015年3月22日下午10:08:37
* @version   TestNetworkRewriteTestClient4 V1.0
* 功能：
                步骤：
* 注意：
* 掌握：
                思考：
* 回顾：
*/
public class RewriteTestClient4
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /**
     * @param args 
     * 原因：
     * 解决：
     * 功能：
     *       思考：        
     *       步骤：
     */
    public static void main(String[] args)
    {
            // TODO Auto-generated method stub
             new TCPClient1().launch();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;class TCPClient1
{
        // class variables
        // class variables
        // connect
         private Socket s = null;
         // data flow
         private DataOutputStream dos = null;
         private DataInputStream dis = null;
         // UI
         private Frame f = null;
         private TextArea ta = null;
         private TextField tf = null;
         private Button  bn = null;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     public void launch()
     {
         createUI();
         connect();
       //  new ClientRead().start();
        // new ClientWrite().start();
     }
    // construct member
    /*
    public TCPClient()
    {

    }
    */
    public void createUI()
    {
        Frame f = new Frame(&amp;quot;客户端&amp;quot;);
        ta = new TextArea();
        tf = new TextField();
        Panel p = new Panel(new BorderLayout());
        bn = new Button(&amp;quot;发送&amp;quot;);
        p.add(tf,BorderLayout.CENTER);
        p.add(bn,BorderLayout.EAST);

        f.add(ta,BorderLayout.CENTER);
        f.add(p,BorderLayout.SOUTH);

        f.setSize(400,200);
        f.setVisible(true);
        //f.setVisable(true);
            tf.addActionListener(new TCPClientListener());
            bn.addActionListener(new TCPClientListener());
        f.addWindowListener(new WindowAdapter()
                {
                    public void windowClosing(WindowEvent e)
                    {
                        System.exit(0);
                    }
                });
    }
    public void connect()
    {
        try{
            s = new Socket(&amp;quot;127.0.0.1&amp;quot;,5599);
            dis = new DataInputStream(s.getInputStream());
            dos = new DataOutputStream(s.getOutputStream());
                try{
                        //少了这个while不行！则不能循环接收
                        while(true)
                        {
                                      String str = dis.readUTF();
                                   //System.out.println(&amp;quot;对方说:&amp;quot;+str);
                                   ta.append(&amp;quot;服务器说:&amp;quot;+str+&amp;quot;\n&amp;quot;);
                                   if(str.equalsIgnoreCase(&amp;quot;再见&amp;quot;))
                                   {
                                       close();
                                       System.exit(0);
                                   }
                        }

                  }catch(Exception e)
                  {
                      JOptionPane.showMessageDialog(f,&amp;quot;客户端已离开&amp;quot;);
                      return;
                  }

        }catch(Exception e)
        {
                System.out.println(&amp;quot;客户端异常&amp;quot;);
            //System.exit(0);
        }
    }
    public void close()
    {
        try{
            dis.close();
            dos.close();
            s.close();
        }catch(Exception e)
        {
            System.exit(0);
        }
    }


    class TCPClientListener implements ActionListener
    {
        @Override
        public void actionPerformed(ActionEvent e)
        {
               try{
                    String str = tf.getText();
                    tf.setText(&amp;quot;&amp;quot;);
                    ta.append(&amp;quot;客户端说:&amp;quot;+str+&amp;quot;\n&amp;quot;);
                    dos.writeUTF(str);
                    if(str.equalsIgnoreCase(&amp;quot;再见&amp;quot;))
                    {
                        close();
                        System.exit(0);
                    }
               }catch(Exception e1)
               {
                  // e.printStackTrace();
                  System.exit(0);
               } 
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;结果：

通过分析发现，的确是需要把socket.accept放在main中，而不是connection中！ 为什么？ 也许是connection会跳出？ 具体的不太清楚，如果有人知道求证明之。。。。

另外还存在一个问题，为什么服务器发出的数据只是放在第一个连接的地方？ 这是不是跟Client没有线程有关系，如果我也建个clientRead &amp;amp; clientWrite线程？
![现在的切换和传递都不成问题](/images/java/切换不成问题.png)






1：增加了两个ClientRead &amp;amp; ClientWrite两个线程，尝试看一下是否可以群发，
2： 并把socket的创建 提到main当中

Client的重写：

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java
/**
* 解释：
*/
package TestNetwork;&lt;/p&gt;

&lt;p&gt;import java.awt.BorderLayout;
import java.awt.Button;
import java.awt.Frame;
import java.awt.Panel;
import java.awt.TextArea;
import java.awt.TextField;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.io.BufferedReader;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.Socket;&lt;/p&gt;

&lt;p&gt;import javax.swing.JOptionPane;&lt;/p&gt;

&lt;p&gt;/**
* @author    叶昭良
* @time      2015年3月22日下午10:08:37
* @version   TestNetworkRewriteTestClient4 V1.0
* 功能：
                步骤：
* 注意：
* 掌握：
                思考：
* 回顾：
*/
public class RewriteTestClient4
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /**
     * @param args 
     * 原因：
     * 解决：
     * 功能：
     *       思考：        
     *       步骤：
     */
    public static void main(String[] args)
    {
            // TODO Auto-generated method stub
            Socket s  = null;
             try
            {
                    s = new Socket(&amp;quot;127.0.0.1&amp;quot;,5599);
            } catch (IOException e)
            {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
            }
             new TCPClient1(s).launch();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;class TCPClient1
{
        // class variables
        // class variables
        // connect
         private Socket s = null;
         // data flow
         private DataOutputStream dos = null;
         private DataInputStream dis = null;
         // UI
         private Frame f = null;
         private TextArea ta = null;
         private TextField tf = null;
         private Button  bn = null;
         public TCPClient1(Socket s)
         {
                 this.s = s;
         }&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     public void launch()
     {
         createUI();
         connect();
         new ClientRead(dis).start();
         new ClientWrite(dos).start();
     }
    // construct member
    /*
    public TCPClient()
    {

    }
    */
    public void createUI()
    {
        Frame f = new Frame(&amp;quot;客户端&amp;quot;);
        ta = new TextArea();
        tf = new TextField();
        Panel p = new Panel(new BorderLayout());
        bn = new Button(&amp;quot;发送&amp;quot;);
        p.add(tf,BorderLayout.CENTER);
        p.add(bn,BorderLayout.EAST);

        f.add(ta,BorderLayout.CENTER);
        f.add(p,BorderLayout.SOUTH);

        f.setSize(400,200);
        f.setVisible(true);
        //f.setVisable(true);
            tf.addActionListener(new TCPClientListener());
            bn.addActionListener(new TCPClientListener());
        f.addWindowListener(new WindowAdapter()
                {
                    public void windowClosing(WindowEvent e)
                    {
                        System.exit(0);
                    }
                });
    }
    public void connect()
    {
        try{

            dis = new DataInputStream(s.getInputStream());
            dos = new DataOutputStream(s.getOutputStream());

        }catch(Exception e)
        {
                System.out.println(&amp;quot;客户端异常&amp;quot;);
            //System.exit(0);
        }
    }
    public void close()
    {
        try{
            dis.close();
            dos.close();
            s.close();
        }catch(Exception e)
        {
            System.exit(0);
        }
    }
    class ClientRead extends Thread
    {
        private DataInputStream dis = null;
        public ClientRead(DataInputStream dis)
        {
            this.dis = dis;
        }

        public void run()
        {
            while(true)
            {
               try{
                    String str = dis.readUTF();
                    ta.append(&amp;quot;服务器说:&amp;quot;+str+&amp;quot;\n&amp;quot;);
                    if(str.equalsIgnoreCase(&amp;quot;再见&amp;quot;))
                    {
                        close();
                        System.exit(0);
                    }
                    System.out.println(&amp;quot;服务器说:&amp;quot;+str);
                    if(str.equalsIgnoreCase(&amp;quot;byebye&amp;quot;))
                        break;
               }catch(Exception e)
               {
                          JOptionPane.showMessageDialog(f,&amp;quot;客户端已离开&amp;quot;);
                          return;
               }
            }
        }
    }
    class ClientWrite extends Thread
    {
        private DataOutputStream dos = null;
        public ClientWrite(DataOutputStream dos)
        {
            this.dos = dos;
        }

        public void run()
        {
            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
            while(true)
            {
               try{
                    String str = br.readLine();
                    dos.writeUTF(str);
                    if(str.equalsIgnoreCase(&amp;quot;byebye&amp;quot;))
                        break;
               }catch(Exception e)
               {
                   e.printStackTrace();
               }
            }
        }
    }

    class TCPClientListener implements ActionListener
    {
        @Override
        public void actionPerformed(ActionEvent e)
        {
               try{
                    String str = tf.getText();
                    tf.setText(&amp;quot;&amp;quot;);
                    ta.append(&amp;quot;客户端说:&amp;quot;+str+&amp;quot;\n&amp;quot;);
                    dos.writeUTF(str);
                    if(str.equalsIgnoreCase(&amp;quot;再见&amp;quot;))
                    {
                        close();
                        System.exit(0);
                    }
               }catch(Exception e1)
               {
                  // e.printStackTrace();
                  System.exit(0);
               } 
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;结果：
结果分析发现，并没有丝毫的改进。what a pity.

![结果还是跟上例的client没有线程一样](/images/java/yiranmeiyou.png)


参考此文进行修改：

1：加入了三个主要集合   
  用户   user_list
  线程集
  消息集
2：服务器端的主要修正：
    1.在线程类的构造函数都添加 了start() 开启线程
    2.删掉了ServerWrite &amp;amp;ServerRead线程  都整合到ThreadServer类中
    3.增加了一个PrintOutThread用于向客户端发送消息
3：客户端的主要修正：
   新建了一个readLineThread() 读取服务器数据，并传递客户端数据
   删除了ClientReader  &amp;amp; ClientWriter  &amp;amp; launch等函数


基本能够实现转发的功能，但是
存在的问题：开启多个则计算机变得特别卡


RewriteServer5的实现：


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java
/**
* 解释：
*/
package TestNetwork;&lt;/p&gt;

&lt;p&gt;import java.awt.BorderLayout;
import java.awt.Button;
import java.awt.Frame;
import java.awt.Panel;
import java.awt.TextArea;
import java.awt.TextField;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.*;&lt;/p&gt;

&lt;p&gt;/**
* @author    叶昭良
* @time      2015年3月23日上午12:41:10
* @version   TestNetworkRewriteTestServer5 V1.0
* 功能：
                步骤：
* 注意：
* 掌握：
                思考：
* 回顾：
*/
public class RewriteTestServer5
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /**
     * @param args 
     * 原因：
     * 解决：
     * 功能：
     *       思考：        
     *       步骤：
     */
    public static void main(String[] args) throws Exception
    {
            // TODO Auto-generated method stub
        ServerSocket ss = new ServerSocket(5599);
    while(true)
    {
            new TCPServer2(ss.accept());
    }

    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
class TCPServer2
{
        // class variables
        // class variables
        // connect&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     private Socket s = null;
     // data flow
     private DataOutputStream dos = null;
     private DataInputStream dis = null;
     // UI
     private static Frame f = null;
     private static TextArea ta = null;
     private static TextField tf = null;
     private static Button  bn = null;

     private static boolean isPrint = false;//是否输出消息标志
     private static List user_list = new ArrayList();//登陆用户集合
     private static List&amp;lt;ServerThread&amp;gt; thread_list = new ArrayList&amp;lt;ServerThread&amp;gt;();//服务器已启用的线程集合
     private static LinkedList&amp;lt;String&amp;gt; message_list = new LinkedList&amp;lt;String&amp;gt;();//存放消息队列

     static
     {
             createUI();
     }
     public  TCPServer2(Socket s) throws Exception
     {
             this.s = s;
             new PrintOutThread();//创建向客户端发送消息线程
         new ServerThread(this.s);  
         //本以为可以让其线程安全的，没想到没什么效果 反而更卡
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;/*             Collections.synchronizedList(user_list);
             Collections.synchronizedList(thread_list);
             Collections.synchronizedList(message_list);*/
            // launch();&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     }

    // construct member
    /*
    public TCPServer()
    {

    }
    */
    public static void createUI()
    {
        Frame f = new Frame(&amp;quot;服务器&amp;quot;);
        ta = new TextArea();
        tf = new TextField();
        Panel p = new Panel(new BorderLayout());
        bn = new Button(&amp;quot;发送&amp;quot;);
        p.add(tf,BorderLayout.CENTER);
        p.add(bn,BorderLayout.EAST);

        f.add(ta,BorderLayout.CENTER);
        f.add(p,BorderLayout.SOUTH);

        f.setSize(400,200);
        f.setVisible(true);
        //f.setVisable(true);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;/*            tf.addActionListener(new TCPServerListener());
            bn.addActionListener(new TCPServerListener());*/
            f.addWindowListener(new WindowAdapter()
                    {
                        public void windowClosing(WindowEvent e)
                        {
                            System.exit(0);
                        }
                    });
        }&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public void close()
    {
        try{
            s.close();
        }catch(Exception e)
        {
            System.exit(0);
        }
    }

    class TCPServerListener implements ActionListener
    {
        @Override
        public void actionPerformed(ActionEvent e)
        {
               try{
                       String str = tf.getText();
                   if(!str.isEmpty())
                   {
                           tf.setText(&amp;quot;&amp;quot;);
                            ta.append(&amp;quot;服务器说:&amp;quot;+str+&amp;quot;\n&amp;quot;);
                            dos.writeUTF(str);
                            if(str.equalsIgnoreCase(&amp;quot;再见&amp;quot;))
                            {
                                close();
                                System.exit(0);
                            }
                   }
               }catch(Exception e1)
               {
                  // e.printStackTrace();
                  System.exit(0);
               } 
        }
    }

    /**
     * 服务器线程类
     */
    class ServerThread extends Thread{
            private Socket client;
            private String name = null;
            public ServerThread(Socket s) throws Exception
            {
                    this.client = s;
                    dis = new DataInputStream(client.getInputStream());
            dos = new DataOutputStream(client.getOutputStream());
            dos.writeUTF(&amp;quot;成功连上服务器&amp;quot;+client.getInetAddress().getHostAddress());
            dos.writeUTF(Thread.currentThread().getName()+&amp;quot;已开启&amp;quot;+&amp;quot;请输入你的姓名&amp;quot;);
            this.start();
            tf.addActionListener(new TCPServerListener());
            bn.addActionListener(new TCPServerListener());
            }
            @Override
            public void run()
            {
                    try
                    {
                            int flag = 0 ;
                            String line = dis.readUTF();
                            while(!&amp;quot;bye&amp;quot;.equals(line))
                            {
                                    //查看在线用户列表
                    if (&amp;quot;showuser&amp;quot;.equals(line)) {
                        dos.writeUTF(this.listOnlineUsers());
                        line = dis.readUTF();
                    }
                    //第一次进入，保存名字

                    if(flag++ ==0){
                        name = line;
                        user_list.add(name);
                        thread_list.add(this);
                        System.out.println(&amp;quot;this=&amp;quot;+this);
                        dos.writeUTF(name +&amp;quot;你好,可以开始聊天了...&amp;quot;);
                        this.pushMessage(&amp;quot;Client&amp;lt;&amp;quot; + name +&amp;quot;&amp;gt;进入聊天室...+\n&amp;quot;);
                        ta.append(&amp;quot;Client&amp;lt;&amp;quot; + name +&amp;quot;&amp;gt;进入聊天室...\n&amp;quot;);
                    }else{
                            ta.append(&amp;quot;Client&amp;lt;&amp;quot; + name +&amp;quot;&amp;gt; say : &amp;quot; + line+&amp;quot;\n&amp;quot;);
                            this.pushMessage(&amp;quot;Client&amp;lt;&amp;quot; + name +&amp;quot;&amp;gt; say : &amp;quot; + line+&amp;quot;\n&amp;quot;);
                    }
                    line = dis.readUTF();
                            }
                    }catch(IOException e)
                    {

                    }
            }

             //放入消息队列末尾，准备发送给客户端
        private void pushMessage(String msg){
            message_list.addLast(msg);
            isPrint =true;
        }

        //向客户端发送一条消息(在PrintOutThread 有使用 于是变成了public修饰)
        public void sendMessage(String msg) throws Exception{
            dos.writeUTF(msg);
            dos.flush();
        }

        //统计在线用户列表  需要在showuser中使用  改为public
        private String listOnlineUsers() {
            String s =&amp;quot;--- 在线用户列表 ---\015\012&amp;quot;;
            for (int i =0; i &amp;lt; user_list.size(); i++) {
                s +=&amp;quot;[&amp;quot; + user_list.get(i) +&amp;quot;]\015\012&amp;quot;;
            }
            s +=&amp;quot;--------------------&amp;quot;;
            return s;
        }
    }
    /**
     * 监听是否有输出消息请求线程类,向客户端发送消息
     */
    class PrintOutThread extends Thread
    {
        public PrintOutThread()
        {
            start();
        }

        @Override
        public void run() 
        {
            while(true){
                if(isPrint){//将缓存在队列中的消息按顺序发送到各客户端，并从队列中清除。
                    String message = message_list.getFirst();
                    for (ServerThread thread : thread_list) 
                    {
                        try
                                                    {
                                                            thread.sendMessage(message);
                                                    } catch (Exception e)
                                                    {
                                                            // TODO Auto-generated catch block
                                                            e.printStackTrace();
                                                    }
                    }
                    message_list.removeFirst();
                    isPrint = message_list.size() &amp;gt;0 ?true :false;
                }
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;


RewriteClient5的实现：


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java
/**
* 解释：
*/
package TestNetwork;&lt;/p&gt;

&lt;p&gt;import java.awt.BorderLayout;
import java.awt.Button;
import java.awt.Frame;
import java.awt.Panel;
import java.awt.TextArea;
import java.awt.TextField;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.io.BufferedReader;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.Socket;&lt;/p&gt;

&lt;p&gt;import javax.swing.JOptionPane;&lt;/p&gt;

&lt;p&gt;import TestNetwork.TCPClient1.ClientRead;
import TestNetwork.TCPClient1.ClientWrite;
import TestNetwork.TCPClient1.TCPClientListener;&lt;/p&gt;

&lt;p&gt;/**
* @author    叶昭良
* @time      2015年3月23日上午1:57:54
* @version   TestNetworkRewriteTestClient5 V1.0
* 功能：
                步骤：
* 注意：
* 掌握：
                思考：
* 回顾：
*/
public class RewriteTestClient5
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /**
     * @param args 
     * 原因：
     * 解决：
     * 功能：
     *       思考：        
     *       步骤：
     */
    public static void main(String[] args) throws Exception
    {
            // TODO Auto-generated method stub
            Socket s  = null;
            s = new Socket(&amp;quot;127.0.0.1&amp;quot;,5599);

             new TCPClient5(s);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
class TCPClient5
{
        // class variables
        // class variables
        // connect
         private Socket s = null;
         // data flow
         private DataOutputStream dos = null;
         private DataInputStream dis = null;
         // UI
         private Frame f = null;
         private TextArea ta = null;
         private TextField tf = null;
         private Button  bn = null;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     /**
      * 与服务器连接，并输入发送消息
      */
     public TCPClient5(Socket s) throws Exception
     {
             this.s = s;
             dis = new DataInputStream(s.getInputStream());
         dos = new DataOutputStream(s.getOutputStream());
         createUI();
         //new ClientRead(dis);
         //new ClientWrite(dos);
         new readLineThread();

     }
     /**
      * 用于监听服务器端向客户端发送消息线程类
      */

    public void createUI()
    {
        Frame f = new Frame(&amp;quot;客户端&amp;quot;);
        ta = new TextArea();
        tf = new TextField();
        Panel p = new Panel(new BorderLayout());
        bn = new Button(&amp;quot;发送&amp;quot;);
        p.add(tf,BorderLayout.CENTER);
        p.add(bn,BorderLayout.EAST);

        f.add(ta,BorderLayout.CENTER);
        f.add(p,BorderLayout.SOUTH);

        f.setSize(400,200);
        f.setVisible(true);
        //f.setVisable(true);
            tf.addActionListener(new TCPClientListener());
            bn.addActionListener(new TCPClientListener());
        f.addWindowListener(new WindowAdapter()
                {
                    public void windowClosing(WindowEvent e)
                    {
                        System.exit(0);
                    }
                });
    }

    public void close()
    {
        try{
            dis.close();
            dos.close();
            s.close();
        }catch(Exception e)
        {
            System.exit(0);
        }
    }
    /**
     * 用于监听服务器端向客户端发送消息线程类
     */
    class readLineThread extends Thread
    {

        private BufferedReader buff = null;;
        public readLineThread(){
                start();

        }

        @Override
        public void run() {
            try {
                while(true){
                    String result = dis.readUTF();
                    if(&amp;quot;byeClient&amp;quot;.equals(result)){//客户端申请退出，服务端返回确认退出
                        break;
                    }else{//输出服务端发送消息
                            //ta.append(result);
                        System.out.println(result);
                       // dos.writeUTF(result);
                        ta.append(&amp;quot;服务器传递说:&amp;quot;+result+&amp;quot;\n&amp;quot;);
                        if(result.equalsIgnoreCase(&amp;quot;再见&amp;quot;))
                        {
                            close();
                            System.exit(0);
                        }
                    }
                }
            }catch (Exception e) {
            }
        }
    }

    class TCPClientListener implements ActionListener
    {
        @Override
        public void actionPerformed(ActionEvent e)
        {
               try{
                    String str = tf.getText();
                    tf.setText(&amp;quot;&amp;quot;);
                    ta.append(&amp;quot;客户端说:&amp;quot;+str+&amp;quot;\n&amp;quot;);
                    dos.writeUTF(str);
                    if(str.equalsIgnoreCase(&amp;quot;再见&amp;quot;))
                    {
                        close();
                        System.exit(0);
                    }
               }catch(Exception e1)
               {
                  // e.printStackTrace();
                  System.exit(0);
               } 
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;


结果： 还有一问题待解决，运行多个界面，程序占用内存过大！！！！！！ 如何解决？？

![服务器转发客户端实现局部聊天](/images/java/jiben.png)

还有一个问题：服务器说的话只能发给一个人。

解决办法：
修改TCPServerListener的实现：
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java
private ServerThread st = null;
                public TCPServerListener(ServerThread s)
                {
                        st =s ;
                }&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;并在actionPerformed中增加 st.pushMessage();

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java
                   try{
                           String str = tf.getText();
                       if(!str.isEmpty())
                       {
                                       tf.setText(&amp;ldquo;&amp;rdquo;);
                                ta.append(&amp;ldquo;服务器说:&amp;ldquo;+str+&amp;rdquo;\n&amp;rdquo;);
                                dos.writeUTF(str);
                                if(str.equalsIgnoreCase(&amp;ldquo;再见&amp;rdquo;))
                                {
                                    close();
                                    System.exit(0);
                                }
                                //ta.append(&amp;ldquo;Client&amp;lt;&amp;rdquo; + name +&amp;ldquo;&amp;gt; say : &amp;ldquo; + line+&amp;rdquo;\n&amp;rdquo;);
                                st.pushMessage(&amp;ldquo;服务器说:&amp;ldquo;+str+&amp;rdquo;\n&amp;rdquo;);
                       }&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;当然在ServerThread服务器线程类中，增加

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java
private ServerThread st = null; // 受到启发的作用！！ Client=s&lt;/p&gt;

&lt;p&gt;this.st = this;
的确这样修改完有效果，能够群发了，但是就是有些哥们的客户端发的是两条重复信息，有些却是一条。&lt;/p&gt;

&lt;p&gt;重要修改，能够保证服务器发的信息不至于发太多给某一个客户端：
                           String str = tf.getText();
                       if(!str.isEmpty())
                       {
                                       tf.setText(&amp;ldquo;&amp;rdquo;);
                                ta.append(&amp;ldquo;服务器说:&amp;ldquo;+str+&amp;rdquo;\n&amp;rdquo;);
                                //dos.writeUTF(str);  //如果不注释掉 其中有一个用户会得到两条重复信息，都把他放在message_list中进行转发，而不是特例的一个利用dos.writeUTF(str)
                                if(str.equalsIgnoreCase(&amp;ldquo;再见&amp;rdquo;))
                                {
                                    close();
                                    System.exit(0);
                                }&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                            st.pushMessage(&amp;quot;服务器说:&amp;quot;+str+&amp;quot;\n&amp;quot;);
                   }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;

基于此我们的Server端如下：



&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java
/**
* 解释：
*/
package TestNetwork;&lt;/p&gt;

&lt;p&gt;import java.awt.BorderLayout;
import java.awt.Button;
import java.awt.Frame;
import java.awt.Panel;
import java.awt.TextArea;
import java.awt.TextField;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.*;&lt;/p&gt;

&lt;p&gt;/**
* @author    叶昭良
* @time      2015年3月23日上午12:41:10
* @version   TestNetworkRewriteTestServer5 V1.0
* 功能：
                步骤：
* 注意：
* 掌握：
                思考：
* 回顾：
*/
public class RewriteTestServer5
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /**
     * @param args 
     * 原因：
     * 解决：
     * 功能：
     *       思考：        
     *       步骤：
     */
    public static void main(String[] args) throws Exception
    {
            // TODO Auto-generated method stub
        ServerSocket ss = new ServerSocket(5599);
    while(true)
    {
            new TCPServer2(ss.accept());
    }

    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
class TCPServer2
{
        // class variables
        // class variables
        // connect&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     private Socket s = null;
     // data flow
     private DataOutputStream dos = null;
     private DataInputStream dis = null;
     // UI
     private static Frame f = null;
     private static TextArea ta = null;
     private static TextField tf = null;
     private static Button  bn = null;

     private static boolean isPrint = false;//是否输出消息标志
     private static List user_list = new ArrayList();//登陆用户集合
     private static List&amp;lt;ServerThread&amp;gt; thread_list = new ArrayList&amp;lt;ServerThread&amp;gt;();//服务器已启用的线程集合
     private static LinkedList&amp;lt;String&amp;gt; message_list = new LinkedList&amp;lt;String&amp;gt;();//存放消息队列

     static
     {
             createUI();
     }
     public  TCPServer2(Socket s) throws Exception
     {
             this.s = s;
             new PrintOutThread();//创建向客户端发送消息线程
         new ServerThread(this.s);  
         //本以为可以让其线程安全的，没想到没什么效果 反而更卡
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;/*             Collections.synchronizedList(user_list);
             Collections.synchronizedList(thread_list);
             Collections.synchronizedList(message_list);*/
            // launch();&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     }

    // construct member
    /*
    public TCPServer()
    {

    }
    */
    public static void createUI()
    {
        Frame f = new Frame(&amp;quot;服务器&amp;quot;);
        ta = new TextArea();
        tf = new TextField();
        Panel p = new Panel(new BorderLayout());
        bn = new Button(&amp;quot;发送&amp;quot;);
        p.add(tf,BorderLayout.CENTER);
        p.add(bn,BorderLayout.EAST);

        f.add(ta,BorderLayout.CENTER);
        f.add(p,BorderLayout.SOUTH);

        f.setSize(400,200);
        f.setVisible(true);
        //f.setVisable(true);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;/*            tf.addActionListener(new TCPServerListener());
            bn.addActionListener(new TCPServerListener());*/
            f.addWindowListener(new WindowAdapter()
                    {
                        public void windowClosing(WindowEvent e)
                        {
                            System.exit(0);
                        }
                    });
        }&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public void close()
    {
        try{
            s.close();
        }catch(Exception e)
        {
            System.exit(0);
        }
    }

    class TCPServerListener implements ActionListener
    {
            private ServerThread st = null;
            public TCPServerListener(ServerThread s)
            {
                    st =s ;
            }
        @Override
        public void actionPerformed(ActionEvent e)
        {
               try{
                       String str = tf.getText();
                   if(!str.isEmpty())
                   {
                                   tf.setText(&amp;quot;&amp;quot;);
                            ta.append(&amp;quot;服务器说:&amp;quot;+str+&amp;quot;\n&amp;quot;);
                            //dos.writeUTF(str);
                            if(str.equalsIgnoreCase(&amp;quot;再见&amp;quot;))
                            {
                                close();
                                System.exit(0);
                            }

                            st.pushMessage(&amp;quot;服务器说:&amp;quot;+str+&amp;quot;\n&amp;quot;);
                   }
               }catch(Exception e1)
               {
                  // e.printStackTrace();
                  System.exit(0);
               } 
        }
    }

    /**
     * 服务器线程类
     */
    class ServerThread extends Thread{
            private Socket client;
            private String name = null;
            private ServerThread st = null; // 受到启发的作用！！ Client=s
            public ServerThread(Socket s) throws Exception
            {
                    this.client = s;
                    this.st = this;
                    dis = new DataInputStream(client.getInputStream());
            dos = new DataOutputStream(client.getOutputStream());
            dos.writeUTF(&amp;quot;成功连上服务器&amp;quot;+client.getInetAddress().getHostAddress());
            dos.writeUTF(Thread.currentThread().getName()+&amp;quot;已开启&amp;quot;+&amp;quot;请输入你的姓名&amp;quot;);
            this.start();
            //tf的监听器
            tf.addActionListener(new TCPServerListener(this.st));
            bn.addActionListener(new TCPServerListener(this.st));
            }
            @Override
            public void run()
            {
                    try
                    {
                            int flag = 0 ;
                            String line = dis.readUTF();
                            while(!&amp;quot;bye&amp;quot;.equals(line))
                            {
                                    //查看在线用户列表
                    if (&amp;quot;showuser&amp;quot;.equals(line)) {
                        dos.writeUTF(this.listOnlineUsers());
                        line = dis.readUTF();
                    }
                    //第一次进入，保存名字

                    if(flag++ ==0){
                        name = line;
                        user_list.add(name);
                        thread_list.add(this);
                        System.out.println(&amp;quot;this=&amp;quot;+this);
                        dos.writeUTF(name +&amp;quot;你好,可以开始聊天了...&amp;quot;);
                        //
                        this.pushMessage(&amp;quot;Client&amp;lt;&amp;quot; + name +&amp;quot;&amp;gt;进入聊天室...+\n&amp;quot;);
                        //现在在服务器的大厅中
                        ta.append(&amp;quot;Client&amp;lt;&amp;quot; + name +&amp;quot;&amp;gt;进入聊天室...\n&amp;quot;);
                    }else{
                             //现在在服务器的大厅中
                            ta.append(&amp;quot;Client&amp;lt;&amp;quot; + name +&amp;quot;&amp;gt; say : &amp;quot; + line+&amp;quot;\n&amp;quot;);
                            this.pushMessage(&amp;quot;Client&amp;lt;&amp;quot; + name +&amp;quot;&amp;gt; say : &amp;quot; + line+&amp;quot;\n&amp;quot;);
                    }
                    line = dis.readUTF();
                            }
                    }catch(IOException e)
                    {

                    }
            }
             //放入消息队列末尾，准备发送给客户端
        public void pushMessage(String msg){
            message_list.addLast(msg);
            isPrint =true;
        }

        //向客户端发送一条消息(在PrintOutThread 有使用 于是变成了public修饰)
        public void sendMessage(String msg) throws Exception{
            dos.writeUTF(msg);
            dos.flush();
        }

        //统计在线用户列表  需要在showuser中使用  改为public
        private String listOnlineUsers() {
            String s =&amp;quot;--- 在线用户列表 ---&amp;quot;;
            for (int i =0; i &amp;lt; user_list.size(); i++) {
                s +=&amp;quot;[&amp;quot; + user_list.get(i) +&amp;quot;]&amp;quot;;
            }
            s +=&amp;quot;--------------------&amp;quot;;
            return s;
        }

    }

    /**
     * 监听是否有输出消息请求线程类,向客户端发送消息
     */
    class PrintOutThread extends Thread
    {
        public PrintOutThread()
        {
            start();
        }

        @Override
        public void run() 
        {
            while(true){
                if(isPrint){//将缓存在队列中的消息按顺序发送到各客户端，并从队列中清除。
                    String message = message_list.getFirst();
                    for (ServerThread thread : thread_list) 
                    {
                        try
                                                    {
                                //this.
                                thread.sendMessage(message);
                                                    } catch (Exception e)
                                                    {
                                                            // TODO Auto-generated catch block
                                                            e.printStackTrace();
                                                    }
                    }
                    message_list.removeFirst();
                    isPrint = message_list.size() &amp;gt;0 ?true :false;
                }
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Client端如下：

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java
/**
* 解释：
*/
package TestNetwork;&lt;/p&gt;

&lt;p&gt;import java.awt.BorderLayout;
import java.awt.Button;
import java.awt.Frame;
import java.awt.Panel;
import java.awt.TextArea;
import java.awt.TextField;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.io.BufferedReader;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.Socket;&lt;/p&gt;

&lt;p&gt;import javax.swing.JOptionPane;&lt;/p&gt;

&lt;p&gt;import TestNetwork.TCPClient1.ClientRead;
import TestNetwork.TCPClient1.ClientWrite;
import TestNetwork.TCPClient1.TCPClientListener;&lt;/p&gt;

&lt;p&gt;/**
* @author    叶昭良
* @time      2015年3月23日上午1:57:54
* @version   TestNetworkRewriteTestClient5 V1.0
* 功能：
                步骤：
* 注意：
* 掌握：
                思考：
* 回顾：
*/
public class RewriteTestClient5
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /**
     * @param args 
     * 原因：
     * 解决：
     * 功能：
     *       思考：        
     *       步骤：
     */
    public static void main(String[] args) throws Exception
    {
            // TODO Auto-generated method stub
            Socket s  = null;
            s = new Socket(&amp;quot;127.0.0.1&amp;quot;,5599);

             new TCPClient5(s);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
class TCPClient5
{
        // class variables
        // class variables
        // connect
         private Socket s = null;
         // data flow
         private DataOutputStream dos = null;
         private DataInputStream dis = null;
         // UI
         private Frame f = null;
         private TextArea ta = null;
         private TextField tf = null;
         private Button  bn = null;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     /**
      * 与服务器连接，并输入发送消息
      */
     public TCPClient5(Socket s) throws Exception
     {
             this.s = s;
             dis = new DataInputStream(s.getInputStream());
         dos = new DataOutputStream(s.getOutputStream());
         createUI();
         //new ClientRead(dis);
         //new ClientWrite(dos);
         new readLineThread();

     }
     /**
      * 用于监听服务器端向客户端发送消息线程类
      */

    public void createUI()
    {
        Frame f = new Frame(&amp;quot;客户端&amp;quot;);
        ta = new TextArea();
        tf = new TextField();
        Panel p = new Panel(new BorderLayout());
        bn = new Button(&amp;quot;发送&amp;quot;);
        p.add(tf,BorderLayout.CENTER);
        p.add(bn,BorderLayout.EAST);

        f.add(ta,BorderLayout.CENTER);
        f.add(p,BorderLayout.SOUTH);

        f.setSize(400,200);
        f.setVisible(true);
        //f.setVisable(true);
            tf.addActionListener(new TCPClientListener());
            bn.addActionListener(new TCPClientListener());
        f.addWindowListener(new WindowAdapter()
                {
                    public void windowClosing(WindowEvent e)
                    {
                        System.exit(0);
                    }
                });
    }

    public void close()
    {
        try{
            dis.close();
            dos.close();
            s.close();
        }catch(Exception e)
        {
            System.exit(0);
        }
    }
    /**
     * 用于监听服务器端向客户端发送消息线程类
     */
    class readLineThread extends Thread
    {

        private BufferedReader buff = null;;
        public readLineThread(){
                start();

        }

        @Override
        public void run() {
            try {
                while(true){
                    String result = dis.readUTF();
                    if(&amp;quot;byeClient&amp;quot;.equals(result)){//客户端申请退出，服务端返回确认退出
                        break;
                    }else{//输出服务端发送消息
                            //ta.append(result);
                        System.out.println(result);
                       // dos.writeUTF(result);
                        ta.append(&amp;quot;服务器传递说:&amp;quot;+result+&amp;quot;\n&amp;quot;);
                        if(result.equalsIgnoreCase(&amp;quot;再见&amp;quot;))
                        {
                            close();
                            System.exit(0);
                        }
                    }
                }
            }catch (Exception e) {
            }
        }
    }

    class TCPClientListener implements ActionListener
    {
        @Override
        public void actionPerformed(ActionEvent e)
        {
               try{
                    String str = tf.getText();
                    tf.setText(&amp;quot;&amp;quot;);
                    ta.append(&amp;quot;客户端说:&amp;quot;+str+&amp;quot;\n&amp;quot;);
                    dos.writeUTF(str);
                    if(str.equalsIgnoreCase(&amp;quot;再见&amp;quot;))
                    {
                        close();
                        System.exit(0);
                    }
               }catch(Exception e1)
               {
                  // e.printStackTrace();
                  System.exit(0);
               } 
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;结果：

1：之前的线程卡的问题，还没有解决，运行起来仍然感觉占用大量内存！！
2：为什么 第一个进入聊天系统的杨中科，会打印出三次呢？ 当然后面的消息正常，当然三次的意思是聊天系统进入了三个人，都教授和Rocket. 所以肯定是那部分有问题待解决  


![在这边有一个小问题，出现了三行打印](/images/java/服务器2.png)

![群发效果OK,服务器也没问题了](/images/java/基本满足题意.png)



http://www.cnblogs.com/linjiqin/archive/2013/05/30/3108188.html  欣赏了这篇佳作

基于上次的问题，打开的时候经常会出现多个打印的情况，
尝试如下修改：
“登录用户集合”和“服务器已启用线程集合”的list，如果变化不频繁，读多写少，使用CopyOnWriteArrayList。
“存放消息队列”用Queue接口比List接口更方便（每次直接POP，没消息时候还可以让广播线程自己阻塞在上面），具体的用ArrayBlockingQueue或者LinkedBlockingQueue都可以。http://my.oschina.net/leejun2005/blog/104955
   对应的message_list.addLast(msg)  变成了message_list.put(msg)              message_list.take()来取代 message_list.getFirst() &amp;amp; message_list.removeFirst()
效果就是居然没问题。居然也不卡了

Server端的修正版本：（Client端不需要修正）

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java&lt;/p&gt;

&lt;p&gt;/**
* 解释：
*/
package TestNetwork;&lt;/p&gt;

&lt;p&gt;import java.awt.BorderLayout;
import java.awt.Button;
import java.awt.Frame;
import java.awt.Panel;
import java.awt.TextArea;
import java.awt.TextField;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.*;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.LinkedBlockingQueue;&lt;/p&gt;

&lt;p&gt;/**
* @author    叶昭良
* @time      2015年3月23日上午12:41:10
* @version   TestNetworkRewriteTestServer5 V1.0
* 功能：
                步骤：
* 注意：
* 掌握：
                思考：
* 回顾：
*/
public class RewriteTestServer5
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /**
     * @param args 
     * 原因：
     * 解决：
     * 功能：
     *       思考：        
     *       步骤：
     */
    public static void main(String[] args) throws Exception
    {
            // TODO Auto-generated method stub
        ServerSocket ss = new ServerSocket(5599);
    while(true)
    {
            new TCPServer2(ss.accept());
    }

    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
class TCPServer2
{
        // class variables
        // class variables
        // connect&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     private Socket s = null;
     // data flow
     private DataOutputStream dos = null;
     private DataInputStream dis = null;
     // UI
     private static Frame f = null;
     private static TextArea ta = null;
     private static TextField tf = null;
     private static Button  bn = null;

     private static boolean isPrint = false;//是否输出消息标志
     private static List user_list = new CopyOnWriteArrayList();//登陆用户集合
     private static List&amp;lt;ServerThread&amp;gt; thread_list = new CopyOnWriteArrayList&amp;lt;ServerThread&amp;gt;();//服务器已启用的线程集合
     private static LinkedBlockingQueue&amp;lt;String&amp;gt; message_list = new LinkedBlockingQueue&amp;lt;String&amp;gt;();//存放消息队列
    // private static List&amp;lt;String&amp;gt; message_list = new LinkedList&amp;lt;String&amp;gt;();//存放消息队列

     static
     {
             createUI();
     }
     public  TCPServer2(Socket s) throws Exception
     {
             this.s = s;
             new PrintOutThread();//创建向客户端发送消息线程
         new ServerThread(this.s);  
         //本以为可以让其线程安全的，没想到没什么效果 反而更卡
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;/*             Collections.synchronizedList(user_list);
             Collections.synchronizedList(thread_list);
             Collections.synchronizedList(message_list);*/
            // launch();&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     }

    // construct member
    /*
    public TCPServer()
    {

    }
    */
    public static void createUI()
    {
        Frame f = new Frame(&amp;quot;服务器&amp;quot;);
        ta = new TextArea();
        tf = new TextField();
        Panel p = new Panel(new BorderLayout());
        bn = new Button(&amp;quot;发送&amp;quot;);
        p.add(tf,BorderLayout.CENTER);
        p.add(bn,BorderLayout.EAST);

        f.add(ta,BorderLayout.CENTER);
        f.add(p,BorderLayout.SOUTH);

        f.setSize(400,200);
        f.setVisible(true);
        //f.setVisable(true);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;/*            tf.addActionListener(new TCPServerListener());
            bn.addActionListener(new TCPServerListener());*/
            f.addWindowListener(new WindowAdapter()
                    {
                        public void windowClosing(WindowEvent e)
                        {
                            System.exit(0);
                        }
                    });
        }&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public void close()
    {
        try{
            s.close();
        }catch(Exception e)
        {
            System.exit(0);
        }
    }

    class TCPServerListener implements ActionListener
    {
            private ServerThread st = null;
            public TCPServerListener(ServerThread s)
            {
                    st =s ;
            }
        @Override
        public void actionPerformed(ActionEvent e)
        {
               try{
                       String str = tf.getText();
                   if(!str.isEmpty())
                   {
                                   tf.setText(&amp;quot;&amp;quot;);
                            ta.append(&amp;quot;服务器说:&amp;quot;+str+&amp;quot;\n&amp;quot;);
                            //dos.writeUTF(str);
                            if(str.equalsIgnoreCase(&amp;quot;再见&amp;quot;))
                            {
                                close();
                                System.exit(0);
                            }

                            st.pushMessage(&amp;quot;服务器说:&amp;quot;+str+&amp;quot;\n&amp;quot;);
                   }
               }catch(Exception e1)
               {
                  // e.printStackTrace();
                  System.exit(0);
               } 
        }
    }

    /**
     * 服务器线程类
     */
    class ServerThread extends Thread{
            private Socket client;
            private String name = null;
            private ServerThread st = null; // 受到启发的作用！！ Client=s
            public ServerThread(Socket s) throws Exception
            {
                    this.client = s;
                    this.st = this;
                    dis = new DataInputStream(client.getInputStream());
            dos = new DataOutputStream(client.getOutputStream());
            dos.writeUTF(&amp;quot;成功连上服务器&amp;quot;+client.getInetAddress().getHostAddress());
            dos.writeUTF(Thread.currentThread().getName()+&amp;quot;已开启&amp;quot;+&amp;quot;请输入你的姓名&amp;quot;);
            this.start();
            //tf的监听器
            tf.addActionListener(new TCPServerListener(this.st));
            bn.addActionListener(new TCPServerListener(this.st));
            }
            @Override
            public void run()
            {
                    try
                    {
                            int flag = 0 ;
                            String line = dis.readUTF();
                            while(!&amp;quot;bye&amp;quot;.equals(line))
                            {
                                    //查看在线用户列表
                    if (&amp;quot;showuser&amp;quot;.equals(line)) {
                        dos.writeUTF(this.listOnlineUsers());
                        line = dis.readUTF();
                    }
                    //第一次进入，保存名字

                    if(flag++ ==0){
                        name = line;
                        user_list.add(name);
                        thread_list.add(this);
                        System.out.println(&amp;quot;this=&amp;quot;+this);
                        this.pushMessage(&amp;quot;Client&amp;lt;&amp;quot; + name +&amp;quot;&amp;gt;进入聊天室...+\n&amp;quot;);
                        dos.writeUTF(name +&amp;quot;你好,可以开始聊天了...&amp;quot;);
                        //

                        //现在在服务器的大厅中
                        ta.append(&amp;quot;Client&amp;lt;&amp;quot; + name +&amp;quot;&amp;gt;进入聊天室...\n&amp;quot;);
                    }else{
                             //现在在服务器的大厅中
                            ta.append(&amp;quot;Client&amp;lt;&amp;quot; + name +&amp;quot;&amp;gt; say : &amp;quot; + line+&amp;quot;\n&amp;quot;);
                            this.pushMessage(&amp;quot;Client&amp;lt;&amp;quot; + name +&amp;quot;&amp;gt; say : &amp;quot; + line+&amp;quot;\n&amp;quot;);
                    }
                    line = dis.readUTF();
                            }
                    }catch(IOException e)
                    {

                    }
            }
             //放入消息队列末尾，准备发送给客户端
        public void pushMessage(String msg){
                //msssage_list.
            //message_list.addLast(msg); //针对于LinkedList
                try
                            {
                                    message_list.put(msg);
                            } catch (InterruptedException e)
                            {
                                    // TODO Auto-generated catch block
                                    e.printStackTrace();
                            }
            isPrint =true;
        }

        //向客户端发送一条消息(在PrintOutThread 有使用 于是变成了public修饰)
        public void sendMessage(String msg) throws Exception{
            dos.writeUTF(msg);
            dos.flush();
        }

        //统计在线用户列表  需要在showuser中使用  改为public
        private String listOnlineUsers() {
            String s =&amp;quot;--- 在线用户列表 ---&amp;quot;;
            for (int i =0; i &amp;lt; user_list.size(); i++) {
                s +=&amp;quot;[&amp;quot; + user_list.get(i) +&amp;quot;]&amp;quot;;
            }
            s +=&amp;quot;--------------------&amp;quot;;
            return s;
        }

    }

    /**
     * 监听是否有输出消息请求线程类,向客户端发送消息
     */
    class PrintOutThread extends Thread
    {
        public PrintOutThread()
        {
            start();
        }

        @Override
        public void run() 
        {
            while(true){
                if(isPrint){//将缓存在队列中的消息按顺序发送到各客户端，并从队列中清除。
                    String message = null;
                                            try
                                            {
                                                    message = message_list.take();
                                            } catch (InterruptedException e1)
                                            {
                                                    // TODO Auto-generated catch block
                                                    e1.printStackTrace();
                                            }
                    //message = message_list.getFirst();
                    for (ServerThread thread : thread_list) 
                    {
                        try
                                                    {
                                //this.
                                thread.sendMessage(message);
                                                    } catch (Exception e)
                                                    {
                                                            // TODO Auto-generated catch block
                                                            e.printStackTrace();
                                                    }
                    }
                   // message_list.removeFirst();
                    //isPrint = false;
                    //这句话很重要！！！不能随便修改
                    isPrint = message_list.size()&amp;gt;0 ?true :false;
                }
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
![有问题的版本（但是基本满足题意）](/images/java/服务器3.png)

![不卡版本，且解决了登陆时候的多条打印问题](/images/java/居然不卡了.png)


1 动机是为了熟悉网络编程，于是重写了之前写过的代码。从TCPServer 1 2 3三个进行重新的改写
2 发现TCPServer3有问题？  
  在客户端连接上后，客户端发送数据可以到服务器端，接着切换到服务器端，但是服务器的输入出现了问题，
  无论你输入一个字还是n个字都无法切换回客户端了 

3 于是基于这个问题开始进行修改
   主要包含一个主要
                    版本1     Server有一对读写线程类   Client有一对读写线程类
                   版本2     Server有一对读写线程类   Client没有一对读写线程类
                   版本3    Server有一个ServerThread线程类    Client有一个readLineThread线程类 

真的是从原先的四个类，到最后抛弃了原先的四个类，重写了另外的几个类


RewriteServer1.java
RewriteServer2.java
RewriteServer3.java
RewriteServer4.java
RewriteServer5.java
最后的一个版本是RewriteServer5

4 版本3  引入了新的数据结构 CopyWriteArrayList和LinkedBlockingQueue 线程阻塞类

5: 注意了
   5.1 线程的使用(从thread到Runnable)，线程开启放置的位置，最后发现使用了多线程服务器客户端
   5.2 静态代码段static的使用
   5.3 ServerThread的静态变量的使用，配合上构造函数
   5.4 数据结构的使用




猛然发现一个特点：

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java
  GTK.g_timeout_add(100, new IGSourceFunc()
                {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                    @Override
                    public boolean execute(Object userdata)
                    {
                            // TODO Auto-generated method stub
                            int len = otv.getText().length();
                            char ch = love.charAt(len);
                            otv.insertTextAtEnd(Character.toString(ch));
                            if(otv.getText().length() == love.length()-1)
                            {
                                    //om.close();
                                    try
                                    (
                                                    OOMusic om = new OOMusic(&amp;quot;我如此爱你.mp3&amp;quot;,true);
                                    )
                                    {
                                                    om.playRepeat();
                                    }

                                    return true;
                            }else if(otv.getText().length() == love.length())
                            {
                                    return false;
                            }
                            else
                            { 
                                    //System.out.println(&amp;quot;2&amp;quot;);
                                    return true;
                            }

                    }
            }, null);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;2：


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java
vgOpen.addActivateListener(new IGCallBack()
                {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                    @Override
                    public void execute(int instance, int eventData, Object object)
                    {
                            youOpenfile(ootv);

                    }
            });
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;3：


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java
//添加按钮事件
                GTK.g_signal_connect(btnShow, &amp;ldquo;clicked&amp;rdquo;, new IGCallBack()
                {
                        @Override
                        public void execute(int instance, int eventData, Object object)
                        {
                                // TODO 自动生成的方法存根
                                String text = GTK.gtk_text_buffer_get_text(textbuffer);
                                GTK.gtk_label_set_text(label, text);
                        }
                }, null);&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;4：
前三个都是针对gtk的
awt的事件关闭监听，
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java
f = new JFrame(&amp;ldquo;客户端&amp;rdquo;);
f.addWindowListener(new WindowAdapter()
                    {
                        public void windowClosing(WindowEvent e)
                        {
                            System.exit(0);
                        }
                    });&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;当然在JFrame可以采用：
f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
复制代码
他们共同的特点是都采用匿名类，当做时间的响应函数或者回调函数，于是当前的网络编程的button和  textfield也是采用匿名类来实现：
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java
class TCPClientListener implements ActionListener
        {
            @Override
            public void actionPerformed(ActionEvent e)
            {
                   try{
                        String str = tf.getText();
                        tf.setText(&amp;ldquo;&amp;rdquo;);
                        ta.append(&amp;ldquo;客户端说:&amp;ldquo;+str+&amp;rdquo;\n&amp;rdquo;);
                        dos.writeUTF(str);
                        if(str.equalsIgnoreCase(&amp;ldquo;再见&amp;rdquo;))
                        {
                            close();
                            System.exit(0);
                        }
                   }catch(Exception e1)
                   {
                      // e.printStackTrace();
                      System.exit(0);
                   }
            }
        }&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
添加监听：

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     tf.addActionListener(new TCPClientListener());
            bn.addActionListener(new TCPClientListener());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;注意匿名类的监听函数的匿名类对象实现回调&lt;/p&gt;

&lt;p&gt;学习了匿名类的事件回调函数。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>递归的简单阐述</title>
      <link>https://jueqingsizhe66.github.io/blog/2015/05/11/di-gui-de-jian-dan-chan-shu/</link>
      <pubDate>Mon, 11 May 2015 14:58:45 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/blog/2015/05/11/di-gui-de-jian-dan-chan-shu/</guid>
      <description>&lt;p&gt;递归和迭代的区别：
递归需要调用自己
迭代不断修正自己的返回值&lt;/p&gt;

&lt;p&gt;递归伪代码：
(define factoral
   (lambda (x)
        (if (&amp;lt;=  x 1)    //1.必须有一个输出口
        1                  //出口值
        (* x (factoral (- x 1)))&lt;/p&gt;

&lt;p&gt;所以递归就看两个部分：1 输出口（递归终止条件）  2：循环表达式，并且一定要减减 或者++ 直到能够达到递归终止条件&lt;/p&gt;

&lt;p&gt;进一步通过java比较递归和尾递归的执行过程：
尾递归代码：
/**
         *&lt;br /&gt;
         * @param n          计算5！ 则n =5
         * @param product    一般是设置为1  比如 计算5! factail1(5,1)
         * @return           返回递归结果
         */
    public static long facttail1(int n, int product)
    {
    if(n&amp;lt;0)
    {
        return 0;
    }
    if(1 == n)
   {
       return product;
   }
  else
  {
        return  facttail1(n-1, product*n);
   }
    }&lt;/p&gt;

&lt;p&gt;普通递归代码：
/**
         *
         * @param n   5! 则 n = 5
         * @return    返回阶乘的计算结果
         */
    public static long facttail1(int n)
    {
     long a = 0;// 用于调试，可注释
     if(n==1)
     {
         a = 1;// 用于调试，可注释
         return 1;
     }
     a =n*facttail1(n-1);  // 用于调试，可注释
     return n*facttail1(n-1);
    }&lt;/p&gt;

&lt;p&gt;无递归的阶乘：
/**
         *
         * @param n   计算 5！ 则n=5
         * @return
         */
        public static int fact2(int n)
        {
   if(n &amp;lt; 0)
  {
      throw new IllegalArgumentException();
   }
   int result = 1;
   for(int i = 1; i &amp;lt;= n; i++)
  {
     result = result*i;
   }
     return result;
        }&lt;/p&gt;

&lt;p&gt;主程序：
public static void main(String[] args)
        {
                // TODO 自动生成的方法存根
             long Apple =facttail(5,1);
             System.out.println(&amp;ldquo;Apple get by 尾递归：&amp;rdquo;+Apple);
             long Banana =facttail1(5);
             System.out.println(&amp;ldquo;Banana get by 递归：&amp;rdquo;+Banana);
        }&lt;/p&gt;

&lt;p&gt;通过调试可以看到，尾递归的执行过程为:
看下图   尾递归的调试过程
而普通的递归方式为：
看下图   [size=14.4444446563721px]普通的递归运行方式&lt;/p&gt;

&lt;p&gt;通过上述调试发现，尾递归的确是比较快的。&lt;/p&gt;

&lt;p&gt;另外不知道java中的大的数值范围该如何表示，比如 [size=14.4444446563721px]facttail(32,1); 就运行不出来结果？ long无法解决问题。估计java不适合进行大型的数值运算
&lt;img src=&#34;https://jueqingsizhe66.github.io/images/java/尾递归.png&#34; alt=&#34;尾递归的调试过程&#34; /&gt;
&lt;img src=&#34;https://jueqingsizhe66.github.io/images/java/普通的递归.png&#34; alt=&#34;普通的递归运行方式&#34; /&gt;&lt;/p&gt;

&lt;p&gt;利用BigInteger类型的改造版本：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.math.BigInteger;

/**
* @author 叶昭良
*
*/        
public class TestRecursive
{

        public static void main(String[] args)
        {
                // TODO 自动生成的方法存根
             BigInteger Apple =fact(100l,BigInteger.valueOf(1));
            System.out.println(&amp;quot;Apple get by 尾递归：&amp;quot;+Apple);
            BigInteger Banana =facttail(100l);
           System.out.println(&amp;quot;Banana get by  递归：&amp;quot;+Banana);
        }
        // 尾递归方式
        /**
         * 
         * @param n        待计算的阶乘  比如5！ 则n=5
         * @param product  中间变量
         * @return         一个BigInteger对象,包含阶乘的计算结果
         */
        public static BigInteger fact(long n, BigInteger product)
        {
                if(n&amp;lt;0)
                {
                      return BigInteger.valueOf(0);
                }
                else if(n==1)
                     return product;
                else
                     return fact(n-1,product.multiply(BigInteger.valueOf(n)));
        }
        //递归方式
        /**
         * 
         * @param n   待计算的阶乘  比如5！ 则n=5
         * @return    一个BigInteger对象,包含阶乘的计算结果
         */
        public static BigInteger facttail(long n)
        {
          if(n==1)
                {
                     return BigInteger.valueOf(1);
                }else
                {
                     //a =n*facttail1(n-1);
                    return facttail(n-1).multiply(BigInteger.valueOf(n));
                }

        }        

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果：&lt;/p&gt;

&lt;p&gt;Apple get by 尾递归：93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000
Banana get by  递归：93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000&lt;/p&gt;

&lt;p&gt;真的是可以要有多大就有多大。
java 在eclipse使用ctrl+o 调用multiply发现他需要传递一个BigInteger对象。
[c#版本 BigInteger:][&lt;a href=&#34;https://msdn.microsoft.com/zh-cn/library/system.numerics.biginteger.aspx&#34; target=&#34;_blank&#34;&gt;https://msdn.microsoft.com/zh-cn/library/system.numerics.biginteger.aspx&lt;/a&gt;]&lt;/p&gt;

&lt;p&gt;补充杨老师串讲的内容，补上参数说明，并归结为方法，进行独立测试&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.util.Arrays;


/**
* @author 叶昭良
*
*/
public abstract class TestChuangjian2
{

        /**
         * @param args
         */
        public static void main(String[] args)
        {
                // TODO 自动生成的方法存根
                //第一部分 递归
                // case1讲故事
                tellStory(1);
                System.out.println(fact(5));
                System.out.println(fact2(5));
                System.out.println(fact3(5,1));
                System.out.println(&amp;quot;fibnacii1 :&amp;quot;+fib1(5));
                System.out.println(fib2(5));
                System.out.println(fib3(5));
        }
        //第一部分  递归
        //case 1*讲故事
        /**
         * 
         * @param i  讲故事的次数
         */
        public static void tellStory(int i)
        {
                System.out.println(&amp;quot;从前有座山，山里有座庙，。。。。&amp;quot;);
                if(i &amp;lt; 3)
                {
                        tellStory(++i);
                }
                System.out.println(&amp;quot;完了&amp;quot;);
        }
        //case2  阶乘
        /**
         * 
         * @param n  计算 5！ 则n=5
         * @return  返回阶乘的计算结果
         */
        public static int fact(int n)
        {
                if(n &amp;lt; 0)
                {
                        throw new IllegalArgumentException();
                }
                if( 1 == n)
                {
                        return 1;
                }else
                {
                        return n*fact(n-1);
                }
        }
        
        // case3  无递归的阶乘
        /**
         * 
         * @param n   计算 5！ 则n=5
         * @return
         */
        public static int fact2(int n)
        {
                if(n &amp;lt; 0)
                {
                        throw new IllegalArgumentException();
                }
                int result = 1;
                for(int i = 1; i &amp;lt;= n; i++)
                {
                        result = result*i;
                }
                return result;
        }
        // case 4  尾递归方式
        /**
         * 
         * @param n      计算 5！ 则n=5
         * @param result  存储阶乘的计算结果，并作为中间变量
         * @return       返回阶乘计算结果
         */
        public static int fact3(int n, int result)
        {
                if(n &amp;lt;= 0)
                {
                        throw new IllegalArgumentException(&amp;quot;胡算的阶乘数&amp;lt;=0&amp;quot;);
                }
                if(1== n)
                {
                        return result;
                }else
                {
                        return fact3(n-1,result*n);
                }
        }
        
        //case 5 Fibnacci1
        /**
         * 
         * @param n  fibnacci的个数n
         * @return   fibnacci数
         */
        public static int fib1(int n)
        {
                if(n &amp;lt; 0)
                {
                        throw new IllegalArgumentException(&amp;quot;n不可以小于0&amp;quot;);
                }
                if(1 == n || 2 == n)
                {
                        return 1;
                }
                else
                {
                        return fib1(n-1)+fib1(n-2);
                }
        }
        /**
         * 
         * @param n  fibnacci的计算数
         * @return   fibanacci数
         */
        public static int fib2(int n)
        {
                int[] nums = new int[n+1];
                nums[0] = 1;
                nums[1] = 1;
                System.out.println(Arrays.toString(nums));
                for(int i = 2; i &amp;lt; n ; i++)
                {
                        nums[i] = nums[i-1]+ nums[i-2];
                        System.out.println(Arrays.toString(nums));
                }
                return nums[n-1];
        }
        /**
         * 
         * @param n   fibnacci的计算数
         * @return    fibanacci数
         */
        public static int fib3(int n)
        {
                int apple = 1;
                int banana = 1;
                int temp = 1;
                for (int i = 2 ; i &amp;lt; n; i++)
                {
                        temp = apple + banana;
                        banana = apple;
                    apple = temp;
                }
                return temp;
        }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://jueqingsizhe66.github.io/images/java/讲故事的执行顺序.png&#34; alt=&#34;讲故事的顺序 先执行完红的 再反过来执行黄色的线&#34; /&gt;
&lt;img src=&#34;https://jueqingsizhe66.github.io/images/java/杨老师手绘递归图的缺陷反复计算占用空间.png&#34; alt=&#34;普通递归的缺陷：重复计算 空间占用 （于是尾递归 和一些其他的非递归方法的引入）&#34; /&gt;&lt;/p&gt;

&lt;p&gt;一个反例：栈溢出 stackOverFlowError
一般要求的StackSize是1MB&lt;/p&gt;

&lt;p&gt;反例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;        /**
         * 
         * @param i  讲故事的次数
         */
        public static void tellStory(int i)
        {
                System.out.println(&amp;quot;从前有座山，山里有座庙.....&amp;quot;);
                {
                        tellStory(++i);  // i+1
                }        
                System.out.println(&amp;quot;Time Over in &amp;quot;+i);
                
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行完之后会报错，问题原因是栈溢出，达到栈的最大容量限制。
结论：在递归中必须设置终止条件，这样才不至于引起栈溢出。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Jar包打包成可安装的EXE文件</title>
      <link>https://jueqingsizhe66.github.io/blog/2015/05/11/jarbao-da-bao-cheng-ke-an-zhuang-de-exewen-jian/</link>
      <pubDate>Mon, 11 May 2015 14:58:43 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/blog/2015/05/11/jarbao-da-bao-cheng-ke-an-zhuang-de-exewen-jian/</guid>
      <description>&lt;p&gt;学习java的人都知道，java执行class文件是需要在jvm的环境下。但是你写完一个软件难道非得叫人安装一个JRE嘛？！是的，必须。但是这样别人用起来会不爽，于是我们就事先把java的JRE给嵌入到我们的EXE安装包，这样不是很ok！ 于是就调研了一番，最后选择eclipse+exe4j+innosetup这三个软件配合使用
附加的word文件分成三个部分进行，
  第一部分   eclipse生成可运行的jar包
      第二部分 Exe4j产生exe程序&lt;br /&gt;
      第三部分   InnoSetup封装 jre到exe的运行环境下
      exe4j是非破解版，在Word中提供了注册码，主要作用是生成exe文件（运行在有JRE的环境下），由于太大并未上传，提供连接exe4j下载 。 InnoSetup.exe是一个打包程序，编程setup.exe安装版（安装之后，没有JRE也可以运行。）
主要关键点：
   exe4j 的 GUI和console两种情况的生成&lt;br /&gt;
填写JRE最小版本，最大版本可以不用填。删掉InnoSetup默认的Java_home信息，导入正确的JRE文件夹（切勿小心）。 其他的都是傻瓜式安装&lt;/p&gt;

&lt;p&gt;Jar包打包成可安装的EXE文件.docx
559.84 KB, 下载次数: 0
jar变exe的详细步骤&lt;/p&gt;

&lt;p&gt;innosetup-5.5.5.rar
1.83 MB, 下载次数: 0
innosetup打包程序&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;在word 文档里面，使用的jre不是jdk自带的，而是另外下载，当时不知道为什么直接拷贝到项目文件夹不行,报找不到jvm的错误。今天下午帅锅锅一折腾，才发现下载的jre和jdk自带的jre有些不同，jdk的jre目录的bin目录多了一个server文件夹，而同时还有一个client 文件夹（非java自带的jre只有一个client文件夹），所以其实java自带的jre文件夹有两个jvm（听赵帅说是：为了设计完程序后以用户角度体验程序效果，我表示不解） ，而也正因为这两个jvm的原因导致了程序不知道使用哪个jvm运行了，于是有了下面的方法。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以，基于这番调查，提出另一种方法
1.  拷贝jdk底下的jre到项目文件夹下，然后删掉bin目录下的server（删掉多余的jvm) ,然后按照word中的过程照样有效（不需要额外再去下载jre)
   测试，有效。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Java班 1月24日</title>
      <link>https://jueqingsizhe66.github.io/blog/2015/05/11/javaban-1yue-24ri/</link>
      <pubDate>Mon, 11 May 2015 14:58:43 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/blog/2015/05/11/javaban-1yue-24ri/</guid>
      <description>&lt;p&gt;第一题：合并图片&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
* @author 叶昭良
*
*/
import java.io.*;
public class TestCopyTwoFilesToOne implements AutoCloseable
{

        /**
         * @param args
         */
        public static void main(String[] args)
        {
                // TODO 自动生成的方法存根
                File inputFileApple = new File(&amp;quot;e://a.jpg&amp;quot;);
                File inputFileBanana = new File(&amp;quot;e://b.jpg&amp;quot;);
                File inputFileOrange = new File(&amp;quot;e://c.jpg&amp;quot;);
                String temp = null;
                try
                (
                        //字节流
                        InputStream  fisApple= new FileInputStream(inputFileApple);
                        InputStream  fisBanana= new FileInputStream(inputFileBanana);
                        OutputStream  fosOrange= new FileOutputStream(inputFileOrange);
                        // 缓冲流（已通过字符流转换）
                        BufferedReader brApple =  new BufferedReader(new InputStreamReader(fisApple));
                        BufferedReader brBanana =  new BufferedReader(new InputStreamReader(fisBanana));
                        BufferedWriter brOrange =  new BufferedWriter(new OutputStreamWriter(fosOrange));
                )
                {
                        while((temp = brApple.readLine()) != null)
                        {        
                                brOrange.write(temp); // 写入第一个文件
                                brOrange.newLine();
                        }
                        while((temp = brBanana.readLine()) != null)
                        {        
                                brOrange.write(temp);//写入第二个文件信息
                                brOrange.newLine();
                        }
                }catch(IOException e)
                {
                        System.out.println(&amp;quot;文件读取或者写入错误&amp;quot;);
                }
        }

        @Override
        public void close() throws Exception
        {
                // TODO 自动生成的方法存根
                
        }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一题合并图片第二种方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
* @author 叶昭良
*
*/
import java.io.*;

import org.apache.commons.io.FileUtils;
public class TestCopyTwoFilesToOne2
{

        /**
         * @param args
         */
        public static void main(String[] args)
        {
                // TODO 自动生成的方法存根
                try
                {
                        // FileUtils暂时无法实现追加！
                        //FileUtils.copyFile(new File(&amp;quot;e:/a.jpg&amp;quot;), new File(&amp;quot;e://c.jpg&amp;quot;));
                        //FileUtils.copyFile(new File(&amp;quot;e:/b.jpg&amp;quot;), new File(&amp;quot;e://c.jpg&amp;quot;), true);
                        // 对于大文件可能有问题
                        //利用FileUtils的readFileToString方法读取a.jpg文件的数据，并保存在content中
                        String content = FileUtils.readFileToString(new File(&amp;quot;e:/a.jpg&amp;quot;));

                        // 利用FileUtils的writeStringToFIle方法，借用content中间变量写入a.jpg文件信息到c.jpg
                        // 也可以利用FileUtils的copyFile方法，直接复制到c.jpg.
                        FileUtils.writeStringToFile(new File(&amp;quot;e://c.jpg&amp;quot;), content);
                        // //利用FileUtils的readFileToString方法读取b.jpg文件的数据，并保存在content中
                        content = FileUtils.readFileToString(new File(&amp;quot;e:/b.jpg&amp;quot;));
                        FileUtils.writeStringToFile(new File(&amp;quot;e://c.jpg&amp;quot;), content,true);
                } catch (IOException e)
                {
                        // TODO 自动生成的 catch 块
                        System.out.println(&amp;quot;写入文件错误！&amp;quot;);
                }
        }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二题：把文件夹下所有的txt  文件变为doc文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.io.File;

/**
* @author 叶昭良
*
*/
public class RenameDirectoryFiles
{

        /**
         * @param args
         */
        public static void main(String[] args)
        {
                // TODO 自动生成的方法存根
                String roots = &amp;quot;e:&amp;quot;;         //盘符
                String Testfile =&amp;quot;TestFile&amp;quot;; //文件夹
                String targetDir = roots+File.separator+Testfile;
                reNameUnderDirectory(new File(targetDir),&amp;quot;.java&amp;quot;,&amp;quot;.txt&amp;quot;); //调用自定义方法
        }
        
        public static void reNameUnderDirectory(File dir,String from, String to)
        {
                if(null == dir)
                {
                        return; //为空则直接退出
                }
                if(dir.isDirectory())                // 通过路径读入,给定一个路径
                { 
                       //抵用File的listFiles方法获取文件夹下的所有File对象
                        File[] fileArray = dir.listFiles(); 
                        String banana = null;
                        if(null == fileArray)          // 判断是否为空
                        {
                                System.out.println(&amp;quot;文件夹内文件为空  找个别的文件夹吧！&amp;quot;);
                                return;
                        }
                        for(int i = 0 ; i&amp;lt; fileArray.length; i++)  // 遍历所有文件
                        {
                                if(fileArray[i].isFile())             // 判断是否是文件
                                {
                                        banana = fileArray[i].getName(); //获取文件对象的文件名
                                        if(banana.endsWith(from))        // 只是对以java文件结尾的进行修改
                                        {
                                                String newFilename= fileArray[i].getParent()+File.separator
                                                        +banana.replaceAll(from+&amp;quot;[        DISCUZ_CODE_1        ]quot;;, to); //只替换最后一个from表征的字符串
                                                fileArray[i].renameTo(new File(newFilename)); // 利用renameTo方法 修改文件夹的名字
                                        }
                                }else
                                {
                                        reNameUnderDirectory(fileArray[i],from,to); //递归调用该方法 实现遍历文件夹
                                }
                        }
                }else
                {
                        System.out.println(&amp;quot;不是文件夹&amp;quot;);
                }
        }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第三题：后缀修改（Directory walker):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
* @author 叶昭良
*
*/
import java.io.*;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;

import org.apache.commons.io.DirectoryWalker;
public class TestCommonIODirectoryWalkRename extends DirectoryWalker
{

        /**
         * @param args
         */
        public TestCommonIODirectoryWalkRename() 
        {
                     super();
    }
        public List reName(File startDirectory) 
        {
                List results = new ArrayList();
                try
                {
                        walk(startDirectory,results        );
                } catch (IOException e)
                {
                        // TODO 自动生成的 catch 块
                        e.printStackTrace();
                }
                return results;
        }
        
        protected boolean handleDirectory(File directory,int depth,Collection results)
        {
                //save.svn directories and then skip 不会删除.svn文件夹下的任何信息
                if(&amp;quot;fasf&amp;quot;.equals(directory.getName())) // 如果你想要保存某个文件夹
                                                        //就添加elseif即可！！当然文件架构还在
                {
                        directory.delete();
                        return false;
                }else
                {
                        return true;
                }
        }
        
        protected void handleFile(File file,int depth, Collection results)
        {
                String banana = file.getName();
                String newFilename= file.getParent()+File.separator+banana.replaceAll(&amp;quot;.txt&amp;quot;+&amp;quot;$&amp;quot;, &amp;quot;.doc&amp;quot;);
                file.renameTo(new File(newFilename));
                results.add(file);
        }
        // 使用Directory Walker来遍历一个目录并进行相应操作步骤如下
        // 1:创建一个继承DirectoryWalker的类，并在构造函数调用super()
        // 2:定义一个业务入口方法，比如clean，这个方法调用walk方法
        // 3:重写handleDiretory方法  提供相应的业务逻辑
        // 4:重写handleFile方法，提供相应处理逻辑
        
        // 其中最为关键的是walk方法，该方法制定入口路径，
        // 并提供一个用于接受处理结构的参数。
        // 在walk方法的内部：针对目录对象调用handleDirectory
        //                       文件对象调用handleFile
        public static void main(String[] args)
        {
                // TODO 自动生成的方法存根
                TestCommonIODirectoryWalkRename dw = new TestCommonIODirectoryWalkRename() ;
                List l1 = dw.reName(new File(&amp;quot;e://codes&amp;quot;));
                Iterator it = l1.iterator();
                while(it.hasNext())
                {
                        System.out.println(it.next());
                }
        }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第四题：读取文本文件，并统计数字字符的个数查阅了ASCII表信息：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
* @author 叶昭良
*
*/
import java.io.*;
public class getDigtiNumberCount
{

        /**
         * @param args
         */
        public static void main(String[] args)
        {
                // TODO 自动生成的方法存根
                // TODO 自动生成的方法存根

                String  temp = null;
                String roots = &amp;quot;e:&amp;quot;;
                String filename = &amp;quot;student.txt&amp;quot;;
                String filenameWithPathname=roots+File.separator+filename;
                int len = 0;
                try  // try_with_resources方法，不需要关闭需要closed的资源。
                (
                        BufferedReader br = new BufferedReader(new FileReader(filenameWithPathname));                           
                )
                {
                        int  i = 0;
                        int count = 0;
                        while((temp = br.readLine()) != null)
                        {
                                System.out.println(&amp;quot;打印一行&amp;quot;);
                                System.out.println(temp);
                                for(int  j = 0 ;  j  &amp;lt; temp.length(); j++)
                                {//进行数字字符的区间范围判断 
                                        if(temp.charAt(j) &amp;gt;= 48 &amp;amp;&amp;amp; temp.charAt(j) &amp;lt;= 57)
                                        {
                                                count++;
                                        }
                                }
                                i++;
                        }
                        System.out.println(filenameWithPathname+&amp;quot;文件总

共有：&amp;quot;+count+&amp;quot;个数字&amp;quot;);
                }catch(IOException e)
                {
                        System.out.println(&amp;quot;文件打开失败&amp;quot;）;
                }
        }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;![ASCII码表数字字符的数值][/images/java/ASCII表.gif]&lt;/p&gt;

&lt;p&gt;第四题： 读取文本文件的信息，输入某个人的名字，并输出对应某个人的成绩
文本文件：（保存为 student.txt)
张三 80
李四 90
王五 95
赵四 80
李丹江 64&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
* @author 叶昭良
*
*/
import java.io.*;
import java.util.*;
public class GetMessageofNameFromFile
{

        /**
         * @param args
         */
        public static void main(String[] args)
        {
                // TODO 自动生成的方法存根
                String  temp = null;
                int len = 0;
                try
                (
                        BufferedReader br = new BufferedReader(new FileReader(&amp;quot;e:/student.txt&amp;quot;));                
                )
                {
                        while((temp = br.readLine()) != null)
                        {
                                len++;
                        }
                }catch(IOException e)
                {
                        System.out.println(&amp;quot;读取文件失败&amp;quot;);
                }
                String[] names = new String[len];
                //String[] banana = null;
                double[] chengji = new double[len] ;
                try
                (
                        BufferedReader br = new BufferedReader(new FileReader(&amp;quot;e:/student.txt&amp;quot;));        
                )
                {
                        int  i = 0;
                        while((temp = br.readLine()) != null)
                        {
                                //System.out.println(temp);
                                String[] banana = temp.split(&amp;quot; &amp;quot;);
                                //System.out.println(banana[0]+&amp;quot;:&amp;quot;+banana[1]);
                                // 读取文件的name信息
                                names[i] = banana[0];
                                //chengji[i]  = Double.parseDouble(banana[1].trim());
                                //读取文件的成绩信息
                                chengji[i]  = Double.parseDouble(banana[1]);
                                i++;
                        }
                }catch(IOException e)
                {
                        System.out.println(&amp;quot;读取文件失败&amp;quot;);
                }
                
                Scanner  sc = new Scanner(System.in);
        
                while(true)
                {        
                        System.out.println(&amp;quot;请输入你要查询的名字&amp;quot;);
                        String name = sc.nextLine();
                        //如果不输入姓名，直接回车则显示全部姓名！
                        if(name.isEmpty())
                        {
                                System.out.println(&amp;quot;输入为空显示全部&amp;quot;);
                                for(int i = 0; i &amp;lt; names.length ; i++)
                                {
                                        System.out.println(names[i]+&amp;quot;的成绩是:&amp;quot;+chengji[i]);        
                                }
                        }else
                        {
                                for(int i = 0; i &amp;lt; names.length ; i++)
                                {
                                        if(name.equalsIgnoreCase(names[i])) //不区分大小写
                                        {
                                                System.out.println(name+&amp;quot;的成绩是:&amp;quot;+chengji[i]);
                                        }
                                }
                        }
                }

        }

}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>css7-14节笔记代码March25th</title>
      <link>https://jueqingsizhe66.github.io/blog/2015/05/11/css7-14jie-bi-ji-dai-ma-march25th/</link>
      <pubDate>Mon, 11 May 2015 14:58:42 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/blog/2015/05/11/css7-14jie-bi-ji-dai-ma-march25th/</guid>
      <description>&lt;p&gt;&lt;Link type=&#34;text/css&#34; rel=&#34;stylesheet&#34; href=&#34;&#34;&gt;
    &lt;Link type=&#34;javascript&#34; rel=&#34;stylesheet&#34; href=&#34;&#34;&gt;
    &lt;!--
     Link 控件
       rel属性  ：目标文档与当前文档的关系
       type属性 ： 文档类型
    --&gt;
      &lt;!--设background:url(b.jpg);置背景颜色 和文字字体--&gt;
    &lt;!--定义样式--&gt;
    &amp;lt;!&amp;ndash;
    学习的网站 ！
&lt;a href=&#34;http://www.w3school.com.cn/css/index.asp(用到的时候记得查红色关键字即可&#34; target=&#34;_blank&#34;&gt;http://www.w3school.com.cn/css/index.asp(用到的时候记得查红色关键字即可&lt;/a&gt;)
找颜色：&lt;a href=&#34;http://www.114la.com/other/rgb.htm&#34; target=&#34;_blank&#34;&gt;http://www.114la.com/other/rgb.htm&lt;/a&gt;
       背景控件的修饰
           注意background相关信息即可！
                  background-color
                  background-image
                  background-position&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    文本控件的修饰
        一般注意text相关信息
               text-align
               text-width
               text-shadow等
               text-indent:2em     1em =当前文本的一个字符的像素大小 （一个公式）
                        如果font-size=24px(默认是14px)  也就是此时1em=24px
                        这就是em的用法！！注意了！！
                text-decoration:underline
                                none
                                overline
                                line-through
                                blink
    字体控件的修饰
         一般注意font开头
              font-ize
              font-family:&amp;quot;微软雅黑&amp;quot;
              font-style:italic   对应htmlde &amp;lt;I&amp;gt;标签控件
              font-weigth:
                       100-900
                        border
                        lighter
              font-variant:small-cap

    链接控件（A标签）的修饰（伪类选择器）
          四种状态   :link      
                     :visited
                     :hover
                         a:hover{text-decoration:underline; color:red}
                     :active
                  提示 1：a:hover 必须被置于 a:link 和 a:visited 之后，才是有效的。
            提示 2：a:active 必须被置于 a:hover 之后，才是有效的。

    列表控件的修饰
         list-style-image:url{img/a.gif}
         list-style-type:square
         list-style:none

    表格控件的修饰
        表格作用：数据的格式化
        table{border-space: width:50px}
        tr{}
        td{}

    框模型（盒子模型）：

   Opera 浏览器先使用 ctrl+u 再使用ctrl+alt+i  打开computed的窗口，观察盒子模型（注意使用浏览器的开发者功能）
    IE用F12
       Margin是什么？
        元素的最外层，光晕部分 
               Margin-top
               margin: 1px 2px 3px 4px
       Border是什么?
         元素的中间层 夹在margin和padding之间
              border:1px solid #3333

       Padding 是什么？
          元素的内层，包裹着元素
               Padding-top:
               padding: 1px 2px 3px 4px

    轮廓
       元素的border和margin之间！起着一种强调的作用！！ 起着元素突出作用！(元素其实就是控件）
      outline:red  2px dash;
      input:focus{border:green 1px solid}  当点击文本框！！！则显示为绿色！这是很好的技能！！！！
                                           一定要多写几遍！！！！不错！！

所以其实在一个元素的外部有四重的包裹由内至外：  padding-&amp;gt; border--&amp;gt;outline--&amp;gt;margin  注意你所设置的位置
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;综上所述： 所以在标签中一般有Id属性  ，也可能有Class属性
                一般规律1是：（必须掌握）
                            Style的内嵌入的修饰  &amp;gt;   Id选择器&amp;gt;  Class选择器 &amp;gt; 标签选择器
                   公式2：  selectors{属性名：属性值}   对应HTML的 标签&amp;lt;属性名=属性值&amp;gt;       CSS是用selectors来说标签， CSS使用冒号，HTML使用等号
                     CSS+HTML使用得好在乎经验和功夫，非一天两天。&lt;/p&gt;

&lt;p&gt;CSS基本选择器：
标签选择器
id选择器   #id_name
class选择器    .classname
CSS拓展选择器：
派生选择器  h1 a{}   指的是只要h1里面包含着a标签既满足该条件
子元素选择器（直接）  h1&amp;gt;a{}  这个a必须是在h1的下一层  不能是下下层（这边的分层是指谁包裹谁的意思）
属性选择器   a[href]{color:red}
组合选择器   h1,h2,h3,h4{color:blue}（注意提取共性）
伪选择器  主要针对于连接标签   （可用于控制界面的效果）
                     ：linked       ：visited      :hover         :actived       :focus(获得焦点的时候）&lt;/p&gt;

&lt;p&gt;两种外联式方式：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;&amp;lt;link rel=&amp;quot;stylesheet&amp;quot; type=&amp;quot;text/css&amp;quot; href=&amp;quot;*.css&amp;quot;/&amp;gt;    常用               
@import url(&amp;quot;*.css&amp;quot;);  必须写到&amp;lt;style&amp;gt;&amp;lt;/style&amp;gt;标签中
第一种是界面直接加载全部，第二种是在页面加载完毕，然后在加载css文件，也就是刚开始没有样式，了解即可。

    --&amp;gt;

&amp;lt;Style type=&amp;quot;text/css&amp;quot;&amp;gt;
      body{font-family:&amp;quot;微软雅黑&amp;quot;}
      .box{width:600px; margin:0 auto; padding-top:100px;background-color:black}
      .box 
      H1{text-align:center text-shadow:2px 5px 5px 
      rgba(0,0,2,1);color:white; }
      .box 
      p{background:#2c2c29;border-radius:10px;border:1px solid #222220;
      line-height:38px;margin-right:5px;float:left;width=600px;}
      .box 
      span{float:left;display:block;text-align:right;background:#373733
      ;width:70px;height:40px;color:#ffffff;border-right:1px solid #222220;}
      .input_box{width:167px;padding-left:10px;height:38px;border:0px;background:
      #2c2c29;float:left;color:#ffffff}
      .input_btn{width:500px;height:40px;margin-top:15px;line-height:40px;
      background:#009900;border:1px solid #0099900;border-radius:10px;
      cursor:pointer;}
      .input_btn:hover{background:#00CD00}

    &amp;lt;/Style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1.DOM（文档对象模型）是HTML和XML的应用程序&lt;/p&gt;

&lt;p&gt;接口（API)所谓文档对象模型，其实就是对网页&lt;/p&gt;

&lt;p&gt;HTML中的各种元素的一种内部的表示，例如HTML&lt;/p&gt;

&lt;p&gt;中的头、段落、列表、风格、ID等，所有的元素&lt;/p&gt;

&lt;p&gt;都能通过DOM来访问
document （计算机）文档
DOM就是Html页面的模型，将每个标签都做为一个&lt;/p&gt;

&lt;p&gt;对象，JavaScript通过调用DOM中的属性、方法&lt;/p&gt;

&lt;p&gt;就可以对网页中的文本框、层等元素进行编程控&lt;/p&gt;

&lt;p&gt;制。&lt;/p&gt;

&lt;p&gt;2.所有变量，方法，元素等都属于window对象。&lt;/p&gt;

&lt;p&gt;都可以用window调用页面中定义的变量和方法都&lt;/p&gt;

&lt;p&gt;是window的&lt;/p&gt;

&lt;p&gt;3.CSS+JavaScript+DOM=DHtml&lt;/p&gt;

&lt;p&gt;4.onload 事件会在页面或图像加载完成后立即发&lt;/p&gt;

&lt;p&gt;生
5.window对象的方法
window.alert(‘大家好！’);//弹出警告对话&lt;/p&gt;

&lt;p&gt;框
window.confirm(‘确定要删除吗？’);//确定&lt;/p&gt;

&lt;p&gt;、取消对话框，返回true或false;
window.navigate(url);//将网页重新导航到&lt;/p&gt;

&lt;p&gt;url,支持IE、Opera11.6。并不推荐,有些浏览器&lt;/p&gt;

&lt;p&gt;不行,
建议使用window.location.href=‘url’;//支&lt;/p&gt;

&lt;p&gt;持大多数浏览器
6.计时器
1&amp;gt;var steId=setTimeout(function(){
  alert(&amp;lsquo;这是一次性的&amp;rsquo;)
  },1000);
  clearTimeout(setId);//清除计时器
2&amp;gt;var setId=setInterval(function(){
        alert(&amp;lsquo;神州行，我看行&amp;rsquo;);
},1000);&lt;/p&gt;

&lt;p&gt;//clearInterval(setId);//清除计时器
7.onload（页面加载后触发
onunload（页面卸载后触发）
onbeforeunload（页面卸载前触发）&lt;/p&gt;

&lt;p&gt;8.window.location对象：
window.location.href=‘’;//重新导航到新页&lt;/p&gt;

&lt;p&gt;面,可以取值，也可以赋值。
window.location.reload();//刷新当前页
对象的事件，所有元素的事件都可以通过event属&lt;/p&gt;

&lt;p&gt;性取到相关信息。//兼容IEwindow.event是IE下&lt;/p&gt;

&lt;p&gt;非常重要的属性，用来获得发生事件时的信息，&lt;/p&gt;

&lt;p&gt;事件不局限于window、Chrome，不兼容FF（用&lt;/p&gt;

&lt;p&gt;event参数）。
window.event.altKey属性，bool类型，表示事&lt;/p&gt;

&lt;p&gt;件发生时是否按下了alt键。类似的还有&lt;/p&gt;

&lt;p&gt;ctrlKey,shiftKey。
clientX、clientY 发生事件时鼠标在客户区的&lt;/p&gt;

&lt;p&gt;坐标；(页面左上角)不支持火狐
screenX、screenY 发生事件时鼠标在屏幕上的&lt;/p&gt;

&lt;p&gt;坐标；（相对于屏幕）
offsetX、offsetY 发生事件时鼠标相对于事件&lt;/p&gt;

&lt;p&gt;源（比如点击按钮时触发onclick）的坐标。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;onload=function(){

    document.getElementById

(&#39;dv&#39;).onmousedown=function(){

      if(window.event.altKey){
            alert(&#39;按下了alt键&#39;);

       }else if(window.event.shiftKey){
            alert(&#39;按下了shift键&#39;);

       }else if(window.event.ctrlKey){
            alert(&#39;按下了ctrl键&#39;);

        }else{
            alert(&#39;只是按下了鼠标了&#39;);
        }
        alert(window.event.button);

    };
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;9.赋值和粘贴的控制&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
   &amp;lt;/script&amp;gt;

    &amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;

        onload=function(){
         
document.body.oncopy=function(){

                setTimeout(function(){
                  var tt= 
clipboardData.getData(&#39;text&#39;)+&#39;文本出自哪

里&#39;;                    

clipboardData.setData(&#39;text&#39;,tt);
                },100);

            };
        };

    &amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;10.tag(标签)
11.获取元素的三种方式
getElementById(), （非常常用），根据元素的&lt;/p&gt;

&lt;p&gt;Id获得对象，网页中id不能重复。也可以直接通&lt;/p&gt;

&lt;p&gt;过元素的id来引用元素，但是有有效范围、
getElementsByName()，根据元素的name获得对&lt;/p&gt;

&lt;p&gt;象，由于页面中元素的name可以重复，比如多个&lt;/p&gt;

&lt;p&gt;RadioButton的name一样，因此&lt;/p&gt;

&lt;p&gt;getElementsByName返回值是对象数组。
getElementsByTagName()，获得指定标签名称的&lt;/p&gt;

&lt;p&gt;元素数组，比如getElementsByTagName(“input&lt;/p&gt;

&lt;p&gt;”)可以获得所有的&lt;input&gt;标签。*表示所有标签
12.三个练习题，必须熟练
1&amp;gt;每隔一秒获得当前时间
  onload=function(){&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        setInterval(function(){

            document.getElementById
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(&amp;lsquo;p1&amp;rsquo;).innerText=new Date&lt;/p&gt;

&lt;p&gt;().toLocaleTimeString();&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        },1000);
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;13.事件冒泡&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>email邮件发送&#43;OOGTK(0217)</title>
      <link>https://jueqingsizhe66.github.io/blog/2015/05/11/emailyou-jian-fa-song-plus-oogtk-0217/</link>
      <pubDate>Mon, 11 May 2015 14:58:42 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/blog/2015/05/11/emailyou-jian-fa-song-plus-oogtk-0217/</guid>
      <description>&lt;p&gt;参考阅读：
[commons.email的邮件使用：][&lt;a href=&#34;http://commons.apache.org/proper/commons-email/userguide.html&#34; target=&#34;_blank&#34;&gt;http://commons.apache.org/proper/commons-email/userguide.html&lt;/a&gt;]
[我的gtk的封装源代码： ][&lt;a href=&#34;http://www.rupeng.com/forum/thread-44377-1-1.html&#34; target=&#34;_blank&#34;&gt;http://www.rupeng.com/forum/thread-44377-1-1.html&lt;/a&gt;]&lt;/p&gt;

&lt;p&gt;今早起来想着是不是该去对IO流做个总结，于是打开了Apache 的CommonsIO页面，看了一遍，本想写的，后来看到了一个Commons email包！于是页浏览了一下userGuide and JavaDoc,发现不是特别难，于是就按照user guide 做了几个实验！ 刚开始前期遇到了一个比较重要的问题&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
* 
*/
package TestEmail;

/*import java.net.Authenticator;

import org.apache.commons.mail.DefaultAuthenticator;
import org.apache.commons.mail.Email;
import org.apache.commons.mail.SimpleEmail;*/
import org.apache.commons.mail.*;

/**
* @author    叶昭良
* @time      2015年2月17日上午11:10:04
* @version   TestEmailEmailText V1.0
*/
public class EmailText
{

        /**
         * @param args
         */
        public static void main(String[] args)
        {
                // TODO Auto-generated method stub
                Email email = new SimpleEmail();
                email.setHostName(&amp;quot;smtp.163.com&amp;quot;);
                email.setSmtpPort(25);
                email.setSubject(&amp;quot;欢迎你&amp;quot;);
                email.setAuthenticator(new DefaultAuthenticator(&amp;quot;zhaoturkkey@163.com&amp;quot;, &amp;quot;密码&amp;quot;));
                email.setSSLOnConnect(true);
                try
                {
                        email.setFrom(&amp;quot;zhaoturkkey@163.com&amp;quot;,&amp;quot;Ye zhaoliang&amp;quot;);
                        email.setMsg(&amp;quot;This is a test mail ... :-)&amp;quot;);
                        email.addTo(&amp;quot;977962857@qq.com&amp;quot;,&amp;quot;Mr Ye&amp;quot;);
                        email.send();
                } catch (EmailException e)
                {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                }
                email.setSubject(&amp;quot;TestMail&amp;quot;);

        }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;email.setAuthenticator(new DefaultAuthenticator(&amp;ldquo;zhaoturkkey@163.com&amp;rdquo;, &amp;ldquo;密码&amp;rdquo;)); 他是来自javaee的javax.email包（通过ctrl+鼠标点击，一路插查过去就知道了）！！一直报错！于是下载了javaee版本的eclipse并抽取处 javax.email包！已添加在附件中！只要加载到项目中就可以使用。&lt;/p&gt;

&lt;p&gt;紧接着参考了带附件的邮件发送，也编写了相关程序，跟text差不多，只不过是采用了EmailAttachment 和MultiPartEmail 替换掉text版本的SimpleEmail类，就可以增加附件了，下面是我最后版本的源码，需要有OOGTK和com.rupeng.gtk4j.jar这两个类库即可       文本发送邮件是挺快的
       带附件的邮件发送相对较慢些&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
*   邮件发送器
*/
package TestEmail;

import java.io.File;

import org.apache.commons.mail.DefaultAuthenticator;
import org.apache.commons.mail.Email;
import org.apache.commons.mail.EmailAttachment;
import org.apache.commons.mail.EmailException;
import org.apache.commons.mail.MultiPartEmail;
import org.apache.commons.mail.SimpleEmail;

import com.rupeng.gtk4j.GTK;
import com.rupeng.gtk4j.IGCallBack;


/**
* @author    叶昭良
* @time      2015年2月17日下午2:27:35
* @version   TestEmailMyEmailSend V1.0
*/
import GTKEncapsulate.*;
public class MyEmailSend
{

        /**
         * @param args
         */
        //控件的声明
        private static OOWindow ow = null;
        private static OOButton ob = null;
        private static OOButton obApple = null;
        private static OOButton obAttach = null;
        private static OOTextView otv  = null;
        private static OOGrid og = null;
        
        private static OOLabel olPort = null;
        private static OOLabel olMessage = null;
        private static OOLabel olFrom = null;
        private static OOLabel olTo = null;
        private static OOLabel olServer = null;
        private static OOLabel olPassword = null;
        private static OOLabel olSubject = null;
        private static OOLabel olFromName = null;
        private static OOLabel olToName = null;
        private static OOLabel olAttachName = null;
        private static OOLabel olAttachDescription = null;
        private static OOLabel olAttachSetName = null;
        
        private static OOEntry oePort = null;
        private static OOEntry oeFrom = null;
        private static OOEntry oeTo   = null;
        private static OOEntry oeServer = null;
        private static OOPassword opPassword = null;
        private static OOEntry oeSubject = null;
        private static OOEntry oeFromName = null;
        private static OOEntry oeToName = null;
        private static OOEntry oeAttachDescription = null;
        private static OOEntry oeAttachSetName = null;
        
        private static String[] filenames = null;
        
        //构造函数  初始化界面
        public MyEmailSend()
        {
                ow = new OOWindow();
                ow.setTitle(&amp;quot;邮件发送器&amp;quot;);
                ow.setExitAfterDestroy(true);
                
                olServer = new OOLabel(&amp;quot;发送端服务器:&amp;quot;);
                olPort = new OOLabel(&amp;quot;服务器端口：&amp;quot;);
                olMessage = new OOLabel(&amp;quot;待发送信息：&amp;quot;);
                olFrom = new OOLabel(&amp;quot;发送方邮箱（163.com）：&amp;quot;);
                olTo = new OOLabel(&amp;quot;接收方邮箱:&amp;quot;);
                olPassword = new OOLabel(&amp;quot;发送方密码：&amp;quot;);
                olSubject = new OOLabel(&amp;quot;邮件主题：&amp;quot;);
                olFromName = new OOLabel(&amp;quot;你的名字：&amp;quot;);
                olToName = new OOLabel(&amp;quot;对方的名字：&amp;quot;);
                olAttachName = new OOLabel(&amp;quot;&amp;quot;);
                olAttachDescription = new OOLabel(&amp;quot;添加附件描述:&amp;quot;);
                olAttachSetName = new OOLabel(&amp;quot;设置附件名字:&amp;quot;);
                
                //文本框创建
                oePort = new OOEntry();
                oePort.setText(&amp;quot;25&amp;quot;);
                oeFrom = new OOEntry();
                oeFrom.setText(&amp;quot;zhaoturkkey@163.com&amp;quot;);
                oeTo = new OOEntry();
                oeTo.setText(&amp;quot;977962857@qq.com&amp;quot;);
                oeServer = new OOEntry();
                oeServer.setText(&amp;quot;smtp.163.com&amp;quot;);
                opPassword = new OOPassword();
                oeSubject = new OOEntry();
                oeFromName = new OOEntry();
                oeFromName.setText(&amp;quot;叶昭良&amp;quot;);
                oeToName = new OOEntry();
                oeToName.setText(&amp;quot;肖欣然&amp;quot;);
                oeAttachDescription = new OOEntry();
                oeAttachSetName = new OOEntry();
                
                obAttach = new OOButton(&amp;quot;添加附件&amp;quot;);
                ob = new OOButton(&amp;quot;仅文本发送&amp;quot;);
                obApple = new OOButton(&amp;quot;带附件发送&amp;quot;);
                otv = new OOTextView();
                otv.setText(&amp;quot;尊敬的&amp;quot;+oeToName.getText()+&amp;quot;:\n&amp;quot;);
                OOScrollBar osb = new OOScrollBar();
                osb.setWidgetSize(200, 200);
                osb.addView(otv);
                og = new OOGrid();
                
                //显示控件
                ow.show();
                ob.show();
                obApple.show();
                otv.show();
                osb.show();
                obAttach.show();
                
                olMessage.show();
                olPort.show();
                olPassword.show();
                olServer.show();
                olFrom.show();
                olTo.show();
                olSubject.show();
                olFromName.show();
                olToName.show();
                //olAttachName.show();
                
                oeFrom.show();
                oeTo.show();
                oeServer.show();
                oePort.show();
                oeSubject.show();
                opPassword.show();
                oeFromName.show();
                oeToName.show();
                
                og.show();
                //添加控件
                ow.add(og);
                og.add(olServer, 0,0);
                og.add(oeServer, 0, 1);
                
                og.add(olPort,0,2);
                og.add(oePort,0,3);
                
                og.add(olFrom,1,0);
                og.add(oeFrom,1,1);
        
                og.add(olPassword,1,2);
                og.add(opPassword,1,3);
                
                og.add(olTo,2,0);
                og.add(oeTo,2,1);
                og.add(olToName,2,2);
                og.add(oeToName,2,3);
                
                og.add(olSubject,3,0);
                og.add(oeSubject,3,1);
                og.add(olFromName,3,2);
                og.add(oeFromName,3,3);
                
                og.add(olMessage,4,0);
                og.add(osb,5,0,4,2);
                
                og.add(obAttach,7,0);
                og.add(olAttachName,7,1);
                
                og.add(olAttachDescription,8,0);
                og.add(oeAttachDescription,8,1);
                og.add(olAttachSetName,8,2);
                og.add(oeAttachSetName,8,3);
                
                og.add(ob, 9, 0);
                og.add(obApple,9,1);
                //文本监听
                ob.addClickedListener(new IGCallBack()
                {
                        
                        @Override
                        public void execute(int instance, int eventData, Object object)
                        {
                                // TODO Auto-generated method stub
                                Email email = new SimpleEmail();
                                email.setHostName(oeServer.getText());
                                email.setSmtpPort(Integer.parseInt(oePort.getText()));
                                email.setSubject(oeSubject.getText());
//                                email.setAuthenticator(new DefaultAuthenticator(&amp;quot;zhaoturkkey@163.com&amp;quot;, &amp;quot;457866zhao&amp;quot;));
                                email.setAuthenticator(new DefaultAuthenticator(oeFrom.getText(), opPassword.getText()));
                                email.setSSLOnConnect(true);
                                if(opPassword.getText().equalsIgnoreCase(&amp;quot;&amp;quot;)) 
                                {
                                        OOMessageDialog om = new OOMessageDialog(&amp;quot;错误&amp;quot;);
                                        om.showError(&amp;quot;密码框不能为空！&amp;quot;, &amp;quot;赶紧去填写&amp;quot;);
                                        return;
                                }
                                //测试
/*                                System.out.println(oeServer.getText());
                                System.out.println(Integer.parseInt(oePort.getText()));
                                System.out.println(oeFrom.getText());
                                System.out.println(opPassword.getText());
                                System.out.println(oeSubject.getText());
                                System.out.println(otv.getText());*/
                                try
                                {
                                        email.setFrom(oeFrom.getText(),oeFromName.getText());
                                        email.setMsg(otv.getText());
                                        email.addTo(oeTo.getText(),oeToName.getText());
                                        email.send();
                                } catch (EmailException e)
                                {
                                        // TODO Auto-generated catch block
                                        System.out.println(&amp;quot;发送邮件异常&amp;quot;+e.getMessage());
                                }
                        
                        }
                });
                //文本附件监听
                obApple.addClickedListener(new IGCallBack()
                {
                        
                        @Override
                        public void execute(int instance, int eventData, Object object)
                        {
                                // TODO Auto-generated method stub
                                 // Create the attachment
                                
                                if(opPassword.getText().equalsIgnoreCase(&amp;quot;&amp;quot;)) 
                                {
                                        OOMessageDialog om = new OOMessageDialog(&amp;quot;错误&amp;quot;);
                                        om.showError(&amp;quot;密码框不能为空！&amp;quot;, &amp;quot;赶紧去填写&amp;quot;);
                                        return;
                                }
                                  EmailAttachment attachment = new EmailAttachment();
                                  //attachment.setPath(&amp;quot;hunsha.jpg&amp;quot;);
                                  //attachment.setPath(&amp;quot;E:\\a1.zip&amp;quot;);
                                  //attachment.setPath(&amp;quot;E:\\1.jpg&amp;quot;);
                                  if(oeAttachSetName.getText().equalsIgnoreCase(&amp;quot;&amp;quot;))
                                  {
                                         OOMessageDialog om = new OOMessageDialog(&amp;quot;错误&amp;quot;);
                                        om.showError(&amp;quot;你还没有添加附件呢！&amp;quot;, &amp;quot;赶紧去添加&amp;quot;);
                                        return;
                                  }
                                  attachment.setPath(filenames[0]);
                                  
                                  attachment.setDisposition(EmailAttachment.ATTACHMENT);
                                  attachment.setDescription(oeAttachDescription.getText());
                                  attachment.setName(oeAttachSetName.getText());
                                 
                                  // Create the email message
                                  MultiPartEmail email = new MultiPartEmail();
                                  email.setHostName(oeServer.getText());
                                  email.setSmtpPort(Integer.parseInt(oePort.getText()));
                                  email.setAuthenticator(new DefaultAuthenticator(oeFrom.getText(), opPassword.getText()));
                                  email.setSSLOnConnect(true);
                                  try
                                  {
                                          email.addTo(oeTo.getText(), oeToName.getText());
                                          email.setFrom(oeFrom.getText(), oeFromName.getText());
                                          email.setSubject(oeSubject.getText());
                                          email.setMsg(otv.getText());
                        
                                          // add the attachment
                                          email.attach(attachment);
                        
                                          // send the email
                                         
                                          email.send();
                                  }catch(EmailException e)
                                  {
                                          System.out.println(&amp;quot;邮件发送失败 &amp;quot;+e.getMessage());
                                  }
                        }
                });
                
                obAttach.addClickedListener(new IGCallBack()
                {
                        
                        @Override
                        public void execute(int instance, int eventData, Object object)
                        {
                                // TODO Auto-generated method stub
                                OOFileChooser ofApple =new OOFileChooser();
                                ofApple.setMultipleSelect();
                                ofApple.createFilter();
                                ofApple.nameFilter(&amp;quot;任意文件&amp;quot;);
                                ofApple.editFilter(&amp;quot;*.txt&amp;quot;);
                                ofApple.editFilter(&amp;quot;*.java&amp;quot;);
                                ofApple.editFilter(&amp;quot;*.rar&amp;quot;);
                                ofApple.editFilter(&amp;quot;*.zip&amp;quot;);
                                ofApple.editFilter(&amp;quot;*.doc&amp;quot;);
                                //把filter的操作放入打开对话框中
                                ofApple.finishFilter();
                                //String[] filenames = ofApple.processOpen();
                                filenames = ofApple.processOpen();
                                
                                olAttachName.setText(&amp;quot;你选择的文件是&amp;quot;+filenames[0].toString());
                                olAttachName.show();
                                olAttachSetName.show();
                                olAttachDescription.show();
                                oeAttachSetName.show();
                                oeAttachDescription.show();
                                //oeAttachSetName.setText(filenames);
                                int index = filenames[0].lastIndexOf(File.separator);
                                oeAttachSetName.setText(filenames[0].substring(index+1));
                                oeAttachDescription.setText(&amp;quot;这个文件是关于***&amp;quot;);
                        }
                });
                
        }
        public static void main(String[] args)
        {
                // TODO Auto-generated method stub
                GTK.gtk_init();
                MyEmailSend mes = new MyEmailSend();
                
                GTK.gtk_main();
        }

}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;小软件运行的效果:
&lt;img src=&#34;https://jueqingsizhe66.github.io/images/java/email.png&#34; alt=&#34;EmialText的测试&#34; /&gt;
&lt;img src=&#34;https://jueqingsizhe66.github.io/images/java/chuangjiang.png&#34; alt=&#34;EmailAttachment附件的测试&#34; /&gt;
&lt;img src=&#34;https://jueqingsizhe66.github.io/images/java/file.png&#34; alt=&#34;文件选择框添加附件&#34; /&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>hashmap本质March18</title>
      <link>https://jueqingsizhe66.github.io/blog/2015/05/11/hashmapben-zhi-march18/</link>
      <pubDate>Mon, 11 May 2015 14:58:42 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/blog/2015/05/11/hashmapben-zhi-march18/</guid>
      <description>&lt;p&gt;HashMap:
Hashmap本质：
&amp;mdash;-&amp;gt; &amp;mdash;-&amp;gt; &amp;mdash;-&amp;gt; &amp;mdash;-&amp;gt;&amp;mdash;-&amp;gt; &amp;mdash;-&amp;gt; &amp;mdash;-&amp;gt; &amp;mdash;-&amp;gt; &amp;mdash;-&amp;gt;&amp;mdash;-&amp;gt;&amp;mdash;-&amp;gt; &amp;mdash;-&amp;gt; &amp;mdash;-&amp;gt; &amp;mdash;-&amp;gt;&amp;mdash;-&amp;gt;&amp;mdash;-&amp;gt; &amp;mdash;-&amp;gt; &amp;mdash;-&amp;gt; &amp;mdash;-&amp;gt;&amp;mdash;-&amp;gt;
  |            |                |             |
  |            |                 |             |
  |            |                 |
  |            |
  |
  |
  |
优点：因为内部结构为哈希表,所以添加删除查询等操作都很快
缺点：HashMap不能直接遍历keySet() , values() , entrySet()三个方法作为遍历方法
由于Map 把key 和 value 封装到了Entry对象中,所以并不会对key和value直接操作,所以key和value可以为null
HashMap已经替换掉HashTable（只不过还有一个参与分子Properties还在大量使用）
|&amp;ndash;set
  |&amp;mdash;keySet
  |&amp;mdash;entrySet
|&amp;ndash;Collection&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
* 
*/
package com.collections.test;

/**
* @author    叶昭良
* @time      2015年2月25日上午1:38:30
* @version   com.collections.testTestHashMap V1.0
*/
import java.util.*;
public class TestHashMap
{

        /**
         * @param args
         */
        public static void main(String[] args)
        {
                // TODO Auto-generated method stub
                Map map = new HashMap();
                map.put(&amp;quot;1&amp;quot;, &amp;quot;zhangsan&amp;quot;);
                map.put(&amp;quot;2&amp;quot;, &amp;quot;lisi&amp;quot;);
                map.put(&amp;quot;3&amp;quot;, &amp;quot;cbd&amp;quot;);
                
                System.out.println(map.get(&amp;quot;1&amp;quot;));
                
                Set keySet = map.keySet();
                
                Iterator it = keySet.iterator();
                while(it.hasNext())
                {
                        Object o = it.next();
                        System.out.println(map.get(o)+&amp;quot;:&amp;quot;+o);
                }
                
                System.out.println(&amp;quot;The Second method to get Value---&amp;quot;);
                Collection value = map.values();
                Iterator it1 =value.iterator();
                while(it1.hasNext())
                {
                        System.out.println(it1.next());
                }
                
                map.remove(&amp;quot;1&amp;quot;);
                System.out.println(&amp;quot;The Third Method to get value----&amp;quot;);
                Set keyset1 = map.entrySet();
                Iterator itp = keyset1.iterator();
                while(itp.hasNext())
                {
                        Map.Entry o  = (Map.Entry)itp.next();
                        System.out.println(o+&amp;quot;，其中 键位：&amp;quot;+o.getKey()+&amp;quot;,值为：&amp;quot;+o.getValue());
                }
        }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;HashMap源码追踪：&lt;/p&gt;

&lt;p&gt;HashMap源码调研的基础知识:
1.位运算符&lt;/p&gt;

&lt;p&gt;用于容量的翻倍，以及限定在某一范围内：
&amp;gt;&amp;gt;&lt;br /&gt;
&amp;gt;&amp;gt;&amp;gt;   不考虑符号 ，空位都以0补齐 0补最高位 （&amp;gt;&amp;gt;  &amp;gt;&amp;gt;&amp;gt;正数无差别，负数有差别）
&amp;amp;   与运算&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.collections.test;

import java.util.HashMap;
import java.util.HashSet;



/**
* @author    叶昭良
* @time      2015年2月25日上午11:06:09
* @version   com.collections.testDeepHashMap V1.0
*/
public class DeepHashMap
{

        /**
         * @param args
         */
        public static void main(String[] args)
        {
                // TODO Auto-generated method stub
/**
*  Long类型的equals的实现
*     public boolean equals(Object obj) {
        if (obj instanceof Long) {
            return value == ((Long)obj).longValue();
        }
        return false;
    }
*/
                System.out.println(new Long(1).equals(new Integer(1)));
                System.out.println(new Long(1).intValue()==new Integer(1).intValue());
                System.out.println(new Long(1).longValue()==new Integer(1).intValue());
                System.out.println(new Long(1).longValue());
                System.out.println(new Integer(1).intValue());
                System.out.println(new Long(100).hashCode());
                System.out.println(new Integer(100).hashCode());
//                System.out.println(new Integer(100).hashCode(100));
                HashMap&amp;lt;Integer,String&amp;gt; hm = new HashMap&amp;lt;Integer,String&amp;gt;();
                System.out.println(hm.hashCode());
//                HashSet&amp;lt;String&amp;gt; hs ;
                System.out.println( (1 &amp;lt;&amp;lt; 30)/1024/1024/1024); //1G
                System.out.println(8&amp;gt;&amp;gt;&amp;gt;2); //+++
                System.out.printf(&amp;quot;%o -- %x  --- %X\n ----\n&amp;quot;,-14,-14,-14);
                System.out.println(-14&amp;gt;&amp;gt;&amp;gt;2);
                System.out.println(Integer.toBinaryString(-14));
                System.out.println(-14&amp;gt;&amp;gt;2);
                //把一个字符串变为 奇数
                //  &amp;gt;&amp;gt;&amp;gt;
                System.out.println(Integer.parseInt(&amp;quot;00111111111111111111111111111100&amp;quot;,2));
                //  &amp;gt;&amp;gt;
                //Integer.parseInt(&amp;quot;-010101010&amp;quot;,2) 可以带符号
                System.out.println(Integer.toBinaryString(14));
                //~取反运算 仅仅针对 整数
                System.out.println(~14);
                System.out.println(Integer.toBinaryString(~14));
                //如何解析带符号位的
                System.out.println(&amp;quot;2的3次方 的错误答案&amp;quot;+(2^3)); // ^在java当中是异或操作
                System.out.println(&amp;quot;2的3次方 的正确答案&amp;quot;+Math.pow(2, 3)); 
                //System.out.println(11111111111111111111111111110010);
                /*
                 * 封存在一个函数内部
                 * System.out.println(&amp;quot;通过异或的方式进行验证&amp;quot;);
                System.out.println(Long.parseLong(&amp;quot;11111111111111111111111111111111&amp;quot;,2)^(Long.parseLong(&amp;quot;11111111111111111111111111110010&amp;quot;,2)));
                // 1101  8+4+1 = 13
                System.out.println((Long.parseLong(&amp;quot;11111111111111111111111111111111&amp;quot;,2)^(Long.parseLong(&amp;quot;11111111111111111111111111110010&amp;quot;,2)))+1);
                System.out.println(-((Long.parseLong(&amp;quot;11111111111111111111111111111111&amp;quot;,2)^(Long.parseLong(&amp;quot;11111111111111111111111111110010&amp;quot;,2)))+1));
                */
                System.out.println(&amp;quot;通过自定义的获取负数的方法:&amp;quot;+parseNegativeInteger(&amp;quot;11111111111111111111111111110010&amp;quot;));
                //负数的补码的计算是取反加1（然后在最后的数上加上负数）   正数的补码是直接计算
                System.out.println(Integer.parseInt(&amp;quot;100&amp;quot;,2)); //把100这个二进制数按照2进制方式解析
                
                //String.
                System.out.println(100);
                System.out.println(&amp;quot;开始从高到低进行打印&amp;quot;);
                //格式化输出 只有 %d  %o  %x  二进制得用toBinaryString
                for(byte b1 :longToByte8(100)) 
                {
                        System.out.printf(&amp;quot;%d:&amp;quot;,b1);
                }
                //我现在是取反
                
                // returns the number of one-bits 
                System.out.println(Integer.toBinaryString(170));
            System.out.println(&amp;quot;Number of one bits = &amp;quot; + Integer.bitCount(170));
            
            // 牛逼算法！ 让n最终为 某一个范围内的两端值
            System.out.println(15|15&amp;gt;&amp;gt;&amp;gt;1);
            int n = 170; //使得 n都是
            /**
             * 或的运算就是保持最大值（与的运算是为了保持原样（当和0xff))
             *  13 :00000000 00000000 00000000  00001101
             *   6  00000000 00000000 00000000  00000110  
             * 15:  00000000 00000000 00000000  00001111
             *   一直保持15   当时最大值 则保持一样了
             */
        n |= n &amp;gt;&amp;gt;&amp;gt; 1;
        n |= n &amp;gt;&amp;gt;&amp;gt; 2;
        n |= n &amp;gt;&amp;gt;&amp;gt; 4;
        n |= n &amp;gt;&amp;gt;&amp;gt; 8;
        n |= n &amp;gt;&amp;gt;&amp;gt; 16; // 2^16
        System.out.println(&amp;quot;Pow(2,16):&amp;quot;+Math.pow(2, 16));
        System.out.println(n);
        System.out.println(170&amp;gt;&amp;gt;&amp;gt;8);
        
        int tb=0;
        //由此可见 If的赋值是会影响到else的！！！
        //并且是有先后顺序的，这是在看hashmap的时候学到的
        if((tb=4) ==3)
        {
                System.out.println(&amp;quot;In the if&amp;quot;+tb);
        }else 
        {
                System.out.println(&amp;quot;In the else&amp;quot;+tb);
        }
        
        }
        /**
         * 计算机内部负数是用补码表示的，正数的原码与补码相同 (也就是所有数都以补码存在)
         * 你不要用这种连写的方式，改成：
         *   5  0101    3: 0011
         *       
         *        1:  0101 ^ 0011 =  0110
         *        2:  0110 ^ 0011 =  0101  == 5
         *        3:  0110 ^ 0101 =  0011  == 3  
         *                                      真心妙的操作
                i = i^j;
                j = i^j;
                i = i^j; 
                这样就可进行两个数的交换
         * @param sum
         * @return
         */
        public static long parseNegativeInteger(String number)
        {
                return -((Long.parseLong(&amp;quot;11111111111111111111111111111111&amp;quot;,2)^(Long.parseLong(number,2)))+1);
        }
    public static byte[] longToByte8(long sum) {
        byte[] arr = new byte[8];
        //一个字节有8 位   long是8个字节的
        arr[0] = (byte) (sum &amp;gt;&amp;gt; 56); //先提取最高位
        arr[1] = (byte) (sum &amp;gt;&amp;gt; 48); //第二高位
        arr[2] = (byte) (sum &amp;gt;&amp;gt; 40); //第三高位
        arr[3] = (byte) (sum &amp;gt;&amp;gt; 32);
        arr[4] = (byte) (sum &amp;gt;&amp;gt; 24);
        arr[5] = (byte) (sum &amp;gt;&amp;gt; 16);
        arr[6] = (byte) (sum &amp;gt;&amp;gt; 8);
        arr[7] = (byte) (sum &amp;amp; 0xff); //不超过258 15*16+16 =256
        return arr;
    }


}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由此得知HashMap的翻倍原理：
newCap = oldCap &amp;lt;&amp;lt; 1&lt;/p&gt;

&lt;p&gt;2.字节的截断工具：
&amp;amp;的截断作用&lt;/p&gt;

&lt;p&gt;//0xff 其实就是一个字节，也就是最低的一个直接
//通过&amp;amp;来截断最低的一个直接
(byte) (c &amp;amp; 0xff);  来获得c的最低的一个直接（一般用于结尾   ^&lt;/p&gt;

&lt;p&gt;p = tab[index = (n - 1) &amp;amp; hash]
ByteUtils字节工具：（一谈到工具，一般是静态方法）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
* http://www.cnblogs.com/fangfan/p/4086662.html
*/
package com.collections.test;

import java.util.Arrays;

/**
* @author    叶昭良
* @time      2015年2月25日下午11:56:33
* @version   com.collections.testByteUtils V1.0
*/
public class ByteUtils
{

        /**
         * @param args
         */
          /**
     * 
     * &amp;lt;pre&amp;gt;
     * 将4个byte数字组成的数组合并为一个float数.
     * &amp;amp;是位与，&amp;amp;一般用于取一个字节（八位）的位数
     * &amp;lt;/pre&amp;gt;
     * 
     * @param arr
     * @return
     */
    public static float byte4ToFloat(byte[] arr) {
        if (arr == null || arr.length != 4) {
            throw new IllegalArgumentException(&amp;quot;byte数组必须不为空,并且是4位!&amp;quot;);
        }
        int i = byte4ToInt(arr);
        return Float.intBitsToFloat(i);
    }

    /**
     * 
     * &amp;lt;pre&amp;gt;
     * 将一个float数字转换为4个byte数字组成的数组.
     * &amp;lt;/pre&amp;gt;
     * 
     * @param f
     * @return
     */
    public static byte[] floatToByte4(float f) {
        int i = Float.floatToIntBits(f);
        return intToByte4(i);
    }

    /**
     * 
     * &amp;lt;pre&amp;gt;
     * 将八个byte数字组成的数组转换为一个double数字.
     * &amp;lt;/pre&amp;gt;
     * 
     * @param arr
     * @return
     */
    public static double byte8ToDouble(byte[] arr) {
        if (arr == null || arr.length != 8) {
            throw new IllegalArgumentException(&amp;quot;byte数组必须不为空,并且是8位!&amp;quot;);
        }
        long l = byte8ToLong(arr);
        return Double.longBitsToDouble(l);
    }

    /**
     * 
     * &amp;lt;pre&amp;gt;
     * 将一个double数字转换为8个byte数字组成的数组.
     * &amp;lt;/pre&amp;gt;
     * 
     * @param i
     * @return
     */
    public static byte[] doubleToByte8(double i) {
        long j = Double.doubleToLongBits(i);
        return longToByte8(j);
    }

    /**
     * 
     * &amp;lt;pre&amp;gt;
     * 将一个char字符转换为两个byte数字转换为的数组.
     * &amp;lt;/pre&amp;gt;
     * 
     * @param c
     * @return
     */
    public static byte[] charToByte2(char c) {
        byte[] arr = new byte[2];
        arr[0] = (byte) (c &amp;gt;&amp;gt; 8);
        //0xff 其实就是一个字节，也就是最低的一个直接
        //通过&amp;amp;来截断最低的一个直接
        arr[1] = (byte) (c &amp;amp; 0xff);
        return arr;
    }

    /**
     * 
     * &amp;lt;pre&amp;gt;
     * 将2个byte数字组成的数组转换为一个char字符.
     * &amp;lt;/pre&amp;gt;
     * 
     * @param arr
     * @return
     */
    public static char byte2ToChar(byte[] arr) {
        if (arr == null || arr.length != 2) {
            throw new IllegalArgumentException(&amp;quot;byte数组必须不为空,并且是2位!&amp;quot;);
        }
        return (char) (((char) (arr[0] &amp;lt;&amp;lt; 8)) | ((char) arr[1]));
    }

    /**
     * 
     * &amp;lt;pre&amp;gt;
     * 将一个16位的short转换为长度为2的8位byte数组.
     * &amp;lt;/pre&amp;gt;
     * 
     * @param s
     * @return
     */
    public static byte[] shortToByte2(Short s) {
        byte[] arr = new byte[2];
        arr[0] = (byte) (s &amp;gt;&amp;gt; 8);
        arr[1] = (byte) (s &amp;amp; 0xff);
        return arr;
    }

    /**
     * 
     * &amp;lt;pre&amp;gt;
     * 长度为2的8位byte数组转换为一个16位short数字.
     * &amp;lt;/pre&amp;gt;
     * 
     * @param arr
     * @return
     */
    public static short byte2ToShort(byte[] arr) {
        if (arr != null &amp;amp;&amp;amp; arr.length != 2) {
            throw new IllegalArgumentException(&amp;quot;byte数组必须不为空,并且是2位!&amp;quot;);
        }
        return (short) (((short) arr[0] &amp;lt;&amp;lt; 8) | ((short) arr[1] &amp;amp; 0xff));
    }

    /**
     * 
     * &amp;lt;pre&amp;gt;
     * 将short转换为长度为16的byte数组.
     * 实际上每个8位byte只存储了一个0或1的数字
     * 比较浪费.
     * &amp;lt;/pre&amp;gt;
     * 
     * @param s
     * @return
     */
    public static byte[] shortToByte16(short s) {
        byte[] arr = new byte[16];
        for (int i = 15; i &amp;gt;= 0; i--) {
            arr[i] = (byte) (s &amp;amp; 1);
            s &amp;gt;&amp;gt;= 1;
        }
        return arr;
    }

    public static short byte16ToShort(byte[] arr) {
        if (arr == null || arr.length != 16) {
            throw new IllegalArgumentException(&amp;quot;byte数组必须不为空,并且长度为16!&amp;quot;);
        }
        short sum = 0;
        for (int i = 0; i &amp;lt; 16; ++i) {
            sum |= (arr[i] &amp;lt;&amp;lt; (15 - i));
        }
        return sum;
    }

    /**
     * 
     * &amp;lt;pre&amp;gt;
     * 将32位int转换为由四个8位byte数字.
     * &amp;lt;/pre&amp;gt;
     * 
     * @param sum
     * @return
     */
    public static byte[] intToByte4(int sum) {
        byte[] arr = new byte[4];
        arr[0] = (byte) (sum &amp;gt;&amp;gt; 24);
        arr[1] = (byte) (sum &amp;gt;&amp;gt; 16);
        arr[2] = (byte) (sum &amp;gt;&amp;gt; 8);
        arr[3] = (byte) (sum &amp;amp; 0xff);
        return arr;
    }

    /**
     * &amp;lt;pre&amp;gt;
     * 将长度为4的8位byte数组转换为32位int.
     * &amp;lt;/pre&amp;gt;
     * 
     * @param arr
     * @return
     */
    public static int byte4ToInt(byte[] arr) {
        if (arr == null || arr.length != 4) {
            throw new IllegalArgumentException(&amp;quot;byte数组必须不为空,并且是4位!&amp;quot;);
        }
        return (int) (((arr[0] &amp;amp; 0xff) &amp;lt;&amp;lt; 24) | ((arr[1] &amp;amp; 0xff) &amp;lt;&amp;lt; 16) | ((arr[2] &amp;amp; 0xff) &amp;lt;&amp;lt; 8) | ((arr[3] &amp;amp; 0xff)));
    }

    /**
     * 
     * &amp;lt;pre&amp;gt;
     * 将长度为8的8位byte数组转换为64位long.
     * &amp;lt;/pre&amp;gt;
     * 
     * 0xff对应16进制,f代表1111,0xff刚好是8位 byte[]
     * arr,byte[i]&amp;amp;0xff刚好满足一位byte计算,不会导致数据丢失. 如果是int计算. int[] arr,arr[i]&amp;amp;0xffff
     * 
     * @param arr
     * @return
     */
    public static long byte8ToLong(byte[] arr) {
        if (arr == null || arr.length != 8) {
            throw new IllegalArgumentException(&amp;quot;byte数组必须不为空,并且是8位!&amp;quot;);
        }
        return (long) (((long) (arr[0] &amp;amp; 0xff) &amp;lt;&amp;lt; 56) | ((long) (arr[1] &amp;amp; 0xff) &amp;lt;&amp;lt; 48) | ((long) (arr[2] &amp;amp; 0xff) &amp;lt;&amp;lt; 40)
                        | ((long) (arr[3] &amp;amp; 0xff) &amp;lt;&amp;lt; 32) | ((long) (arr[4] &amp;amp; 0xff) &amp;lt;&amp;lt; 24)
                        | ((long) (arr[5] &amp;amp; 0xff) &amp;lt;&amp;lt; 16) | ((long) (arr[6] &amp;amp; 0xff) &amp;lt;&amp;lt; 8) | ((long) (arr[7] &amp;amp; 0xff)));
    }

    /**
     * 将一个long数字转换为8个byte数组组成的数组.
     */
    public static byte[] longToByte8(long sum) {
        byte[] arr = new byte[8];
        arr[0] = (byte) (sum &amp;gt;&amp;gt; 56);
        arr[1] = (byte) (sum &amp;gt;&amp;gt; 48);
        arr[2] = (byte) (sum &amp;gt;&amp;gt; 40);
        arr[3] = (byte) (sum &amp;gt;&amp;gt; 32);
        arr[4] = (byte) (sum &amp;gt;&amp;gt; 24);
        arr[5] = (byte) (sum &amp;gt;&amp;gt; 16);
        arr[6] = (byte) (sum &amp;gt;&amp;gt; 8);
        arr[7] = (byte) (sum &amp;amp; 0xff);
        return arr;
    }

    /**
     * 
     * &amp;lt;pre&amp;gt;
     * 将int转换为32位byte.
     * 实际上每个8位byte只存储了一个0或1的数字
     * 比较浪费.
     * &amp;lt;/pre&amp;gt;
     * 
     * @param num
     * @return
     */
    public static byte[] intToByte32(int num) {
        byte[] arr = new byte[32];
        for (int i = 31; i &amp;gt;= 0; i--) {
            // &amp;amp;1 也可以改为num&amp;amp;0x01,表示取最地位数字.
            arr[i] = (byte) (num &amp;amp; 1);
            // 右移一位.
            num &amp;gt;&amp;gt;= 1;
        }
        return arr;
    }

    /**
     * 
     * &amp;lt;pre&amp;gt;
     * 将长度为32的byte数组转换为一个int类型值.
     * 每一个8位byte都只存储了0或1的数字.
     * &amp;lt;/pre&amp;gt;
     * 
     * @param arr
     * @return
     */
    public static int byte32ToInt(byte[] arr) {
        if (arr == null || arr.length != 32) {
            throw new IllegalArgumentException(&amp;quot;byte数组必须不为空,并且长度是32!&amp;quot;);
        }
        int sum = 0;
        for (int i = 0; i &amp;lt; 32; ++i) {
            sum |= (arr[i] &amp;lt;&amp;lt; (31 - i));
        }
        return sum;
    }

    /**
     * 
     * &amp;lt;pre&amp;gt;
     * 将长度为64的byte数组转换为一个long类型值.
     * 每一个8位byte都只存储了0或1的数字.
     * &amp;lt;/pre&amp;gt;
     * 
     * @param arr
     * @return
     */
    public static long byte64ToLong(byte[] arr) {
        if (arr == null || arr.length != 64) {
            throw new IllegalArgumentException(&amp;quot;byte数组必须不为空,并且长度是64!&amp;quot;);
        }
        long sum = 0L;
        for (int i = 0; i &amp;lt; 64; ++i) {
            sum |= ((long) arr[i] &amp;lt;&amp;lt; (63 - i));
        }
        return sum;
    }

    /**
     * 
     * &amp;lt;pre&amp;gt;
     * 将一个long值转换为长度为64的8位byte数组.
     * 每一个8位byte都只存储了0或1的数字.
     * &amp;lt;/pre&amp;gt;
     * 
     * @param sum
     * @return
     */
    public static byte[] longToByte64(long sum) {
        byte[] arr = new byte[64];
        for (int i = 63; i &amp;gt;= 0; i--) {
            arr[i] = (byte) (sum &amp;amp; 1);
            sum &amp;gt;&amp;gt;= 1;
        }
        return arr;
    }
    
   
    public static void showMaxValAndminVal() {
        // 127
        System.out.println(&amp;quot;Byte.Max_Value:&amp;quot;+Byte.MAX_VALUE);
        // -128
        System.out.println(&amp;quot;Byte.MIN_VALUE:&amp;quot;+Byte.MIN_VALUE);

        // 32767
        System.out.println(&amp;quot;Short.MAX_VALUE:&amp;quot;+Short.MAX_VALUE);
        // -32768
        System.out.println(&amp;quot;Short.MIN_VALUE:&amp;quot;+Short.MIN_VALUE);

        // 65535 2的16次方-1
        System.out.println(&amp;quot;(int) Character.MAX_VALUE:&amp;quot;+(int) Character.MAX_VALUE);
        // 0
        System.out.println(&amp;quot;(int) Character.MIN_VALUE:&amp;quot;+(int) Character.MIN_VALUE);

        // 2147483647
        System.out.println(&amp;quot;Integer.MAX_VALUE:&amp;quot;+Integer.MAX_VALUE);
        // -2147483648
        System.out.println(&amp;quot;Integer.MIN_VALUE:&amp;quot;+Integer.MIN_VALUE);

        // 科学计数法.
        // 3.4028235E38
        System.out.println(&amp;quot;Float.MAX_VALUE:&amp;quot;+Float.MAX_VALUE);
        // 1.4E-45
        System.out.println(&amp;quot;Float.MIN_VALUE:&amp;quot;+Float.MIN_VALUE);

        // 9223372036854775807
        System.out.println(&amp;quot;Long.MAX_VALUE:&amp;quot;+Long.MAX_VALUE);
        // -9223372036854775808
        System.out.println(&amp;quot;Long.MIN_VALUE:&amp;quot;+Long.MIN_VALUE);

        // 科学计数法.
        // 1.7976931348623157E308
        System.out.println(&amp;quot;Double.MAX_VALUE:&amp;quot;+Double.MAX_VALUE);
        // 4.9E-324
        System.out.println(&amp;quot;Double.MIN_VALUE:&amp;quot;+Double.MIN_VALUE);
    }
    
    public static void transByte() {
        char c = &#39;z&#39;;
        byte[] charToByte2Arr = ByteUtils.charToByte2(c);
       

        short s = Short.MAX_VALUE;
        // System.out.println(&amp;quot;Short.MAX_VALUE:&amp;quot; + s);
        byte[] shortToByte2Arr = ByteUtils.shortToByte2(s);
       

        byte[] shortToByte16 = ByteUtils.shortToByte16(s);
        System.out.println(Arrays.toString(shortToByte16));
        System.out.println(ByteUtils.byte16ToShort(shortToByte16));

        int i = Integer.MAX_VALUE;
        // System.out.println(&amp;quot;Integer.MAX_VALUE:&amp;quot; + i);
        byte[] intToByte4Arr = ByteUtils.intToByte4(i);
        

        byte[] intToByte32Arr = ByteUtils.intToByte32(i);
        System.out.println(Arrays.toString(intToByte32Arr));
        System.out.println(ByteUtils.byte32ToInt(intToByte32Arr));

        long j = Long.MAX_VALUE;
        // System.out.println(&amp;quot;Long.MAX_VALUE:&amp;quot; + j);
        byte[] longToByte8Arr = ByteUtils.longToByte8(j);
      

        byte[] longToByte64Arr = ByteUtils.longToByte64(j);
        System.out.println(Arrays.toString(longToByte64Arr));
        System.out.println(ByteUtils.byte64ToLong(longToByte64Arr));

        double d = 2.34;
        byte[] doubleToByte8Arr = ByteUtils.doubleToByte8(d);
       

        float f = 1.2f;
        byte[] floatToByte4Arr = ByteUtils.floatToByte4(f);
       
    }

        public static void main(String[] args)
        {
                // TODO Auto-generated method stub
//                showMaxValAndminVal();
                transByte();
        }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;补充^:
按位异或。比如二进制     1001 ^ 1100 = 0101
0^0=0，1^1=0 ，1^0 = 1，0^1=1
复制代码&lt;/p&gt;

&lt;p&gt;3.理解重新调整大小&lt;/p&gt;

&lt;p&gt;第一部分：理解重新调整大&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    /**
     * Implements Map.putAll and Map constructor
     *
     * @param m the map
     * @param evict false when initially constructing this map, else
     * true (relayed to method afterNodeInsertion).
     */
    final void putMapEntries(Map&amp;lt;? extends K, ? extends V&amp;gt; m, boolean evict) {
        int s = m.size();
        if (s &amp;gt; 0) {
            if (table == null) { // pre-size
                float ft = ((float)s / loadFactor) + 1.0F;
                int t = ((ft &amp;lt; (float)MAXIMUM_CAPACITY) ?
                         (int)ft : MAXIMUM_CAPACITY);
                if (t &amp;gt; threshold)
                    threshold = tableSizeFor(t);
            }
            else if (s &amp;gt; threshold)
                resize();
            for (Map.Entry&amp;lt;? extends K, ? extends V&amp;gt; e : m.entrySet()) {
                K key = e.getKey();
                V value = e.getValue();
                putVal(hash(key), key, value, false, evict);
            }
        }
    }

    public HashMap(int initialCapacity, float loadFactor) {
        if (initialCapacity &amp;lt; 0)
            throw new IllegalArgumentException(&amp;quot;Illegal initial capacity: &amp;quot; +
                                               initialCapacity);
        if (initialCapacity &amp;gt; MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        if (loadFactor &amp;lt;= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException(&amp;quot;Illegal load factor: &amp;quot; +
                                               loadFactor);
        this.loadFactor = loadFactor;
        this.threshold = tableSizeFor(initialCapacity);
    

    /**
     * Returns a power of two size for the given target capacity.
用于理解2的阶乘大小的实现。别人一直强调的2的阶乘的扩容
     */
    static final int tableSizeFor(int cap) {
        int n = cap - 1;
        n |= n &amp;gt;&amp;gt;&amp;gt; 1; //
        n |= n &amp;gt;&amp;gt;&amp;gt; 2;
        n |= n &amp;gt;&amp;gt;&amp;gt; 4;
        n |= n &amp;gt;&amp;gt;&amp;gt; 8;
        n |= n &amp;gt;&amp;gt;&amp;gt; 16;
        return (n &amp;lt; 0) ? 1 : (n &amp;gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4.理解添加&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   /**
     * Implements Map.putAll and Map constructor
     *
     * @param m the map
     * @param evict false when initially constructing this map, else
     * true (relayed to method afterNodeInsertion).
     */
    final void putMapEntries(Map&amp;lt;? extends K, ? extends V&amp;gt; m, boolean evict) {
        int s = m.size();
        if (s &amp;gt; 0) {
            if (table == null) { // pre-size
                float ft = ((float)s / loadFactor) + 1.0F;
                int t = ((ft &amp;lt; (float)MAXIMUM_CAPACITY) ?
                         (int)ft : MAXIMUM_CAPACITY);
                if (t &amp;gt; threshold)
                    threshold = tableSizeFor(t);
            }
            else if (s &amp;gt; threshold)
                resize();
            for (Map.Entry&amp;lt;? extends K, ? extends V&amp;gt; e : m.entrySet()) {
                K key = e.getKey();
                V value = e.getValue();
                putVal(hash(key), key, value, false, evict);
            }
        }
    }



final Node&amp;lt;K,V&amp;gt;[] resize() {
//在创建新表之前 ，先保存旧表
        Node&amp;lt;K,V&amp;gt;[] oldTab = table;
//保存旧表的长度
        int oldCap = (oldTab == null) ? 0 : oldTab.length;
//保存 上限值
        int oldThr = threshold;
        int newCap, newThr = 0;
        if (oldCap &amp;gt; 0) {
            if (oldCap &amp;gt;= MAXIMUM_CAPACITY) {
                threshold = Integer.MAX_VALUE;
                return oldTab;
            }
//加倍了！！！！！！
            else if ((newCap = oldCap &amp;lt;&amp;lt; 1) &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp;
                     oldCap &amp;gt;= DEFAULT_INITIAL_CAPACITY)
                newThr = oldThr &amp;lt;&amp;lt; 1; // double threshold
        }
        else if (oldThr &amp;gt; 0) // initial capacity was placed in threshold
            newCap = oldThr;
        else {               // zero initial threshold signifies using defaults
            newCap = DEFAULT_INITIAL_CAPACITY;
            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
        }
        if (newThr == 0) {
            float ft = (float)newCap * loadFactor;
            newThr = (newCap &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp; ft &amp;lt; (float)MAXIMUM_CAPACITY ?
                      (int)ft : Integer.MAX_VALUE);
        }
        threshold = newThr;
        @SuppressWarnings({&amp;quot;rawtypes&amp;quot;,&amp;quot;unchecked&amp;quot;})
//新标的长度  newTab为newCap,newCap默认为最大的Capacity  16
            Node&amp;lt;K,V&amp;gt;[] newTab = (Node&amp;lt;K,V&amp;gt;[])new Node[newCap];
        table = newTab;
        if (oldTab != null) {
            for (int j = 0; j &amp;lt; oldCap; ++j) {
                Node&amp;lt;K,V&amp;gt; e;
                if ((e = oldTab[j]) != null) {
                    oldTab[j] = null;
//分为两种情况进行扩充
                    if (e.next == null)
//e.hash 是Node类的final属性
                        newTab[e.hash &amp;amp; (newCap - 1)] = e;
                    else if (e instanceof TreeNode)
                        ((TreeNode&amp;lt;K,V&amp;gt;)e).split(this, newTab, j, oldCap);
                    else { // preserve order
                        Node&amp;lt;K,V&amp;gt; loHead = null, loTail = null;
                        Node&amp;lt;K,V&amp;gt; hiHead = null, hiTail = null;
                        Node&amp;lt;K,V&amp;gt; next;
                        do {
                            next = e.next;
// e.hash &amp;amp; oldCap 的作用是 若&amp;lt;oldCap 则范围e.hash
                            if ((e.hash &amp;amp; oldCap) == 0) {
                                if (loTail == null)
                                    loHead = e;
                                else
                                    loTail.next = e;
                                loTail = e;
                            }
                            else {
                                if (hiTail == null)
                                    hiHead = e;
                                else
                                    hiTail.next = e;
                                hiTail = e;
                            }
                        } while ((e = next) != null);
                        if (loTail != null) {
                            loTail.next = null;
                            newTab[j] = loHead;
                        }
                        if (hiTail != null) {
                            hiTail.next = null;
                            newTab[j + oldCap] = hiHead;
                        }
                    }
                }
            }
        }
        return newTab;
    }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5.理解说明：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
     * Initializes or doubles table size.  If null, allocates in
     * accord with initial capacity target held in field threshold.
     * Otherwise, because we are using power-of-two expansion, the
     * elements from each bin must either stay at same index, or move
     * with a power of two offset in the new table.
     *
初始化或者使表格大小加倍。如果为null，分配和初始容量目标（根据threshold字段值） 另外地，因为我们使用2的阶乘的拓展，每个块的元素应该是处于相同的指数，或者在新表中移动2的阶乘&amp;lt;/font&amp;gt; 
复制代码
&amp;lt;font size=&amp;quot;3&amp;quot;&amp;gt;没错我依然以putMapEntries作为话题的引发点。
两个参数：
    static final int MAXIMUM_CAPACITY = 1 &amp;lt;&amp;lt; 30;//1G的大小 2^30次方 

    /**
     * The load factor used when none specified in constructor.
     */
static final float DEFAULT_LOAD_FACTOR = 0.75f;

static final int DEFAULT_INITIAL_CAPACITY = 1 &amp;lt;&amp;lt; 4; // aka 16
* size：该变量保存了该 HashMap 中所包含的 
key-value 对的数量。      
* threshold：该变量包含了 HashMap 能容纳的 key-value 对的极限，它的值等于 HashMap 的容量乘以负载因子（load factor）

当 size++ &amp;gt;= threshold 时，HashMap 会自动调用 resize 方法扩充 HashMap 的容量。每扩充一次，HashMap 的容量就增大一倍

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;6.HashMap和HashSet的区别
   Hashset是继承list，具有iterator特性
   HashMap继承自Map，不具有iterator特性
   两者的共同特点是都是linked数组（数组的bucket号都是一个链表）&lt;/p&gt;

&lt;p&gt;7.理解Hash算法
&lt;font size=&#34;3&#34;&gt;其实就是hash调用自定义类的hashcode方法而已）以及contains key的过程。在HashSet或者HashMap中都有get方法，get方法中都有hash的影子，当然在containsKey中也是包含着hash()的方法，通过这个方法的调用才可以找到bucket(俗语：存储桶，用于装一条链表，可用于存储的桶的个数，也就是数组的长度，也叫做capacity容量，一般对应着一个负载因子算法，当超过最大容量乘上负载因子，就需要进行rehash的过程)&lt;/font&gt;
复制代码
TreeMap:
本质：
优点：
缺点：
LinkedHashMap:
本质：&lt;br /&gt;
优点：
缺点：
Iterator:
替换掉Enumeration,先前的Enumeration类的方法名的长度较长，不方便记忆，淘汰之。
泛型
泛型的本质是参数化类型。当我们再进行泛型定义的时候可以用T  K  V  E，但是当我们在使用泛型接口的时候 必须给泛型附上一个值，就好像给方法附上实参
Java的泛型实际上从编译的角度来说仅仅是一个类型擦除
    public static void doTest(List&amp;lt;?extends Parent&amp;gt; list)
    //包含Parend以及所有继承自Parent的子类
    public static void doTest(List&amp;lt;?super Parent&amp;gt; list)
    //包含Parend以及所有Parent的父类
泛型的兼容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   //泛型的向后兼容

   //l1 只是回去找List的方法   

   List l1 =   new ArrayList&amp;lt;String&amp;gt;();

   l1.add(&amp;quot;abc&amp;quot;);

   l1.add(3);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;泛型的不协变：
       //泛型的不协变
//     List&lt;String&gt;l3 = new ArrayList&lt;Integer&gt;(); //报错&lt;/p&gt;

&lt;p&gt;Arrays:Arrays中 asList  不能使用add ，因为asList根本就没有改变数组的本质！！只不过可以使用遍历的方法常用方法：
sort                     给数组的元素排序
binarySearch     二分查找法查找元素
copyOf               数组复制
equals                  判断两个数组的元素是否相等
fill                         填充数组
hashCode            计算数组的元素的哈希值
toString                返回每个数组元素组成的字符串
asList        把数组转化为结构不可改变,但可以查询修改的集合&lt;/p&gt;

&lt;p&gt;Collections:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.collections.test;

import java.util.ArrayList;
import java.util.Collections;

/**
* 
* @author    叶昭良
* @time      2015年3月19日下午1:25:44
* @version   com.collections.testTestCollections1 V1.0
* 功能：  测试 骰子 的乱序  随机排序
                步骤：
* 注意：
* 掌握：
                思考：
* 回顾：
*/
public class TestCollections1
{
        public static void main(String[] args)
        {
                ArrayList&amp;lt;Integer&amp;gt; arl = new ArrayList&amp;lt;Integer&amp;gt;();
                arl.add(4);
                arl.add(9);
                arl.add(2);
                arl.add(10);
                arl.add(3);
                Collections.shuffle(arl);
                for(Integer temp:arl)
                {
                        System.out.println(temp);
                }
        }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java&lt;/p&gt;

&lt;p&gt;Sort: 只对list排序    treeset内部就有排序   hashmap根本就不需要
binarySearch  二分查找  必须是list 而且该集合必须排好序
fill   只能对list集合有效
shuffle  洗牌   打乱集合的顺序&lt;/p&gt;

&lt;p&gt;只有排完序才能进行binarySearch&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Collections.sort(pileOfApple);
                for(String temp:pileOfApple)
                {
                        System.out.println(temp);
                }
                //已排好序 才可以这样做 ! 否则不可以进行二分查找  Arrays类似的用法
                System.out.println(Collections.binarySearch(pileOfApple, &amp;quot;gd&amp;quot;));&amp;lt;/font&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Collections常用方法：
sort       对List集合进行排序
binarySearch 方法,使用二分查找法查找元素,要求必须是List集合,而且必须已经排好序
fill                  方法,使用指定元素填充List集合
replaceAll      方法,使用指定元素替换所有的另一个元素,只对List有效
max   方法,返回一个集合中最大的元素
min
shuffle  洗牌,打乱集合元素的顺序
synchronizedList     返回指定集合的线程安全的包装集合
unmodifiableList     返回指定集合的不可修改的包装集合&lt;/p&gt;

&lt;p&gt;多重数据结构的实现：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
package com.collections.test;

import java.util.HashMap;

/**
* @author    叶昭良
* @time      2015年3月3日下午6:54:32
* @version   com.collections.testTestMapMap V1.0
*/
import java.util.*;
public class TestMapMap
{

        /**
         * @param args
         */
        public static void main(String[] args)
        {
                // TODO Auto-generated method stub
                //Map&amp;lt;String,Map&amp;lt;String,Map&amp;lt;Integer,Double&amp;gt;&amp;gt;&amp;gt; stuTotal = new HashMap&amp;lt;String,Map&amp;lt;String,Map&amp;lt;Integer,Double&amp;gt;&amp;gt;&amp;gt;();
                Map&amp;lt;String, Integer&amp;gt; innerMap = new HashMap&amp;lt;String, Integer&amp;gt;();
                innerMap.put(&amp;quot;innerKey&amp;quot;, 2014);
                Map&amp;lt;String, Map&amp;lt;String, Integer&amp;gt;&amp;gt; map = new HashMap&amp;lt;String, Map&amp;lt;String, Integer&amp;gt;&amp;gt;();
                map.put(&amp;quot;outerKey&amp;quot;, innerMap);
                 
                Map&amp;lt;String, Integer&amp;gt; targetMap = map.get(&amp;quot;outerKey&amp;quot;);
                if(targetMap == innerMap){
                    System.out.println(&amp;quot;You got the inner Map, and it is saved in targetMap!!!&amp;quot;);
                }
                
                //原来嵌套集合数据结构是可以实现的
                Map&amp;lt;String,Map&amp;lt;String,Map&amp;lt;Integer,Double&amp;gt;&amp;gt;&amp;gt; outterMap = new HashMap&amp;lt;String, Map&amp;lt;String,Map&amp;lt;Integer,Double&amp;gt;&amp;gt;&amp;gt;();
                
                //==
        }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ToStringString函数的append可采用链式的append本质是：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;font size=&amp;quot;3&amp;quot;&amp;gt; @Override
    public StringBuilder append(boolean b) {
        super.append(b);
        return this;
    }

    @Override
    public StringBuilder append(char c) {
        super.append(c);
        return this;
    }
。。。。。&amp;lt;/font&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java
&lt;font size=&#34;3&#34;&gt;String类型的toString方法，会去调用valueOf函数，关键的调研过程:
其实关键是得看println接受的对象，以前一直认为是对象们的toString方法，没错的确是他直接引起，但是其实是因为println的重载方法来限制了对象必须去重写toString方法.
因为再对应String的println重载方法中，包含着String.valueOf所以需要进一步调用String类的valueOf函数，而valueOf函数则是调用了toString方法，所以最基本的函数toString。
不同的参数类型会去加载不同的println的方法！&lt;/font&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>2月1日Java班笔记作业</title>
      <link>https://jueqingsizhe66.github.io/blog/2015/05/11/2yue-1ri-javaban-bi-ji-zuo-ye/</link>
      <pubDate>Mon, 11 May 2015 14:58:41 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/blog/2015/05/11/2yue-1ri-javaban-bi-ji-zuo-ye/</guid>
      <description>&lt;p&gt;第一部分 ：笔记
FileChooserDialog&lt;/p&gt;

&lt;p&gt;1、        创建：int gtk_file_chooser_dialog_new(String title,int parentWindow, int action, String first_button_text)：action可选值GTK_FILE_CHOOSER&lt;em&gt;ACTION&lt;/em&gt;*：OPEN(打开文件)、SAVE(保存文件)、SELECT_FOLDER(选择文件夹)、CREATE_FOLDER(创建文件夹)
2、gtk_file_chooser_set_select_multiple是否允许多选（一般是设置上）
gtk_file_chooser_set_current_name设置默认文件名
gtk_file_chooser_get_filename得到选择的文件名(单选)
gtk_file_chooser_get_filenames得到选择的文件名（数组，多选）
gtk_file_chooser_set_do_overwrite_confirmation选择已经存在的文件是否提示覆盖，一般是用于保存文件（在作业中有体现）
3、文件过滤器
gtk_file_filter_new：创建过滤器
gtk_file_filter_set_name设置显示的名字
gtk_file_filter_add_pattern添加过滤通配符：第二个参数格式“*.txt”，若是多个则多次执行这个函数
gtk_file_chooser_add_filter(int chooser,int filter)将过滤器添加到chooser中&lt;/p&gt;

&lt;p&gt;TreeView
Treemodal的作用是什么？
有点感觉了&lt;/p&gt;

&lt;p&gt;TreeView是基于MVC模式设计的（关键点1）； 也就是说需要有一个M，同时又一个V
把M和V联系起来的函数就叫做C，所以也可以改名为MVF。
C的作用可能是修改M的值，并实时显示在V中； 又或者通过修改V的数据，也能够实时反馈到M中；
所以猜测应该是MVC.png：&lt;/p&gt;

&lt;p&gt;所以我们应该需要拥有数据：M（也就是通过liststore创建）
  如何设置M是V的Model很重要,这样就实现了交互的过程，你变我显（你是M,我是V）,你变我改（你是V,我是M）
      当我们获得了数据就可以通过天猫的淘宝来卖了（这就是treeview）
      我们也可以卸货和添货，这就是C了。
1.         GTK.gtk  columns 数据库的字段。
2.         原来iter就是数据库的行    Columns的列
3.          又明白了一点  在所有的GTK.gtk_*_new的int对象都不是简单的整数，而是一个对象的标识，比如int column是列对象标识
      Int  model是模型对象标识    int textview  是textview对象标识    int gridHouse是网格布局对象标识，  归根结底都得第一反应
      过来这是一个对象标识，认清这些对象就可以琢磨这些方法之间的逻辑关系了。也就是说如果一个方法有某个对象标识那么肯定
       就是说得事先创建这个对象或者通过反射机制获得。当然得看清是不是对象标识。通过对象标识认清逻辑关系（关键点2）&lt;/p&gt;

&lt;p&gt;莫名其妙的多了 tree_model的创建  ， 应该加上一步 无论是gtk_tree_model_get_iter_first  还是gtk_tree_model_iter_next
又或者是gtk_tree_model_get_value 还是gtk_tree_model_set_value都涉及到 tree_model的对象标识，必须有tree_model对象标识，
联系到第一步然后把GtkListStore设置为GtkTreeView的Model  ，也就是list_store其实就是tree_model ，因为 ListStore实现了TreeModel接口，所以有的操作以gtk_tree_model开头。一切就算说通了  关键点3&lt;/p&gt;

&lt;p&gt;关键性一步  设置数据仓库的显示。
void gtk_tree_view_set_model(int tree_view, int model)把listmodel对象设置显示到tree_view上（关键点4 显示出来）。
认清五个对象标识：
1 list_store（tree_model）对象标识  2.tree_iter对象标识   3. Tree_view对象标识  4. treeViewColumn对象标识 5.cellRender对象标识&lt;/p&gt;

&lt;p&gt;一个思路：
思路：首先创建GtkListStore，把要显示数据放到GtkListStore中，接着创建GtkTreeView，添加列配置列属性，然后把GtkListStore设置为GtkTreeView的Model，数据就可以显示出来。对数据添加、遍历等操作的时候都要使用迭代器(类似TextView中的Iter)，int gtk_tree_iter_new()创建迭代器。
一般步骤：
1：  利用treeview创建界面，并创建所需的字段，达到View的目的
2：  根据字段数目，创建liststore的数据仓库，达到Model的目的
3：  利用iter对象标识，插入、遍历、删除、增加。
具体看 作业&lt;/p&gt;

&lt;p&gt;另外treeview的行选择问题：
行选择要通过GtkSelection对象进行，int gtk_tree_view_get_selection(int tree_view)获得行选择对象
2、TreeView支持单选、多选等模式，默认是单选。void gtk_tree_selection_set_mode(int tree_selection,int type) 设置选择模式，第一个参数为GtkSelection；type可选值：GTK_SELECTION_SINGLE单选，GTK_SELECTION_MULTIPLE多选，其他不用管
3、int[] gtk_tree_view_get_selection_indices(int tree_view)获得选中行的序号，因为支持多选，所以返回数组
4、获得行选中改变信号，监听GtkSelection的&amp;rdquo;changed&amp;rdquo;信号。
5、获得双击事件，监听&amp;rdquo;button-press-event&amp;rdquo;信号，判断if(GTK.gdk_event_get_type(eventData)==GTK.GDK_2BUTTON_PRESS)得知是否是双击&lt;/p&gt;

&lt;p&gt;ToolBar
1、int gtk_toolbar_new()创建工具栏容器
2、void gtk_toolbar_insert(int toolbar, int item,int pos)将工具栏项添加到工具栏，item：后面讲的工具栏项，pos插入的位置
3、工具栏项有按钮、下拉菜单按钮、分隔栏、开关等复杂内容，这里不介绍，只介绍简单常用的GtkToolButton。
int gtk_tool_button_new(int icon_widget,String label)创建GtkToolButton。icon_widget为显示的控件id，可以在按钮上显示其他控件，一般传0；label为标题。
void gtk_tool_button_set_stock_id(int button,String stock_id); 设置按钮上显示的图片。
响应工具栏按钮点击只要连接&amp;rdquo;clicked&amp;rdquo;信号即可&lt;/p&gt;

&lt;p&gt;Calendar
1、日历Calendar
int gtk_calendar_new()
int gtk_calendar_get_year(int calendar)、int gtk_calendar_get_month(int calendar)、int gtk_calendar_get_day(int calendar)获得选择的年月日
信号：&amp;rdquo;day-selected&amp;rdquo;：选择日期发生变化；&amp;rdquo;day-selected-double-click&amp;rdquo;双击一个日期。
gtk_progress&lt;em&gt;bar&lt;/em&gt;* 进度条
作业
gtk&lt;em&gt;switch&lt;/em&gt;*  开关
作业
menu
                //分三步
                //1创建单一菜单
                //2创建一个菜单头
                //3创建总的菜单条，把许多菜单头都挂到菜单条上
具体看toolbar的作业。&lt;/p&gt;

&lt;p&gt;gtk_status&lt;em&gt;icon&lt;/em&gt;* 右下角的系统图盘图标
作业&lt;/p&gt;

&lt;p&gt;第二部分 ：作业&lt;/p&gt;

&lt;p&gt;文件选择器+工具栏&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.io.BufferedInputStream;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;

/**
* @author    叶昭良
* @time      2015年2月1日下午5:56:29
* @version   TestFileChooser V1.0  简易记事本  打开文件 保存文件 显示照片
* @version   TestFileChooser V2.0  增加了打开对话框  并添加了对话框内部控件的事件
* @version   TestFileChooser V3.0  增加了工具栏
*/
import com.rupeng.gtk4j.*;
public class TestFileChooser2
{

        /**
         * @param args
         */
        static int window;
        static int gridHouse;
        static int scrolledBar;
        static int textview;
        static int  btnApple;
        static String[] selectFiles = null;
        public static void main(String[] args)
        {
                // TODO 自动生成的方法存根
                GTK.gtk_init();
                window = GTK.gtk_window_new(GTK.GTK_WINDOW_TOPLEVEL);
                GTK.gtk_widget_show(window);
                GTK.g_signal_connect(window, &amp;quot;destroy&amp;quot;, new IGCallBack()
                {
                        @Override
                        public void execute(int instance, int eventData, Object object)
                        {
                                // TODO 自动生成的方法存根
                                GTK.gtk_main_quit();
                        }
                }, null);
                int btnApple = GTK.gtk_button_new_with_label(&amp;quot;打开文件&amp;quot;);
                int btnBanana = GTK.gtk_button_new_with_label(&amp;quot;保存文件&amp;quot;);
                int btnOrange = GTK.gtk_button_new_with_label(&amp;quot;显示图片文件&amp;quot;);
                int btnPeal   = GTK.gtk_button_new_with_label(&amp;quot;打开对话框&amp;quot;);
                //创建布局
                gridHouse= GTK.gtk_grid_new();
                GTK.gtk_widget_show(gridHouse);
                GTK.gtk_container_add(window, gridHouse);
                
                //GTK.gtk_widget_set_size_request(window, 500, 500);
                //添加控件到合租房
                int start = 0;
                createToolbar(gridHouse,start);
                GTK.gtk_grid_attach(gridHouse, btnApple, 0, 2, 1, 1);
                GTK.gtk_grid_attach(gridHouse, btnBanana, 1, 2, 1, 1);
                GTK.gtk_grid_attach(gridHouse, btnOrange, 2, 2, 1, 1);
                GTK.gtk_grid_attach(gridHouse, btnPeal, 3, 2, 1, 1);
                createTextView(window,gridHouse,3);
                
                //显示控件
                GTK.gtk_widget_show(btnApple);
                GTK.gtk_widget_show(btnBanana);
                GTK.gtk_widget_show(btnOrange);
                GTK.gtk_widget_show(btnPeal);
                
                //添加按钮事件
                 insertButtonEvent(btnApple);
                 insertButtonSaveEvent(btnBanana);
                 insertButtonPictureEvent(btnOrange);
                 insertButtonDialogEvent(btnPeal);
                //启动循环
                GTK.gtk_main();
        }
        public static void saveFile(int textview) 
        {
                int dlg1 = GTK.gtk_file_chooser_dialog_new(&amp;quot;保存文件&amp;quot;, 0, GTK.GTK_FILE_CHOOSER_ACTION_SAVE,&amp;quot;保存&amp;quot;);
                GTK.gtk_file_chooser_set_do_overwrite_confirmation(dlg1, true);
                //String filename = GTK.gtk_file_chooser_get_filename(dlg1);
                System.out.println(&amp;quot;已进入save&amp;quot;);
                //SaveOneFile(filename,textview);
                int ret = GTK.gtk_dialog_run(dlg1);
                if(ret == GTK.GTK_RESPONSE_CANCEL)
                {
                        GTK.gtk_widget_destroy(dlg1);
                }else 
                {
                        String filename = GTK.gtk_file_chooser_get_filename(dlg1);
                        System.out.println(filename);
                        SaveOneFile(filename,textview);
                        GTK.gtk_widget_destroy(dlg1);
                }
                
        }
        public static String[] selectFile() 
        {
                int dlg = GTK.gtk_file_chooser_dialog_new(&amp;quot;打开文件&amp;quot;, 0, GTK.GTK_FILE_CHOOSER_ACTION_OPEN,&amp;quot;打开&amp;quot;);
                GTK.gtk_file_chooser_set_select_multiple(dlg, true);
                
                //创建过滤器
                int filter = GTK.gtk_file_filter_new();
                GTK.gtk_file_filter_add_pattern(filter, &amp;quot;*.txt&amp;quot;);
                GTK.gtk_file_filter_add_pattern(filter, &amp;quot;*.java&amp;quot;);
                GTK.gtk_file_filter_set_name(filter, &amp;quot;文本文件&amp;quot;);
                GTK.gtk_file_chooser_add_filter(dlg, filter);
                int ret = GTK.gtk_dialog_run(dlg);
                String[] filenames = null;
                if(ret == GTK.GTK_RESPONSE_OK) 
                {
                        filenames = GTK.gtk_file_chooser_get_filenames(dlg);
                        for(int i = 0 ; i&amp;lt; filenames.length ; i++)
                        {
                                
                                System.out.println(&amp;quot;选中文件名&amp;quot;+i+&amp;quot;: &amp;quot;+filenames[i]);
                        }
                        GTK.gtk_widget_destroy(dlg);
                }else
                {
                        GTK.gtk_widget_destroy(dlg);
                }
                return filenames;
        }
        public static void selectFile(int gridHouse,int start) 
        {
                int dlg = GTK.gtk_file_chooser_dialog_new(&amp;quot;打开文件&amp;quot;, 0, GTK.GTK_FILE_CHOOSER_ACTION_OPEN,&amp;quot;打开&amp;quot;);
                GTK.gtk_file_chooser_set_select_multiple(dlg, true);
                
                //创建过滤器
                int filter = GTK.gtk_file_filter_new();
                GTK.gtk_file_filter_add_pattern(filter, &amp;quot;*.jpg&amp;quot;);
                GTK.gtk_file_filter_add_pattern(filter, &amp;quot;*.png&amp;quot;);
                GTK.gtk_file_filter_add_pattern(filter, &amp;quot;*.gif&amp;quot;);
                GTK.gtk_file_filter_set_name(filter, &amp;quot;图片文件&amp;quot;);
                GTK.gtk_file_chooser_add_filter(dlg, filter);
                int ret = GTK.gtk_dialog_run(dlg);
                String[] filenames = null;
                if(ret == GTK.GTK_RESPONSE_OK) 
                {
                        filenames = GTK.gtk_file_chooser_get_filenames(dlg);
                        for(int i = 0 ; i&amp;lt; filenames.length ; i++)
                        {

                                System.out.println(&amp;quot;选中文件名&amp;quot;+i+&amp;quot;: &amp;quot;+filenames[i]);
                                int temp = GTK.gtk_image_new_from_file(filenames[i]);
                                GTK.gtk_grid_attach(gridHouse, temp, i, start, 3, 1);
                                GTK.gtk_widget_show(temp);
                        }
                        GTK.gtk_widget_destroy(dlg);
                }else
                {
                        GTK.gtk_widget_destroy(dlg);
                }

        }
        
        public static void showAllFiles(String[] filenames,int textview)
        {
                for(int i = 0 ; i &amp;lt; filenames.length; i++)
                {
                        showOneFile(filenames[i],textview);
                }
        }
/*        public static void showOneFile(String filename, int textview)
        {
                try
                (
                        InputStream fis = new FileInputStream(filename);
                        
                        BufferedInputStream bis = new BufferedInputStream(fis);
                )
                {
                        int len = 0;
                        byte[] fileToFile = new byte[512*1024];
                        while((len = bis.read(fileToFile))!= -1) // -1读取完毕
                        {
                                //InsertStringToTextViewFunction(textview,fileToFile.toString());
                                InsertStringToTextViewFunction(textview,new String(fileToFile,&amp;quot;gb2312&amp;quot;));
                        }
                }
                catch(IOException e)
                {
                        System.out.println(&amp;quot;文件读入异常&amp;quot;);
                }
                
        }*/
        public static void showOneFile(String filename, int textview)
        {
                try
                (
                        InputStream is = new FileInputStream(filename);
                        InputStreamReader osr = new InputStreamReader(is);
                        BufferedReader br = new BufferedReader(osr);
                )
                {
                        
                        String  temp= filename.substring(filename.lastIndexOf(&#39;\\&#39;)+1);
                        System.out.println(temp);
                        InsertStringToTextViewFunction(textview,&amp;quot;******************\n当期文件为&amp;quot;+filename+&amp;quot;\n******************\n\n&amp;quot;+temp+&amp;quot; 文件内容如下：\n+---------------------------------------------------------------------------+\n&amp;quot;);
                        String content = null;
                        while((content = br.readLine())!=null) // -1读取完毕
                        {
                                //InsertStringToTextViewFunction(textview,fileToFile.toString());
                                InsertStringToTextViewFunction(textview,new String(content));
                        }
                        InsertStringToTextViewFunction(textview,&amp;quot;\n+---------------------------------------------------------------------------+\n******************\n文件&amp;quot;+filename+&amp;quot;读取结束\n******************\n&amp;quot;);
                }
                catch(IOException e)
                {
                        System.out.println(&amp;quot;文件读入异常&amp;quot;);
                }
                
        }
        
        public static void SaveOneFile(String filename, int textview)
        {
                try
                (
                        OutputStream os = new FileOutputStream(filename);
                        OutputStreamWriter osw = new OutputStreamWriter(os);
                        BufferedWriter bw = new BufferedWriter(osw);
                )
                {
                        
                        String  temp= filename.substring(filename.lastIndexOf(&#39;\\&#39;)+1);
                        System.out.println(temp);
                        
                        int textBuffer =  GTK.gtk_text_view_get_buffer(textview);
                        int textIter = GTK.gtk_text_iter_new();  //这是一个空的iter，需要用textBuffer进行赋值
                        GTK.gtk_text_buffer_get_end_iter(textBuffer, textIter);// 或者textview的textBuffer的末尾！
                        String tempText = GTK.gtk_text_buffer_get_text(textBuffer);
                        
                        //while(tempText != null) // -1读取完毕
                        {
                                //InsertStringToTextViewFunction(textview,fileToFile.toString());
                                bw.write(tempText);
                                bw.newLine();
                        //        GTK.gtk_text_iter_backward_char(textIter);
                        //        tempText = GTK.gtk_text_buffer_get_text(textBuffer);
                        }
                }
                catch(IOException e)
                {
                        System.out.println(&amp;quot;文件读入异常&amp;quot;);
                }
                
        }
        public static void createTextView(int window, int gridHouse,int start)
        {
                textview =  GTK.gtk_text_view_new();
                createScrolledBar(window,textview,gridHouse,start);
                //GTK.gtk_text_view_set_wrap_mode(textview,GTK.GTK_WRAP_WORD);
                GTK.gtk_text_view_set_wrap_mode(textview,GTK.GTK_WRAP_WORD_CHAR);
                GTK.gtk_widget_show(textview);
        }
        public static void createScrolledBar(int window, int textview, int gridHouse,int start)
        {
                scrolledBar = GTK.gtk_scrolled_window_new();
                GTK.gtk_widget_show(scrolledBar);
                GTK.gtk_widget_set_size_request(scrolledBar, 200, 200);
                GTK.gtk_grid_attach(gridHouse, scrolledBar, 0, start, 1, 1);
                GTK.gtk_container_add(scrolledBar, textview);
                
        }
        
        //封装了  TextView的迭代器操作。。。
        /**
         * 
         * @param textview  多行文本TextView的标识
         * @param temp      插入TextView 的字符串。
         */
        public static void InsertStringToTextViewFunction(int textview,String temp)
        {
                //TextIter是一个TextView的迭代器。
                int textBuffer =  GTK.gtk_text_view_get_buffer(textview);
                int textIter = GTK.gtk_text_iter_new();  //这是一个空的iter，需要用textBuffer进行赋值
                //GTK.gtk_text_iter_forward_to_end(textIter);
                GTK.gtk_text_buffer_get_end_iter(textBuffer, textIter);// 或者textview的textBuffer的末尾！
                GTK.gtk_text_buffer_insert(textBuffer, textIter, temp);
                
                //GTK.gtk_text_buffer_g
                GTK.gtk_text_iter_free(textIter);
                
        }
        /**
         * 
         * @param textview   TextView的多行文本的标识
         * @return           返回的字符串
         */
        public static String GetStringFromTextViewFunction(int textview)
        {
                //TextIter是一个TextView的迭代器。
                int textBuffer =  GTK.gtk_text_view_get_buffer(textview);
                int textIter = GTK.gtk_text_iter_new();  //这是一个空的iter，需要用textBuffer进行赋值
                GTK.gtk_text_buffer_get_end_iter(textBuffer, textIter);// 或者textview的textBuffer的末尾！
                String temp = GTK.gtk_text_buffer_get_text(textBuffer);
                
                String[] splitArray = temp.split(&amp;quot;\\n&amp;quot;);
                temp = splitArray[splitArray.length-1];
                System.out.println(temp);
                return temp;
                //GTK.gtk_text_buffer_g
                //GTK.gtk_text_iter_free(textIter);
                
        }
        public static boolean showInfo(  String  message,String title)
        {
                int msgDlg = GTK.gtk_message_dialog_new(0, GTK.GTK_DIALOG_DESTROY_WITH_PARENT|
                                GTK.GTK_DIALOG_MODAL,GTK.GTK_MESSAGE_INFO, GTK.GTK_BUTTONS_OK,message);
                GTK.gtk_window_set_title(msgDlg, title);
                int ret = GTK.gtk_dialog_run(msgDlg);
                GTK.gtk_widget_destroy(msgDlg);
                return ret == GTK.GTK_RESPONSE_OK;
        }
        public static void createDialog()
        {
                int dialogApple = GTK.gtk_dialog_new();
                int btnApple = GTK.gtk_button_new_with_label(&amp;quot;幽灵点击&amp;quot;);
                
                //action_are获得一个 类似box,grid的作用，可以添加容器
                int areaDialog = GTK.gtk_dialog_get_action_area(dialogApple);
                GTK.gtk_widget_show(btnApple);
                GTK.gtk_container_add(areaDialog, btnApple);
                
                GTK.g_signal_connect(btnApple, &amp;quot;clicked&amp;quot;, new IGCallBack()
                {
                        @Override
                        public void execute(int instance, int eventData, Object object)
                        {
                                // TODO Auto-generated method stub
                                showInfo(&amp;quot;欣然是不是很美&amp;quot;,&amp;quot;那可不&amp;quot;);
                        }
                }, null);
                
                int ret = GTK.gtk_dialog_run(dialogApple);
                if(ret == GTK.GTK_RESPONSE_OK)
                {
                        System.out.println(&amp;quot;再见&amp;quot;);
                        GTK.gtk_widget_destroy(dialogApple);
                }
                GTK.gtk_widget_destroy(dialogApple);
        }

        //     ********************事件整体处理 区域***************************
        /**
         * 
         * @param btnSin   按钮的标识
         * @param tv1      textview的标识
         */
        public static void insertButtonEvent(final int btnSin,final int tv1)
        {
                GTK.g_signal_connect(btnSin, &amp;quot;clicked&amp;quot;,new IGCallBack()
                {
                        @Override
                        public void execute(int instance, int eventData, Object object)
                        {
                                // TODO 自动生成的方法存根
                                //double sbValue = GTK.gtk_spin_button_get_value(spinbox);
                                String temp = GTK.gtk_button_get_label(btnSin);
                                InsertStringToTextViewFunction(tv1,temp);
                                //isEnter = false;
                        }
                }, null);
        }
        public static void insertButtonEvent(final int btnSin)
        {
                GTK.g_signal_connect(btnSin, &amp;quot;clicked&amp;quot;,new IGCallBack()
                {
                        @Override
                        public void execute(int instance, int eventData, Object object)
                        {
                                // TODO 自动生成的方法存根
                                //double sbValue = GTK.gtk_spin_button_get_value(spinbox);
                                GTK.gtk_widget_show(scrolledBar);
                                GTK.gtk_widget_set_size_request(scrolledBar, 400, 400);
                                String temp = GTK.gtk_button_get_label(btnSin);
                                selectFiles =  selectFile() ;
                                //isEnter = false;
                                showAllFiles(selectFiles, textview);
                        }
                }, null);
        }
        public static void insertButtonSaveEvent(final int btnSin)
        {
                GTK.g_signal_connect(btnSin, &amp;quot;clicked&amp;quot;,new IGCallBack()
                {
                        @Override
                        public void execute(int instance, int eventData, Object object)
                        {
                                // TODO 自动生成的方法存根
                                //double sbValue = GTK.gtk_spin_button_get_value(spinbox);
                                saveFile(textview);
                        }
                }, null);
        }
        public static void insertButtonPictureEvent(final int btnSin)
        {
                GTK.g_signal_connect(btnSin, &amp;quot;clicked&amp;quot;,new IGCallBack()
                {
                        @Override
                        public void execute(int instance, int eventData, Object object)
                        {
                                // TODO 自动生成的方法存根
                                //double sbValue = GTK.gtk_spin_button_get_value(spinbox);
                                GTK.gtk_widget_hide(scrolledBar);
                                selectFile(gridHouse, 2) ;
                        }
                }, null);
        }
        
        public static void insertButtonDialogEvent(final int btnSin)
        {
                GTK.g_signal_connect(btnSin, &amp;quot;clicked&amp;quot;,new IGCallBack()
                {
                        @Override
                        public void execute(int instance, int eventData, Object object)
                        {
                                // TODO 自动生成的方法存根
                                //double sbValue = GTK.gtk_spin_button_get_value(spinbox);
                                createDialog();
                        }
                }, null);
        }

        public static void createToolbar(int gridHouse,int start)
        {
                //创建工具栏容器
                int tbApple = GTK.gtk_toolbar_new();
                GTK.gtk_widget_show(tbApple);
                GTK.gtk_widget_set_size_request(tbApple, 300, 20);
                GTK.gtk_grid_attach(gridHouse, tbApple, 0, start, 1, 1);
                
          int btnNew = GTK.gtk_tool_button_new(0, &amp;quot;新建&amp;quot;);
          GTK.gtk_tool_button_set_stock_id(btnNew, GTK.GTK_STOCK_NEW);
          GTK.gtk_widget_show(btnNew);
          GTK.gtk_toolbar_insert(tbApple, btnNew, 0);
                   
          final int btnOpen = GTK.gtk_tool_button_new(0, &amp;quot;打开&amp;quot;);
          GTK.gtk_tool_button_set_stock_id(btnOpen, GTK.GTK_STOCK_OPEN);
          GTK.gtk_widget_show(btnOpen);
          GTK.gtk_toolbar_insert(tbApple, btnOpen, 1);

          GTK.g_signal_connect(btnOpen, &amp;quot;clicked&amp;quot;,new IGCallBack()
                {
                        @Override
                        public void execute(int instance, int eventData, Object object)
                        {
                                System.out.println(&amp;quot;hello&amp;quot;);
                                // TODO 自动生成的方法存根
                                //double sbValue = GTK.gtk_spin_button_get_value(spinbox);
                                GTK.gtk_widget_show(scrolledBar);
                                GTK.gtk_widget_set_size_request(scrolledBar, 400, 400);
                                //String temp = GTK.gtk_button_get_label(btnOpen);
                                selectFiles =  selectFile() ;
                                //isEnter = false;
                                showAllFiles(selectFiles, textview);
                        }
                }, null);

          int btnSave = GTK.gtk_tool_button_new(0, &amp;quot;保存&amp;quot;);
          GTK.gtk_tool_button_set_stock_id(btnSave, GTK.GTK_STOCK_SAVE);
          GTK.gtk_widget_show(btnSave);
          GTK.gtk_toolbar_insert(tbApple, btnSave, 2);
          GTK.g_signal_connect(btnSave, &amp;quot;clicked&amp;quot;,new IGCallBack()
                {
                        @Override
                        public void execute(int instance, int eventData, Object object)
                        {
                                // TODO 自动生成的方法存根
                                //double sbValue = GTK.gtk_spin_button_get_value(spinbox);
                                saveFile(textview);
                        }
                }, null);
          
          
        }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;treeview 简单的增加用户，调整treeview的样式，未实现删除&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import com.rupeng.gtk4j.GTK;
import com.rupeng.gtk4j.IGCallBack;

/**
* @author    叶昭良
* @time      2015年2月2日下午6:02:11
* @version   TestGTKTreeView V1.0  一个基本的treeview的使用流程  + 字段创建+记录添加
* @version   TestGTKTreeView V2.0  增加了遍历处理 以及显示某行某列的信息
* @version   TestGTKTreeView V3.0  增加了”列控制“ ！！treeview 的某列可显示，可拉伸 ，可排序，可调整
*                                  列控制只是改变treeview的表现，而不会改变liststore的model的内部值
* @version   TestGTKTreeView V4.0  增加了添加记录的功能         
* @version   TestGTKTreeView V5.0  增加了getSelection 进行行操作， 并未取出数据，也并未删除数据                 
*/ 
public class TestGTKTreeView
{

        /**
         * @param args
         */
        static int window;
        static int gridHouse;
        static int liststore;
        static int listiter;
        static boolean columnVisible = false; //用static 变量  不要用final变量。
        static boolean columnResize = true; //用static 变量  不要用final变量。
        static boolean columnRecordable = true; // 设置可拉动
        static int entryID;
        static int entryName;
        static int entryAge;
        static int treeViewApple;
        public static void main(String[] args)
        {
                // TODO Auto-generated method stub
                GTK.gtk_init();
                window = GTK.gtk_window_new(GTK.GTK_WINDOW_TOPLEVEL);
                GTK.gtk_widget_show(window);
                GTK.gtk_window_set_title(window, &amp;quot;TreeView TestVersion&amp;quot;);
                GTK.g_signal_connect(window, &amp;quot;destroy&amp;quot;, new IGCallBack()
                {
                        
                        @Override
                        public void execute(int instance, int eventData, Object object)
                        {
                                // TODO Auto-generated method stub
                                GTK.gtk_main_quit();
                        }
                }, null);
                int start = 0;
                //创建并添加布局
                gridHouse = GTK.gtk_grid_new();
                GTK.gtk_container_add(window, gridHouse);
                GTK.gtk_widget_show(gridHouse);
                //3  treeview   是一个界面，相当于是一个淘宝前台， V  V的作用
                treeViewApple = GTK.gtk_tree_view_new();
                //4 建立字段  比较费劲
                //4.1创建字段
                int columnID = GTK.gtk_tree_view_column_new_with_attributes(&amp;quot;ID&amp;quot;, GTK.gtk_cell_renderer_text_new(), 0);
                //4.2添加字段
                GTK.gtk_tree_view_append_column(treeViewApple, columnID);
                //4.3创建字段
                int columnName = GTK.gtk_tree_view_column_new_with_attributes(&amp;quot;Names&amp;quot;,GTK.gtk_cell_renderer_text_new(),1);
                //4.4添加字段
                GTK.gtk_tree_view_append_column(treeViewApple,columnName);
                //4.5创建字段
                int  columnAge = GTK.gtk_tree_view_column_new_with_attributes(&amp;quot;Ages&amp;quot;,GTK.gtk_cell_renderer_text_new(),2);
                GTK.gtk_tree_view_append_column(treeViewApple,columnAge);
                
                //创建控件
                //1  list_store  是一个数据结构库，相当于一个仓库  M model的作用
                liststore = GTK.gtk_list_store_new(3); //3代表三个字段：ID  Names   Age
        //        GTK.gtk_list_store_append(list_store, iter);
                //2  list_iter,list_iter是一个内部的数据迭代的控制过程，不需要显示 C的作用，控制
                listiter = GTK.gtk_tree_iter_new();

                //5  第五步 把 iter和listStore联系起来
                          //GTK.gtk_text_buffer_get_end_iter 类似于treeview的buffer和iter联系起来
                           // 以后就可以通过GTK.gtk_text_buffer_insert默认是一个一个iter的执行。
                GTK.gtk_list_store_append(liststore, listiter); //指针开始指到第一个位置
                // 6 逐个iter添加数据到liststore当中:每个iter的意思，就是逐行或者逐个记录。
                GTK.gtk_list_store_set_value(liststore, listiter, 0, &amp;quot;001&amp;quot;);
                GTK.gtk_list_store_set_value(liststore, listiter, 1, &amp;quot;YinMuHuaDao&amp;quot;);
                GTK.gtk_list_store_set_value(liststore, listiter, 2, &amp;quot;35&amp;quot;);
                GTK.gtk_list_store_append(liststore, listiter); //如果不加入，指针不下移，只会覆盖掉前面的数据
                GTK.gtk_list_store_set_value(liststore, listiter, 0, &amp;quot;002&amp;quot;);
                GTK.gtk_list_store_set_value(liststore, listiter, 1, &amp;quot;Taiyanghua&amp;quot;);
                GTK.gtk_list_store_set_value(liststore, listiter, 2, &amp;quot;29&amp;quot;);
                GTK.gtk_list_store_append(liststore, listiter);
                GTK.gtk_list_store_set_value(liststore, listiter, 0 ,&amp;quot;003&amp;quot;);
                GTK.gtk_list_store_set_value(liststore, listiter, 1 ,&amp;quot;Xiaojun&amp;quot;);
                GTK.gtk_list_store_set_value(liststore, listiter, 2 ,&amp;quot;10&amp;quot;);
                // 之所以添加9次是因为  3个字段*3条记录 == 9
                
                //7  使用完iter之后一定要记得 关掉它
                GTK.gtk_tree_iter_free(listiter);
                
                //8 关键的一步，把数字显示出来
                GTK.gtk_tree_view_set_model(treeViewApple, liststore);
                
                //并同时把它显示出来，前台必须显示
                GTK.gtk_widget_show(treeViewApple);
                //最后添加到合租房中
                //GTK.gtk_grid_attach(gridHouse, treeViewApple, 0, 1, 3, 3);
                
                
                start = 1;
                createScrolledBar(gridHouse,start,treeViewApple);
                start = 4;
                createPrintButton(gridHouse,start);
                createLabel(gridHouse, start, &amp;quot;ID&amp;quot;);
                //createEntry(entryID, gridHouse, start);
                entryID = GTK.gtk_entry_new();
                GTK.gtk_entry_set_max_length(entryID, 30);
                GTK.gtk_widget_show(entryID);
                GTK.gtk_grid_attach(gridHouse, entryID, 5, start, 1, 1);
                start = 5;
                createShowButton(gridHouse,start,1,1);
                createLabel(gridHouse, start, &amp;quot;名字&amp;quot;);
                //createEntry(entryName, gridHouse, start);
                entryName = GTK.gtk_entry_new();
                GTK.gtk_entry_set_max_length(entryName, 30);
                GTK.gtk_widget_show(entryName);
                GTK.gtk_grid_attach(gridHouse, entryName, 5, start, 1, 1);
                start = 6 ; 
                createHideColumnButton(gridHouse,treeViewApple,start,1);
                createLabel(gridHouse, start, &amp;quot;年龄&amp;quot;);
                //createEntry(entryAge, gridHouse, start);
                entryAge = GTK.gtk_entry_new();
                GTK.gtk_entry_set_max_length(entryAge, 30);
                GTK.gtk_widget_show(entryAge);
                GTK.gtk_grid_attach(gridHouse, entryAge, 5, start, 1, 1);
                start = 7 ; 
                createResizeColumnButton(gridHouse,treeViewApple,start,1);
                createInsertRecordButton(gridHouse,start);
                start = 8;
                createRecoredColumnButton(gridHouse,treeViewApple,start,1);
                start = 9;
                createSortColumnButton(gridHouse,treeViewApple,start,1);
                
                //加入行选择事件
                rowSelection();
                //3
                
                //添加控件
                
                //显示控件
                //GTK.gtk_widget_show(liststore);
                
                //启动循环
                GTK.gtk_main();
        }
        
        /**
         * 
         * @param gridHouse     网格对象布局的标识
         * @param start         网格布局的所处行数
         * @param treeview      treeview的对象标识
         */
        public static void createScrolledBar(int gridHouse,int start,int treeview)
        {
                int scrollbar = GTK.gtk_scrolled_window_new();
                GTK.gtk_container_add(scrollbar, treeview);
                GTK.gtk_widget_set_size_request(scrollbar, 200, 200);
                GTK.gtk_widget_show(scrollbar);
                GTK.gtk_grid_attach(gridHouse, scrollbar, 0, start, 3, 3);
        }
        /**
         * 
         * @param treeView       treeView对象标识
         * @param nth_columns    添加字段到第几列
         * @param column_name    字段的名字
         * @note  一般是一次创建记录
         */
        public static void createColumn(int treeView, int nth_columns, String column_name)
        {
                int temp_column = GTK.gtk_tree_view_column_new_with_attributes(column_name, GTK.gtk_cell_renderer_text_new(), nth_columns);
                GTK.gtk_tree_view_append_column(treeView, temp_column);
        }
        /**
         * 
         * @param ID      记录的ID号
         * @param Names   记录的名字
         * @param Age     记录的年龄
         * @note      需要多次创建记录
         */
        public static void createRecord(String ID, String Names, String Age,int listiter)
        {
                
                GTK.gtk_list_store_append(liststore, listiter); //指针下一继续添加的作用
                //append两个作用 1：添加 2：iter指针下移
                GTK.gtk_list_store_set_value(liststore, listiter, 0, ID);
                GTK.gtk_list_store_set_value(liststore, listiter, 1, Names);
                GTK.gtk_list_store_set_value(liststore, listiter, 2, Age);
                
        }
        
        public static void printRecord(int liststore)
        {
                //必须新建，不能利用原先的listiter,哪边需要用控制，就需要建一个控件。！！！否则报错！！不能用全局的 listiter
                int iter = GTK.gtk_tree_iter_new();
/*                if(GTK.gtk_tree_model_get_iter_first(liststore, listiter))
                {
                        do
                        {
                                String ID = GTK.gtk_tree_model_get_value(liststore, listiter, 0);
                                String Names = GTK.gtk_tree_model_get_value(liststore, listiter, 1);
                                String Ages = GTK.gtk_tree_model_get_value(liststore, listiter, 2);
                                //showInfo(&amp;quot;这个员工的ID是&amp;quot;+ID+&amp;quot;,他的名字是&amp;quot;+Names+&amp;quot;,并且它的年龄是&amp;quot;+Ages,&amp;quot;显示员工信息&amp;quot;);
                                System.out.println(&amp;quot;这个员工的ID是&amp;quot;+ID+&amp;quot;,他的名字是&amp;quot;+Names+&amp;quot;,并且它的年龄是&amp;quot;+Ages);
                                
                        }while(GTK.gtk_tree_model_iter_next(liststore,listiter));
                }else
                {
                        System.out.println(&amp;quot;表中无数据&amp;quot;);
                }*/
                // 减少代码的深度。
                if(!GTK.gtk_tree_model_get_iter_first(liststore, iter))
                {
                        System.out.println(&amp;quot;treeview没有数据  请添加记录&amp;quot;);
                        return;
                }
                do
                {
                        String ID = GTK.gtk_tree_model_get_value(liststore, iter, 0);
                        String Names = GTK.gtk_tree_model_get_value(liststore, iter, 1);
                        String Ages = GTK.gtk_tree_model_get_value(liststore, iter, 2);
                        //showInfo(&amp;quot;这个员工的ID是&amp;quot;+ID+&amp;quot;,他的名字是&amp;quot;+Names+&amp;quot;,并且它的年龄是&amp;quot;+Ages,&amp;quot;显示员工信息&amp;quot;);
                        System.out.println(&amp;quot;这个员工的ID是&amp;quot;+ID+&amp;quot;,他的名字是&amp;quot;+Names+&amp;quot;,并且它的年龄是&amp;quot;+Ages);
                        
                }while(GTK.gtk_tree_model_iter_next(liststore,iter));
                
                GTK.gtk_tree_iter_free(iter);//释放了 还是有错误。。。
        }
        
        public static void showInfo(  String  message,String title)
        {
                int msgDlg = GTK.gtk_message_dialog_new(0, GTK.GTK_DIALOG_DESTROY_WITH_PARENT|
                                GTK.GTK_DIALOG_MODAL,GTK.GTK_MESSAGE_INFO, GTK.GTK_BUTTONS_OK,message);
                GTK.gtk_window_set_title(msgDlg, title);
                int ret = GTK.gtk_dialog_run(msgDlg);
                 
                if( ret == GTK.GTK_RESPONSE_OK)
                {
                        GTK.gtk_widget_destroy(msgDlg);
                }else
                {
                        GTK.gtk_widget_destroy(msgDlg);
                }

        }
        public static boolean showWarning(  String  message,String title)
        {
                int msgDlg = GTK.gtk_message_dialog_new(0, GTK.GTK_DIALOG_DESTROY_WITH_PARENT|
                                GTK.GTK_DIALOG_MODAL,GTK.GTK_MESSAGE_WARNING, GTK.GTK_BUTTONS_OK,message);
                GTK.gtk_window_set_title(msgDlg, title);
                int ret = GTK.gtk_dialog_run(msgDlg);
                GTK.gtk_widget_destroy(msgDlg);
                return ret == GTK.GTK_RESPONSE_OK;
        }
        public static void createPrintButton(int gridHouse,int start)
        {
                int btnApple = GTK.gtk_button_new_with_label(&amp;quot;遍历&amp;quot;);
                GTK.gtk_widget_show(btnApple);
                GTK.gtk_grid_attach(gridHouse, btnApple, 0, start, 1, 1);
                insertButtonEvent(btnApple);
        }
        public static void createShowButton(int gridHouse,int start,int row, int column)
        {
                int btnApple = GTK.gtk_button_new_with_label(&amp;quot;获取表第&amp;quot;+row+&amp;quot;行&amp;quot;+&amp;quot;第&amp;quot;+column+&amp;quot;列&amp;quot;);
                GTK.gtk_widget_show(btnApple);
                GTK.gtk_grid_attach(gridHouse, btnApple, 0, start, 1, 1);
                insertShowEvent(btnApple,row,column);
        }
        public static void createHideColumnButton(int gridHouse,int treeViewApple,int start,int nthcolumn)
        {
                int btnApple = GTK.gtk_button_new_with_label(&amp;quot;隐藏|显示第&amp;quot;+nthcolumn+&amp;quot;列&amp;quot;);
                GTK.gtk_widget_show(btnApple);
                GTK.gtk_grid_attach(gridHouse, btnApple, 0, start, 1, 1);
                insertHideEvent(treeViewApple, btnApple, nthcolumn);
        }
        
        public static void createResizeColumnButton(int gridHouse,int treeViewApple,int start,int nthcolumn)
        {
                int btnApple = GTK.gtk_button_new_with_label(&amp;quot;赋予第&amp;quot;+nthcolumn+&amp;quot;列可调整大小的权限&amp;quot;);
                GTK.gtk_widget_show(btnApple);
                GTK.gtk_grid_attach(gridHouse, btnApple, 0, start, 1, 1);
                insertResizeEvent(treeViewApple, btnApple, nthcolumn);
        }
        public static void createRecoredColumnButton(int gridHouse,int treeViewApple,int start,int nthcolumn)
        {
                int btnApple = GTK.gtk_button_new_with_label(&amp;quot;赋予第&amp;quot;+nthcolumn+&amp;quot;列可移动的权限&amp;quot;);
                GTK.gtk_widget_show(btnApple);
                GTK.gtk_grid_attach(gridHouse, btnApple, 0, start, 1, 1);
                insertRecordableEvent(treeViewApple, btnApple, nthcolumn);
        }
        public static void createSortColumnButton(int gridHouse,int treeViewApple,int start,int nthcolumn)
        {
                int btnApple = GTK.gtk_button_new_with_label(&amp;quot;赋予第&amp;quot;+nthcolumn+&amp;quot;列可排序的权限&amp;quot;);
                GTK.gtk_widget_show(btnApple);
                GTK.gtk_grid_attach(gridHouse, btnApple, 0, start, 1, 1);
                insertSortEvent(treeViewApple, btnApple, nthcolumn);
        }
        public static void createInsertRecordButton(int gridHouse,int start)
        {
                int btnApple = GTK.gtk_button_new_with_label(&amp;quot;插入数据&amp;quot;);
                GTK.gtk_widget_show(btnApple);
                GTK.gtk_grid_attach(gridHouse, btnApple, 5, start, 1, 1);
                insertRecordEvent(btnApple);
        }
        public static void createLabel(int gridHouse, int start,String labelName)
        {
                int labelApple = GTK.gtk_label_new(labelName);
                GTK.gtk_widget_show(labelApple);
                GTK.gtk_grid_attach(gridHouse, labelApple, 4, start, 1, 1);
                
        }
        public static void createEntry(int entryApple,int gridHouse, int start)
        {
                entryApple = GTK.gtk_entry_new();
                GTK.gtk_entry_set_max_length(entryApple, 30);
                GTK.gtk_widget_show(entryApple);
                GTK.gtk_grid_attach(gridHouse, entryApple, 5, start, 1, 1);
        }
        public static void insertButtonEvent(final int btnSin)
        {
                GTK.g_signal_connect(btnSin, &amp;quot;clicked&amp;quot;,new IGCallBack()
                {
                        @Override
                        public void execute(int instance, int eventData, Object object)
                        {
                                // TODO 自动生成的方法存根
                                //double sbValue = GTK.gtk_spin_button_get_value(spinbox);
                                printRecord(liststore);
                        }
                }, null);
        }
        public static void insertShowEvent(final int btnSin,final int row, final int column)
        {
                GTK.g_signal_connect(btnSin, &amp;quot;clicked&amp;quot;,new IGCallBack()
                {
                        @Override
                        public void execute(int instance, int eventData, Object object)
                        {
                                // TODO 自动生成的方法存根
                                //double sbValue = GTK.gtk_spin_button_get_value(spinbox);
                                showColumnRow(row,column);
                        }
                }, null);
        }
        public static void insertHideEvent(final int treeViewApple,final int btnSin, final int nthcolumn)
        {
                //final boolean columnVisible = true;
                GTK.g_signal_connect(btnSin, &amp;quot;clicked&amp;quot;,new IGCallBack()
                {
                        
                        @Override
                        public void execute(int instance, int eventData, Object object)
                        {
                                // TODO 自动生成的方法存根
                                //double sbValue = GTK.gtk_spin_button_get_value(spinbox);
                                tree_view_column_set_hide(treeViewApple,nthcolumn,columnVisible);
                                columnVisible = !columnVisible;
                        }
                }, null);
        }
        public static void insertResizeEvent(final int treeViewApple,final int btnSin, final int nthcolumn)
        {
                //final boolean columnVisible = true;
                GTK.g_signal_connect(btnSin, &amp;quot;clicked&amp;quot;,new IGCallBack()
                {
                        
                        @Override
                        public void execute(int instance, int eventData, Object object)
                        {
                                // TODO 自动生成的方法存根
                                //double sbValue = GTK.gtk_spin_button_get_value(spinbox);
                                tree_view_column_resize(treeViewApple,nthcolumn,columnResize);
                                columnResize = !columnResize;
                        }
                }, null);
        }
        
        public static void insertRecordableEvent(final int treeViewApple,final int btnSin, final int nthcolumn)
        {
                //final boolean columnVisible = true;
                GTK.g_signal_connect(btnSin, &amp;quot;clicked&amp;quot;,new IGCallBack()
                {
                        
                        @Override
                        public void execute(int instance, int eventData, Object object)
                        {
                                // TODO 自动生成的方法存根
                                //double sbValue = GTK.gtk_spin_button_get_value(spinbox);
                                tree_view_column_recordabel(treeViewApple,nthcolumn,columnRecordable);
                                columnRecordable = !columnRecordable;
                        }
                }, null);
        }
        public static void insertSortEvent(final int treeViewApple,final int btnSin, final int nthcolumn)
        {
                //final boolean columnVisible = true;
                GTK.g_signal_connect(btnSin, &amp;quot;clicked&amp;quot;,new IGCallBack()
                {
                        
                        @Override
                        public void execute(int instance, int eventData, Object object)
                        {
                                // TODO 自动生成的方法存根
                                //double sbValue = GTK.gtk_spin_button_get_value(spinbox);
                                tree_view_column_sort(treeViewApple,nthcolumn,1);
                                //columnRecordable = !columnRecordable;
                        }
                }, null);
        }
        public static void insertRecordEvent(final int btnSin)
        {
                //final boolean columnVisible = true;
                GTK.g_signal_connect(btnSin, &amp;quot;clicked&amp;quot;,new IGCallBack()
                {
                        
                        @Override
                        public void execute(int instance, int eventData, Object object)
                        {
                                String ID = GTK.gtk_entry_get_text(entryID);
                                System.out.println(ID);
                                if(ID.equalsIgnoreCase(&amp;quot;&amp;quot;))
                                {
                                        showWarning(&amp;quot;ID为空，请重新输入&amp;quot;,&amp;quot;警告&amp;quot;);
                                        return;
                                }
                                String Name = GTK.gtk_entry_get_text(entryName);
                                if(Name.equalsIgnoreCase(&amp;quot;&amp;quot;))
                                {
                                        showWarning(&amp;quot;Name为空，请重新输入&amp;quot;,&amp;quot;警告&amp;quot;);
                                        return;
                                }
                                String Age = GTK.gtk_entry_get_text(entryAge);
                                if(Age.equalsIgnoreCase(&amp;quot;&amp;quot;))
                                {
                                        showWarning(&amp;quot;Age为空，请重新输入&amp;quot;,&amp;quot;警告&amp;quot;);
                                        return;
                                }
                                insertRecord(ID,Name, Age, treeViewApple);
                                 
                                
                        }
                }, null);
        }
        public static void insertRecord(String ID,String Name,String Age,int treeViewApple)
        {
                int iter = GTK.gtk_text_iter_new();
                if(!GTK.gtk_tree_model_get_iter_first(liststore, iter))
                {
                        createRecord( ID,  Name,  Age,iter);
                }
                else
                {
                        do
                        {
                                //System.out.println(&amp;quot;hello&amp;quot;);
                        }while(GTK.gtk_tree_model_iter_next(liststore, iter));
                        //while(GTK.gtk_tree_model_iter_next(liststore, iter)); 
                        // 记一次调bug经理，，经常把iter_next写成了 iter_first导致不断的循环
                        //出现无限循环，最后嵌入 system打印出来即可。
                        createRecord( ID,  Name,  Age,iter);
                }
                GTK.gtk_text_iter_free(iter);
                GTK.gtk_tree_view_set_model(treeViewApple, liststore);
        }
        public static void showColumnRow(int row, int column)
        {
                int i = 0;
                if(0 == getNumberOfListstore(liststore))
                {
                        System.out.println(&amp;quot;100块都不给 还想查！&amp;quot;);
                        return ;
                }
                if(row &amp;gt; getNumberOfListstore(liststore))
                {
                        System.out.println(&amp;quot;记录数没有！  请重新查询&amp;quot;);
                        return;
                }
                int iter  = GTK.gtk_tree_iter_new();
                GTK.gtk_tree_model_get_iter_first(liststore, iter);
                do
                {
                        if(i == row)
                        {
                                String temp = GTK.gtk_tree_model_get_value(liststore, iter, column);
                                System.out.println(temp);
                                showInfo(temp,&amp;quot;显示信息&amp;quot;);
                                return;
                        }
                        i++;
                }while(GTK.gtk_tree_model_iter_next(liststore, iter));
                
        }
        public static int getNumberOfListstore(int liststore)
        {
                int sum = 0;
                int iter = GTK.gtk_tree_iter_new();
                if(!GTK.gtk_tree_model_get_iter_first(liststore, iter))
                {
                        return sum;
                }
                do
                {
                        sum++;
                }while(GTK.gtk_tree_model_iter_next(liststore, iter));
                return sum;
        }
        
        public static void tree_view_column_set_hide(int treeViewApple,int nthColumn,boolean visible)
        {
                int column =GTK.gtk_tree_view_get_column(treeViewApple, nthColumn);
                GTK.gtk_tree_view_column_set_visible(column, visible);
        }
        public static void tree_view_column_resize(int treeViewApple,int nthColumn,boolean visible)
        {
                int column =GTK.gtk_tree_view_get_column(treeViewApple, nthColumn);
                GTK.gtk_tree_view_column_set_resizable(column, visible);
        }
        public static void tree_view_column_recordabel(int treeViewApple,int nthColumn,boolean visible)
        {
                int column =GTK.gtk_tree_view_get_column(treeViewApple, nthColumn);
                GTK.gtk_tree_view_column_set_reorderable(column, visible);
        }
        public static void tree_view_column_sort(int treeViewApple,int nthColumn,int sortcolumnid)
        {
                int column =GTK.gtk_tree_view_get_column(treeViewApple, nthColumn);
                GTK.gtk_tree_view_column_set_sort_column_id(column, sortcolumnid);
        }
        
        public static void rowSelection()
        {
                int selection = GTK.gtk_tree_view_get_selection(treeViewApple);
                GTK.gtk_tree_selection_set_mode(selection, GTK.GTK_SELECTION_MULTIPLE);
                GTK.g_signal_connect(treeViewApple, &amp;quot;button-press-event&amp;quot;, new IGCallBack()
                { 
                 @Override
                 public void execute(int instance, int eventData, Object object)
                 {
                  if(GTK.gdk_event_get_type(eventData)==GTK.GDK_2BUTTON_PRESS)
                  {
                   int[] indices = GTK.gtk_tree_view_get_selection_indices(treeViewApple);
                   System.out.println(indices[0]);
                  }
                 }
                }, null);
        }
        
/*        public static void deleteOneRecore()
        {
                int selection = GTK.gtk_tree_view_get_selection(treeViewApple);
                
        }*/
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;case3 工具栏+进度条+menu+statusIcon+开关按钮+calendar&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import com.rupeng.gtk4j.GTK;
import com.rupeng.gtk4j.IGCallBack;

/**
* @author    叶昭良
* @time      2015年2月3日上午1:24:01
* @version   TestToolBar V1.0
* @version   TestToolBar V2.0  增加了一个日历控件,添加了天数变化时间和双击时间
* @version   TestToolBar V2.0  增加了进度条的创建，和按钮事件 控制进度条
* @version   TestToolBar V4.0  建议的开关按钮，未实现信号的接受。。。
* @version   TestToolBar V5.0  增加了一个菜单控件
* @version   TestToolBar V6.0  增加了一个StatusIcon的简单控件        
*/
public class TestToolBar
{

        /**
         * @param args
         */
        static int window;
        static int gridHouse;
        static double progress = 0.0;
        public static void main(String[] args)
        {
                // TODO Auto-generated method stub
                GTK.gtk_init();
                window= GTK.gtk_window_new(GTK.GTK_WINDOW_TOPLEVEL);
                GTK.gtk_widget_show(window);
                GTK.g_signal_connect(window, &amp;quot;destroy&amp;quot;, new IGCallBack()
                {
                        
                        @Override
                        public void execute(int instance, int eventData, Object object)
                        {
                                // TODO Auto-generated method stub
                                GTK.gtk_main_quit();
                        }
                }, null);
                
                //设置网格布局
                gridHouse = GTK.gtk_grid_new();
                GTK.gtk_widget_show(gridHouse);
                GTK.gtk_container_add(window, gridHouse);
                
                //定义一些常用的控件
                int start = 0;
                createToolbar(gridHouse,start);
                start =1;
                createCalendar(gridHouse,start);
                start = 2;
                createProgressBar(gridHouse, start);
                start = 3;
                createSwitchOn(gridHouse, start);
                start = 4;
                createMenu(gridHouse,start);
                start = 5;
                createStatusIcon(gridHouse,start);
                //启动循环
                GTK.gtk_main();
        }
        
        public static void createToolbar(int gridHouse,int start)
        {
                //创建工具栏容器
                int tbApple = GTK.gtk_toolbar_new();
                GTK.gtk_widget_show(tbApple);
                GTK.gtk_widget_set_size_request(tbApple, 300, 20);
                GTK.gtk_grid_attach(gridHouse, tbApple, 0, start, 1, 1);
                
          int btnNew = GTK.gtk_tool_button_new(0, &amp;quot;新建&amp;quot;);
          GTK.gtk_tool_button_set_stock_id(btnNew, GTK.GTK_STOCK_NEW);
          GTK.gtk_widget_show(btnNew);
          GTK.gtk_toolbar_insert(tbApple, btnNew, 0);
                   
          int btnOpen = GTK.gtk_tool_button_new(0, &amp;quot;打开&amp;quot;);
          GTK.gtk_tool_button_set_stock_id(btnOpen, GTK.GTK_STOCK_OPEN);
          GTK.gtk_widget_show(btnOpen);
          GTK.gtk_toolbar_insert(tbApple, btnOpen, 1);
          
          int btnSave = GTK.gtk_tool_button_new(0, &amp;quot;保存&amp;quot;);
          GTK.gtk_tool_button_set_stock_id(btnSave, GTK.GTK_STOCK_SAVE);
          GTK.gtk_widget_show(btnSave);
          GTK.gtk_toolbar_insert(tbApple, btnSave, 2);
        }
        
        public static void createCalendar(int gridHouse, int start) 
        {
                final int clApple = GTK.gtk_calendar_new();
                int labelApple = GTK.gtk_label_new(&amp;quot;&amp;quot;);
                GTK.gtk_widget_show(clApple);
                GTK.gtk_widget_show(labelApple);
                GTK.gtk_grid_attach(gridHouse, clApple, 0, start, 1, 1);
                GTK.gtk_grid_attach(gridHouse, clApple, 1, start, 1, 1);
                GTK.gtk_widget_set_size_request(clApple, 200, 200);
                
                GTK.g_signal_connect(clApple, &amp;quot;day-selected&amp;quot;, new IGCallBack()
                {
                        
                        @Override
                        public void execute(int instance, int eventData, Object object)
                        {
                                // TODO Auto-generated method stub
                                int day = GTK.gtk_calendar_get_day(clApple);
                                int month = GTK.gtk_calendar_get_month(clApple);
                                int year = GTK.gtk_calendar_get_year(clApple);
                                System.out.println(&amp;quot;用户选择了&amp;quot;+year+&amp;quot;年&amp;quot;+month+&amp;quot;月&amp;quot;+day+&amp;quot;日&amp;quot;);
                                //showInfo(&amp;quot;用户选择了&amp;quot;+year+&amp;quot;年&amp;quot;+month+&amp;quot;月&amp;quot;+day+&amp;quot;日&amp;quot;,&amp;quot;选择的日期&amp;quot;);
                        }
                }, null);
                GTK.g_signal_connect(clApple, &amp;quot;day-selected-double-click&amp;quot;, new IGCallBack()
                {
                        
                        @Override
                        public void execute(int instance, int eventData, Object object)
                        {
                                // TODO Auto-generated method stub
                                int day = GTK.gtk_calendar_get_day(clApple);
                                int month = GTK.gtk_calendar_get_month(clApple);
                                int year = GTK.gtk_calendar_get_year(clApple);
                                showInfo(&amp;quot;用户选择了&amp;quot;+year+&amp;quot;年&amp;quot;+month+&amp;quot;月&amp;quot;+day+&amp;quot;日&amp;quot;,&amp;quot;选择的日期&amp;quot;);
                        }
                }, null);
        }
        public static boolean showInfo(  String  message,String title)
        {
                int msgDlg = GTK.gtk_message_dialog_new(0, GTK.GTK_DIALOG_DESTROY_WITH_PARENT|
                                GTK.GTK_DIALOG_MODAL,GTK.GTK_MESSAGE_INFO, GTK.GTK_BUTTONS_OK,message);
                GTK.gtk_window_set_title(msgDlg, title);
                int ret = GTK.gtk_dialog_run(msgDlg);
                GTK.gtk_widget_destroy(msgDlg);
                return ret == GTK.GTK_RESPONSE_OK;
        }
        
        public static void createProgressBar(int gridHouse,int start)
        {
                final int pbApple =GTK.gtk_progress_bar_new();
                int btnApple =GTK.gtk_button_new_with_label(&amp;quot;加快进度&amp;quot;);
                GTK.gtk_widget_show(btnApple);
                GTK.gtk_widget_show(pbApple);
                GTK.gtk_grid_attach(gridHouse, pbApple, 0, start, 1, 1);
                GTK.gtk_grid_attach(gridHouse, btnApple, 1, start, 1, 1);
                
                GTK.gtk_progress_bar_set_fraction(pbApple, progress);
                        //GTK.gtk_progress_bar_set_pulse_step()
/*                        try
                        {
                                Thread.sleep(1000);
                        } catch (InterruptedException e)
                        {
                                // TODO Auto-generated catch block
                                e.printStackTrace();
                        }*/
                GTK.g_signal_connect(btnApple, &amp;quot;clicked&amp;quot;, new IGCallBack() 
                {
                        @Override
                        public void execute(int instance, int eventData, Object object)
                        {
                                // TODO Auto-generated method stub
                                if(progress &amp;lt;= 1.0)
                                {
                                        progress = progress + 0.2;
                                        GTK.gtk_progress_bar_set_fraction(pbApple, progress);
                                }else
                                {
                                        System.out.println(&amp;quot;stop clicked&amp;quot;);
                                }
                                
                        }
                }, null);
                
                GTK.gtk_progress_bar_set_text(pbApple, &amp;quot;请稍后&amp;quot;);
        }
        
        public static void createSwitchOn(int gridHouse, int start)
        {
                final int switchOff = GTK.gtk_switch_new();
                final int label = GTK.gtk_label_new(&amp;quot;&amp;quot;);
                GTK.gtk_widget_show(switchOff);
                GTK.gtk_widget_show(label);
                GTK.gtk_grid_attach(gridHouse, switchOff, 0, start, 1, 1);
                GTK.gtk_grid_attach(gridHouse, label, 1, start, 1, 1);
                GTK.gtk_switch_set_active(switchOff, true);
                //GTK.g_signal_connect(switchOff, &amp;quot;state-set&amp;quot;, new IGCallBack()
                
                GTK.g_signal_connect(switchOff, &amp;quot;activate&amp;quot;, new IGCallBack()
                {
                        
                        @Override
                        public void execute(int instance, int eventData, Object object)
                        {
                                // TODO Auto-generated method stub
                                System.out.println(&amp;quot;hello&amp;quot;);
                                        if(GTK.gtk_switch_get_active(switchOff))
                                        {
                                                //GTK.gtk_label_set_text(label, &amp;quot;你打开了&amp;quot;);
                                                System.out.println(&amp;quot;hello&amp;quot;);
                                        }
                                        else
                                        {
                                                //GTK.gtk_label_set_text(label, &amp;quot;你关闭了&amp;quot;);
                                                System.out.println(&amp;quot;fuck&amp;quot;);
                                        }
                        }
                }, null);

        }
        public static void createMenu(int gridHouse, int start)
        {
                //分三步
                //1创建单一菜单
                //2创建一个菜单头
                //3创建总的菜单条，把许多菜单头都挂到菜单条上
                //创建一个菜单
                int menu = GTK.gtk_menu_new();
                
                int file = GTK.gtk_menu_item_new_with_label(&amp;quot;_F文件&amp;quot;);
                int new1  = GTK.gtk_menu_item_new_with_label(&amp;quot;新建&amp;quot;);
                int open1 = GTK.gtk_menu_item_new_with_label(&amp;quot;打开&amp;quot;);
                int closed = GTK.gtk_menu_item_new_with_label(&amp;quot;关闭&amp;quot;);
                int import1 = GTK.gtk_menu_item_new_with_mnemonic(&amp;quot;_Import导入&amp;quot;);
                //int image = GTK.gtk_menu_tool_button_new_from_stock(GTK.GTK_STOCK_NEW);
                //fengexian 
                GTK.gtk_widget_show(menu);
                GTK.gtk_widget_show(new1);
                GTK.gtk_widget_show(open1);
                GTK.gtk_widget_show(closed);
                GTK.gtk_widget_show(file);
                GTK.gtk_widget_show(import1);
                
                GTK.gtk_menu_shell_append(menu, file);
                GTK.gtk_menu_shell_append(menu, new1);
                GTK.gtk_menu_shell_append(menu, open1);
                GTK.gtk_menu_shell_append(menu, closed);
                GTK.gtk_menu_shell_append(menu, import1);
                // 菜单条
                int menubar = GTK.gtk_menu_bar_new();
                GTK.gtk_widget_show(menubar);
                GTK.gtk_grid_attach(gridHouse, menubar, 0, start, 1, 1);
                
                //2 添加一个menu 到menu小头
                int file_item =  GTK.gtk_menu_item_new_with_label(&amp;quot;File&amp;quot;);
                GTK.gtk_widget_show(file_item);
                GTK.gtk_menu_item_set_submenu(file_item, menu);
                
                //3 添加一个 menu小头到menubar
                GTK.gtk_menu_shell_append(menubar, file_item);
//                GTK.gtk_menu_attach_to_widget(menubar, attach_widget);
                GTK.g_signal_connect(closed, &amp;quot;activate&amp;quot;,new IGCallBack(){
                                @Override
                                public void execute(int instance, int eventData, Object object)
                                {
                                        // TODO Auto-generated method stub
                                        GTK.gtk_main_quit();
                                }
                        }, null);
                }
        
        public static void createStatusIcon(int gridHouse,int start)
        {
                int status = GTK.gtk_status_icon_new();
                //GTK.gtk_widget_show(status);
                //GTK.gtk_grid_attach(gridHouse, status, 0, status, 1, 1);
                GTK.gtk_status_icon_set_from_stock(status, GTK.GTK_STOCK_CONNECT);
                GTK.gtk_status_icon_set_tooltip_text(status, &amp;quot;hello&amp;quot;); //的确是会显示在下方
                GTK.gtk_status_icon_set_visible(status, true);
                
                GTK.g_signal_connect(status, &amp;quot;popup-menu&amp;quot;, new IGCallBack() {
                        @Override
                        public void execute(int instance, int eventData, Object object)
                        {
                                // TODO Auto-generated method stub
/*                                int menu = GTK.gtk_menu_new();
                                
                                int file = GTK.gtk_menu_item_new_with_label(&amp;quot;_F文件&amp;quot;);
                                int new1  = GTK.gtk_menu_item_new_with_label(&amp;quot;新建&amp;quot;);
                                int open1 = GTK.gtk_menu_item_new_with_label(&amp;quot;打开&amp;quot;);
                                int closed = GTK.gtk_menu_item_new_with_label(&amp;quot;关闭&amp;quot;);
                                int import1 = GTK.gtk_menu_item_new_with_mnemonic(&amp;quot;_Import导入&amp;quot;);
                                //int image = GTK.gtk_menu_tool_button_new_from_stock(GTK.GTK_STOCK_NEW);
                                //fengexian 
                                GTK.gtk_widget_show(menu);
                                GTK.gtk_widget_show(new1);
                                GTK.gtk_widget_show(open1);
                                GTK.gtk_widget_show(closed);
                                GTK.gtk_widget_show(file);
                                GTK.gtk_widget_show(import1);
                                
                                GTK.gtk_menu_shell_append(menu, file);
                                GTK.gtk_menu_shell_append(menu, new1);
                                GTK.gtk_menu_shell_append(menu, open1);
                                GTK.gtk_menu_shell_append(menu, closed);
                                GTK.gtk_menu_shell_append(menu, import1);
                                GTK.gtk_menu_popup(menu);*/
                                showInfo(&amp;quot;hello&amp;quot;,&amp;quot;wenho&amp;quot;);
                        }
                }, null);
/*                GTK.g_signal_connect(status, &amp;quot;statusIconActivate&amp;quot;, new IGCallBack() {
                        @Override
                        public void execute(int instance, int eventData, Object object)
                        {
                                showInfo(&amp;quot;hello&amp;quot;,&amp;quot;wenho&amp;quot;);
                          
                        }},null);*/
        
        }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://jueqingsizhe66.github.io/images/java/MVC.gif&#34; alt=&#34;MVC交互图&#34; /&gt;
&lt;img src=&#34;https://jueqingsizhe66.github.io/images/java/jianyijishi.gif&#34; alt=&#34;简易记事本+工具栏&#34; /&gt;
&lt;img src=&#34;https://jueqingsizhe66.github.io/images/java/yang.gif&#34; alt=&#34;工具栏+menu+statusICON+prograssBar+switchOFF+calendar&#34; /&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>2月27日Java周末班试题</title>
      <link>https://jueqingsizhe66.github.io/blog/2015/05/11/2yue-27ri-javazhou-mo-ban-shi-ti/</link>
      <pubDate>Mon, 11 May 2015 14:58:41 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/blog/2015/05/11/2yue-27ri-javazhou-mo-ban-shi-ti/</guid>
      <description>&lt;p&gt;0105班Java周末班试题（JDBC 9-16）
阶段性考试（考试6个小时，讲评+重写6个小时）：
记录完成每个题所需要的时长。
第一题、SQL题
表格见图片附件
题目：编写SQL语句完成下面的功能：
条件查询：
1. 在GRADE表中查找80-90份的学生学号和分数
2. 在GRADE 表中查找课程编号为003学生的平均分
3. 在GRADE 表中查询学习各门课程的人数
4. 查询所有姓张的学生的学号和姓名
5. 查询分数在80-90分的学生的学号、姓名、分数
6. 查询学习了’C语言’课程的学生学号、姓名和分数
第二题
不参考、不对照任何老师、同学的代码编写JDBCUtils。并记录写完需要的时间。
第三题
编写手机号码查询归属地案例。并记录写完需要的时间&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;第一题表格.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;考试未通过，中途出去，fail;&lt;/p&gt;

&lt;p&gt;第一题：
费时：4个小时左右
表设计阶段：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;;;;创建一个考试数据库
create database exam;  
use exam;
````



错误分析： 
curriculum是一个基础表！ 连接grade表！Grade表连接student_info表 ，认为student_info存在外键
经过折腾：认为student_info没有外键，而grade表存在两个外键



Curriculum 表的设计：
curriculum_no 课程编号 :

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mysql
    varchar(20)not null auto_increment primary key,
    ;;后来思考 int改变为varchar(20)因为也许会出现非数字
corriculum_name课程名称   varchar(20) not null default ‘’
Credit学分 ： real(5,2) not null default 0.0&lt;br /&gt;
    ;;;(real默认是double类型)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
其间遇到无法显示汉字的情况：
1：数据库级别修改
修改数据库级别，命令如下：use edu(换成你要修改的数据库名，在这里我的数据库为edu),，然后执行命令：
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mysql
alter database exam character set utf-8;
或者
SET NAMES &amp;lsquo;utf8&amp;rsquo;;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
2：数据表级别的修改
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mysql
ALTER TABLE table_name DEFAULT CHARSET utf8;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;3: 发现经过这两个大小修改还是不行,于是也对字段进行修改
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mysql
alter table curriculum modify curriculum_no varchar(20) character set utf8
alter table curriculum modify curriculum_name varchar(20) character set utf8;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;但是依然不行！！说明之前插入的只好清空，再插入一遍， 然后就可以了



grade表的设计：


此表的设计一波三折，在添加外键的时候多次出现错误，下面先给出错误的，再列出正确的添加方式


错误分析表：
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mysql
stu_no 学号：  varchar(20) not null auto_increment primary key,
  ;;后来思考 int改变为varchar(20)因为也许会出现非数字
课程编号  curriculum_no : int not null, foreign key(curriculum_no) references Curriculum&lt;/p&gt;

&lt;p&gt;(Curriculum_no) on delete restrict on update cascade
Score 分数 :    real(5,2) not null default 0.0&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;外键知识：
1.MYSQL在建外键后,会自动建一个同名的索引,引入外键的缺点是会使速度和性能下降

在创建表的时候添加外键：
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mysql
create table grade(
   stu_no varchar(20) not null default &amp;ldquo;,
    curriculum varchar(20) not null default &amp;ldquo;,constraint hello foreign key
     (curriculum) references curriculum(curriculum_no) on delete restrict
     on update cascade,
    stu_score real(5,2) not null default 0.00);&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
在创建表后天添加外键：
添加一个叫hello的外键：
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mysql
alter table grade add constraint hello foreign key(stu_curriculum_no) ref
erences curriculum(curriculum_no) on delete restrict on update cascade;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
查看grade表信息：
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mysql
| grade | CREATE TABLE &lt;code&gt;grade&lt;/code&gt; (
  &lt;code&gt;stu_no&lt;/code&gt; varchar(20) NOT NULL,
  &lt;code&gt;stu_curriculum_no&lt;/code&gt; varchar(20) NOT NULL DEFAULT &amp;ldquo;,
  &lt;code&gt;stu_score&lt;/code&gt; double(5,2) NOT NULL DEFAULT &amp;lsquo;0.00&amp;rsquo;,
  PRIMARY KEY (&lt;code&gt;stu_no&lt;/code&gt;),
  KEY &lt;code&gt;hello&lt;/code&gt; (&lt;code&gt;stu_curriculum_no&lt;/code&gt;),
  CONSTRAINT &lt;code&gt;hello&lt;/code&gt; FOREIGN KEY (&lt;code&gt;stu_curriculum_no&lt;/code&gt;) REFERENCES &lt;code&gt;curriculum&lt;/code&gt; (
&lt;code&gt;curriculum_no&lt;/code&gt;) ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8 |&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;其中Key hello (stu_curriculum_no) 就是所谓的索引，一般可以这样
查看表索引  show index from grade;
删除表索引  alter table grade drop index hello 

删除表中的外键：
ALTER TABLE grade DROP FOREIGN KEY fk_member;
当然一般在删除的时候需要
show create table grade 这样可以查看 CONSTRAINT后的名字  比如fk_memeber在本例中就是hello        

后来再次思考，grade表不可能有主键，因为学号可能多次出现在不同记录中！于是删除主键
alter table grade drop primary key;
（添加主键的方式：alter table table_test add primary key(id);）


我再次新建一张表grade1目的是测试，在同一个库中的确不能存在两个相同的外键名，否则报错，
下面我用hello1则是通过。（应该是此原因）
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mysql
create table grade1(
     stuno varchar(20) not null default &amp;ldquo;,
    curi varchar(20) not null default &amp;ldquo;,constraint hello1 foreign key
     (curi) references curriculum(curriculum_no),
     score real(5,2) not null default 0.00);&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ERROR 1022 (23000): Can&#39;t write; duplicate key in table &#39;grade&#39;的解决方案：外键名字改成没用过的就可以（整个数据库exam范围内）
下面再次新建一张表grade2 ,目的是测试不同表是不是可以使用字段名字相同的充当外键，当然是没问题啦！
因为在设计表的时候，曾经怕如果curi改为curriculum_no会不会报错的问题。所以就一起尝试了

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mysql
create table grade2(
     stu_no varchar(20) not null default &amp;ldquo;,
    curi varchar(20) not null default &amp;ldquo;,constraint hello2 foreign key
     (curi) references curriculum(curriculum_no) on delete restrict on update
    cascade,
     score real(5,2) not null default 0.00);&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;现在先把grade表放在一边 ，待会设计完student_info表之后再聊grade表的事情。

Student_info表的设计


不合理的设计（主键同时是外键，不好）：
学号 student_no : int  not null auto_increment primary key, foreign key(student_no) references 


grade on grade(student_no) on delete restrict on update cascade,（后来修改为 主键！因为一个表即为


主键和外键叠加不好！！ 同时让grade的stu_no 也增加一个外键  连接到student_info表）
姓名  stu_name  : varchar(20) not null default ‘’,
性别  stu_sex    : char(2)  not null default ‘男‘，
出生年月 stu_date (stu_birth): date not null default ‘1990-01-04’
家庭住址 stu_family (stu_addr): varchar(20) not null default ‘’,
备注     stu_note : varchar(30) not null default ‘’,



然后再次回到grade表，添加外键，

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mysql
alter table grade add constraint fuck foreign key(stu_no) references stud
ent_info(stu_no) ;
ERROR 1452 (23000): Cannot add or update a child row: a foreign key constraint f
ails (&lt;code&gt;exam&lt;/code&gt;.&lt;code&gt;#sql-167c_1&lt;/code&gt;, CONSTRAINT &lt;code&gt;fuck&lt;/code&gt; FOREIGN KEY (&lt;code&gt;stu_no&lt;/code&gt;) REFERENCES
&lt;code&gt;student_info&lt;/code&gt; (&lt;code&gt;stu_no&lt;/code&gt;))&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;报错了！！！为什么？ 
原来在非空表的情况不能添加外键
于是： delete from grade;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mysql
alter table grade add constraint pig foreign key(stu_no) references
    student_info(stu_no) on delete restrict on update cascade;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
最终我的grade表的结构：

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mysql
| grade | CREATE TABLE &lt;code&gt;grade&lt;/code&gt; (
  &lt;code&gt;stu_no&lt;/code&gt; varchar(20) NOT NULL DEFAULT &amp;ldquo;,
  &lt;code&gt;curriculum&lt;/code&gt; varchar(20) NOT NULL DEFAULT &amp;ldquo;,
  &lt;code&gt;stu_score&lt;/code&gt; double(5,2) NOT NULL DEFAULT &amp;lsquo;0.00&amp;rsquo;,
  KEY &lt;code&gt;hello&lt;/code&gt; (&lt;code&gt;curriculum&lt;/code&gt;),
  KEY &lt;code&gt;pig&lt;/code&gt; (&lt;code&gt;stu_no&lt;/code&gt;),
  CONSTRAINT &lt;code&gt;hello&lt;/code&gt; FOREIGN KEY (&lt;code&gt;curriculum&lt;/code&gt;) REFERENCES &lt;code&gt;curriculum&lt;/code&gt; (&lt;code&gt;curric
ulum_no&lt;/code&gt;) ON UPDATE CASCADE,
  CONSTRAINT &lt;code&gt;pig&lt;/code&gt; FOREIGN KEY (&lt;code&gt;stu_no&lt;/code&gt;) REFERENCES &lt;code&gt;student_info&lt;/code&gt; (&lt;code&gt;stu_no&lt;/code&gt;) O
N UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8 |&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;


其实经过前面n过程的之后，你会发现这几张表在你的脑海中特别清晰：
1.学生的
2.成绩的
3.课程的



最终的结果是：


curriculum表的设计：
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mysql
create table curriculum(
    curriculum_no int not null auto_increment primary key,
    curriculum_name varchar(20) not null default &amp;ldquo;,
    curriculum_credit real(5,2) not null  default 0.0);&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curriculum表的数据添加：
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mysql
insert into curriculum(curriculum_no,curriculum_name,curriculum_credit) v
alues(&amp;lsquo;0002&amp;rsquo;,&amp;lsquo;C语言&amp;rsquo;,3.0);&lt;/p&gt;

&lt;p&gt;insert into curriculum &amp;lt;curriculum_no,curriculum_name,curriculum_credit)
values (&amp;lsquo;0001&amp;rsquo;,&amp;lsquo;计算机基础&amp;rsquo;,2.2);
insert into curriculum (curriculum_no,curriculum_name,curriculum_credit) values(&amp;lsquo;0003&amp;rsquo;,&amp;lsquo;编译原理&amp;rsquo;,2.5);
insert into curriculum (curriculum_no,curriculum_name,curriculum_credit) values(&amp;lsquo;0004&amp;rsquo;,&amp;lsquo;错做系统&amp;rsquo;,3.5);&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;

student_info表的设计：
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mysql
create table student_info(
     stu_no varchar(20) not null default &amp;ldquo; primary key,
     stu_name varchar(20) not  null default &amp;ldquo;,
    stu_sex char(4) not null default &amp;lsquo;男&amp;rsquo;,
     stu_birth date not null default &amp;lsquo;1990-01-07&amp;rsquo;,
     stu_addr varchar(20) not null default &amp;ldquo;,
     stu_note varchar(30));&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;student_info表的数据添加：
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mysql
insert into student_info (stu_no,stu_name,stu_sex,stu_birth,stu_addr) val
ues(&amp;lsquo;0001&amp;rsquo;,&amp;lsquo;张三&amp;rsquo;,&amp;lsquo;男&amp;rsquo;,1989-05-17,&amp;lsquo;北京&amp;rsquo;);&lt;/p&gt;

&lt;p&gt;insert into student_info (stu_no,stu_name,stu_sex,stu_birth,stu&lt;em&gt;addr,stu&lt;/em&gt;
note) values(&amp;lsquo;0002&amp;rsquo;,&amp;lsquo;李四&amp;rsquo;,&amp;lsquo;女&amp;rsquo;,1990-06-22,&amp;lsquo;内蒙古&amp;rsquo;,&amp;lsquo;此女子性格刁蛮&amp;rsquo;);&lt;/p&gt;

&lt;p&gt;insert into student_info(stu_no,stu_name,stu_sex,stu_birth,stu_addr) valu
es(&amp;lsquo;0003&amp;rsquo;,&amp;lsquo;王五&amp;rsquo;,&amp;lsquo;男&amp;rsquo;,1992-02-18,&amp;lsquo;江西&amp;rsquo;);&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
grade表的设计
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mysql
create table grade3(
    stu_no varchar(20) not null default &amp;ldquo;,constraint pig34 foreign key(stu_n
o) references student_info(stu_no) on delete restrict on update cascade,
     curriculum varchar(20) not null default &amp;ldquo;,constraint hellodff foreign ke
y(curriculum) references curriculum(curriculum_no) on delete restrict on update
cascade,
    stu_score real(5,2) not null default 0.00);&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grade表的数据添加（截取部分）：
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mysql
insert into grade values(&amp;lsquo;0002&amp;rsquo;,&amp;lsquo;0001&amp;rsquo;,75),(&amp;lsquo;0002&amp;rsquo;,&amp;lsquo;0002&amp;rsquo;,60),(&amp;lsquo;0002&amp;rsquo;,&amp;lsquo;00
03&amp;rsquo;,79),(&amp;lsquo;0002&amp;rsquo;,&amp;lsquo;0004&amp;rsquo;,76);
insert into grade(stu_no,curriculum,stu_score) values(&amp;lsquo;0003&amp;rsquo;,&amp;lsquo;0002&amp;rsquo;,78);
注意了：如果外键表的0003没有的话，则无法添加0003，并报错！很正常，因为外键表student_info没有！！&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;



题目结果：
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mysql
mysql&amp;gt; select * from grade;
+&amp;mdash;&amp;mdash;&amp;ndash;+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;+&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+
| stu_no | curriculum | stu_score |
+&amp;mdash;&amp;mdash;&amp;ndash;+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;+&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+
| 0001   | 0001       |     80.00 |
| 0001   | 0002       |     85.00 |
| 0001   | 0003       |     90.00 |
| 0001   | 0004       |     92.00 |
| 0002   | 0001       |     75.00 |
| 0002   | 0002       |     60.00 |
| 0002   | 0003       |     79.00 |
| 0002   | 0004       |     76.00 |
| 0003   | 0001       |     80.00 |
| 0003   | 0002       |     78.00 |
| 0003   | 0003       |     97.00 |
| 0003   | 0004       |     86.00 |
+&amp;mdash;&amp;mdash;&amp;ndash;+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;+&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+
12 rows in set (0.00 sec)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. 在GRADE表中查找80-90份的学生学号和分数
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mysql
mysql&amp;gt; select stu_no as 学好 ,stu_score as 分数 from grade where stu_score&amp;gt;80.0
and stu_score&amp;lt;90.0;
+&amp;mdash;&amp;mdash;+&amp;mdash;&amp;mdash;-+
| 学好 | 分数  |
+&amp;mdash;&amp;mdash;+&amp;mdash;&amp;mdash;-+
| 0001 | 85.00 |
| 0003 | 86.00 |
+&amp;mdash;&amp;mdash;+&amp;mdash;&amp;mdash;-+
2 rows in set (0.00 sec)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;


2. 在GRADE 表中查找课程编号为003学生的平均分
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mysql
mysql&amp;gt; select avg(stu_score) from grade where curriculum=&amp;lsquo;0003&amp;rsquo;;
+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-+
| avg(stu_score) |
+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-+
|      88.666667 |
+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-+
1 row in set (0.04 sec)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;



3. 在GRADE 表中查询学习各门课程的人数

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mysql
mysql&amp;gt; select count(&lt;em&gt;),curriculum from grade group by curriculum;
+&amp;mdash;&amp;mdash;&amp;mdash;-+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;+
| count(&lt;/em&gt;) | curriculum |
+&amp;mdash;&amp;mdash;&amp;mdash;-+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;+
|        3 | 0001       |
|        3 | 0002       |
|        3 | 0003       |
|        3 | 0004       |
+&amp;mdash;&amp;mdash;&amp;mdash;-+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;+
4 rows in set (0.00 sec)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;



4. 查询所有姓张的学生的学号和姓名
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mysql
mysql&amp;gt; select stu_no 学号,stu_name 姓名  from student_info where stu_name like &amp;lsquo;
张%&amp;lsquo;;
+&amp;mdash;&amp;mdash;+&amp;mdash;&amp;mdash;+
| 学号 | 姓名 |
+&amp;mdash;&amp;mdash;+&amp;mdash;&amp;mdash;+
| 0001 | 张三 |
+&amp;mdash;&amp;mdash;+&amp;mdash;&amp;mdash;+
1 row in set (0.00 sec)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;



5. 查询分数在80-90分的学生的学号、姓名、分数
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mysql
mysql&amp;gt; select s.stu_no 学号,s.stu_name 姓名,g.curriculum 课程,g.stu_score 分数 f
rom grade g
    -&amp;gt; left join student_info s on g.stu_no=s.stu_no;
+&amp;mdash;&amp;mdash;+&amp;mdash;&amp;mdash;+&amp;mdash;&amp;mdash;+&amp;mdash;&amp;mdash;-+
| 学号 | 姓名 | 课程 | 分数  |
+&amp;mdash;&amp;mdash;+&amp;mdash;&amp;mdash;+&amp;mdash;&amp;mdash;+&amp;mdash;&amp;mdash;-+
| 0001 | 张三 | 0001 | 80.00 |
| 0001 | 张三 | 0002 | 85.00 |
| 0001 | 张三 | 0003 | 90.00 |
| 0001 | 张三 | 0004 | 92.00 |
| 0002 | 李四 | 0001 | 75.00 |
| 0002 | 李四 | 0002 | 60.00 |
| 0002 | 李四 | 0003 | 79.00 |
| 0002 | 李四 | 0004 | 76.00 |
| 0003 | 王五 | 0001 | 80.00 |
| 0003 | 王五 | 0002 | 78.00 |
| 0003 | 王五 | 0003 | 97.00 |
| 0003 | 王五 | 0004 | 86.00 |
+&amp;mdash;&amp;mdash;+&amp;mdash;&amp;mdash;+&amp;mdash;&amp;mdash;+&amp;mdash;&amp;mdash;-+
12 rows in set (0.00 sec)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;进一步求解：

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mysql
mysql&amp;gt; select s.stu_no 学号,s.stu_name 姓名,c.curriculum_name 课程名称,g.stu_sco
re 分数 from grade g
    -&amp;gt; left join student_info s on g.stu_no=s.stu_no
    -&amp;gt; left join curriculum c on g.curriculum=c.curriculum_no;
+&amp;mdash;&amp;mdash;+&amp;mdash;&amp;mdash;+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;+&amp;mdash;&amp;mdash;-+
| 学号 | 姓名 | 课程名称   | 分数  |
+&amp;mdash;&amp;mdash;+&amp;mdash;&amp;mdash;+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;+&amp;mdash;&amp;mdash;-+
| 0001 | 张三 | 计算机基础 | 80.00 |
| 0001 | 张三 | C语言      | 85.00 |
| 0001 | 张三 | 编译原理   | 90.00 |
| 0001 | 张三 | 操作系统   | 92.00 |
| 0002 | 李四 | 计算机基础 | 75.00 |
| 0002 | 李四 | C语言      | 60.00 |
| 0002 | 李四 | 编译原理   | 79.00 |
| 0002 | 李四 | 操作系统   | 76.00 |
| 0003 | 王五 | 计算机基础 | 80.00 |
| 0003 | 王五 | C语言      | 78.00 |
| 0003 | 王五 | 编译原理   | 97.00 |
| 0003 | 王五 | 操作系统   | 86.00 |
+&amp;mdash;&amp;mdash;+&amp;mdash;&amp;mdash;+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;+&amp;mdash;&amp;mdash;-+
12 rows in set (0.00 sec)&lt;/p&gt;

&lt;p&gt;mysql&amp;gt; select s.stu_no 学号,s.stu_name 姓名,c.curriculum_name 课程名称,g.stu_sco
re 分数 from grade g
    -&amp;gt; left join student_info s on g.stu_no=s.stu_no
    -&amp;gt; left join curriculum c on g.curriculum=c.curriculum_no
    -&amp;gt; where g.stu_score&amp;gt;80 and g.stu_score&amp;lt;90;
+&amp;mdash;&amp;mdash;+&amp;mdash;&amp;mdash;+&amp;mdash;&amp;mdash;&amp;mdash;-+&amp;mdash;&amp;mdash;-+
| 学号 | 姓名 | 课程名称 | 分数  |
+&amp;mdash;&amp;mdash;+&amp;mdash;&amp;mdash;+&amp;mdash;&amp;mdash;&amp;mdash;-+&amp;mdash;&amp;mdash;-+
| 0001 | 张三 | C语言    | 85.00 |
| 0003 | 王五 | 操作系统 | 86.00 |
+&amp;mdash;&amp;mdash;+&amp;mdash;&amp;mdash;+&amp;mdash;&amp;mdash;&amp;mdash;-+&amp;mdash;&amp;mdash;-+
2 rows in set (0.00 sec)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;


6. 查询学习了’C语言’课程的学生学号、姓名和分数

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mysql
mysql&amp;gt; select s.stu_no 学号,s.stu_name 姓名,c.curriculum_name 课程名称,g.stu_sco
re 分数 from grade g
    -&amp;gt; left join curriculum c on g.curriculum=c.curriculum_no
    -&amp;gt; left join student_info s on g.stu_no=s.stu_no
    -&amp;gt; where c.curriculum_name=&amp;lsquo;c语言&amp;rsquo;;
+&amp;mdash;&amp;mdash;+&amp;mdash;&amp;mdash;+&amp;mdash;&amp;mdash;&amp;mdash;-+&amp;mdash;&amp;mdash;-+
| 学号 | 姓名 | 课程名称 | 分数  |
+&amp;mdash;&amp;mdash;+&amp;mdash;&amp;mdash;+&amp;mdash;&amp;mdash;&amp;mdash;-+&amp;mdash;&amp;mdash;-+
| 0001 | 张三 | C语言    | 85.00 |
| 0002 | 李四 | C语言    | 60.00 |
| 0003 | 王五 | C语言    | 78.00 |
+&amp;mdash;&amp;mdash;+&amp;mdash;&amp;mdash;+&amp;mdash;&amp;mdash;&amp;mdash;-+&amp;mdash;&amp;mdash;-+
3 rows in set (0.00 sec)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;

7. 查询学习了’C语言’课程的学生学号、姓名和分数 并排序
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mysql
mysql&amp;gt; select s.stu_no 学号,s.stu_name 姓名,c.curriculum_name 课程名称,g.stu_sco
re 分数 from grade g
    -&amp;gt; left join curriculum c on g.curriculum=c.curriculum_no
    -&amp;gt; left join student_info s on g.stu_no=s.stu_no
    -&amp;gt; where c.curriculum_name=&amp;lsquo;c语言&amp;rsquo;
    -&amp;gt; order by g.stu_score;
+&amp;mdash;&amp;mdash;+&amp;mdash;&amp;mdash;+&amp;mdash;&amp;mdash;&amp;mdash;-+&amp;mdash;&amp;mdash;-+
| 学号 | 姓名 | 课程名称 | 分数  |
+&amp;mdash;&amp;mdash;+&amp;mdash;&amp;mdash;+&amp;mdash;&amp;mdash;&amp;mdash;-+&amp;mdash;&amp;mdash;-+
| 0002 | 李四 | C语言    | 60.00 |
| 0003 | 王五 | C语言    | 78.00 |
| 0001 | 张三 | C语言    | 85.00 |
+&amp;mdash;&amp;mdash;+&amp;mdash;&amp;mdash;+&amp;mdash;&amp;mdash;&amp;mdash;-+&amp;mdash;&amp;mdash;-+
3 rows in set (0.00 sec)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;



第二题：
费时：3个小时（重写5遍）
http://www.rupeng.com/forum/thread-44516-1-1.html
sql_properties：

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mysqlDriver=com.mysql.jdbc.Driver
connectDatabase=jdbc:mysql://localhost/study?seUnicode=true&amp;amp;characterEncoding=UTF8
userName=root
Password=root&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;JDBCUtils:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java
package com.jdbc.test;&lt;/p&gt;

&lt;p&gt;/**
* @author    叶昭良
* @time      2015年2月19日下午10:41:37
*                        10:55     14min
* @version   com.jdbc.testrewrite4 V1.0
&lt;em&gt;/
import java.util.&lt;/em&gt;;
import java.sql.&lt;em&gt;;
import java.io.&lt;/em&gt;;
public class rewrite4
{
        private final static String mysqlDriver;
        private final static String connectDatabase;
        private final static String userName;
        private final static String Password;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    static
    {
            Properties prop = new Properties();
            InputStream in = rewrite4.class.getResourceAsStream(&amp;quot;sql.properties&amp;quot;);
            try
            {
                    prop.load(in);
                    mysqlDriver = prop.getProperty(&amp;quot;mysqlDriver&amp;quot;);
                    connectDatabase = prop.getProperty(&amp;quot;connectDatabase&amp;quot;);
                    userName = prop.getProperty(&amp;quot;userName&amp;quot;);
                    Password = prop.getProperty(&amp;quot;Password&amp;quot;);
            } catch (IOException e)
            {
                    // TODO Auto-generated catch block
                    throw new RuntimeException(&amp;quot;配置文件加载失败&amp;quot;);
            }
            try
            {
                    Class.forName(mysqlDriver);
            } catch (ClassNotFoundException e)
            {
                    // TODO Auto-generated catch block
                    throw new RuntimeException(&amp;quot;mysql驱动加载失败&amp;quot;);
            }
    }
    public static Connection createConnection()
    {
            Connection conn = null;
            try
            {
                    conn = DriverManager.getConnection(connectDatabase);
            } catch (SQLException e)
            {
                    // TODO Auto-generated catch block
                    throw new RuntimeException(&amp;quot;未能正确创建连接&amp;quot;);
            }
            return conn;

    }
    public static int executeUpdate(String sql,Object... param) throws SQLException
    {
            Connection conn = rewrite4.createConnection();
            return rewrite4.executeUpdate(conn,sql, param);
    }
    public static int executeUpdate(Connection conn,String sql,Object... param) throws SQLException
    {
            PreparedStatement ps = null;
            int row = 1;
            try
            {
                    ps = conn.prepareStatement(sql);
                    for(Object par:param)
                    {
                            ps.setObject(row, par);
                            row++;
                    }                
                    return ps.executeUpdate();
            }finally
            {
                    rewrite4.closeQuietly(ps);
            }

    }

    public static ResultSet executeQuery(String sql,Object... param) throws SQLException
    {
            Connection conn = rewrite4.createConnection();
            return rewrite4.executeQuery(conn, sql, param);
    }
    public static ResultSet executeQuery(Connection conn,String sql,Object... param) throws SQLException
    {
            ResultSet  rs = null;
            PreparedStatement ps = null;

            ps = conn.prepareStatement(sql);
            int row =1;
            for(Object par:param)
            {
                    ps.setObject(row, par);
                    row++;
            }
            rs = ps.executeQuery();
            return rs;

    }
    public static void closeQuietly(Connection conn)
    {
            if(conn != null)
            {
                    try
                    {
                            conn.close();
                    } catch (SQLException e)
                    {
                            // TODO Auto-generated catch block
                            e.printStackTrace();
                    }
            }
    }
    public static void closeQuietly(Statement stmt)
    {
            if(stmt != null)
            {
                    try
                    {
                            stmt.close();
                    } catch (SQLException e)
                    {
                            // TODO Auto-generated catch block
                            e.printStackTrace();
                    }
            }
    }
    public static void closeQuietly(ResultSet rs)
    {
            if(rs != null)
            {
                    try
                    {
                            rs.close();
                    } catch (SQLException e)
                    {
                            // TODO Auto-generated catch block
                            e.printStackTrace();
                    }
            }
    }
    public static void closeAll(ResultSet rs)
    {
            if(rs != null)
            {
                    try
                    {
                            rs.close();
                    } catch (SQLException e)
                    {
                            // TODO Auto-generated catch block
                            e.printStackTrace();
                    }
            }
    }

    public static void rollback(Connection conn)
    {
            if(conn != null)
            {
                    try
                    {
                            conn.rollback();
                    } catch (SQLException e)
                    {
                            // TODO Auto-generated catch block
                            e.printStackTrace();
                    }
            }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;

第三题：
费时1个小时左右

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java
/**
*
*/
package com.jdbc.test;&lt;/p&gt;

&lt;p&gt;/**
* @author    叶昭良
* @time      2015年2月18日下午3:49:22
*                        下午5:00左右
* @version   com.jdbc.testphoneCheck V1.0
&lt;em&gt;/
import java.io.&lt;/em&gt;;
import java.sql.*;
import java.util.Scanner;&lt;/p&gt;

&lt;p&gt;public class phoneCheck
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /**
     * @param args
     */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;/**
* ID,MobileNumber,MobileArea,MobileType,AreaCode,PostCode,0
        连接成功
        总共添加了300105条数据.耗时：64712
*/
        private static void load()
        {
                //导入csv数据，利用BufferedInputStream
          InputStream is = null;
          InputStreamReader isr = null;
          BufferedReader bis = null; //一行一行读入数据&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      Connection conn = null;
      PreparedStatement ps = null;
            int len = 0;
            int i = 0;
            long startms = System.currentTimeMillis();
            try
            {
                    is = new FileInputStream(&amp;quot;e://phone.csv&amp;quot;);
                isr = new InputStreamReader(is);
                    bis = new BufferedReader(isr);

                    System.out.println(bis.readLine());
                    //第一行字段舍去
                    String apple=  null;
                    String[] applePiles = null;
                    //第一次测试  字符串的行读入
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;/*                        System.out.println(bis.readLine());
                        System.out.println(bis.readLine());*/
                        /&lt;em&gt;apple =bis.readLine();
                        //字符串的一次失误！！ 导致插入失败！！＂＂是默认存在的　必须删掉
                        apple = apple.replaceAll(&amp;rdquo;\&amp;ldquo;&amp;rdquo;, &amp;ldquo;&amp;rdquo;);
                        //第二次测试 字符串分隔
                        String[] splitArray = apple.split(&amp;ldquo;,&amp;rdquo;);
                        for(String apple1 :splitArray)
                        {
                                System.out.println(apple1);
                        }&lt;/em&gt;/
                        conn = JDBCUtils.createConnection();
                        conn.setAutoCommit(false);&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                    String sql = &amp;quot;insert into phone(MobileNumber,MobileArea,MobileType,Area&amp;quot;
                                    + &amp;quot;Code,PostCode) values(?,?,?,?,?);&amp;quot;;
                    ps = conn.prepareStatement(sql);
                    /**
                     * 370中国电信
                            371中国电信
                            之后 报错 ，可能是为空的原因 
                     */
                    while((apple=bis.readLine()) != null)
                    {
                            apple = apple.replaceAll(&amp;quot;\&amp;quot;&amp;quot;, &amp;quot;&amp;quot;);
                            applePiles = apple.split(&amp;quot;,&amp;quot;);

                            ps.clearParameters();
                            //ps.setInt(1, Integer.parseInt(applePiles[1].equalsIgnoreCase(&amp;quot;&amp;quot;)?&amp;quot;1111&amp;quot;:applePiles[4]));
                            //ps.setInt(1, Integer.parseInt(applePiles[1]));
                            ps.setString(1, applePiles[1]);
                            ps.setString(2, applePiles[2]);
                            //System.out.println(i+applePiles[3]+applePiles[4]);
                            ps.setString(3, applePiles[3]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;//                                ps.setInt(4, Integer.parseInt(applePiles[4]));//.equalsIgnoreCase(&amp;ldquo;&amp;rdquo;)?&amp;ldquo;1111&amp;rdquo;:applePiles[4]));
//                                ps.setInt(5, Integer.parseInt(applePiles[5]));//.equalsIgnoreCase(&amp;ldquo;&amp;rdquo;)?&amp;ldquo;1111&amp;rdquo;:applePiles[4]));
                                ps.setString(4, applePiles[4]);
                                ps.setString(5, applePiles[5]);
                                ps.addBatch();&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                            i++;
                            //每个2000步之后进行提交一次 到数据库
                            if(i%2000==0)
                            {
                                    ps.executeBatch();
                            }
                    }
                    //提交 最后的几百步
                    ps.executeBatch();
                    conn.commit();
                    long endMs = System.currentTimeMillis();
                    System.out.println(&amp;quot;总共添加了&amp;quot;+i+&amp;quot;条数据&amp;quot;+&amp;quot;.耗时：&amp;quot;+(endMs-startms));
            }catch(IOException e)
            {
                    throw new RuntimeException(&amp;quot;读取文件异常&amp;quot;);
            }catch(SQLException e)
            {
                    try
                    {
                            conn.rollback();
                    } catch (SQLException e1)
                    {
                            // TODO Auto-generated catch block
                            e1.printStackTrace();
                    } //又忘记了
                    throw new RuntimeException(&amp;quot;数据库插入异常！&amp;quot;);

            }finally
            {
                    //用完之后记得差屁股
                    JDBCUtils.closeQuietly(ps);
                    JDBCUtils.closeQuietly(conn);
            }
    }

    public static void checkPhoneNumber(String PhoneNumber)
    {


            PhoneNumber = &amp;quot;%&amp;quot;+PhoneNumber+&amp;quot;%&amp;quot;;
            String sql = &amp;quot;select * from phone where MobileNumber like ?&amp;quot;;
            ResultSet rs  = null;
            try
            {
                    rs = JDBCUtils.executeQuery(sql, PhoneNumber);
                    if(!rs.next())
                    {
                            System.out.println(&amp;quot;当前版本没有&amp;quot;+PhoneNumber+&amp;quot;的信息&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;//                                return;
                        }
                        //rs.next();
                        System.out.println(PhoneNumber+&amp;ldquo;手机号来自&amp;rdquo;+rs.getString(&amp;ldquo;MobileArea&amp;rdquo;)+rs.getString(&amp;ldquo;MobileType&amp;rdquo;));
                } catch (SQLException e)
                {
                        // TODO Auto-generated catch block
                        return;
                }finally
                {
                        //用完之后就差屁股
                        JDBCUtils.closeAll(rs);
                }&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    }
    public static void main(String[] args)
    {
            // TODO Auto-generated method stub
            //导入一次即可
            //load();
            while(true)
            {
                    System.out.println(&amp;quot;请输入手机号(至少7位)&amp;quot;);
                    Scanner sc = new Scanner(System.in);
                    String PhoneNumber = sc.nextLine();

                    if(PhoneNumber.equalsIgnoreCase(&amp;quot;exit&amp;quot;)||PhoneNumber.equalsIgnoreCase(&amp;quot;quit&amp;quot;))
                    {
                            return;
                    }
                    PhoneNumber = PhoneNumber.substring(0,7);
                    checkPhoneNumber(PhoneNumber);
            }

    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;加上对话框的设计：

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java
/**
*
*/
package com.jdbc.test;&lt;/p&gt;

&lt;p&gt;import java.sql.ResultSet;
import java.sql.SQLException;&lt;/p&gt;

&lt;p&gt;import com.rupeng.gtk4j.GTK;
import com.rupeng.gtk4j.IGCallBack;&lt;/p&gt;

&lt;p&gt;/**
* @author    叶昭良
* @time      2015年2月22日下午7:48:03
* @version   com.jdbc.testPhoneCheckUpdate V1.0
&lt;em&gt;/
import GTKEncapsulate.&lt;/em&gt;;
public class PhoneCheckUpdate
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /**
     * @param args
     */
    private static  OOLabel olLabel;
    private static  OOEntry oeCerti;
    private static OOButton obClick;
    private static OOBox obBox;
    private static OOWindow owPig;
    public PhoneCheckUpdate()
    {
            olLabel = new  OOLabel(&amp;quot;请输入电话的前六位：&amp;quot;);
            oeCerti = new OOEntry();
            oeCerti.setTextMaxLength(6);
            oeCerti.setText(&amp;quot;151010&amp;quot;);

            obBox = new OOBox();
            obClick = new OOButton(&amp;quot;查询&amp;quot;);
            owPig = new OOWindow();
            owPig.setWidgetSize(200, 50);
            //show
            owPig.show();
            owPig.setExitAfterDestroy(true);
            olLabel.show();
            oeCerti.show();
            obBox.show();
            obClick.show();

            //contains
            owPig.add(obBox);        
            obBox.add(olLabel);
            obBox.add(oeCerti);
            obBox.add(obClick);

            //添加事件
            obClick.addClickedListener(new IGCallBack()
            {

                    @Override
                    public void execute(int instance, int eventData, Object object)
                    {
                            // TODO Auto-generated method stub
                            String text= oeCerti.getText();
                            OOMessageDialog omd = new OOMessageDialog(checkPhoneNumber(text));
                            omd.run();
                            omd.destroy();

                    }
            });
    }
    private static String checkPhoneNumber(String PhoneNumber)
    {


            PhoneNumber = &amp;quot;%&amp;quot;+PhoneNumber+&amp;quot;%&amp;quot;;
            String sql = &amp;quot;select * from phone where MobileNumber like ?&amp;quot;;
            ResultSet rs  = null;
            try
            {
                    rs = JDBCUtils.executeQuery(sql, PhoneNumber);
                    if(!rs.next())
                    {
                            System.out.println(&amp;quot;当前版本没有&amp;quot;+PhoneNumber+&amp;quot;的信息&amp;quot;);
                            return &amp;quot;当前版本没有&amp;quot;+PhoneNumber+&amp;quot;的信息&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;//                                return;
                        }
                        //rs.next();
                        System.out.println(PhoneNumber+&amp;ldquo;手机号来自&amp;rdquo;+rs.getString(&amp;ldquo;MobileArea&amp;rdquo;)+rs.getString(&amp;ldquo;MobileType&amp;rdquo;));
                        return PhoneNumber+&amp;ldquo;手机号来自&amp;rdquo;+rs.getString(&amp;ldquo;MobileArea&amp;rdquo;)+rs.getString(&amp;ldquo;MobileType&amp;rdquo;);&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;            } catch (SQLException e)
            {
                    // TODO Auto-generated catch block
                    return null;
            }finally
            {
                    //用完之后就差屁股
                    JDBCUtils.closeAll(rs);
            }

    }
    public static void main(String[] args)
    {
            // TODO Auto-generated method stub
            GTK.gtk_init();
            PhoneCheckUpdate pcu = new PhoneCheckUpdate();

            GTK.gtk_main();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
```&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>2月4日Java班GTK</title>
      <link>https://jueqingsizhe66.github.io/blog/2015/05/11/2yue-4ri-javaban-gtk/</link>
      <pubDate>Mon, 11 May 2015 14:58:41 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/blog/2015/05/11/2yue-4ri-javaban-gtk/</guid>
      <description>&lt;p&gt;第一部分：笔记&lt;/p&gt;

&lt;p&gt;1：封装两个不需要Id的类，OORGB,OOCairo
  OORGB用于设置颜色值，并封装几个常见的颜色OORGB.RED OORGB.BLUE OORGB.GREEN..
  OOCairo则是一个绘图类，主要包括移动点，画线，画圆，画矩形等。当然先前的GTK.Cairo类的方法中，都是包含环境句柄，所以OOCairo的封装需要考虑环境句柄，并在封装之后不需要再
调入环境句柄(已封装）&lt;/p&gt;

&lt;p&gt;2：封装GtkWidget为OOWidget
最为关键的一步是设置Id的工作。 每一个句柄都具有一个对象标识，而Gtk+默认是通过一个
整数来表示对象标识，于是需要把这个值设置为私有的Id(估计想到这个得费点时间。。）于是
就有了getId和setId。这一步的作用影响到下节的进一步封装，
javadoc的注释： /** + enter键，会自动导入方法的参量和返回值以及类的创建者等
javadoc的生成： 项目&amp;mdash;&amp;gt;生成javadoc&amp;mdash;&amp;gt;填入javadoc路径
                        jd2chm+httphelper 转化为chm文档&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;利用上述方法，让所有的控件都继承自OOWidget(现在想想有点不合理），封装了21个类
 包括：OOBox, OOButton,OOCairo,OOCalendar,OODialog,OOEntry,OOFileChooser,OOGrid
         OOLabel,OOMenu,OOProgressBar, OORGB,OOScrollBar,OOSpinBox,OOStatusIcon,
         OOSwitch,OOTextIter,OOTextView,OOToolBar,OOTreeView,OOWidget
 并进行了一个简单测试 TestOOCairo.java&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;上面的内容构成了源码v1.0版&lt;/p&gt;

&lt;p&gt;进一步发现源码V1.0存在很多问题，没有照顾到继承关系图。&lt;/p&gt;

&lt;p&gt;后来继续学习了杨老师的视频，发现源码v1.0并未体现GTK+继承关系
如图GTK继承结构关系图.png
    由此可见，并不是所有的控件是直接继承OOWidget的，并考虑到以下bug情况
bug1:
     Protected是指兄弟和儿子可以访问！！ 也就是不同包的不可以访问。
为什么setId()最好改为protected呢？
因为我们经常是让一个包打成tar，然后别人引用这个jar包！ 也就是和这个jar包不一样
也就是他无法执行这样的操作
也就是 比如OOEntry oe = new OOEntry();
Oe.setId(GTK.gtk_label_new())的换心操作。 不要让entry变成了label而你却是不知道。&lt;/p&gt;

&lt;p&gt;bug2：
把OOWidget 标记为抽象类！ 这样防止用户
*&lt;br /&gt;
  直接OOWidget ow = new OOWidget() ; ow.show()
*                                       这完全是无意义的工作
这就是抽象的好处！！ 让子类去做，父类不要去实例化了&lt;/p&gt;

&lt;p&gt;bug3:&lt;/p&gt;

&lt;p&gt;见图Container是只大老虎.png ,发现先前写的大部分控件的封装都是container的子类，于是新建了OOContainer类，并重新改写了OOBox，OOGrid,OOTextView,OOToolBar,OOTreeView ,（修改的只是把extends 改为了OOContainer，这个工作量不大，发现有效  其他构造函数不需要改，修改完毕）
并发现我并未封装combobox,和radiobutton之类的，checkbox
并最终还使得button在原先的两个构造函数的基础上增加了图片资源的加载，和加载图片的位置控制
增加了8个工作量。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.csdn.net/uunubt/article/details/6089402&#34; target=&#34;_blank&#34;&gt;http://blog.csdn.net/uunubt/article/details/6089402&lt;/a&gt;
参考此文，琢磨出来RadioButton的用法：
int cbMan = GTK.gtk_radio_button_new_with_label(0, &amp;ldquo;男&amp;rdquo;);
                int cbWoman = GTK.gtk_radio_button_new_with_label_from_widget(cbMan, &amp;ldquo;女&amp;rdquo;);&lt;/p&gt;

&lt;p&gt;OK经过了努力终于完成此项工作的封装
（修改的只是把extends 改为了OOContainer，这个工作量不大，发现有效  其他构造函数不需要改，修改完毕）&lt;/p&gt;

&lt;p&gt;后来发现这种该法其实有不恰当的地方，应该是可以省略掉构造函数。但是这是仅仅如果构造函数和OOContainer是一样的情况（还是涉及到构造函数可以重写的问题）&lt;/p&gt;

&lt;p&gt;bug4:&lt;/p&gt;

&lt;p&gt;后来发现bug3并不完善，观察继承图发现很多的控件都是来自Gtkbin，见GtkBin是只小老虎.png.
由于GtkBin是单控件容器，于是采用杨老师针对OOContainer的 add方法的Override重写（GtkBin也是OOContainer的一部分）
Override方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
        public void add(OOWidget ow)
        {
                int[] children = GTK.gtk_container_get_children(this.getId());
                if(children.length &amp;lt;= 0 )
                {
                        //调用父类的add方法
                        super.add(ow);
                        //super.add  调用父类
                        //this.add   调用本类
                        //super() 调用父类构造方法(在构造函数中)
                        //this()  调用本类的构造方法(在构造函数中，记得我为什写上括号)
                }else
                {
                        throw new IllegalArgumentException(&amp;quot;容器中已经有了一个对象&amp;quot;);
                }
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;bug5:
并进一步修改了GTKButton, GTKImageButton   GGTKComboBox   GTKToolItem  GTKWindow
学习了封装原则： 能省则省，尽量调用父类实现的代码，减少代码量，减少出错的语句
最终把代码封装到了31个，见图2.0的所有类文件。&lt;/p&gt;

&lt;p&gt;下面是我代码的提交记录：
    1：重新封装了程序 根据GTK的继承关系  所有的控件都来自GTKwidget  GTKBin是指只能添加一个空间的类
    GTKContainer是包含着GTKBin  GTKGrid GTKBox，GTKToolBar,OOTreeView,OOTextView
    2. 封装了GTKImage
    3. 封装了GTKCheckButton和radioButton，并琢磨了GTKRadioButton的用法
    4. 添加了GTKBin和GTKWindow的封装，至此基本上所有的东西，都已经面向对象化了
    5. 测试了OOPassword之类的用法，使得OOPassword继承自OOEntry
    6. 添加了OOFileChooser的封装
    7  修改OOButton 使其继承自OOBin,也就是只能添加单一空间
    8. 使得OOWidget变得抽象画，这样就不会出现 定义一个OOWidget对象的额情况，使得程序更具可靠性
    9. 使得OOWidget的setId变成protected，这样只有子类和兄弟类（同包）可以使用，不同包的不可以使用。
    10：增加了OOCombo(从OOBin继承得到)类充当 OOCombobox的父类
    11: 把ComboBoxText的 addLister 添加到OOCombo类中！！
    12: 增加了OOToggleButton类
    13：修改了CheckBox使其充当OOToggleButtonde
    14： 修改了OOScrollBar的继承项 从OOWidget到OOContainer&lt;/p&gt;

&lt;p&gt;上面的内容构成了GTKEncapsulateV2.0源码&lt;/p&gt;

&lt;p&gt;第二部分 作业&lt;/p&gt;

&lt;p&gt;源码V1.0版本.rar
源码V2.0版本.rar
&lt;img src=&#34;https://jueqingsizhe66.github.io/images/java/gtk继承关系图.png&#34; alt=&#34;gtk继承关系图&#34; /&gt;
&lt;img src=&#34;https://jueqingsizhe66.github.io/images/java/Container是只大老虎&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;https://jueqingsizhe66.github.io/images/java/Gtkbin是只小老虎.png&#34; alt=&#34;Gtkbin是只小老虎&#34; /&gt;
&lt;img src=&#34;V2.0继承图.png&#34; alt=&#34;v2.0的所有类文件&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Bug再修复1  menu的clicked事件改为activate(menu  item响应 activate事件），这个activate让我花费了至少两个小时，因为把所有的OOMenu的过程                  重新在书写了一遍，并拆成孤立的四个片段分别是： OOMenuBar.java（将包装添入包装条，菜单条）    OOSubMenu.java（把菜单包装）    OOSingleMenu.java （绘制菜单） OOMenuVegetable.java （绘制一盘菜）。具体的也在源代码第三个版本。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Bug修复2    文件过滤器的 抽象方法的返回值从void变为 String[]，这样可以返回字符串（比如打开文件夹的文件名）
      //public abstract void processResponse();
        public abstract String[] processResponse();&lt;/p&gt;

&lt;p&gt;Bug修复3    FileChooser的run方法 从void 变到int,  这样可以接受返回值，判断对应的执行行为
Bug修复4    修改了OOTextView 使其从&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void addScrollBar(int width, int height)
        {
                OOScrollBar osb = new OOScrollBar();
                osb.setWidgetSize(width, height);
                osb.addView(this.getId());
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;变到&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void addScrollBar(OOGrid og,int start,int width, int height)
        {
                OOScrollBar osb = new OOScrollBar();
                osb.setWidgetSize(width, height);
                osb.addView(this.getId());
                osb.show();
                og.add(osb.getId(), start);
                
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;让textview自动可以添加滚动条。&lt;/p&gt;

&lt;p&gt;bug5修复
   使OOToolBar里面的addTool方法从void方法改变到返回值为ToolButton&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void addTool(String toolName,String toolPic,int position)
        {
                tbApple[i] = new ToolButton(toolName);
                tbApple[i].show();
                tbApple[i].setStock(toolPic);
                GTK.gtk_toolbar_insert(this.getId(), tbApple[i].getId(), position);
                i++;
                
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;到&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public ToolButton addTool(String toolName,String toolPic,int position)
        {
                tbApple[i] = new ToolButton(toolName);
                tbApple[i].show();
                tbApple[i].setStock(toolPic);
                GTK.gtk_toolbar_insert(this.getId(), tbApple[i].getId(), position);
                i++;
                return tbApple[i-1];
                
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就可以添加事件监听。&lt;/p&gt;

&lt;p&gt;bug6修复    OOWindow的ExitAfterDestroy 的返回值的设置
//也就是当收到 destroy信号的时候 不一定是关闭的（一般我们写的时候是关闭的）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;        public void setExitAfterDestroy(boolean value)
        {
                this.exitAfterDestroy  = true;
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;到&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void setExitAfterDestroy(boolean value)
        {
                this.exitAfterDestroy  = value;
        }
``



针对OOMenu针对两种封装方法进行了测试：
1：封装方法1(体现在TestMenuFileChooserToolbar.java)
     所有的方法 都浓缩到OOMenu中 ，包括第一步创建 menubar    第二步创建submenu     第三步创建 menu   第四步创建menuitem
2：封装方法2(体现在TestNewMenuFourStep)
     把原先的OOMenu 分为四个类   第一步 OOMenuBar类      第二步 OOSubMenu类     第三步   OOSingleMenu类    第四步  OOMenuVegetable类

从上面看到也许第二种方法更加体现着面向对象的方法，这也是被逼的，一直测试为什么menuitem的clicked方法不通过，原来是因为menuitem响应的是activate信号。

同时也可以看到面向对象方法的清晰性
封装方法1 的源代码 TestMenuFileChooseAndToolBar.java:

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java
package GTKEncapsulate;&lt;/p&gt;

&lt;p&gt;import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;&lt;/p&gt;

&lt;p&gt;import com.rupeng.gtk4j.GTK;
import com.rupeng.gtk4j.IGCallBack;&lt;/p&gt;

&lt;p&gt;/**
*
* @author    叶昭良
* @time      2015年2月6日下午8:13:45
* @version   GTKEncapsulateTestMenuFileChooserAndToolbar V1.0
*                                                         并进一步采用封装的OOWindow编写程序，由于继承了OOBin，所以具有add 一个控件的功能
*                                                         由于OOWindow在构造函数中添加了destroy的事件监听，所以不需要再重写，但是现在的
*                                                         OOWindow的对象还是可以添加destroy监听，要是可以不能再添加destroy就好了！！！
*&lt;br /&gt;
*                                                         另外发现了一个不对的地方，所有的控件现在都是可以弹出消息对话框，question对话框。
*
* 这个测试出现在事件监听！还有bug，等到以后再次修改，估计是继承关系出现了问题
*解决了这个问题，原来是因为menu的监听是通过activate而不是click
*涉及到的文件      OOMenu.java （这是主要的类包含另外一种方法的OOMenuBar OOSubMenu OOSingleMenu)
*              OOMenuVegetable.java （这是原先从OOMenu剥离出来的一个文件）
&lt;em&gt;/
public class TestMenuFileChooserAndToolbar
{
/&lt;/em&gt;        public IGCallBack IGCQuit = new IGCallBack()
        {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;            @Override
            public void execute(int instance, int eventData, Object object)
            {
                    // TODO Auto-generated method stub
                    GTK.gtk_main_quit();
            }
    };*/
    static OOTextView ootv =  null;
    public static void main(String[] args)
    {
            //初始化还是需要的
            GTK.gtk_init();
            //创建一个OOWindow对象，其中已经包含了  
            OOWindow window = new OOWindow();
            window.setTitle(&amp;quot;测试面向对象&amp;quot;);
            window.setExitAfterDestroy(true);
            window.show();


            //创建布局对象
            OOGrid grid = new OOGrid();
            grid.show();
            //添加到window对象
            window.add(grid);



            //创建一个textview 界面
            ootv = new OOTextView();
            ootv.setType();
            ootv.show();
            ootv.addScrollBar(grid, 2, 500, 300);
            //创建menubar对象
            OOMenu omMenu = new OOMenu();
            omMenu.show();

            //创建垂直menubar（最终需要文件的下拉菜单 添加到menubar(水平的menubar)
            omMenu.createVerticalMenu(&amp;quot;File&amp;quot;);
            //创建单一的一盘菜
            omMenu.createMenu();

            //往菜盘中添菜,改变了return选项 使得可以返回Vegetable对象，从而进行事件监听
            //由于已经在内部show了 所以不需要show
            OOMenuVegetable vgNew = new OOMenuVegetable(&amp;quot;新建&amp;quot;);
            OOMenuVegetable vgOpen = new OOMenuVegetable(&amp;quot;打开&amp;quot;);
            OOMenuVegetable vgSave = new OOMenuVegetable(&amp;quot;保存&amp;quot;);
            OOMenuVegetable vgQuit = new OOMenuVegetable(&amp;quot;退出&amp;quot;);
            vgOpen.addActivateListener(new IGCallBack()
            {

                    @Override
                    public void execute(int instance, int eventData, Object object)
                    {
                            youOpenfile(ootv);

                    }
            });
            vgSave.addActivateListener(new IGCallBack()
            {

                    @Override
                    public void execute(int instance, int eventData, Object object)
                    {
                            youSavefile();

                    }
            });
            vgQuit.addActivateListener( new IGCallBack()
            {

                    @Override
                    public void execute(int instance, int eventData, Object object)
                    {
                            // TODO Auto-generated method stub
                            GTK.gtk_main_quit();
                    }
            });
            omMenu.addMenuVegetable(vgNew);
            omMenu.addMenuVegetable(vgOpen);
            omMenu.addMenuVegetable(vgSave);
            omMenu.addMenuVegetable(vgQuit);

            //已经show了，唯一需要的是添加进网格
            omMenu.addVerticalMenuTOBar();

            grid.add(omMenu.getId(), 0);

            //上面的部分都是关于menu的现在做一个关于
            OOToolBar otbApple = new OOToolBar();
            //必须设置上 否则太小了
            otbApple.setWidgetSize(300, 20);
            OOToolBar.ToolButton tbApple = otbApple.addTool(&amp;quot;新建&amp;quot;, GTK.GTK_STOCK_NEW, 0);
            OOToolBar.ToolButton tbBanana =otbApple.addTool(&amp;quot;打开&amp;quot;, GTK.GTK_STOCK_OPEN, 1);
            OOToolBar.ToolButton tbOrange =otbApple.addTool(&amp;quot;保存&amp;quot;, GTK.GTK_STOCK_SAVE, 2);
            tbBanana.addClickedListener(new IGCallBack()
            {

                    @Override
                    public void execute(int instance, int eventData, Object object)
                    {
                            // TODO Auto-generated method stub
                            youOpenfile(ootv);
                    }
            });
            tbOrange.addClickedListener(new IGCallBack()
            {

                    @Override
                    public void execute(int instance, int eventData, Object object)
                    {
                            youSavefile();
                    }
            });
            otbApple.show();
            grid.add(otbApple.getId(),1);



            GTK.gtk_main();

    }

    public static void youOpenfile(OOTextView ootv)
    {
            OpenFile ofApple = new OpenFile();
            ofApple.setMultipleSelect();
            ofApple.createFilter();
            ofApple.nameFilter(&amp;quot;文本文件&amp;quot;);
            ofApple.editFilter(&amp;quot;*.txt&amp;quot;);
            ofApple.editFilter(&amp;quot;*.java&amp;quot;);
            //把filter的操作放入打开对话框中
            ofApple.finishFilter();
            String[] filenames = ofApple.processResponse();
            showAllFiles(filenames,  ootv);
    }
    public static void youSavefile()
    {
            SaveFile ofBanana = new SaveFile(&amp;quot;保存文件&amp;quot;,GTK.GTK_FILE_CHOOSER_ACTION_SAVE,&amp;quot;保存&amp;quot;);
            //把filter的操作放入打开对话框中

            ofBanana.processResponse();
    }

    public static void showAllFiles(String[] filenames,OOTextView otv)
    {
            for(int i = 0 ; i &amp;lt; filenames.length; i++)
            {
                    showOneFile(filenames[i],otv);
            }
    }

    public static void showOneFile(String filename, OOTextView otv)
    {
            try
            (
                    InputStream is = new FileInputStream(filename);
                    InputStreamReader osr = new InputStreamReader(is);
                    BufferedReader br = new BufferedReader(osr);
            )
            {

                    String  temp= filename.substring(filename.lastIndexOf(&#39;\\&#39;)+1);
                    System.out.println(temp);
                    otv.insertTextAtEnd(&amp;quot;******************\n当期文件为&amp;quot;+filename+&amp;quot;\n******************\n\n&amp;quot;+temp+&amp;quot; 文件内容如下：\n+---------------------------------------------------------------------------+\n&amp;quot;);
                    String content = null;
                    while((content = br.readLine())!=null) // -1读取完毕
                    {
                            //InsertStringToTextViewFunction(textview,fileToFile.toString());
                            otv.insertTextAtEnd(new String(content));

                    }
                    otv.insertTextAtEnd(&amp;quot;\n+---------------------------------------------------------------------------+\n******************\n文件&amp;quot;+filename+&amp;quot;读取结束\n******************\n&amp;quot;);
            }
            catch(IOException e)
            {
                    System.out.println(&amp;quot;文件读入异常&amp;quot;);
            }

    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;class OpenFile extends OOFileChooser
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @Override
    public  String[] processResponse()
    {
            String[] filenames = null;
            // TODO Auto-generated method stub
            int ret = this.run();
            if(ret == GTK.GTK_RESPONSE_OK) 
            {
                    filenames = GTK.gtk_file_chooser_get_filenames(this.getId());
                    for(int i = 0 ; i&amp;lt; filenames.length ; i++)
                    {

                            System.out.println(&amp;quot;选中文件名&amp;quot;+i+&amp;quot;: &amp;quot;+filenames[i]);
                    }
                    GTK.gtk_widget_destroy(this.getId()); //必须需要！！否则报错
            }else
            {
                    GTK.gtk_widget_destroy(this.getId());
            }
            return filenames;
    }                
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;class SaveFile extends OOFileChooser
{
        public SaveFile(String title, int action, String buttonText)
        {
                setId(GTK.gtk_file_chooser_dialog_new(title, 0, action, buttonText));
        }
        @Override
        public String[] processResponse()
        {
                String[] filenames = null;
                GTK.gtk_file_chooser_set_do_overwrite_confirmation(this.getId(), true);
                // TODO Auto-generated method stub
                System.out.println(&amp;ldquo;已进入save&amp;rdquo;);
                //SaveOneFile(filename,textview);
                int ret = GTK.gtk_dialog_run(this.getId());
                if(ret == GTK.GTK_RESPONSE_CANCEL)
                {
                        GTK.gtk_widget_destroy(this.getId());
                }else
                {
                        String filename = GTK.gtk_file_chooser_get_filename(this.getId());
                        filenames[0] = filename;
                        System.out.println(filename);
                        GTK.gtk_widget_destroy(this.getId());
                        return  filenames;
                }
                return filenames;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;


封装方法2 的源代码TestNewMenuFourStep.java:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java
package GTKEncapsulate;&lt;/p&gt;

&lt;p&gt;import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;&lt;/p&gt;

&lt;p&gt;import com.rupeng.gtk4j.GTK;
import com.rupeng.gtk4j.IGCallBack;&lt;/p&gt;

&lt;p&gt;/**
* @author    叶昭良
* @time      2015年2月6日下午10:09:33
* @version   GTKEncapsulateTestNewMenuFourStep V1.0
*
* 涉及到四个类       OOMenuBar.java
*               OOSubMenu.java
*               OOSingleMenu.java
*               OOMenuVetetable.menu   依次创建四个类即可
*/
public class TestNewMenuFourStep
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /**
     * @param args
     */
    static OOTextView ootv =  null;
    public static void main(String[] args)
    {
            // TODO Auto-generated method stub
            //初始化还是需要的
                            GTK.gtk_init();
                            //创建一个OOWindow对象，其中已经包含了  
                            OOWindow window = new OOWindow();
                            window.setTitle(&amp;quot;测试面向对象&amp;quot;);
                            window.setExitAfterDestroy(true);
                            window.show();


                            //创建布局对象
                            OOGrid grid = new OOGrid();
                            grid.show();
                            //添加到window对象
                            window.add(grid);

                            //创建一个textview 界面
                            ootv = new OOTextView();
                            ootv.setType();
                            ootv.show();
                            ootv.addScrollBar(grid, 2, 500, 300);
                            //创建一个大的menubar
                            OOMenuBar ombApple = new OOMenuBar();
                            //创建第二大的（可以有很多个）
                            OOSubMenu osmApple = new OOSubMenu(&amp;quot;File&amp;quot;);

                            //创建第三大的（可以有很多个）
                            OOSingleMenu menuApple = new OOSingleMenu();

                            //往菜盘中添菜,改变了return选项 使得可以返回Vegetable对象，从而进行事件监听
                            //由于已经在内部show了 所以不需要show
                            //创建第四大的（可以有很多个）
                            OOMenuVegetable vgNew = new OOMenuVegetable(&amp;quot;新建&amp;quot;);
                            OOMenuVegetable vgOpen = new OOMenuVegetable(&amp;quot;打开&amp;quot;);
                            OOMenuVegetable vgSave = new OOMenuVegetable(&amp;quot;保存&amp;quot;);
                            OOMenuVegetable vgQuit = new OOMenuVegetable(&amp;quot;退出&amp;quot;);
                            vgOpen.addActivateListener(new IGCallBack()
                            {

                                    @Override
                                    public void execute(int instance, int eventData, Object object)
                                    {
                                            youOpenfile(ootv);

                                    }
                            });
                            vgSave.addActivateListener(new IGCallBack()
                            {

                                    @Override
                                    public void execute(int instance, int eventData, Object object)
                                    {
                                            youSavefile();

                                    }
                            });
                            vgQuit.addActivateListener(new IGCallBack()
                            {

                                    @Override
                                    public void execute(int instance, int eventData, Object object)
                                    {
                                            // TODO Auto-generated method stub
                                            GTK.gtk_main_quit();
                                    }
                            });
                            //添加第四大到第三大
                            menuApple.addVegetable(vgNew);
                            menuApple.addVegetable(vgOpen);
                            menuApple.addVegetable(vgSave);
                            menuApple.addVegetable(vgQuit);

                            //添加第三大到第二大  采用的是填充
                            osmApple.fillSubMenu(menuApple);
                            //添加第二大到第一大
                            ombApple.addSubMenuToBar(osmApple);
                            ombApple.show();

                            grid.add(ombApple.getId(), 0);


                            //上面的部分都是关于menu的现在做一个关于
                            OOToolBar otbApple = new OOToolBar();
                            //必须设置上 否则太小了
                            otbApple.setWidgetSize(300, 20);
                            OOToolBar.ToolButton tbApple = otbApple.addTool(&amp;quot;新建&amp;quot;, GTK.GTK_STOCK_NEW, 0);
                            OOToolBar.ToolButton tbBanana =otbApple.addTool(&amp;quot;打开&amp;quot;, GTK.GTK_STOCK_OPEN, 1);
                            OOToolBar.ToolButton tbOrange =otbApple.addTool(&amp;quot;保存&amp;quot;, GTK.GTK_STOCK_SAVE, 2);
                            tbBanana.addClickedListener(new IGCallBack()
                            {

                                    @Override
                                    public void execute(int instance, int eventData, Object object)
                                    {
                                            // TODO Auto-generated method stub
                                            youOpenfile(ootv);
                                    }
                            });
                            tbOrange.addClickedListener(new IGCallBack()
                            {

                                    @Override
                                    public void execute(int instance, int eventData, Object object)
                                    {
                                            youSavefile();
                                    }
                            });
                            otbApple.show();
                            grid.add(otbApple.getId(),1);
                            //启动循环
                            GTK.gtk_main();
    }

    public static void youOpenfile(OOTextView ootv)
    {
            OpenFileNew ofApple = new OpenFileNew();
            ofApple.setMultipleSelect();
            ofApple.createFilter();
            ofApple.nameFilter(&amp;quot;文本文件&amp;quot;);
            ofApple.editFilter(&amp;quot;*.txt&amp;quot;);
            ofApple.editFilter(&amp;quot;*.java&amp;quot;);
            //把filter的操作放入打开对话框中
            ofApple.finishFilter();
            String[] filenames = ofApple.processResponse();
            showAllFiles(filenames,  ootv);
    }
    public static void youSavefile()
    {
            SaveFileNew ofBanana = new SaveFileNew(&amp;quot;保存文件&amp;quot;,GTK.GTK_FILE_CHOOSER_ACTION_SAVE,&amp;quot;保存&amp;quot;);
            //把filter的操作放入打开对话框中

            ofBanana.processResponse();
    }

    public static void showAllFiles(String[] filenames,OOTextView otv)
    {
            for(int i = 0 ; i &amp;lt; filenames.length; i++)
            {
                    showOneFile(filenames[i],otv);
            }
    }

    public static void showOneFile(String filename, OOTextView otv)
    {
            try
            (
                    InputStream is = new FileInputStream(filename);
                    InputStreamReader osr = new InputStreamReader(is);
                    BufferedReader br = new BufferedReader(osr);
            )
            {

                    String  temp= filename.substring(filename.lastIndexOf(&#39;\\&#39;)+1);
                    System.out.println(temp);
                    otv.insertTextAtEnd(&amp;quot;******************\n当期文件为&amp;quot;+filename+&amp;quot;\n******************\n\n&amp;quot;+temp+&amp;quot; 文件内容如下：\n+---------------------------------------------------------------------------+\n&amp;quot;);
                    String content = null;
                    while((content = br.readLine())!=null) // -1读取完毕
                    {
                            //InsertStringToTextViewFunction(textview,fileToFile.toString());
                            otv.insertTextAtEnd(new String(content));

                    }
                    otv.insertTextAtEnd(&amp;quot;\n+---------------------------------------------------------------------------+\n******************\n文件&amp;quot;+filename+&amp;quot;读取结束\n******************\n&amp;quot;);
            }
            catch(IOException e)
            {
                    System.out.println(&amp;quot;文件读入异常&amp;quot;);
            }

    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
//取和OpenFile不一样的类名防止重复
class OpenFileNew extends OOFileChooser
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @Override
    public  String[] processResponse()
    {
            String[] filenames = null;
            // TODO Auto-generated method stub
            int ret = this.run();
            if(ret == GTK.GTK_RESPONSE_OK) 
            {
                    filenames = GTK.gtk_file_chooser_get_filenames(this.getId());
                    for(int i = 0 ; i&amp;lt; filenames.length ; i++)
                    {

                            System.out.println(&amp;quot;选中文件名&amp;quot;+i+&amp;quot;: &amp;quot;+filenames[i]);
                    }
                    GTK.gtk_widget_destroy(this.getId()); //必须需要！！否则报错
            }else
            {
                    GTK.gtk_widget_destroy(this.getId());
            }
            return filenames;
    }                
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;class SaveFileNew extends OOFileChooser
{
        public SaveFileNew(String title, int action, String buttonText)
        {
                setId(GTK.gtk_file_chooser_dialog_new(title, 0, action, buttonText));
        }
        @Override
        public String[] processResponse()
        {
                String[] filenames = null;
                GTK.gtk_file_chooser_set_do_overwrite_confirmation(this.getId(), true);
                // TODO Auto-generated method stub
                System.out.println(&amp;ldquo;已进入save&amp;rdquo;);
                //SaveOneFile(filename,textview);
                int ret = GTK.gtk_dialog_run(this.getId());
                if(ret == GTK.GTK_RESPONSE_CANCEL)
                {
                        GTK.gtk_widget_destroy(this.getId());
                }else
                {
                        String filename = GTK.gtk_file_chooser_get_filename(this.getId());
                        filenames[0] = filename;
                        System.out.println(filename);
                        GTK.gtk_widget_destroy(this.getId());
                        return  filenames;
                }
                return filenames;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;

    基本上两种封装方法的思路一样，就书写来说，第二种方法，更加的清晰些。

运行界面一样：

![软件的运行界面](/images/java/filechooser1.png)
![利用工具栏打开一个文件](/images/java/filechooser2.png)
![利用菜单栏保存一个文档](/images/java/filechooser3.png)




2月7号的笔记：
再次介绍主要的控件的封装过程
OOWindow的封装思路
这个控件是OOBin的子类，也就是该控件只能容纳一个控件，为此在封装之前必须封装OOBin。
OOWindow类的封装主要包含 1：构造函数创建window并添加关闭的监听  2：设置window文本  3：设置window全屏 4：设置winow可以调整大小 5：设置window居中

有一点不明白的是：为毛非得有这个setExitAfterDestroy(boolean value)判断在window的关闭程序的事件监听，直接关掉不是大吉？！ 


OOFileChooser为什么把它封装成抽象类？
OOFileChooser的处理GTK.gtk_dialog_run的返回值的函数被我封装成一个抽象函数，如下

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java
/**
         *   一个抽象方法 ，要求继承者去实现它
         */
        public abstract String[] processResponse();&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;这样只要子类继承了OOFileChooser就让他去实现对应的processResponse方法，因为也许每次你打开文件的时候需要的处理都是有所不一样的并且为了能够让打开的时候保存多个文件名字，在保存的时候又不需要保存多个文件 ，新建了一个抽象类的方法针对savafile
        public abstract void processResponse1();  //用于保存
        public abstract String[] processResponse(); //用于打开

OOBin的封装思路
之前在介绍OOWindow中提及了OOBin的单容器功能，而OOBin是继承自OOContainer的，比如OOGrid,OOBox的都是继承自OOContainer的，但是他们都是可以容纳多个控件，为此必须重写OOBin的add方法。主要的作用是利用gtk_container_get_children判断是否当前的OOBin对象是否有多个控件，如果有了一个则 不能再添加，如果没有则可以添加
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java
@Override
        public void add(OOWidget ow)
        {
                int[] children = GTK.gtk_container_get_children(this.getId());
                if(children.length &amp;lt;= 0 )
                {
                        //调用父类的add方法
                        super.add(ow);
                        //super.add  调用父类
                        //this.add   调用本类
                        //super() 调用父类构造方法(在构造函数中)
                        //this()  调用本类的构造方法(在构造函数中，记得我为什写上括号)
                }else
                {
                        throw new IllegalArgumentException(&amp;ldquo;容器中已经有了一个对象&amp;rdquo;);
                }
        }&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;OOWidget的封装思路
OOWidget是祖宗级的任务，必须是大大滴。试想所有的控件都是可以显示、隐藏、摧毁，于是可以把这些函数的封装都容纳在OOWidget中，这是一个比较实际而又有效的封装。 然而是否所有的控件都有click事件的监听？ 这点我表示质疑，比如GtkMenuItem控件就没有，他只是响应activate事件，所以把click的事件监听放在OOWidget里面还是有点问题的。
另外地，把所有的基于OODialog(OODialog基于OOWindow)的消息对话框showInfo,问题对话框showYesNo,确认对话框showOkCancle放在OOWidget,从当前考虑也是可以的，但是封装的函数内部的实现还是面向过程，可不可以把MessageInfo类也可以提取出来，当然可以。
当然首先得把OODialog修改为继承自OOWindow！ 因为OODialog也是单容器控件。然后再把OOCalendar，OOFileChooser也修改为继承自OODialog
并新建OOInputDialog（暂时未能实现，com.rupeng.gtk4j没有）,OOMessageDialog  因为这些Dialog都有一个共同的特点需要GTK.gtk_dialog_run，可以把这个方法封装在OODialog中
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java
/**
         *    在一切设置完毕后  必须要让他run起来，类似于线程的做法,并且一定要摧毁它 this.destroy..
         */
        public  int run()
        {
                int response =  GTK.gtk_dialog_run(this.getId());
                return response;
        }&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;这样所有的OOdialog子类都可以run起来，并且都是单容器控件了。也算是一个bug修复。


OOBox容器的修改：
public OOBox(int orientation)的封装改为 this（orientation,0)的实现，这样如果以后需要修改GTK.gtk_box_new..只需要修改一个地方即可，不至于留下bug,此方法可以思考
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java
public OOBox(int orientation,int spacing)
        {
                setId(GTK.gtk_box_new(orientation, spacing));
        }
        /**
         *
         * @param orientation   方向的说明
         */
        public OOBox(int orientation)
        {
                this(orientation,0);  //调用本类的构造函数
                //setId(GTK.gtk_box_new(orientation,0));
        }&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;

至此  源码v4.0已经增加到37个类，并进行了4个简单的测试。



2月8号笔记：
  接口
接口其实就是一个头文件，提供方法的声明或者变量的声(）

接口文件仅仅是一个能力的声明，我能够做什么，具体实现还得自己去做。

一句话总结：接口定义做什么，实现接口能力的类定义怎么做
    使用：
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java
1：drawingCallback
public interface OODrawCallback
{
        public void drawCairo(OOCairo cairo);
//        public void speak();
}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;使用接口：

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java
//使用
public void addDrawListener(final OODrawCallback ocbApple) //声明了我要调用一个接口，里头可以假设已经
  //实现了OODrawCallback的接口，并进行调用。 等到OODrawingArea这个对象生成，并添加了&lt;/p&gt;

&lt;p&gt;//draw监听器，传入接口对象时候，则需要具体去实现借口对象的方法（并且是所有方法）
        {
                GTK.g_signal_connect(this.getId(), &amp;ldquo;draw&amp;rdquo;, new IGCallBack()
                {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                    @Override
                    public void execute(int instance, int eventData, Object object)
                    {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;//通过现象来解释的话，在一个类中方法，调用了接口的未实现的类，那么当你
//定义这个包含接口类方法的对象时候，需要实现这个接口的未实现类，因为
//类似于Throws的方法，我就让你调用这个类的对象去实现它，你们谁调用
//谁就给我去维护，我就提供一本秘籍，你自己去修炼！！！！当前的话eventData&lt;/p&gt;

&lt;p&gt;//小结：  在&amp;rdquo;draw&amp;rdquo;信号发出 执行了一个IGCallBack的接口，通过内部类实现，
//          在execute实现IGCallback接口的execute方法，主要是定义了一个Cairo对象
//          传进去了绘画环境，然后通过新建了一个OODrawCallback提供一个内容的接口
//          并调用了drawCairo，而由于drawCairo是未定义的方法，且是一个接口的未实现
//          方法，所以允许放在一个定义类中空着，
// 但是必须在存在未实现方法的类接口的对象去实现它（注意是对象中）
//
// 猜想： 一个class的定义，不带有implemetns,那么其内部有一个变量  CanWithouImplement = true;
//       如果一个calss定义，带有implements,那么其内的  CanWithouImplement = false、
//      通过这个猜想来解释为什么我们下面在未实现drawCairo方法还是可以调用了drawCairo
// 但是有一句话是正确的，这边肯定是声明了具有drawCairo的能力。（具体什么能力不知道）
// 猜想： implements ocbApple是必须实现ocbApple的所有方法，而ocbApple.drawCairo仅仅需要实现一个方法。
//     错误：因为在一开头就定义了final  OODrawCallback ocbApple,形参定义了接口声明，调用的时候需要传入
//           接口对象（一般可以通过内部类实现)
//     测试方法： 通过在OODrawCallback增加一个未实现方法，发现还是需要实现两种未实现方法
//再次小结： 这边仅仅是一个形式上的定义！接口在形参变量中出现，则在调用具有该形参变量表的函数时候，必须
//         去实现他们，当然在该方法的定义中可以直接使用该方法。相当于是在该形式方法中事先隐式调用了
复制代码
接口调用的实现：
//创建绘图
                 //1 面向对象的方法
                OODrawingArea odaApple = new OODrawingArea();
                odaApple.show();
                //必须setSize否则看不到  这点一定要注意了
                odaApple.setWidgetSize(300, 300);
                gridApple.add(odaApple, 0);
                // 第一种情况重画： 画面被挡住了，揭开画面时候
                // 第二种情况重画： 打开画面饿时候
                odaApple.addDrawListener(new OODrawCallback()
                {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                    @Override
                    public void drawCairo(OOCairo cairo)
                    {
                            // TODO Auto-generated method stub
                            cairo.setPenColor(OORGB.RED);
                            cairo.drawRectangle(20, 20, 100, 100);
                            cairo.fill();
                            cairo.drawCircle(200, 200, 50);
                            cairo.stroke();
                    }
            });
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
2：treeview当中的双击事件
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java
        public void addDoubleClickedListener(final IGCallBack callback)
        {
                GTK.g_signal_connect(this.getId(), &amp;ldquo;button-press-event&amp;rdquo;, new IGCallBack()
                {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                    @Override
                    public void execute(int instance, int eventData, Object object)
                    {
                            // TODO Auto-generated method stub
                            if(GTK.gdk_event_get_type(eventData)==GTK.GDK_2BUTTON_PRESS)
                            {
                                    //调用时候 需要再次重写他。
                                    callback.execute(instance, eventData, object);
                            }
                    }
            }, null);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;TestTreeView
定义了一个 TestOOTreeView otv = new TestOOTreeView(); //通过内部接口

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java
  otv.addDoubleClickedListener(new IGCallBack()
                {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                    @Override
                    public void execute(int instance, int eventData, Object object)
                    {
                            int[] selection = otv.getMultipleSelectRows();
                            for(int i = 0; i &amp;lt; selection.length; i++)
                            {
                                    System.out.println(&amp;quot;selection&#39;s length== &amp;quot;+ selection.length+&amp;quot;当前行&amp;quot;+selection[i]);
                                    //values[i]  = otv.getliststore().getValue(selection[i], 1);
                                    OOMessageDialog.showInfo(&amp;quot;选中的信息为&amp;quot;+otv.getliststore().getValue(selection[i], 1), &amp;quot;用户名&amp;quot;);
                                    System.out.println(&amp;quot;selection[&amp;quot;+i+&amp;quot;]&amp;quot;+selection[i]);
                            }
                    }
            });
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;


接口的多态，比如Speakable sp = new People()

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java
/**
*
*/
package InterfacePractice;&lt;/p&gt;

&lt;p&gt;/**
* @author    叶昭良
* @time      2015年2月8日上午9:30:40
* @version   InterfacePracticeTestSpeackable V1.0
*/
public class TestSpeackable implements Speakable
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /**
     * @param args
     */
    public static void main(String[] args)
    {
            // TODO Auto-generated method stub
            new TestSpeackable().speak();
            new TestSpeackable().look();
            //利用多态来实现        
            Speakable sp = new TestSpeackable();
            sp.speak();

            //利用匿名类的方式 是吸纳了Speakable接口，并立马返回
            Speakable sp1 = new Speakable()
            {

                    @Override
                    public void speak()
                    {
                            // TODO Auto-generated method stub
                            System.out.println(&amp;quot;这也可以&amp;quot;);
                    }

                    @Override
                    public void look()
                    {
                            // TODO Auto-generated method stub
                            System.out.println(&amp;quot;这也可以&amp;quot;);
                    }
            };

            sp1.speak();
            sp1.look();

    }

    @Override
    public  void speak()
    {
            // TODO Auto-generated method stub
            System.out.println(&amp;quot;yamadie&amp;quot;);
    }

    @Override
    public void look()
    {
            // TODO Auto-generated method stub
            System.out.println(&amp;quot;带你去看星星&amp;quot;);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;

小技巧：
Ctr+H可以在workspace项目里面查找。。。
Ctrl+shift+T 显示workspace的类
Ctrl+T  O则显示当前文件夹下的类(ctrl+O列举当前类的所有成员)


枚举类
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java
package GTKEncapsulate;&lt;/p&gt;

&lt;p&gt;import com.rupeng.gtk4j.GTK;&lt;/p&gt;

&lt;p&gt;/**
* @author    叶昭良
* @time      2015年2月8日下午4:07:49
* @version   GTKEncapsulateOOResponseType V1.0  用途 简化对话框返回值的判断
*                                   V2.0 parseResponseType 替换掉parseInt这样更加符合常规
*                                        封装返回值的一个返回值，不至于说传递的值是非法（非法值有提醒）
*                                        增加程序的稳定性
*/
public enum OOResponseType
{
        //对话框几种可能的返回值类型
        //GTK_RESPONSE_HELP    GTK_RESPONSE_DELETE_EVENT   GTK_RESPONSE_NONE
        OK(GTK.GTK_RESPONSE_OK),  //最常用放在第一个
        YES(GTK.GTK_RESPONSE_YES),
        NO(GTK.GTK_RESPONSE_NO),
        CANCEL(GTK.GTK_RESPONSE_CANCEL),
        ACCEPT(GTK.GTK_RESPONSE_ACCEPT), //如果改为分号则报错
        APPLY(GTK.GTK_RESPONSE_APPLY),
        REJECT(GTK.GTK_RESPONSE_REJECT),
        NONE(GTK.GTK_RESPONSE_NONE),&lt;br /&gt;
        HELP(GTK.GTK_RESPONSE_HELP),
        DELETE_EVENT(GTK.GTK_RESPONSE_DELETE_EVENT);&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    private  int value = 0;
    /**
     * 
     * @param value  构造函数的参数
     */
    private OOResponseType(int value)
    {
            this.value = value;
    }
    /**
     * 
     * @return  返回OOResponseType对象的int值
     */
    public int getValue()
    {
            return this.value;
    }
    /**
     * 
     * @param value   带解析的数字 在OOResponse枚举类中代表的枚举值
     * @return        返回一个OOResponseType对象
     */
    public static OOResponseType parseResponseType(int value)
    {
            OOResponseType[] apple = OOResponseType.values();
            for(int i = 0 ; i &amp;lt; apple.length; i++)
            {
                    if(value == apple[i].getValue())
                    {
                            return  apple[i];
                    }
            }
            throw new IllegalArgumentException(&amp;quot;ResponseValue = &amp;quot;+value+&amp;quot;是个不合法的参数&amp;quot;);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;

OODialog的封装修改
OODialog封装的思路：分成两个区域进行封装 actionarea     contentarea     Run函数（返回responseType枚举对象）  response（解析responsetype类型，就是你传给一个responseType类型的参数给你在对话框上面响应一个函数）。

涉及到OOContainer    定义了一个无参构造函数和一个有参构造函数；无参构造函数是为了防止子类报错，因为当父类定义了有参构造函数，
                  无参构造函数默认会被屏蔽，所以增加一个protected无参构造函数，可以防止类似于OOContainer的子类OOBin不会 报错。
                   默认OOBin会调用的构造函数是   public OOBin(){super();}  ;//而super默认即是指 OOContainer(){}如果没有
                   则会报错。
       OODialog
       OOResponseType --?涉及到枚举的知识-?枚举类的定义减少用户输错的可能性，增加程序的稳定性


还是得再次使用枚举类OOMESSAGEType 以及OOButtonsType来显示不同的对话框类型！  类似于OOResponseType（当时并不知道考虑去封装这一步 还一直傻呵呵利用GTK_MESSAGE_ERROR之类的）,封装了一个信息类

再次复习了OOResponseTyep的parseResponseType的方法实现。


TreeView的封装思路
1：MVC的V  建立一个View
2：MVC的M  建立一个OOListStore  和OOTreeIter(注意和OOTextIter的区别）
3：MVC的C  用于控制view和listmodel
详看练习TestOOTreeView

一种新的编程方式：玻璃出来业务逻辑从main函数中，减少界面的组合过程，main只是负责显示。

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java
/**
*
*/
package GTKEncapsulate;&lt;/p&gt;

&lt;p&gt;import com.rupeng.gtk4j.GTK;
import com.rupeng.gtk4j.IGCallBack;&lt;/p&gt;

&lt;p&gt;/**
* @author    叶昭良
* @time      2015年2月9日下午1:33:31
* @version   GTKEncapsulateTestOOTreeView2Window V1.0
*/
public class TestOOTreeView2Window extends OOWindow
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /**
     * @param args
     */
    private static OOTreeView otv ;
    public TestOOTreeView2Window() 
    {

            //设置布局
            otv = new  OOTreeView();
            otv.addField(&amp;quot;ID&amp;quot;, 0);
            otv.addField(&amp;quot;Name&amp;quot;, 1);
            otv.addField(&amp;quot;Age&amp;quot;, 2);

            otv.createModel(3);
            otv.setFieldValue(&amp;quot;001&amp;quot;, &amp;quot;yezhao&amp;quot;, &amp;quot;21&amp;quot;);
            otv.setFieldValue(&amp;quot;002&amp;quot;, &amp;quot;huowa&amp;quot;, &amp;quot;32&amp;quot;);
            otv.setFieldValue(&amp;quot;003&amp;quot;, &amp;quot;yefeng&amp;quot;, &amp;quot;31&amp;quot;);
            OOScrollBar osb = new OOScrollBar();
            osb.show();
            osb.setWidgetSize(300, 300);
            osb.addView(otv);
            //otv.addScrollBar(grid, 0, 200, 200);

            //显示
            otv.fillModel();
            otv.show();
            otv.setRecordColumn(2);
            otv.setResizeColumn(2);
            otv.setColumnSort(2);
            otv.setMultipleSelect();
            System.out.println(otv.getliststore().getValue(1, 1));
            System.out.println(otv.getliststore().getValue(2, 1));
            System.out.println(otv.getliststore().getValue(2, 2));
            otv.addDoubleClickedListener(new IGCallBack()
            {

                    @Override
                    public void execute(int instance, int eventData, Object object)
                    {
                            int[] selection = otv.getMultipleSelectRows();
                            for(int i = 0; i &amp;lt; selection.length; i++)
                            {
                                    //System.out.println(&amp;quot;selection&#39;s length== &amp;quot;+ selection.length+&amp;quot;当前行&amp;quot;+selection[i]);
                                    //values[i]  = otv.getliststore().getValue(selection[i], 1);
                                    OOMessageDialog.showInfo(&amp;quot;选中的信息为&amp;quot;+otv.getliststore().getValue(selection[i], 1), &amp;quot;用户名&amp;quot;);
                            //        System.out.println(&amp;quot;selection[&amp;quot;+i+&amp;quot;]&amp;quot;+selection[i]);
                            }
                    }
            });
            this.add(osb);
    }
    public static void main(String[] args)
    {
            // TODO Auto-generated method stub
            GTK.gtk_init();
            //TestOOTreeView2Window 的封装的责任是新建字段 添加数据 加入监听  main不负责这些事情，main只是显示
            TestOOTreeView2Window ttv2w = new TestOOTreeView2Window();
            ttv2w.setExitAfterDestroy(true);
            ttv2w.show();
            GTK.gtk_main();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;

2月8号练习：

1：学习了接口类，并利用接口类进一步学习了匿名类对接口类的实现，在多处体现，比如比如打开文件夹 的处理可以放在匿名接口类
      比如封装的treeView的双击时间的匿名接口类的实现,比如画图板的draw事件的匿名接口类的实现

2：封装了OODrawingArea  和 OODrawCallback（待实现drawCairo方法）接口，进一步理解了匿名接口类

3：学习了枚举类用于封装OOResponseTyep   OOMessageType  OOFileAction   OOButtonsType四个枚举类，
    这样可以减少用户输入参数的错误

4：封装了消息对话框  OOMessageDialog  ，包含showInfo  showError 等，兵删掉OOWidget中的showInfo等函数

5：继承OODialog实现了OOInputDialog，了解了ActionArea和contentArea

6: 修改了OOFileChooser的实现，利用OOFileAction枚举类在修改，并增加部分函数

7：修改了OOTreeView的实现，玻璃出OOListStore和OOlistIter这两个类，并进一步的在OOTreeView的内部中新建了
   两个内部类OOColumn  OOSelection，更加体现面向对象的过程。

8：修改了OOToolBar的实现，为了让外包可以访问工具栏的按钮，增加了一个共有的OOToolButton类

9：修改了OOContainer类的方法，利用对象直接添加。

10：增加了一个测试包TestGTKEncapsulate，用于测试。

源码V5.0版本 类增加到46个类，不包含内部类，并做了外包测试，修正了使用，已在TestGTKEncapsulate文件夹。

面向对象：让对象自己去做自己的内部逻辑，就好像我们自己去打扮我们自己的程序，main（杨老师）定义了一个对象，然后一个show而已。面向对象其实就是师傅领进门修行在个人。


2-9号笔记和练习
第一部分 笔记
1计时器的使用
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java
                GTK.g_timeout_add(1000, new IGSourceFunc()
                {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                    @Override
                    public boolean execute(Object userdata)
                    {
                            // TODO Auto-generated method stub
                            getTime();
                            return true;
                    }
            }, null);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
说明： 1000表示1000ms也就是1s
          IGS...是一个回调函数，当return为true时候继续监听，当return为false则停止计时器的即使，所以如果一直为true，则计时器一直再走。
2：打开音乐
GTK.mci_play(filename)  打开音乐
      GTK.mci_close(deviceID) 关闭音乐

3： OOToolButton 没有OOToolItem的 setToolTip的方法，但是在OOToolButton可以设置图片
并进行监听。OOToolButton暂时用的多。

4. OODialog response的作用
理解了OODialog的response的作用之后，重新修改了，OOInputDialog等继承自OODialog的空间。
  response是使得添加进dialog的控件能够发出某种信号！！ 当我们定义完之后，后期新建一个对象，并run之后，就会返回一个信号（可能来自原先的dialog的信号，也可能是按钮的信号，这边的按钮不再用clicked事件进行外部监听了，但是其实是封装在对应的dialog子类控件中，表面上是活的对话框的OOResponseTyep的信号，其实内部也是触发了clicked事件，只不过是在clicked事件中，调用response函数，发出对应的OOResponseTyep的信号）

5：LED时钟
a. 冒号和空图片的切换
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java
colon1.setResourceImage(&amp;ldquo;ledclock//&amp;rdquo;+(secondGe%2==1?&amp;ldquo;colon&amp;rdquo;:&amp;ldquo;empty&amp;rdquo;)+&amp;ldquo;.png&amp;rdquo;);&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
b.LED的整点报时
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java
String[] table = {&amp;ldquo;零&amp;rdquo;,&amp;ldquo;壹&amp;rdquo;,&amp;ldquo;贰&amp;rdquo;,&amp;ldquo;叁&amp;rdquo;,&amp;ldquo;肆&amp;rdquo;,&amp;ldquo;伍&amp;rdquo;,&amp;ldquo;陆&amp;rdquo;,&amp;ldquo;柒&amp;rdquo;,&amp;ldquo;扒&amp;rdquo;,&amp;ldquo;玖&amp;rdquo;};
if( minute ==0 &amp;amp;&amp;amp; second == 0)
                {
                        System.out.println(&amp;ldquo;北京时间&amp;rdquo;+table[hourShi]+table[hourGe]+&amp;ldquo;整&amp;rdquo;);
                        OOMessageDialog.showInfo(&amp;ldquo;北京时间&amp;rdquo;+table[hourShi]+table[hourGe]+&amp;ldquo;整&amp;rdquo;, &amp;ldquo;整点消息&amp;rdquo;);
                }&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;

6：三重button：OOCalendarButton的封装
  目的：简化开发的过程，提供一个按钮，并让用户选择日期，回馈到按钮的标签上
  设计的三个类：
     OOCalendar (继承自OOContainer)
     OOCalendarDialog(继承自OODialog) 
     OOCalendarButton(继承自OOButton)


OOCalendarDialog的封装和OOInputDialog的封装基本上思路一样。在actionaArea添加两个按钮，在contentArea添加一个OOCalendar，进行对应的事件监听。

一个小bug:(自己犯的一点小错误)
OOCalendarButton 的
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java
SimpleDateFormat sdf = new SimpleDateFormat(&amp;ldquo;yyyy年mm月dd日&amp;rdquo;);&lt;/p&gt;

&lt;p&gt;改为
SimpleDateFormat sdf = new SimpleDateFormat(&amp;ldquo;yyyy年MM月dd日&amp;rdquo;);&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;

一个重点：
    三种调用类私有变量date的方式
1 可以用  date = ocd.getDate();    直接写上date,那么编译器会从内往外一层一层走，直到
找到date,所以可能会造成外层需要被赋值的date并未被赋值，而里层不需要赋值的date反而
赋值了
2.  this.date  也可能会造成错误，比如在一个匿名类中，那么this.date的意思就是匿名类的date,如果匿名类没有定义date，则报错

3 OOCalendarButton.this.date = ocd.getDate();  //最好的一种方法 
//OOCalendarButton的this对象，直接找到该类中的类变量。

第二部分  练习

1： 计时器
case1  progereeBar 的安装条
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java
package GTKEncapsulate;&lt;/p&gt;

&lt;p&gt;import com.rupeng.gtk4j.GTK;
import com.rupeng.gtk4j.IGCallBack;
import com.rupeng.gtk4j.IGSourceFunc;&lt;/p&gt;

&lt;p&gt;/**
* @author    叶昭良
* @time      2015年2月9日下午3:13:29
* @version   GTKEncapsulateTestOOProgressBar2Window V1.0
*/
public class TestOOProgressBar2Window extends OOWindow
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /**
     * @param args
     */
    private OOLabel  olApple = null;
    private OOProgressBar opbApple = null;
    private OOButton obApple = null;
    public  TestOOProgressBar2Window()
    {

            OOBox obtemp = new OOBox();
            obtemp.show();

            olApple = new OOLabel(&amp;quot;0&amp;quot;);
            olApple.show();
            obtemp.add(olApple);
            opbApple = new OOProgressBar();
            opbApple.setText(&amp;quot;请稍等&amp;quot;);
            opbApple.showText(&amp;quot;请稍后&amp;quot;);
            opbApple.show();
            obtemp.add(opbApple);

            obApple = new OOButton(&amp;quot;安装&amp;quot;);
            obApple.show();
            obtemp.add(obApple);
            obApple.addClickedListener(new IGCallBack()
            {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;@Override
public void execute(int instance, int eventData, Object object)
{
        // TODO Auto-generated method stub
        GTK.g_timeout_add(1000, new IGSourceFunc()
        {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;            @Override
            public boolean execute(Object userdata)
            {
                    // TODO Auto-generated method stu
                    String txt = olApple.getText();        

                    int apple = Integer.parseInt(txt);

                    apple++;
                    olApple.setText(Integer.toString(apple));
                    double banana = apple*0.1;
                    if(banana== 1.0)
                    {
                            OOMessageDialog.showInfo(&amp;quot;安装完成&amp;quot;, &amp;quot;安装&amp;quot;);
                    }
                    opbApple.setProgress(banana);
                    return banana&amp;lt;=1;
            }
    }, null);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
                });&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;            this.add(obtemp);


    }
    public static void main(String[] args)
    {
            // TODO Auto-generated method stub
            GTK.gtk_init();
            TestOOProgressBar2Window top2w = new TestOOProgressBar2Window();
            top2w.show();
            top2w.setExitAfterDestroy(true);
            GTK.gtk_main();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;

case2 LED灯+整点报时（未加上声音改用弹出对话框）
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java
package TestGTKEncapsulate;&lt;/p&gt;

&lt;p&gt;import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;&lt;/p&gt;

&lt;p&gt;import com.rupeng.gtk4j.GTK;
import com.rupeng.gtk4j.IGSourceFunc;&lt;/p&gt;

&lt;p&gt;import GTKEncapsulate.*;&lt;/p&gt;

&lt;p&gt;/**
* @author    叶昭良
* @time      2015年2月10日下午1:17:40
* @version   TestGTKEncapsulateLEDClock V1.0
*/
public class LEDClock extends OOWindow
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /**
     * @param args
     */
    private OOImage oiHourShi;

    private OOImage oiHourGe;
    private OOImage oiMinuteShi;
    private OOImage oiMinuteGe;
    private OOImage oiSecondShi;
    private OOImage oiSecondGe;
    private int hourShi;
    private int hourGe;
    private int minuteShi;
    private int minuteGe;
    private int secondShi;
    private int secondGe;
    private OOBox obApple;
    private OOImage colon1;
    private OOImage colon2;
    private OOLabel olDate;
    public LEDClock()
    {
            obApple = new OOBox();
            obApple.show();

            olDate = new OOLabel(&amp;quot;&amp;quot;);
            olDate.show();

            obApple.addWidget(olDate);

            oiHourShi = new OOImage();
            oiHourGe = new OOImage();
            colon1 = new OOImage();
            oiMinuteShi = new OOImage();
            oiMinuteGe = new OOImage();
            colon2 = new OOImage();
            oiSecondShi = new OOImage();
            oiSecondGe = new OOImage();
            obApple.addWidget(oiHourShi);
            obApple.addWidget(oiHourGe);
            obApple.addWidget(colon1);
            obApple.addWidget(oiMinuteShi);
            obApple.addWidget(oiMinuteGe);
            obApple.addWidget(colon2);
            obApple.addWidget(oiSecondShi);
            obApple.addWidget(oiSecondGe);
            getTime();

            GTK.g_timeout_add(1000, new IGSourceFunc()
            {

                    @Override
                    public boolean execute(Object userdata)
                    {
                            // TODO Auto-generated method stub
                            getTime();
                            return true;
                    }
            }, null);
            this.setWidgetSize(200, 100);
            this.add(obApple);
    }

    public void getTime()
    {
            String[] table = {&amp;quot;零&amp;quot;,&amp;quot;壹&amp;quot;,&amp;quot;贰&amp;quot;,&amp;quot;叁&amp;quot;,&amp;quot;肆&amp;quot;,&amp;quot;伍&amp;quot;,&amp;quot;陆&amp;quot;,&amp;quot;柒&amp;quot;,&amp;quot;扒&amp;quot;,&amp;quot;玖&amp;quot;};

            Date date = new Date();
            SimpleDateFormat sdf = new SimpleDateFormat(&amp;quot;yyyy年-MM月-dd日 &amp;quot;);
            String labelText = sdf.format(date);
            //System.out.println(labelText);
            olDate.setText(labelText);
            Calendar cl = Calendar.getInstance();
            cl.setTime(date);
            int hour = cl.get(Calendar.HOUR_OF_DAY);
            int minute = cl.get(Calendar.MINUTE);
            int second = cl.get(Calendar.SECOND);

            hourShi = hour/10;
            hourGe  = hour%10;
            minuteShi = minute/10;
            minuteGe = minute%10;
            secondShi = second/10;
            secondGe  = second%10;


            oiHourShi.setResourceImage(&amp;quot;ledclock//&amp;quot;+hourShi+&amp;quot;.png&amp;quot;);
            oiHourGe.setResourceImage(&amp;quot;ledclock//&amp;quot;+hourGe+&amp;quot;.png&amp;quot;);
            colon1.setResourceImage(&amp;quot;ledclock//&amp;quot;+(secondGe%2==1?&amp;quot;colon&amp;quot;:&amp;quot;empty&amp;quot;)+&amp;quot;.png&amp;quot;);
            oiMinuteShi.setResourceImage(&amp;quot;ledclock//&amp;quot;+minuteShi+&amp;quot;.png&amp;quot;);
            oiMinuteGe.setResourceImage(&amp;quot;ledclock//&amp;quot;+minuteGe+&amp;quot;.png&amp;quot;);
            colon2.setResourceImage(&amp;quot;ledclock//&amp;quot;+(secondGe%2==1?&amp;quot;colon&amp;quot;:&amp;quot;empty&amp;quot;)+&amp;quot;.png&amp;quot;);
            oiSecondShi.setResourceImage(&amp;quot;ledclock//&amp;quot;+secondShi+&amp;quot;.png&amp;quot;);
            oiSecondGe.setResourceImage(&amp;quot;ledclock//&amp;quot;+secondGe+&amp;quot;.png&amp;quot;);

            if( minute ==0 &amp;amp;&amp;amp; second == 0)
            {
                    System.out.println(&amp;quot;北京时间&amp;quot;+table[hourShi]+table[hourGe]+&amp;quot;整&amp;quot;);
                    OOMessageDialog.showInfo(&amp;quot;北京时间&amp;quot;+table[hourShi]+table[hourGe]+&amp;quot;整&amp;quot;, &amp;quot;整点消息&amp;quot;);
            }

    }
    public static void main(String[] args)
    {
            // TODO Auto-generated method stub
            GTK.gtk_init();
            LEDClock lc = new LEDClock();
            lc.show();
            lc.setExitAfterDestroy(true);
            GTK.gtk_main();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;

3小兵聊天工具：
事先封装了键盘上面的ASCII码  为一个枚举类OOKeycode:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java
package GTKEncapsulate;&lt;/p&gt;

&lt;p&gt;/**
* @author    叶昭良
* @time      2015年2月9日下午9:28:07
* @version   GTKEncapsulateOOKeycode V1.0  封装大部分的GTK对于键盘识别的keycode
&lt;em&gt;/
public enum OOKeycode
{
        //字母
                A(&amp;ldquo;键盘上的a&amp;rdquo;,65),
                B(&amp;ldquo;键盘上的b&amp;rdquo;,66),
                C(&amp;ldquo;键盘上的c&amp;rdquo;,67),
                D(&amp;ldquo;键盘上的d&amp;rdquo;,68),
                E(&amp;ldquo;键盘上的e&amp;rdquo;,69),
                F(&amp;ldquo;键盘上的f&amp;rdquo;,70),
                G(&amp;ldquo;键盘上的g&amp;rdquo;,71),
                H(&amp;ldquo;键盘上的h&amp;rdquo;,72),
                I(&amp;ldquo;键盘上的i&amp;rdquo;,73),
                J(&amp;ldquo;键盘上的j&amp;rdquo;,74),
                K(&amp;ldquo;键盘上的k&amp;rdquo;,75),
                L(&amp;ldquo;键盘上的l&amp;rdquo;,76),
                M(&amp;ldquo;键盘上的m&amp;rdquo;,77),
                N(&amp;ldquo;键盘上的n&amp;rdquo;,78),
                O(&amp;ldquo;键盘上的o&amp;rdquo;,79),
                P(&amp;ldquo;键盘上的p&amp;rdquo;,80),
                Q(&amp;ldquo;键盘上的q&amp;rdquo;,81),
                R(&amp;ldquo;键盘上的r&amp;rdquo;,82),
                S(&amp;ldquo;键盘上的s&amp;rdquo;,83),
                T(&amp;ldquo;键盘上的t&amp;rdquo;,84),
                U(&amp;ldquo;键盘上的u&amp;rdquo;,85),
                V(&amp;ldquo;键盘上的v&amp;rdquo;,86),
                W(&amp;ldquo;键盘上的w&amp;rdquo;,87),
                X(&amp;ldquo;键盘上的x&amp;rdquo;,88),
                Y(&amp;ldquo;键盘上的y&amp;rdquo;,89),
                Z(&amp;ldquo;键盘上的z&amp;rdquo;,90),
        //数字
            NUM_0(&amp;ldquo;键盘上的0和)&amp;rdquo;,48),
            NUM_1(&amp;ldquo;键盘上的1和!&amp;rdquo;,49),
            NUM_2(&amp;ldquo;键盘上的2和@&amp;rdquo;,50),
            NUM_3(&amp;ldquo;键盘上的3和#&amp;rdquo;,51),
            NUM_4(&amp;ldquo;键盘上的4和[        DISCUZ_CODE_6        ]quot;,52),
            NUM_5(&amp;ldquo;键盘上的5和%&amp;rdquo;,53),
            NUM_6(&amp;ldquo;键盘上的6和^&amp;rdquo;,54),
            NUM_7(&amp;ldquo;键盘上的7和&amp;amp;&amp;ldquo;,55),
            NUM_8(&amp;ldquo;键盘上的8和&lt;/em&gt;&amp;rdquo;,56),
            NUM_9(&amp;ldquo;键盘上的9和(&amp;rdquo;,57),
        //比较重要的几个按键
            SHIFT(&amp;ldquo;键盘上的SHIFT键&amp;rdquo;,16),
            CTRL(&amp;ldquo;键盘上的ctrl键&amp;rdquo;,17),
            ALT(&amp;ldquo;键盘上的ALT键&amp;rdquo;,18),
            CAPS_LOCK(&amp;ldquo;键盘上的大写键&amp;rdquo;,20),
            ESC(&amp;ldquo;键盘上的ESC键&amp;rdquo;,27),
            TAB(&amp;ldquo;键盘上的Tab键&amp;rdquo;,9),
            RIGTH_SHIFT(&amp;ldquo;键盘上右边的SHIFT键&amp;rdquo;,161),
            RIGHT_CTRL(&amp;ldquo;键盘上右边的ctrl键&amp;rdquo;,163),
            RIGHT_ALT(&amp;ldquo;键盘上右边的ALT键&amp;rdquo;,165),
            WINDOWS(&amp;ldquo;键盘上的WINDOWS键&amp;rdquo;,91),
            FN(&amp;ldquo;键盘上的FN键&amp;rdquo;,17),
            BACKSPACE(&amp;ldquo;键盘上的baskspace回退键&amp;rdquo;,8),
            SPACE(&amp;ldquo;键盘上的空格键&amp;rdquo;,32),
        //方向键
            LEFT(&amp;ldquo;键盘上的左方向键&amp;rdquo;,37),
            UP(&amp;ldquo;键盘上的上方向键&amp;rdquo;,38),
            RIGHT(&amp;ldquo;键盘上的右方向键&amp;rdquo;,39),
            DOWN(&amp;ldquo;键盘上的下方向键&amp;rdquo;,40),&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    //小键盘数字 当前情况下必须是在小键盘开启的情况下，否则会匹配错误
        SMALLBOARD_0(&amp;quot;小键盘上的0和insert&amp;quot;,96),
        SMALLBOARD_1(&amp;quot;小键盘上的1和end&amp;quot;,97),
        SMALLBOARD_2(&amp;quot;小键盘上的2和向下方向键&amp;quot;,98),
        SMALLBOARD_3(&amp;quot;小键盘上的3和pgdn&amp;quot;,99),
        SMALLBOARD_4(&amp;quot;小键盘上的4和向左方向键&amp;quot;,100),
        SMALLBOARD_5(&amp;quot;小键盘上的5&amp;quot;,101),
        SMALLBOARD_6(&amp;quot;小键盘上的6和向右方向键&amp;quot;,102),
        SMALLBOARD_7(&amp;quot;小键盘上的7和home&amp;quot;,103),
        SMALLBOARD_8(&amp;quot;小键盘上的8和向上方向键&amp;quot;,104),
        SMALLBOARD_9(&amp;quot;小键盘上的9和pgdn&amp;quot;,105),
    //小键盘上的+ - * /
        SMALLBOARD_PLUS(&amp;quot;小键盘上的加号&amp;quot;,107),
        SMALLBOARD_MINUS(&amp;quot;小键盘上的减号&amp;quot;,109),
        SMALLBOARD_MULTIPLY(&amp;quot;小键盘上的乘号&amp;quot;,106),
        SMALLBOARD_DIVIDE(&amp;quot;小键盘上的除号&amp;quot;,111),
    //小键盘上的enter和点号（delete),enter和主键盘一样
        SMALLBOARD_DELETE(&amp;quot;小键盘上的点号&amp;quot;,110),
        ENTER(&amp;quot;小键盘上的ENTER以及主键盘的ENTER&amp;quot;,13),

    //右手边的一些符号键
        SINGLEQUOTE(&amp;quot;键盘上的双引号和单引号&amp;quot;,222),
        SEMICOLON(&amp;quot;键盘上的分号和冒号colon键&amp;quot;,186),
        COMMA(&amp;quot;键盘上的逗号键和&amp;lt;&amp;quot;,188),
        POINT(&amp;quot;键盘盘上的句号和&amp;gt;&amp;quot;,190),
        SLASH(&amp;quot;键盘上的/正斜杠表示除法和问号&amp;quot;,191),
        BACKSLASH(&amp;quot;键盘上的反斜杠\\和竖线&amp;quot;,220),
        LEFTSQUARE(&amp;quot;键盘上的左中括号和左大括号&amp;quot;,219),
        RIGHTSQUARE(&amp;quot;键盘上的右中括号和右大括号&amp;quot;,221),

        DASH(&amp;quot;键盘上的破折号和减号&amp;quot;,189),
        EQUAL(&amp;quot;键盘上的等号和加号&amp;quot;,187),
        REVERSEQUOTE(&amp;quot;键盘上的反引号和约等号&amp;quot;,192),

      //一些不经常用的
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;//            PRINT(&amp;ldquo;键盘上的PRINT&amp;rdquo;,)
            PAUSE(&amp;ldquo;键盘上的暂停键和break&amp;rdquo;,19),
            DELETE(&amp;ldquo;键盘上的delete和insert键&amp;rdquo;,46),
            HOME(&amp;ldquo;键盘上的HOME键&amp;rdquo;,36),
            PAGEUP(&amp;ldquo;键盘上的PAGEUP&amp;rdquo;,33),
            PAGEDOWN(&amp;ldquo;键盘上的PAGEDOWN&amp;rdquo;,34),
            END(&amp;ldquo;键盘上的END&amp;rdquo;,35),
            NUMLOCK(&amp;ldquo;键盘上的NUMLOCK&amp;rdquo;,144),&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        //F1--F12
        F1(&amp;quot;键盘上的F1键&amp;quot;,112),
        F2(&amp;quot;键盘上的F2键&amp;quot;,113),
        F3(&amp;quot;键盘上的F3键&amp;quot;,114),
        F4(&amp;quot;键盘上的F4键&amp;quot;,115),

        F5(&amp;quot;键盘上的F5键&amp;quot;,116),
        F6(&amp;quot;键盘上的F6键&amp;quot;,117),
        F7(&amp;quot;键盘上的F7键&amp;quot;,118),
        F8(&amp;quot;键盘上的F8键&amp;quot;,119),
        F9(&amp;quot;键盘上的F9键&amp;quot;,120),
        F10(&amp;quot;键盘上的F10键&amp;quot;,121),
        F11(&amp;quot;键盘上的F11键&amp;quot;,122),
        F12(&amp;quot;键盘上的F12键&amp;quot;,123),
        ;




    //ctrl shift tab caps_lock  , . ; / &#39; [ ]的
    private int keycode;
    private String keyName;
    private OOKeycode(String keyName,int keycode)
    {
            this.keyName = keyName;
            this.keycode = keycode;
    }

    public int getKeycode()
    {
            return this.keycode;
    }
    public String getKeyName()
    {
            return this.keyName;
    }

    public static OOKeycode parseOOKeycode(int keycode)
    {
            OOKeycode[] apples = OOKeycode.values();
            for(int i = 0 ; i &amp;lt; apples.length; i++)
            {
                    if(keycode == apples[i].getKeycode())
                    {
                            return apples[i];
                    }
            }
            throw new IllegalArgumentException(keycode+&amp;quot;是一个不合法的参数&amp;quot;);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
修改了OOEntry, 添加一个键盘敲击响应事件
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java
public void addKeyPressListener(final IGCallBack callback)
        {
                GTK.g_signal_connect(this.getId(), &amp;ldquo;key-press-event&amp;rdquo;, new IGCallBack()
                {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                    @Override
                    public void execute(int instance, int eventData, Object object)
                    {
                            // TODO Auto-generated method stub
                            callback.execute(instance, eventData, object);
                    }
            }, null);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;小兵聊天主程序

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java
package TestGTKEncapsulate;&lt;/p&gt;

&lt;p&gt;import javax.xml.crypto.dsig.keyinfo.KeyValue;&lt;/p&gt;

&lt;p&gt;import com.rupeng.gtk4j.GTK;
import com.rupeng.gtk4j.IGCallBack;&lt;/p&gt;

&lt;p&gt;import GTKEncapsulate.OOContainer;
import GTKEncapsulate.OODialog;
import GTKEncapsulate.OOEntry;
import GTKEncapsulate.OOFileChooser;
import GTKEncapsulate.OOGrid;
import GTKEncapsulate.OOImage;
import GTKEncapsulate.OOKeycode;
import GTKEncapsulate.OOMessageDialog;
import GTKEncapsulate.OOMusic;
import GTKEncapsulate.OOMusicMode;
import GTKEncapsulate.OOScrollBar;
import GTKEncapsulate.OOTextView;
import GTKEncapsulate.OOWindow;
//import GTKEncapsulate.OpenFile;&lt;/p&gt;

&lt;p&gt;/**
* @author    叶昭良
* @time      2015年2月9日下午8:20:47
* @version   TestGTKEncapsulateTestXiaoBingWindow V1.0
*                                                         V2.0  把所有的equalsIgnoreCase 改为contains 只需要字符串包含即可，
*/
public class TestXiaoBingWindow extends OOWindow
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /**
     * @param args
     */
    private  OOEntry oeApple ;
    private OOTextView otvApple;
    private OOImage oim;
    private OOMusic om;
    public TestXiaoBingWindow()
    {
            OOGrid grid = new OOGrid();
            oeApple = new OOEntry();
            oeApple.show();
            //oeApple.setText(&amp;quot;请在这边输入文本：&amp;quot;);
            otvApple = new OOTextView();
            otvApple.show();
            otvApple.setEditable(false);
            OOScrollBar osbApple = new OOScrollBar();
            osbApple.show();
            osbApple.setWidgetSize(300, 300);
            osbApple.add(otvApple);

            grid.add(osbApple, 0);
            grid.add(oeApple,1);
            grid.show();
            this.add(grid);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;//                GTK.MCI_MODE_OPEN&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;            //设置监听
            oeApple.addKeyPressListener(new IGCallBack()
            {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;@Override
public void execute(int instance, int eventData, Object object)
{
        // TODO Auto-generated method stub
        int keycode = GTK.gdk_event_get_keycode(eventData);
        if(keycode == OOKeycode.ENTER.getKeycode())
        {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;            String text = oeApple.getText();
            otvApple.insertTextAtEnd(&amp;quot;你说:&amp;quot;+text+&amp;quot;\n&amp;quot;);
            oeApple.setText(&amp;quot;&amp;quot;);
            //text.contains
            if(text.contains(&amp;quot;你好啊&amp;quot;))
            {
                    otvApple.insertTextAtEnd(&amp;quot;小兵说:&amp;quot;+&amp;quot;好你妹！\n&amp;quot;);
            }else if(text.contains(&amp;quot;脱衣舞&amp;quot;))
            {
                    otvApple.insertTextAtEnd(&amp;quot;小兵说:&amp;quot;+&amp;quot;不跟你玩了\n&amp;quot;);
            }else if(text.contains(&amp;quot;今年几岁&amp;quot;))
            {
                    otvApple.insertTextAtEnd(&amp;quot;小兵说:&amp;quot;+&amp;quot;女孩子的年龄不能随便告诉别人\n&amp;quot;);
            }else if(text.contains(&amp;quot;你是男的还是女的&amp;quot;))
            {
                    otvApple.insertTextAtEnd(&amp;quot;Little Bing Said:&amp;quot;+&amp;quot;You guess\n&amp;quot;);
            }else if(text.contains(&amp;quot;让我们去外面玩吧&amp;quot;))
            {
                    otvApple.insertTextAtEnd(&amp;quot;Little Bing Said:&amp;quot;+&amp;quot;去哪里玩？\n&amp;quot;);
            }else if(text.contains(&amp;quot;select&amp;quot;))
            {
                    OpenFile ofApple = new OpenFile();
                    ofApple.setMultipleSelect();
                    ofApple.createFilter();
                    ofApple.nameFilter(&amp;quot;音乐文件&amp;quot;);
                    ofApple.editFilter(&amp;quot;*.MP3&amp;quot;);
                    ofApple.editFilter(&amp;quot;*.wav&amp;quot;);
                    //把filter的操作放入打开对话框中
                    ofApple.finishFilter();
                    String[] filenames = ofApple.processResponse();
                    //在src文件夹下
                    om = new OOMusic(filenames[0]);
                    om.playOnce();
            }else if(text.contains(&amp;quot;sing&amp;quot;))
            {
                    //在src文件夹下
                    om = new OOMusic(&amp;quot;breathless.mp3&amp;quot;,false);
                    om.playOnce();
            }else if(text.contains(&amp;quot;pause&amp;quot;))
            {
                    //在src文件夹下

                    om.pause();
            }else if(text.contains(&amp;quot;resume&amp;quot;))
            {
                    //在src文件夹下

                    om.pause();
            }else if(text.contains(&amp;quot;close&amp;quot;))
            {
                    //在src文件夹下

                    om.close();
            }else if(text.contains(&amp;quot;show&amp;quot;))
            {
                    OODialog od = new OODialog();
                    OOContainer oct = od.createContentArea();
                    oim = new OOImage();
                    oim.setResourceImage(&amp;quot;hunsha.jpg&amp;quot;);
                    oim.setWidgetSize(200, 200);
                    oim.show();
                    oct.add(oim);
                    od.run();
                    od.destroy();
            }
            else if(text.contains(&amp;quot;北京怎么样&amp;quot;))
            {
                    otvApple.insertTextAtEnd(&amp;quot;Little Bing Said:&amp;quot;+&amp;quot;不怎么样，先这样，改天再聊\n&amp;quot;);       
            }else
            {
                    otvApple.insertTextAtEnd(&amp;quot;小兵说：没听见，再说一遍\n&amp;quot;);
            }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;//                                System.out.println(OOKeycode.parseOOKeycode(keycode).getKeyName());
}
});
/*GTK.g_signal_connect(oeApple.getId(), &amp;ldquo;key-press-event&amp;rdquo;, new IGCallBack()
                {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                    @Override
                    public void execute(int instance, int eventData, Object object)
                    {
                            // TODO Auto-generated method stub
                            int keycode = GTK.gdk_event_get_keycode(eventData);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;//                                System.out.println(keycode);
                                System.out.println(OOKeycode.parseOOKeycode(keycode).getKeyName());
                                //int value = GTK.gdk_event_get_keyval(eventData);
                                //String enterCharacterString= String.valueOf(keycode);
                                //System.out.println(enterCharacterString);
                                //char enterCharacter = enterCharacterString.charAt(0);
                                //String text = oeApple.getText();
                                //char lastchar = text.charAt(text.length()-1);
                                //System.out.println(text+&amp;ldquo;text length=&amp;rdquo;+text.length());
//                                System.out.println(&amp;ldquo;当前输入的字符&amp;rdquo;+enterCharacter+&amp;ldquo;的ascii码为:&amp;ldquo;+keycode+&amp;rdquo;\n并且的他的10进制数为&amp;rdquo;+value);
//                                OOMessageDialog.showInfo(&amp;ldquo;当前输入的字符&amp;rdquo;+enterCharacter+&amp;ldquo;的ascii码为:&amp;ldquo;+keycode+&amp;rdquo;\n并且的他的10进制数为&amp;rdquo;+value, &amp;ldquo;学习ASCII码&amp;rdquo;);
                                //System.out.println(&amp;ldquo;当前输入的字符&amp;rdquo;+enterCharacter+&amp;ldquo;的ascii码为:&amp;ldquo;+keycode);
                                //OOMessageDialog.showInfo(&amp;ldquo;当前输入的字符&amp;rdquo;+enterCharacter+&amp;ldquo;的ascii码为:&amp;ldquo;+keycode, &amp;ldquo;学习ASCII码&amp;rdquo;);
                        }
                }, null);*/
}
        public static void main(String[] args)
        {
                // TODO Auto-generated method stub
                GTK.gtk_init();
                TestXiaoBingWindow txbw = new TestXiaoBingWindow();
                txbw.setExitAfterDestroy(true);
                txbw.show();
                GTK.gtk_main();
        }
        class OpenFile extends OOFileChooser
        {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;            @Override
            public  String[] processResponse()
            {
                    String[] filenames = null;
                    // TODO Auto-generated method stub
                    int ret = this.run().getValue();
                    if(ret == GTK.GTK_RESPONSE_OK) 
                    {
                            filenames = GTK.gtk_file_chooser_get_filenames(this.getId());
                            for(int i = 0 ; i&amp;lt; filenames.length ; i++)
                            {

                                    System.out.println(&amp;quot;选中文件名&amp;quot;+i+&amp;quot;: &amp;quot;+filenames[i]);
                            }
                            GTK.gtk_widget_destroy(this.getId()); //必须需要！！否则报错
                    }else
                    {
                            GTK.gtk_widget_destroy(this.getId());
                    }
                    return filenames;
            }

            @Override
            public void processResponse1()
            {
                    // TODO Auto-generated method stub

            }                
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;


4 音乐的使用+定时器+图片空间+textview === 女神表达神器之爱的誓言

在敲完誓言之后，开始播放音乐
未修复的bug: 有时候读着读着文字就崩溃了， 另外加入背景音乐也不行。。。相当不稳定。
最大的bug:  memery  error.......
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java
package TestGTKEncapsulate;
import com.rupeng.gtk4j.GTK;
import com.rupeng.gtk4j.IGSourceFunc;&lt;/p&gt;

&lt;p&gt;import GTKEncapsulate.*;&lt;/p&gt;

&lt;p&gt;/**
* @author    叶昭良
* @time      2015年2月10日上午1:17:57
* @version   TestGTKEncapsulateTestGrilGift V1.0 女朋友表达神器
*/
public class TestGirlGift extends OOWindow
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /**
     * @param args
     */
    private OOImage oim ;
    private OOTextView otv;
    private OOMusic om ;
    public TestGirlGift() 
    {
            OOBox ob =new OOBox(false);
            ob.show();
            oim = new OOImage();
            oim.setResourceImage(&amp;quot;yumufeng.jpg&amp;quot;);
            oim.show();
            ob.addWidget(oim);
            otv = new OOTextView();
            otv.show();
            otv.setType();
            OOScrollBar osb = new OOScrollBar();
            osb.show();
            osb.setWidgetSize(200, 220);
            osb.add(otv);
            ob.addWidget(osb);
            this.add(ob);

            final StringBuilder love = new StringBuilder();
            // +号之后都会出现bug
            final String Lovewords = &amp;quot;欣然:\r\n谢谢你给我的所有关怀和理解，尤其是那些孤立无助的时刻你温暖的陪伴，它让我始终强大坚定!\r\n&amp;quot;
                +&amp;quot;我要让你成为世界上最幸福的女人,不是因为这一生积累的名望,地位与财富,而仅仅因为我默默恒久的爱!\r\n&amp;quot;
                +&amp;quot;今天,说出这些话语是那么艰难却又那么快乐,这都是我这么长时间以来埋在心底的话语!这一切只是因为下面我要唱给&amp;quot;
                +&amp;quot;你听的这首歌的名字:我如此爱你!\r\n落款人：叶昭良 &amp;quot;;
            love.append(Lovewords);
    //这个过程是慢慢地，但是一直持续的在运行
            GTK.g_timeout_add(100, new IGSourceFunc()
            {

                    @Override
                    public boolean execute(Object userdata)
                    {
                            // TODO Auto-generated method stub
                            int len = otv.getText().length();
                            char ch = love.charAt(len);
                            otv.insertTextAtEnd(Character.toString(ch));
                            if(otv.getText().length() == love.length()-1)
                            {
                                    //om.close();
                                    om = new OOMusic(&amp;quot;我如此爱你.mp3&amp;quot;,true);
                                    om.playRepeat();
                                    return true;
                            }else if(otv.getText().length() == love.length())
                            {
                                    return false;
                            }
                            else
                            { 

                                    //System.out.println(&amp;quot;2&amp;quot;);
                                    return true;
                            }

                    }
            }, null);

            //System.out.println(&amp;quot;134&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;/*                if(otv.getText().length() == Lovewords.length()-1)
                {
                        System.out.println(&amp;ldquo;12&amp;rdquo;);
                        OOMusic om = new OOMusic(&amp;ldquo;我如此爱你.mp3&amp;rdquo;,true);
                        om.playRepeat();
                }&lt;em&gt;/
                //不能放在里面。。。
                //暂时有问题  添加报错   只好让他在写字的时候专心写字，不放背景音乐
/&lt;/em&gt;                om = new OOMusic(&amp;ldquo;ISurrender.mp3&amp;rdquo;,true);
                om.playOnce();*/
        }
        public static void main(String[] args)
        {
                // TODO Auto-generated method stub
                GTK.gtk_init();
                TestGirlGift tgg = new TestGirlGift();
                tgg.setTitle(&amp;ldquo;女神表达神器之爱的誓言&amp;rdquo;);
                tgg.show();
                tgg.setExitAfterDestroy(true);
                GTK.gtk_main();
        }&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;


5OOCalendarButton的创建

具体的OOCalendarDialog   OOCalendarButton的封装详见   GTKEncapsulate源码6.0

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java
package TestGTKEncapsulate;&lt;/p&gt;

&lt;p&gt;import com.rupeng.gtk4j.GTK;
import com.rupeng.gtk4j.IGCallBack;&lt;/p&gt;

&lt;p&gt;import GTKEncapsulate.*;&lt;/p&gt;

&lt;p&gt;/**
* @author    叶昭良
* @time      2015年2月10日下午2:48:55
* @version   TestGTKEncapsulateTestCalendar V1.0
*/
public class TestCalendar extends OOWindow
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /**
     * @param args
     */
    private OOCalendar ocl ;
    private OOCalendarDialog ocld;
    private OOBox obApple;
    private OOButton btnclick;
    private OOCalendarButton ocbApple;
    public TestCalendar()
    {
            ocl = new OOCalendar();
            ocl.show();

            btnclick = new OOButton(&amp;quot;点击&amp;quot;);
            btnclick.show();
            btnclick.addClickedListener(new IGCallBack()
            {

                    @Override
                    public void execute(int instance, int eventData, Object object)
                    {
                            // TODO Auto-generated method stub
                            ocld = new OOCalendarDialog();
                            ocld.show();
                    }
            });

            ocbApple = new OOCalendarButton(&amp;quot;选择日期&amp;quot;);
            ocbApple.show();


            obApple = new OOBox();
            obApple.addWidget(ocl);
            obApple.addWidget(btnclick);
            obApple.addWidget(ocbApple);
            obApple.show();

            System.out.println(ocl.getDay()+ocl.getMonth()+ocl.getYear());
            this.add(obApple);
    }
    public static void main(String[] args)
    {
            // TODO Auto-generated method stub
            GTK.gtk_init();
            TestCalendar tc = new TestCalendar();
            tc.show();
            tc.setExitAfterDestroy(true);
            GTK.gtk_main();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;

当前主要的OO库加上枚举类总的有56个，V6.0主要增加了  OOImageButton , OOKeycode,OOMusic, OOMusicMode ,OOMusicStatus,OOStockImage, OOStockSize,OOCalendarDialog，OOCalendarButton

GTKEncapsulate源码V6.0.rar




测试了一个toolbar控件，修正了ToolButton的构造函数没有设置ID的重大的bug

修改的代码：
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java
public class OOToolButton extends OOContainer
{
        /**
         * V2.0  新的构造方法
         * @param icon_widget
         * @param label
         */
        public OOToolButton(OOWidget icon_widget,String label)
        {
                //如果为0 则工具栏控件没有图片
                int icon_widgetID = (icon_widget==null)?0:icon_widget.getId();
                //GTK.gtk_tool_button_new(icon_widgetID, label) 已添加setId否则报错
                setId(GTK.gtk_tool_button_new(icon_widgetID, label));
        }&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;

测试代码就是之前2月6号的TestMenuFileChooseAndToolBar.java
因为采用了新的封装的ToolButton类，所以重新测试，发现了在ToolButton类构造函数缺失setId()的问题，特此修正


OOFileChooser为抽象类，使用起来不是特别舒服，于是改变成为非抽象的，并提供一个接口，供用户使用。
具体OOFileChooser的修改如下：
县创建一个OOFileChooserInterface接口：
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java
/**
*
*/
package GTKEncapsulate;&lt;/p&gt;

&lt;p&gt;/**
* @author    叶昭良
* @time      2015年2月13日下午2:13:25
* @version   GTKEncapsulateOOFileChooserInterface V1.0
*/
public interface OOFileChooserInterface
{
        public void doit();
}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;


然后在OOFileChooser类中开放接口并加入默认的两个处理打开和保存的函数：

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java
package GTKEncapsulate;&lt;/p&gt;

&lt;p&gt;import java.io.BufferedWriter;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;&lt;/p&gt;

&lt;p&gt;import com.rupeng.gtk4j.GTK;
import com.rupeng.gtk4j.IGCallBack;&lt;/p&gt;

&lt;p&gt;/**
* @author    叶昭良
* @time      2015年2月5日下午4:38:57
* @version   GTKEncapsulateOOFileChooser V1.0 把类标记为abstract，
*                                 这样的类无法被直接实例化（new），这就叫抽象类。
*  V2.0   修改了run方法
*  V3.0   抽象方法的返回值从void 该到了String[]
*  v4.0   修改OOFileChooser继承类为来自OODailog
*         并把public int run()方法提到OODialog中
*  V5.0   利用OOFileAction枚举类 重新编写了OOFIleChooser
*  V6.0   创建了setDoOverWrittenConfirmatio函数，并在封装构造函数中
*         运用了一个判断技巧，增加了 getFileName()  setCurrentFilename
*         createFileFolder
*  V7.0   从抽象类转变到非抽象类
*         增加了一个文件接口 OOFileChooserInterface 供用户使用
*         增加了打开文件和保存文件的默认处理方式
*/
public  class OOFileChooser extends OODialog
{
        private static Filter fi ;
        //private static int response;  //对话框的响应
        /**
         *
         * @param title     有参构造函数的窗口标题
         * @param action    有参构造函数的 行为，打开、保存。。
         * @param buttonText  有参构造函数的 按钮的标签名字
         *  创建一个文件对话框，对话框一定要run一下。。。。。 并且一定要摧毁它
         &lt;em&gt;/
/&lt;/em&gt;        public OOFileChooser(String title, int action, String buttonText)
        {
                setId(GTK.gtk_file_chooser_dialog_new(title, 0, action, buttonText));
        }*/
        public OOFileChooser(String title, OOFileAction action, String buttonText)
        {
                setId(GTK.gtk_file_chooser_dialog_new(title, 0, action.getValue(), buttonText));
                //一个封装技巧。
                if(action ==OOFileAction.SAVE)
                {
                        setDoOverWrittenConfirmation(true);
                }&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    }

    /**
     *   无参构造函数  默认为打开文件对话框说
     */
    public OOFileChooser()
    {
            this(&amp;quot;打开文件&amp;quot;, OOFileAction.OPEN, &amp;quot;打开&amp;quot;);
    }
    /**
     *   设置文件打开窗口的多选
     */
    public void setMultipleSelect() 
    {
            GTK.gtk_file_chooser_set_select_multiple(this.getId(), true);
    }
    /**
     * 
     * @param do_overwrite_confirmation  在save模式下，保存时需要判断是否覆盖
     */
    public void setDoOverWrittenConfirmation(boolean do_overwrite_confirmation)
    {
            GTK.gtk_file_chooser_set_do_overwrite_confirmation(this.getId(), do_overwrite_confirmation);
    }
    /**
     * 
     * @param text  设置当前选择的文件名为text
     */
    public void setCurrentFilename(String text)
    {
            GTK.gtk_file_chooser_set_current_name(this.getId(), text);
    }

    /**
     * 
     * @param create_folders  布尔值 用于判断是否创建。。。不清楚这边。
     */
    public void createFileFolder(boolean create_folders)
    {
            GTK.gtk_file_chooser_set_create_folders(this.getId(), create_folders);
    }
    /**
     *   创建一个过滤器
     */
    public void createFilter()
    {
            fi = new Filter();
    }
    /**
     * 
     * @param text     设置过滤器的名字
     */
    public void nameFilter(String text)
    {
            fi.setFilterName(text);
    }
    /**
     * 
     * @param pattern   增加过滤器的后缀
     */
    public void editFilter(String pattern)
    {
            fi.addFilterPattern(pattern);
    }

    public void finishFilter()
    {
            GTK.gtk_file_chooser_add_filter(this.getId(), fi.getId());
    }




    public String[]  getFileNames()
    {
            return GTK.gtk_file_chooser_get_filenames(this.getId());
    }

    public String  getFileName()
    {
            return GTK.gtk_file_chooser_get_filename(this.getId());
    }
    /**
     *   一个抽象方法 ，要求继承者去实现它
     *   多了一个
     *   
     *   V 可不可以用接口来实现，估计也是一样的下过
     */
    /**
     * 
     * @param ofci  开放了一个OOFileChooserInterface接口，
     *              用于处理打开文件和保存文件，需要进行的额外操作
     */
    public void processResponse(final OOFileChooserInterface ofci)
    {
            ofci.doit();
    }
    /**
     *   默认处理打开的函数的方式，得到文件！！ 显示到textview和treeview交给用户去做
     *   而processSave则交给OOFileChooser的processSave去做
     *   新版本改用OOResponseTyep的类型进行判断
     */
    public String[] processOpen()
    {
            String[] filenames = null;
            // TODO Auto-generated method stub
            OOResponseType ret = this.run();
            //int ret = this.run().getValue();
            if(ret == OOResponseType.OK) 
            {
                    filenames = GTK.gtk_file_chooser_get_filenames(this.getId());
                    for(int i = 0 ; i&amp;lt; filenames.length ; i++)
                    {

                            System.out.println(&amp;quot;选中文件名&amp;quot;+i+&amp;quot;: &amp;quot;+filenames[i]);
                    }
                    //GTK.gtk_widget_destroy(this.getId()); //必须需要！！否则报错
                    this.destroy();
            }else
            {
                    //GTK.gtk_widget_destroy(this.getId());
                    this.destroy();
            }
            return filenames;
    }
    /**
     *   默认处理保存对话框的方式   基本上默认是大部分采用的方式，
     *   保存文件的打开文件流有OOFileChooser去做
     *   
     *   暂时直接接受textview的文本信息，类似的可以使用OOTreeview
     *   
     *   新版本改用OOResponseTyep的类型进行判断
     */
    public void processSave(OOTextView ootv)
    {
            //GTK.gtk_file_chooser_set_do_overwrite_confirmation(this.getId(), true);
            // TODO Auto-generated method stub
            System.out.println(&amp;quot;已进入save&amp;quot;);
            //SaveOneFile(filename,textview);
            OOResponseType ret = this.run();
            //int ret = GTK.gtk_dialog_run(this.getId());
            if(ret == OOResponseType.CANCEL)
            {
                    this.destroy();
                    //GTK.gtk_widget_destroy(this.getId());
            }else 
            {
                    String filename =this.getFileName() ;
                    //保存文件
                    SaveOneFile(filename,ootv);
                    System.out.println(filename);
                    //GTK.gtk_widget_destroy(this.getId());
                    this.destroy();

            }
    }


    public static void SaveOneFile(String filename, OOTextView ootv)
    {
            try
            (
                    OutputStream os = new FileOutputStream(filename);
                    OutputStreamWriter osw = new OutputStreamWriter(os);
                    BufferedWriter bw = new BufferedWriter(osw);
            )
            {

                    String  temp= filename.substring(filename.lastIndexOf(&#39;\\&#39;)+1);
                    System.out.println(temp);

                    /*int textBuffer =  GTK.gtk_text_view_get_buffer(textview);
                    //这是一个空的iter，需要用textBuffer进行赋值
                    int textIter = GTK.gtk_text_iter_new();  

                    GTK.gtk_text_buffer_get_end_iter(textBuffer, textIter);
                    // 或者textview的textBuffer的末尾！
                    String tempText = GTK.gtk_text_buffer_get_text(textBuffer);*/

                    //while(tempText != null) // -1读取完毕
                    {
                            //InsertStringToTextViewFunction(textview,fileToFile.toString());
                            bw.write(ootv.getText());
                            bw.newLine();
                    //        GTK.gtk_text_iter_backward_char(textIter);
                    //        tempText = GTK.gtk_text_buffer_get_text(textBuffer);
                    }
            }
            catch(IOException e)
            {
                    System.out.println(&amp;quot;文件读入异常&amp;quot;);
            }

    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;/*        public abstract void processResponse1();  //用于保存
        public abstract String[] processResponse(); //用于打开
*/        /**
         *
         * @author    叶昭良
         * @time      2015年2月5日下午5:07:17
         * @version   GTKEncapsulateFilter V1.0
         */
        class Filter extends OOWidget
        {
                public Filter()
                {
                        setId(GTK.gtk_file_filter_new());
                }
                /**
                 *
                 * @param text   设置过滤器的名字
                 */
                public void setFilterName(String text)
                {
                        GTK.gtk_file_filter_set_name(this.getId(), text);
                }
                /**
                 *
                 * @param pattern  设置过滤器的过滤类型
                 */
                public void addFilterPattern(String pattern)
                {
                        GTK.gtk_file_filter_add_pattern(this.getId(), pattern);
                }&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
```&lt;/p&gt;

&lt;p&gt;附上 最新版本的封装GTK的源代码： 感兴趣的鹏友，可以下载交流哈。
最新的提交记录：1.修正了OOToolButton 缺少setId的一个重大bug
2.原先的OOFileChooser为抽象类，看起来不爽，于是再给OOFileChooser配置了一个接口和两个默认的处理函数
   一个用于打开一个用于关闭
3.修改了项目文件相关的  TestXiaoBingWindow.java  TestNewMenuFourStep.java&lt;br /&gt;
4.利用OOResponseTyep的判断方式修改代码
基本测试通过，同时顺便复习了内部类的接口类的实现和在一个类中添加接口的方式。
具体可以参看本贴第一次讲过的关于内部类实现接口的问题包含OODrawCallback和OOTreeView的双击事件的内部类的实现。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>3月21日Java周末班试题收集</title>
      <link>https://jueqingsizhe66.github.io/blog/2015/05/11/3yue-21ri-javazhou-mo-ban-shi-ti-shou-ji/</link>
      <pubDate>Mon, 11 May 2015 14:58:41 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/blog/2015/05/11/3yue-21ri-javazhou-mo-ban-shi-ti-shou-ji/</guid>
      <description>&lt;p&gt;阶段性考试（考试6个小时，讲评+重写6个小时）
题目1：简述LinkedList和ArrayList的区别是什么？
题目2：简述Java 中Set有哪几种？区别是什么？
题目3：有如下一个类：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Person
{
private int age;
private String name;
public void setAge(int age)
{
    this.age = age;
}
public void setName(String name)
{
    this.name = name;
}
public void sayHello()
{
    System.out.println(&amp;quot;你好，我是&amp;quot;+name+&amp;quot;，我&amp;quot;+age+&amp;quot;岁了&amp;quot;);
}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;采用反射的方法创建Person类的一个对象，并且通过反射的方法调用setAge、setName进行赋值，并且用反射的方法调用sayHello方法。
记录完成所需要的时长。
题目4：要求用户输入一个email地址，使用正则表达式检查用户输入的是否是合法的email地址，如果是合法的email地址，则把用户名和域名分别输出，比如用户输入yzk@rupeng.com，则输出“用户名为yzk，域名为rupeng.com”；
记录完成所需要的时长。
题目5：创建一个数据库表T_Students，包含Id（主键）、Name（姓名）、Num（学号）三个列。编写一个Socket服务器端，服务器接受如下的Socket指令：
客户端发送“1|学号”（比如&amp;rdquo;1|a001&amp;rdquo;），代表客户端要查询指定学号的学生的姓名，服务器端通过JDBC连接数据库进行查询，如果找到了则返回&amp;rdquo;ok|姓名&amp;rdquo;（比如&amp;rdquo;ok|张三&amp;rdquo;），如果没找到则返回&amp;rdquo;error|notfound&amp;rdquo;，如果服务器端查询过程中出现异常等则返回&amp;rdquo;error|servererror&amp;rdquo;。
客户端发送&amp;rdquo;2&amp;rdquo;，则代表客户端要查询学生总人数，服务器端通过JDBC连接数据库进行查询学生总人数，并且进行返回，比如&amp;rdquo;ok|30&amp;rdquo;，如果服务器端查询过程中出现异常等则返回&amp;rdquo;error|servererror&amp;rdquo;。
编写Socket客户端对于服务的两个指令进行测试。客户端和服务器端都使用控制台窗口就可以，不用图形界面。
记录完成所需要的时长。&lt;/p&gt;

&lt;p&gt;第一题：
ArrayList 本质数组，优点： 易于获取缺点：不方便插入和删除。
LinkedList本质链表，优点：易于添加和删除。缺点：不方便获取。&lt;/p&gt;

&lt;p&gt;第二题：
Set:HashSet  TreeSet     LinkedHashSet
HashSet的本质是链表数组，实现基于HashMap,速度快
       优点：添加和删除效率高
       缺点：获取慢（遍历都一样）,只能遍历一遍，Set集合无法直接获取某个元素
TreeSet：二叉树，注意查看root节点（这是二叉树结构的标志）  TreeSet关键是排序！（不是插入 和获取元素）
优点：增加和删除
缺点：获取
但是必须加入计数器也就是实现comparable接口，或者new Comparator
具体参看：&lt;a href=&#34;http://www.rupeng.com/forum/thread-44838-1-1.html&#34; target=&#34;_blank&#34;&gt;http://www.rupeng.com/forum/thread-44838-1-1.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;LinkedHashSet:是基于HashSet只不过是使得插入获得存在顺序
未做深入研究
第三题：
Person类的设计：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
* 解释：
*/
package com.reflect.test;

/**
* @author    叶昭良
* @time      2015年3月21日下午1:42:37
* @version   com.reflect.testPerson1 V1.0
* 功能： 
                步骤：
* 注意：
* 掌握：
                思考：
* 回顾：
*/
public class Person1
{

        /**
         * @param args 
         * 原因：
         * 解决：
         * 功能：
         *       思考：        
         *       步骤：
         */
        private int age;

        private String name;

        public void setAge(int age)

        {

            this.age = age;

        }

        public void setName(String name)

        {

            this.name = name;

        }

        public void sayHello()

        {

            System.out.println(&amp;quot;你好，我是&amp;quot;+name+&amp;quot;，我&amp;quot;+age+&amp;quot;岁了&amp;quot;);

        }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试Person类：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
* 解释：
* 采用反射的方法创建Person类的一个对象，并且通过反射的方法调用setAge、setName进行赋值，并且用反射的方法调用sayHello方法。

记录完成所需要的时长

*/
package com.reflect.test;
import java.lang.reflect.*;
/**
* @author    叶昭良
* @time      2015年3月21日下午1:43:08
* @version   com.reflect.testTestPerson1Reflect V1.0
* 功能： 
                步骤：
* 注意：
* 掌握：
                思考：
* 回顾：
*/
public class TestPerson1Reflect
{

        /**
         * @param args 
         * 原因：
         * 解决：
         * 功能：
         *       思考：        
         *       步骤：
         */
        public static void main(String[] args)
        {
                // TODO Auto-generated method stub
                Person1 p1 = new Person1();
                Class testClass = p1.getClass();
                try
                {
                        Field nameField  = testClass.getDeclaredField(&amp;quot;name&amp;quot;);
                        Field ageField = testClass.getDeclaredField(&amp;quot;age&amp;quot;);
                        nameField.setAccessible(true);
                        ageField.setAccessible(true);
                        nameField.set(p1, &amp;quot;张三&amp;quot;);
                        ageField.set(p1, 32);
                        System.out.println(&amp;quot;通过对象调用sayHello方法&amp;quot;);
                        p1.sayHello();
                        
                        Method helloSay = testClass.getDeclaredMethod(&amp;quot;sayHello&amp;quot;);
                        System.out.println(&amp;quot;第二种方法打印sayHello&amp;quot;);
                        helloSay.invoke(p1);
                        
                } catch (NoSuchFieldException | SecurityException | IllegalArgumentException | IllegalAccessException e)
                {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                } catch (NoSuchMethodException e)
                {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                } catch (InvocationTargetException e)
                {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                }
        }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第四题：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
* 解释：
* 题目4：要求用户输入一个email地址，使用正则表达式检查用户输入的
* 是否是合法的email地址，如果是合法的email地址，则把用户名和域名
* 分别输出，比如用户输入yzk@rupeng.com，则输出“用户名为yzk，
* 域名为rupeng.com”；
*/
package TestRegex;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
/**
* @author    叶昭良
* @time      2015年3月21日下午1:54:30
* @version   TestRegexTestRegexExam V1.0
* 功能： 
                步骤：
* 注意：
* 掌握：
                思考：
* 回顾：
*/
public class TestRegexExam
{

        /**
         * @param args 
         * 原因：
         * 解决：
         * 功能：
         *       思考：        
         *       步骤：
         */
        public static void main(String[] args)
        {
                // TODO Auto-generated method stub
                Scanner sc = new Scanner(System.in);
                String temp = null;
                while(true)
                {
                        System.out.println(&amp;quot;请输入一个邮箱地址,比如zhaoturkkey@163.com,退出敲exit|quit&amp;quot;);
                        temp= sc.nextLine();
                        if(temp.equalsIgnoreCase(&amp;quot;exit&amp;quot;)||temp.equalsIgnoreCase(&amp;quot;quit&amp;quot;))
                        {
                                break;
                        }
                        
                        if(temp.matches(&amp;quot;@&amp;quot;))
                        {
                                System.out.println(&amp;quot;你输入的不是正确的邮箱地址！&amp;quot;);
                                continue;
                        }
                        
                        int countAddr = 0;
                        Pattern p1 = Pattern.compile(&amp;quot;@&amp;quot;);
                        Matcher mp = p1.matcher(temp);
                        while(mp.find())
                        {
                                countAddr++;
                        }
                        if(countAddr == 1)
                        {
                                String[] piles = temp.split(&amp;quot;@&amp;quot;);
                                System.out.println(&amp;quot;用户名为&amp;quot;+piles[0]+&amp;quot;  域名为&amp;quot;+piles[1]);
                        }else
                        {
                                System.out.println(&amp;quot;你输入的邮箱有多个@&amp;quot;);
                        }
                        //matches要求整体匹配！
                        System.out.println(&amp;quot;sdfas|fsdfs&amp;quot;.matches(&amp;quot;fsdfs&amp;quot;));
                        String likeType = &amp;quot;23&amp;quot;;
                          String pattern = &amp;quot;[a-zA-Z0-9]*[&amp;quot; + likeType + &amp;quot;]{1}[a-zA-Z0-9]*&amp;quot;;
                          String sourceStr = &amp;quot;adfjaslfj23ldfalsf&amp;quot;;
                             System.out.println(sourceStr.matches(&amp;quot;.*&amp;quot;+likeType+&amp;quot;.*&amp;quot;));
                }
        }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;请输入一个邮箱地址,比如zhaoturkkey@163.com,退出敲exit|quit
zhaoturkkey@163.com
用户名为zhaoturkkey  域名为163.com
false
true
请输入一个邮箱地址,比如zhaoturkkey@163.com,退出敲exit|quit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第五题：&lt;/p&gt;

&lt;p&gt;采用ORM的实现
具体查看&lt;a href=&#34;http://www.rupeng.com/forum/thread-44526-1-1.html&#34; target=&#34;_blank&#34;&gt;http://www.rupeng.com/forum/thread-44526-1-1.html&lt;/a&gt;
满足ORM的设计条件：
*    约束条件：主键必须为Id，且是int类型，自动递增
*             字段名必须和属性名一样   也就是类的属性和表的字段保持一致
*             表名字和类的名字一样
Student表的设计：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;create table student(
id int not null auto_increment primary key
name varchar(20) not null default &#39;&#39;,
num varchar(20) not null default &#39;&#39;);


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Student类的设计：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
* 
*/
package com.introspect.test;

/**
* @author    叶昭良
* @time      2015年3月21日下午2:10:39
* @version   com.introspect.testStudent V1.0
*/
//据说下面是符合javaBeans设计思想的普通类
public class Student
{
        //字段私有化  ，使用BeansInfo必须是用id  name  num而不是id name num
        /*private String id;
        private String name;
        private int num;*/
        
        private int id;
        private String name;
        private String num;
        
        //提供一个无参的构造函数
        public Student()
        {
                
        }
        @Override
        public String toString()
        {
                StringBuilder studentInfo = new StringBuilder();
                studentInfo.append(&amp;quot;学生的id：&amp;quot;).append(id).append(&amp;quot;,姓名:&amp;quot;).append(name).append(
                                &amp;quot;,学号是:&amp;quot;).append(num);
                return studentInfo.toString();
        }        
        public int getid()
        {
                return id;
        }
        public void setid(int id)
        {
                this.id = id;
        }
        public String getname()
        {
                return name;
        }
        public void setname(String name)
        {
                this.name = name;
        }
        public String getnum()
        {
                return num;
        }
        public void setnum(String num)
        {
                
                this.num = num;
        }
}
	```
MyORM的修改
1： 修改select的id变为num即可  修改对应的代码段 
2： 重载select方法   变成只接受一个class的函数，具体如下所示

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java
public static Object select(Class clazz) throws SQLException
        {
                int count = 0;
                //用于数据库表
                String className = clazz.getSimpleName();
                StringBuilder sbSQL = new StringBuilder();&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;            //第一步 拼接  insert
            sbSQL.append(&amp;quot;select count(*) tb from &amp;quot;).append(className);
            //获取到 ResultSet
            ResultSet rs = JDBCUtils.executeQuery(sbSQL.toString());
            while(rs.next())
            {
                    count = rs.getInt(&amp;quot;tb&amp;quot;);
                    System.out.println(&amp;quot;总共有&amp;quot;+count+&amp;quot;个数据&amp;quot;);
            }

            System.out.println(&amp;quot;成功&amp;quot;);
            return count;

            //先非泛型  再泛型的selectById
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;最终的MyORM代码如下：

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java
/**
*  对象 Student
*  mysql表   Student
*&lt;br /&gt;
*  类 表对应！  通过对象传递进数组，并利用内省机制，获得类中的所有属性！
*   并获得其中的值，然后组合成为一个sql语句，并执行JDBCUtils 来进行
*   增、删、修改、查等操作
*&lt;br /&gt;
*   目的 ：对象 &amp;ndash;mysql表 进行一一对应并且可以进行传递
*   简单的MyOrm.insert(
*              delete
*              select
*              update 等
*&lt;br /&gt;
*    约束条件：主键必须为Id，且是int类型，自动递增
*             字段名必须和属性名一样   也就是类的属性和表的字段保持一致
*             表名字和类的名字一样
*/&lt;/p&gt;

&lt;p&gt;package com.introspect.test;
import com.jdbc.test.*;&lt;/p&gt;

&lt;p&gt;import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.*;  //需要存储字段的 list  同时需要存储值的list
                     // 最后组装成一条mysql语句
/**
* @author    叶昭良
* @time      2015年3月4日下午8:57:46
* @version   com.introspect.testMyORM V1.0
*/
public class MyORM
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /**
     * sql = insert into Person(fieldName) values(?,?..)
     *         1                 2             3   4
     *  JDBCUTils.executeUpdate(sql,propValue)
     * @param args
     */
    public static void insert(Object obj) throws SQLException
    {
            Class clazz = obj.getClass();
            BeanInfo beanInfo = null;
            beanInfo = getBeanInfo(clazz);

            //用于数据库表
            String className = clazz.getSimpleName(); 

            PropertyDescriptor[] pro = beanInfo.getPropertyDescriptors();
            List&amp;lt;String&amp;gt; listFieldName = new ArrayList&amp;lt;String&amp;gt;();
            for(PropertyDescriptor temp:pro)
            {
                    String propName = temp.getName();
                    if(!propName.equals(&amp;quot;id&amp;quot;) &amp;amp;&amp;amp; !propName.equals(&amp;quot;class&amp;quot;)) 
                    {
                            //扣除 id和class这两个内部字段
                            listFieldName.add(propName);
                    }
            }

            StringBuilder sbSQL = new StringBuilder();

            //第一步 拼接  insert
            sbSQL.append(&amp;quot;insert into &amp;quot;).append(className);

            //第二步 拼接  字段
            String fieldNames = listFieldName.toString();
            sbSQL.append(fieldNames.replace(&#39;[&#39;, &#39;(&#39;).replace(&#39;]&#39;, &#39;)&#39;));

            //第三步  拼接  值
            sbSQL.append(&amp;quot; values&amp;quot;);

            //第四步  拼接  添加问号
            char[] paramMarkArray  = new char[listFieldName.size()];
            for(int i = 0 ; i &amp;lt; listFieldName.size() ; i++)
            {
                    paramMarkArray[i] = &#39;?&#39;;
            }
            sbSQL.append(Arrays.toString(paramMarkArray).replace(&#39;[&#39;, &#39;(&#39;).replace
                            (&#39;]&#39;, &#39;)&#39;));

            //最后一步    调用JDBCUtils的 executeUpdate
            List&amp;lt;Object&amp;gt; paramValues = new ArrayList&amp;lt;Object&amp;gt;();
            for(String propName : listFieldName)
            {
                    PropertyDescriptor propDesc = findPropertyDescriptor(propName, pro);
                    Object propValue =null;
                    //obj传入的类或者表名的对象
                    propValue = invoke(propDesc, obj);
                    paramValues.add(propValue);
            }
            //最终过程  toString  toArray的转换
            JDBCUtils.executeUpdate(sbSQL.toString(), paramValues.toArray());

    }
    /**
     * 
     * @param clazz
     * @return  返回一个beanInfo对象
     */
    private static BeanInfo getBeanInfo(Class clazz)
    {
            BeanInfo beanInfo = null;
            try
            {
                    beanInfo = Introspector.getBeanInfo(clazz);
            }catch(IntrospectionException e)
            {
                    throw new RuntimeException(&amp;quot;内省出错！&amp;quot;+e.getMessage());
            }
            return beanInfo;
    }
    /**
     *  从propDesc中找名字为propName的PropertyDescriptor
     * @param propName
     * @param prop
     * @return
     */
    private static PropertyDescriptor findPropertyDescriptor(String propName,
                    PropertyDescriptor[] prop)
    {
            for(PropertyDescriptor temp : prop)
            {
                    if(temp.getName().equals(propName))
                    {
                            return temp;
                    }
            }
            return null;
    }
    /**
     *  执行某个字段的读方法  并返回 propValue
     * @param propDesc
     * @param obj
     * @return
     */
    private static Object invoke(PropertyDescriptor propDesc,Object obj)
    {
            Object propValue = null;

            try
            {
                    propValue = propDesc.getReadMethod().invoke(obj);
            } catch (IllegalAccessException | IllegalArgumentException
                            | InvocationTargetException e)
            {
                    // TODO Auto-generated catch block
                    throw new RuntimeException(&amp;quot;获取&amp;quot;+propDesc.getName()+&amp;quot;错误&amp;quot;);
            }
            return propValue; 
    }
    //------------------------insert 程序 结束----------------
    /**
     * delete from className where id = ?
     * 
     * 
     *   删除clazz对应表中的字段id为id的值   delete(Person.class,5);
     * @param clazz
     * @param id
     */
    public static void delete(Class clazz, int id) throws SQLException
    {
            BeanInfo beanInfo = null;
            beanInfo = getBeanInfo(clazz);

            //用于数据库表
            String className = clazz.getSimpleName(); 

            PropertyDescriptor[] pro = beanInfo.getPropertyDescriptors();
            List&amp;lt;String&amp;gt; listFieldName = new ArrayList&amp;lt;String&amp;gt;();


            StringBuilder sbSQL = new StringBuilder();

            //第一步 拼接  insert
            sbSQL.append(&amp;quot;delete from &amp;quot;).append(className).append(&amp;quot; where id = ?&amp;quot;);

            JDBCUtils.executeUpdate(sbSQL.toString(), id);

    }


    /**
     * select * from Person where id = 2;
     * 
     *   获取clazz对应表中id为字段为id的对应航的   并且填充到对象中
     *   Person p1 = (Person)select(Person.class,2)
     *   p1.getName(), p1.getAge();
     * @param clazz
     * @param id
     * @return
     */
    //----------------------delete 程序结束--------------------
    public static Object select(Class clazz,String num) throws SQLException
    {
            Object b1 = null;
            b1 = getInstance(clazz);

            BeanInfo beanInfo = null;
            beanInfo = getBeanInfo(clazz);

            //用于数据库表
            String className = clazz.getSimpleName(); 

            PropertyDescriptor[] pro = beanInfo.getPropertyDescriptors();
            List&amp;lt;String&amp;gt; listFieldName = new ArrayList&amp;lt;String&amp;gt;();
            for(PropertyDescriptor temp:pro)
            {
                    String propName = temp.getName();
                    if(!propName.equals(&amp;quot;id&amp;quot;) &amp;amp;&amp;amp; !propName.equals(&amp;quot;class&amp;quot;)) 
                    {
                            //扣除 id和class这两个内部字段
                            listFieldName.add(propName);
                    }
            }

            StringBuilder sbSQL = new StringBuilder();

            //第一步 拼接  insert
            sbSQL.append(&amp;quot;select * from &amp;quot;).append(className).append(&amp;quot; where num = ?&amp;quot;);
            //获取到 ResultSet
            ResultSet rs = JDBCUtils.executeQuery(sbSQL.toString(), num);
            if(!rs.next())
            {
                    System.out.println(&amp;quot;当前版本没有&amp;quot;+num+&amp;quot;的信息&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;//                        return;
                }else
                {
                        System.out.println(&amp;ldquo;当前版本有&amp;rdquo;+num+&amp;ldquo;的信息&amp;rdquo;);
                        for(String propName : listFieldName)
                        {
                                PropertyDescriptor propDesc = findPropertyDescriptor(propName, pro);
                                //obj传入的类或者表名的对象
                                invoke(propDesc, b1,rs.getObject(propName));
                                //invoke(propDesc, b1,rs.getString(propName));
                        }
                }
                //设置num字段
                PropertyDescriptor propDesc1 = findPropertyDescriptor(&amp;ldquo;num&amp;rdquo;, pro);
                invoke(propDesc1, b1,num);
                System.out.println(&amp;ldquo;成功&amp;rdquo;);
                return b1;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;            //先非泛型  再泛型的selectById
    }

    public static Object select(Class clazz) throws SQLException
    {
            int count = 0;
            //用于数据库表
            String className = clazz.getSimpleName(); 
            StringBuilder sbSQL = new StringBuilder();

            //第一步 拼接  insert
            sbSQL.append(&amp;quot;select count(*) tb from &amp;quot;).append(className);
            //获取到 ResultSet
            ResultSet rs = JDBCUtils.executeQuery(sbSQL.toString());
            while(rs.next())
            {
                    count = rs.getInt(&amp;quot;tb&amp;quot;);
                    System.out.println(&amp;quot;总共有&amp;quot;+count+&amp;quot;个数据&amp;quot;);
            }

            System.out.println(&amp;quot;成功&amp;quot;);
            return count;

            //先非泛型  再泛型的selectById
    }
    private static Object getInstance(Class clazz)
    {
            Object b1 = null;
            try
            {
                    b1 = clazz.newInstance();
            } catch (InstantiationException | IllegalAccessException e)
            {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
            }
            return b1;
    }
    //private static void invoke(PropertyDescriptor propDesc,Object obj,String value)

    private static void invoke(PropertyDescriptor propDesc,Object obj,Object value)
    {

            //有问题 因为
            /*try
            {
                    propDesc.getWriteMethod().invoke(obj,value);
            } catch (IllegalAccessException | IllegalArgumentException
                            | InvocationTargetException e)
            {
                    // TODO Auto-generated catch block
                    throw new RuntimeException(&amp;quot;获取&amp;quot;+propDesc.getName()+&amp;quot;错误&amp;quot;);
            } */
            try
            {
                    Method methodSet= propDesc.getWriteMethod();
                    if(methodSet !=null)
                    {
                            methodSet.invoke(obj,value);
                    }

            } catch (IllegalAccessException | IllegalArgumentException
                            | InvocationTargetException e)
            {
                    // TODO Auto-generated catch block
                    throw new RuntimeException(&amp;quot;获取&amp;quot;+propDesc.getName()+&amp;quot;错误&amp;quot;);
            } 
    }

    //------------------select 结束------------------

    // update Person set age=&#39;&#39; where id=4;

    /**
     *   设置id= id的对象 ， 他的年龄为。。。 也可以名字 ，具体修改update 语句
     * @param clazz
     * @param newValue    设置年龄的新值
     * @param id          设置某个id
     * @throws SQLException
     */
    public static void update(Class clazz,Object newValue,int id) throws SQLException
    {
            BeanInfo beanInfo = null;
            beanInfo = getBeanInfo(clazz);

            //用于数据库表
            String className = clazz.getSimpleName(); 

            PropertyDescriptor[] pro = beanInfo.getPropertyDescriptors();
            List&amp;lt;String&amp;gt; listFieldName = new ArrayList&amp;lt;String&amp;gt;();
            for(PropertyDescriptor temp:pro)
            {
                    String propName = temp.getName();
                    if(!propName.equals(&amp;quot;id&amp;quot;) &amp;amp;&amp;amp; !propName.equals(&amp;quot;class&amp;quot;)) 
                    {
                            //扣除 id和class这两个内部字段
                            listFieldName.add(propName);
                    }
            }

            StringBuilder sbSQL = new StringBuilder();

            //第一步 拼接  insert
            //可以设置 update 那个字符串  比如 String temp = &amp;quot;age&amp;quot;
            sbSQL.append(&amp;quot;update &amp;quot;).append(className).append(&amp;quot; set age = &amp;quot;).append(newValue).append(&amp;quot;&amp;quot;
                            + &amp;quot; where id = ?&amp;quot;);
            JDBCUtils.executeUpdate(sbSQL.toString(), id);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
关于JDBCUtils的片段：请参考http://www.rupeng.com/forum/thread-44526-1-1.html
测试新版本MyORM的有效性


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java
/**
* 解释：
*/
package com.introspect.test;&lt;/p&gt;

&lt;p&gt;import java.sql.SQLException;&lt;/p&gt;

&lt;p&gt;/**
* @author    叶昭良
* @time      2015年3月21日下午2:21:40
* @version   com.introspect.testFifthExam V1.0
* 功能：
                步骤：
* 注意：
* 掌握：
                思考：
* 回顾：
*/
public class FifthExam
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /**
     * @param args 
     * 原因：
     * 解决：
     * 功能：
     *       思考：        
     *       步骤：
     */
    public static void main(String[] args)
    {
            // TODO Auto-generated method stub
            Student s1 = new Student();
            //插入数据
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;/*                s1.setname(&amp;ldquo;zhaoliang&amp;rdquo;);
                s1.setnum(&amp;ldquo;a001&amp;rdquo;);&lt;em&gt;/
/&lt;/em&gt;                s1.setname(&amp;ldquo;xinran&amp;rdquo;);
                s1.setnum(&amp;ldquo;a002&amp;rdquo;);&lt;em&gt;/
/&lt;/em&gt;                s1.setname(&amp;ldquo;liming&amp;rdquo;);
                s1.setnum(&amp;ldquo;a003&amp;rdquo;);*/
                s1.setname(&amp;ldquo;wanglei&amp;rdquo;);
                s1.setnum(&amp;ldquo;a004&amp;rdquo;);
                try
                {
                        //插入数据部分
                        //MyORM.insert(s1);
                        //测试查询第一部分
                        System.out.println(MyORM.select(Student.class));&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                    //测试查询第二部分
                    //s1= (Student)MyORM.select(Student.class,&amp;quot;a001&amp;quot;);
                    //s1= (Student)MyORM.select(Student.class,&amp;quot;a002&amp;quot;);
                    System.out.println(s1.toString());
            } catch (SQLException e)
            {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
            }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;结果很好，并插入数据到了表中

紧接着进行网络编程   Server端和Client段，参考了我的复习笔记的http://www.rupeng.com/forum/thread-44838-1-1.html网络编程部分 ，针对Server的主要修改部分是ServerRead, 从客户端读取的字符串，需要进行两个判断  1：  1|a001     如何是这种情况  则使用MyORM.select(Student.class,num)         2: 2  如果输入的是一个2,则使用 MyORM.select(Student.class)返回总共的学生数 ，Server端代码如下：


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java
/**
* 解释：
*/
package com.introspect.test;&lt;/p&gt;

&lt;p&gt;import java.awt.BorderLayout;
import java.awt.Button;
import java.awt.Font;
import java.awt.Frame;
import java.awt.Panel;
import java.awt.TextArea;
import java.awt.TextField;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.net.ServerSocket;
import java.net.Socket;&lt;/p&gt;

&lt;p&gt;import javax.swing.JOptionPane;
import javax.swing.UIManager;&lt;/p&gt;

&lt;p&gt;/**
* @author    叶昭良
* @time      2015年3月21日下午2:56:04
* @version   com.introspect.testTestExamServer V1.0
* 功能：
                步骤：
* 注意：
* 掌握：
                思考：
* 回顾：
*/
public class TestExamServer
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /**
     * @param args 
     * 原因：
     * 解决：
     * 功能：
     *       思考：        
     *       步骤：
     */
    public static void main(String[] args)
    {
            // TODO Auto-generated method stub
            // TODO Auto-generated method stub
            Font font = new Font(&amp;quot;Dialog&amp;quot;, Font.PLAIN, 12); //一下是改变默认的组建上显示的字体，这样更加美观一些
            UIManager.put(&amp;quot;MenuBar.font&amp;quot;, font);
            UIManager.put(&amp;quot;MenuItem.font&amp;quot;, font);
            UIManager.put(&amp;quot;Menu.font&amp;quot;, font);
            UIManager.put(&amp;quot;PopupMenu.font&amp;quot;, font);
            UIManager.put(&amp;quot;ToolBar.font&amp;quot;, font);
            UIManager.put(&amp;quot;ToolTip.font&amp;quot;, font);
            UIManager.put(&amp;quot;TabbedPane.font&amp;quot;, font);
            UIManager.put(&amp;quot;Label.font&amp;quot;, font);
            UIManager.put(&amp;quot;List.font&amp;quot;, font);
            UIManager.put(&amp;quot;ComboBox.font&amp;quot;, font);
            UIManager.put(&amp;quot;Button.font&amp;quot;, font);
            UIManager.put(&amp;quot;Table.font&amp;quot;, font);
            UIManager.put(&amp;quot;TableHeader.font&amp;quot;, font);
            UIManager.put(&amp;quot;Tree.font&amp;quot;, font);
            UIManager.put(&amp;quot;TextField.font&amp;quot;, font);
            UIManager.put(&amp;quot;TextArea.font&amp;quot;, font);
            UIManager.put(&amp;quot;TitledBorder.font&amp;quot;, font);
            UIManager.put(&amp;quot;OptionPane.font&amp;quot;, font);
            UIManager.put(&amp;quot;RadioButton.font&amp;quot;, font);
            UIManager.put(&amp;quot;CheckBox.font&amp;quot;, font);
            UIManager.put(&amp;quot;ToggleButton.font&amp;quot;, font);
            UIManager.put(&amp;quot;Dialog.font&amp;quot;, font);
            UIManager.put(&amp;quot;Panel.font&amp;quot;, font);
             new TCPServer().launch();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;class TCPServer
{
        // class variables
        // class variables
        // connect
         private ServerSocket ss = null;
         private Socket s = null;
         // data flow
         private DataOutputStream dos = null;
         private DataInputStream dis = null;
         // UI
         private Frame f = null;
         private TextArea ta = null;
         private TextField tf = null;
         private Button  bn = null;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     public void launch()
     {
         createUI();
         connect();
         new ServerRead().start();
         new ServerWrite().start();
     }
    // construct member
    /*
    public TCPServer()
    {

    }
    */
    public void createUI()
    {
        Frame f = new Frame(&amp;quot;服务器&amp;quot;);
        ta = new TextArea();
        tf = new TextField();
        Panel p = new Panel(new BorderLayout());
        bn = new Button(&amp;quot;发送&amp;quot;);
        p.add(tf,BorderLayout.CENTER);
        p.add(bn,BorderLayout.EAST);

        f.add(ta,BorderLayout.CENTER);
        f.add(p,BorderLayout.SOUTH);

        f.setSize(400,200);
        f.setVisible(true);
        //f.setVisable(true);
        f.addWindowListener(new WindowAdapter()
                {
                    public void windowClosing(WindowEvent e)
                    {
                        System.exit(0);
                    }
                });
    }
    public void connect()
    {
        try{
            ss = new ServerSocket(5599);
            s = ss.accept();
            dis = new DataInputStream(s.getInputStream());
            dos = new DataOutputStream(s.getOutputStream());
        }catch(Exception e)
        {
            System.exit(0);
        }
    }
    public void close()
    {
        try{
            dis.close();
            dos.close();
            ss.close();
            s.close();
        }catch(Exception e)
        {
            System.exit(0);
        }
    }

    class ServerRead extends Thread
    {
        public void run()
        {
            while(true)
            {
               try{
                    String str = dis.readUTF();
          //          System.out.println(&amp;quot;对方说:&amp;quot;+str);
                    ta.append(&amp;quot;客户端说：&amp;quot;+str+&amp;quot;\n&amp;quot;);
                    if(str.equalsIgnoreCase(&amp;quot;再见&amp;quot;))
                    {
                        close();
                        System.exit(0);
                    }
                    if(str.matches(&amp;quot;.*\\|.*&amp;quot;))
                    {
                            System.out.println(&amp;quot;的确存在&amp;quot;);
                            String[] piles = str.split(&amp;quot;[|]&amp;quot;);
                            Student s1 = (Student)MyORM.select(Student.class, piles[1]);
                            ta.append(&amp;quot;str的姓名是:&amp;quot;+s1.getname());
                    }
                    if(str.matches(&amp;quot;2&amp;quot;))
                    {
                            ta.append(&amp;quot;服务器对客户端说：总共有&amp;quot;+MyORM.select(Student.class)+&amp;quot;个学生\n&amp;quot;); 
                    }
               }catch(Exception e)
               {
                   JOptionPane.showMessageDialog(f,&amp;quot;客户端已离开&amp;quot;);
                   return;
               //    e.printStackTrace();
               }
            }
        }
    }
    class ServerWrite extends Thread
    {
        public void run()
        {
            tf.addActionListener(new TCPServerListener());
            bn.addActionListener(new TCPServerListener());
        }
    }
    class TCPServerListener implements ActionListener
    {
        @Override
        public void actionPerformed(ActionEvent e)
        {
               try{
                    String str = tf.getText();
                    tf.setText(&amp;quot;&amp;quot;);
                    ta.append(&amp;quot;服务器说:&amp;quot;+str+&amp;quot;\n&amp;quot;);
                    dos.writeUTF(str);
                    if(str.equalsIgnoreCase(&amp;quot;再见&amp;quot;))
                    {
                        close();
                        System.exit(0);
                    }
               }catch(Exception e1)
               {
                  // e.printStackTrace();
                  System.exit(0);
               } 
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Client端代码如下：


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java
/**
* 解释：
*/
package com.introspect.test;&lt;/p&gt;

&lt;p&gt;import java.awt.BorderLayout;
import java.awt.Button;
import java.awt.Font;
import java.awt.Frame;
import java.awt.Panel;
import java.awt.TextArea;
import java.awt.TextField;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.net.Socket;&lt;/p&gt;

&lt;p&gt;import javax.swing.JOptionPane;
import javax.swing.UIManager;&lt;/p&gt;

&lt;p&gt;/**
* @author    叶昭良
* @time      2015年3月21日下午2:56:17
* @version   com.introspect.testTestExamClient V1.0
* 功能：
                步骤：
* 注意：
* 掌握：
                思考：
* 回顾：
*/
public class TestExamClient
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /**
     * @param args 
     * 原因：
     * 解决：
     * 功能：
     *       思考：        
     *       步骤：
     */
    public static void main(String[] args)
    {
            // TODO Auto-generated method stub
            Font font = new Font(&amp;quot;Dialog&amp;quot;, Font.PLAIN, 12); //一下是改变默认的组建上显示的字体，这样更加美观一些
            UIManager.put(&amp;quot;MenuBar.font&amp;quot;, font);
            UIManager.put(&amp;quot;MenuItem.font&amp;quot;, font);
            UIManager.put(&amp;quot;Menu.font&amp;quot;, font);
            UIManager.put(&amp;quot;PopupMenu.font&amp;quot;, font);
            UIManager.put(&amp;quot;ToolBar.font&amp;quot;, font);
            UIManager.put(&amp;quot;ToolTip.font&amp;quot;, font);
            UIManager.put(&amp;quot;TabbedPane.font&amp;quot;, font);
            UIManager.put(&amp;quot;Label.font&amp;quot;, font);
            UIManager.put(&amp;quot;List.font&amp;quot;, font);
            UIManager.put(&amp;quot;ComboBox.font&amp;quot;, font);
            UIManager.put(&amp;quot;Button.font&amp;quot;, font);
            UIManager.put(&amp;quot;Table.font&amp;quot;, font);
            UIManager.put(&amp;quot;TableHeader.font&amp;quot;, font);
            UIManager.put(&amp;quot;Tree.font&amp;quot;, font);
            UIManager.put(&amp;quot;TextField.font&amp;quot;, font);
            UIManager.put(&amp;quot;TextArea.font&amp;quot;, font);
            UIManager.put(&amp;quot;TitledBorder.font&amp;quot;, font);
            UIManager.put(&amp;quot;OptionPane.font&amp;quot;, font);
            UIManager.put(&amp;quot;RadioButton.font&amp;quot;, font);
            UIManager.put(&amp;quot;CheckBox.font&amp;quot;, font);
            UIManager.put(&amp;quot;ToggleButton.font&amp;quot;, font);
            UIManager.put(&amp;quot;Dialog.font&amp;quot;, font);
            UIManager.put(&amp;quot;Panel.font&amp;quot;, font);
             new TCPClient().launch();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;class TCPClient
{
        // class variables
        // class variables
        // connect
         private Socket s = null;
         // data flow
         private DataOutputStream dos = null;
         private DataInputStream dis = null;
         // UI
         private Frame f = null;
         private TextArea ta = null;
         private TextField tf = null;
         private Button  bn = null;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     public void launch()
     {
         createUI();
         connect();
         new ClientRead().start();
         new ClientWrite().start();
     }
    // construct member
    /*
    public TCPClient()
    {

    }
    */
    public void createUI()
    {
        Frame f = new Frame(&amp;quot;客户端&amp;quot;);
        ta = new TextArea();
        tf = new TextField();
        Panel p = new Panel(new BorderLayout());
        bn = new Button(&amp;quot;发送&amp;quot;);
        p.add(tf,BorderLayout.CENTER);
        p.add(bn,BorderLayout.EAST);

        f.add(ta,BorderLayout.CENTER);
        f.add(p,BorderLayout.SOUTH);

        f.setSize(400,200);
        f.setVisible(true);
        //f.setVisable(true);
        f.addWindowListener(new WindowAdapter()
                {
                    public void windowClosing(WindowEvent e)
                    {
                        System.exit(0);
                    }
                });
    }
    public void connect()
    {
        try{
            s = new Socket(&amp;quot;127.0.0.1&amp;quot;,5599);
            dis = new DataInputStream(s.getInputStream());
            dos = new DataOutputStream(s.getOutputStream());
        }catch(Exception e)
        {
            System.exit(0);
        }
    }
    public void close()
    {
        try{
            dis.close();
            dos.close();
            s.close();
        }catch(Exception e)
        {
            System.exit(0);
        }
    }

    class ClientRead extends Thread
    {
        public void run()
        {
            while(true)
            {
               try{
                    String str = dis.readUTF();
               //     System.out.println(&amp;quot;对方说:&amp;quot;+str);
                    ta.append(&amp;quot;服务器说:&amp;quot;+str+&amp;quot;\n&amp;quot;);
                    if(str.equalsIgnoreCase(&amp;quot;再见&amp;quot;))
                    {
                        close();
                        System.exit(0);
                    }
               }catch(Exception e)
               {
                   JOptionPane.showMessageDialog(f,&amp;quot;客户端已离开&amp;quot;);
                   return;
               //    e.printStackTrace();
               }
            }
        }
    }
    class ClientWrite extends Thread
    {
        public void run()
        {
            tf.addActionListener(new TCPClientListener());
            bn.addActionListener(new TCPClientListener());
        }
    }
    class TCPClientListener implements ActionListener
    {
        @Override
        public void actionPerformed(ActionEvent e)
        {
               try{
                    String str = tf.getText();
                    tf.setText(&amp;quot;&amp;quot;);
                    ta.append(&amp;quot;客户端说:&amp;quot;+str+&amp;quot;\n&amp;quot;);
                    dos.writeUTF(str);
                    if(str.equalsIgnoreCase(&amp;quot;再见&amp;quot;))
                    {
                        close();
                        System.exit(0);
                    }
               }catch(Exception e1)
               {
                  // e.printStackTrace();
                  System.exit(0);
               } 
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;```
&lt;img src=&#34;https://jueqingsizhe66.github.io/images/java/kehuduan.png&#34; alt=&#34;客户端读取服务器段数据库的学生信息&#34; /&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>1月25日Java班笔记试题</title>
      <link>https://jueqingsizhe66.github.io/blog/2015/05/11/1yue-25ri-javaban-bi-ji-shi-ti/</link>
      <pubDate>Mon, 11 May 2015 14:58:40 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/blog/2015/05/11/1yue-25ri-javaban-bi-ji-shi-ti/</guid>
      <description>&lt;p&gt;一、IO基础
        1.File在Java中，既可以表示文件，也可以表示目录。可以通过File对象来判定文件是否可读，可写，存在等。
        2.File对象的mkdirs()推荐使用这个方法，此方法可以创建多层次的目录。而mkdir()只能一层一层创建。
        3.File的createNewfile()是创建的文件。
        4.File的delete()删除的File的构造函数String的那最后的一级，如果是文件，可以删除。如果是目录，需要这个目录是空的才能够删除。
        5.File的listFiles()返回的是File构造函数指定路径下的所有File对象，包括了目录，也包括了文件。
        6.File的静态方法，listRoots()可以获取所有的盘符。
        7.OutputStream和InputStream都是字节流。
        8.以后对于流的关闭等操作，还是使用JDK1.6的形式。1.7的怕以后公司不用。
        9.NullPointerException是空指针异常。
        10.当通过InputStream的read()方法读取值的时候他是一个byte一个byte的读取的，所以对于汉字读取会出现乱码。
        11.java中数字是1个byte，汉字和汉字标点是2个byte。
        12.可以通过System.currentTimMillis()来获取1970年1月1日到现在的毫秒数。
        13.在Java中，字节流的读取推荐使用read方法，对于read方法，是把一个流的内容读取到byte[] 这种缓冲区中。且如果读取到了最后，返回值是-1.C#是0.所以如果使用do-while需要判定下！
        14.缓冲区也不是越大越好！一般来说1M就够了！1024*1024
        15.closeable为哪些可以关闭流的接口。所以封装finally中的close方法的时候，可以使用closeable的多态来表示完成。
        16.对于output流，不用写创建一个File。会自动覆盖。
        17.对于InputStream每次读取的是一个byte，就是一个byte一个byte的读，本质来说，其实是非常费时间的。
        18.FileInputStream在read到最后返回值是-1.如果不是-1的话，那么返回值为int。int代表的是ASCII(?)的char。所以强制转成char就可以获取汉字。
        19.InputStream在读取汉字的时候，内部是在做判定的，本质来说他也是一个byte一个byte的在读，但是没读取一个byte，他会判定是否是中文特征码，如果是那么会在读下一个byte。合起来返回一个char。
        20.为了规避乱码问题，用什么编码来写，就用什么编码来读。
        21.ANSI编码不是一种真正意义上的编码，而是根据不同的操作系统来设定不同的编码。就是default编码。
        22.关于字符串编码的设置是在InputStreamReader或者OutputStreamWriter中。
        23.在关闭流的时候，推荐从外到内依次关闭。
        24.BufferedReader读取到最后，返回时是null。
        25.获取默认编码的2个方法 System.getProperty(&amp;ldquo;file.encoding&amp;rdquo;)  还有一个是 Charset.defaultCharset().toString()&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;文件夹的遍历  可以通过listFiles(), 如果是文件夹，则递归调用该定义方法
27.BufferedReader 需要一个Reader对象充当其参数，一般是InputStreamReader, 而InputStreamReader又需要一个InputStream（抽象方法不能new处对象）类的对象，一般采用InputStream的子类FileInputStream，类似的BufferedWriter
28.通过创建Properties对象可以载入项目的配置文件。一般有两种方法载入文件 ，1是 直接通过项目文件载入 调用当前类的getClass方法，并接着调用getResourceAsStream载入文件流  ，通过Properites对象的load方法载入 。（得写好b.properties的路径  com/rupeng/b.properties 表示在com.rupeng这个包下的b.properties文件） 2 直接通过FileInputStream创建一个文件流，然后再用Properties对象的load方法载入。两者区别未知，效果一样。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;CommonsIO的学习
统一说明：
import org.apache.commons.io.IOUtils; // 加载类库
import org.apache.commons.io.FilesUtils; // 加载类库&lt;/p&gt;

&lt;p&gt;1： IOUtils
案例1：从一个URL中读取字节并打印
主要代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;InputStream in = null;
                try
                {
                        in = new URL(&amp;quot;http://www.rupeng.com&amp;quot;).openStream();
                        System.out.println(IOUtils.toString(in,&amp;quot;utf-8&amp;quot;));
                } catch (MalformedURLException e)
                {
                        // TODO 自动生成的 catch 块
                        
                } catch (IOException e)
                {
                        // TODO 自动生成的 catch 块
                        e.printStackTrace();
                }finally
                {
                        IOUtils.closeQuietly(in);
                }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在大多数的运用领域，上述的CommonsIO操作是非常常见的，并且会节省很多的时间。对于工具代码，比如IOUtils,灵活性和速度
占据主要的作用。然而，在使用过程中也需要注意他的缺点，比如如果使用上述的技术读取一个1GB的大文件，将导致产生一个
1GB的字符串对象。&lt;/p&gt;

&lt;p&gt;案例2:复制文件
主要代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;                try
                {
                        fis = new FileInputStream(&amp;quot;e://a.txt&amp;quot;);
                        fos = new FileOutputStream(&amp;quot;e://acopyByStream.txt&amp;quot;);
                        IOUtils.copy(fis, fos); // 把e盘下的a.txt复制到e://的acopyByStream.txt
                }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2：FileUtils
案例1：复制url内容链接到文件
主要代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;URL url1 = null;
                File newFile = new File(&amp;quot;e://rupeng.html&amp;quot;);
                try
                {
                        url1  = new URL(&amp;quot;http://www.rupeng.com&amp;quot;);
                        FileUtils.copyURLToFile(url1, newFile); //把如鹏网首页写入e盘下的rupeng.html
                }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;案例2：复制文本、文件夹
主要代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;                // TODO 自动生成的方法存根
                File input = new File(&amp;quot;e://a.txt&amp;quot;);
                File output = new File(&amp;quot;e://acopy.txt&amp;quot;);
                File Input1 = new File(&amp;quot;e://a&amp;quot;);  //文件夹
                File Output1 = new File(&amp;quot;e://TestFile&amp;quot;);//文件夹
                String loveWord = &amp;quot;love you,my girl&amp;quot;;
                
                try
                {
                        //FileUtils.cleanDirectory(readyToDeleteDir); // 保留文件夹
                        System.out.println(&amp;quot;目录e://a的大小：&amp;quot;+FileUtils.sizeOfDirectory(readyToDeleteDir)/1024.0+&amp;quot;KB&amp;quot;);
                        //FileUtils.deleteDirectory(readyToDeleteDir); // 连文件夹多没有
                        FileUtils.copyFile(input, output);  //复制文件
                        FileUtils.copyDirectory(Input1, Output1); //复制文件夹
                        FileUtils.copyFileToDirectory(input, Output1); //复制文件到文件夹
                        FileUtils.writeStringToFile(output, loveWord, true); // 追加写入
                }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;IOUtils是采用流方式进行复制，FileUtils把文本文件作为参数（省去中间流的创建，估计有）&lt;/p&gt;

&lt;p&gt;3：Directory-walker
DirectoryWalker 是一个抽象类，无法直接创建对象。通过创建一个继承类，并实现类中的抽象方法。
案例1：递归删除某个文件夹下的文件
全部代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
* @author 叶昭良
*
*/
import java.io.*;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;

import org.apache.commons.io.DirectoryWalker;
public class TestCommonIODiretoryWalk extends DirectoryWalker
{

        /**
         * @param args
         */
        public TestCommonIODiretoryWalk() 
        {
                     super();
    }
        public List reName(File startDirectory) 
        {
                List results = new ArrayList();
                try
                {
                        walk(startDirectory,results        );
                } catch (IOException e)
                {
                        // TODO 自动生成的 catch 块
                        e.printStackTrace();
                }
                return results;
        }
        
        protected boolean handleDirectory(File directory,int depth,Collection results)
        {
                //save.svn directories and then skip 不会删除.svn文件夹下的任何信息
                if(&amp;quot;fasf&amp;quot;.equals(directory.getName())) // 如果你想要保存某个文件夹
                                                        //就添加elseif即可！！当然文件架构还在
                {
                        directory.delete();
                        return false;
                }else
                {
                        return true;
                }
        }
        
        protected void handleFile(File file,int depth, Collection results)
        {
                file.delete();
                results.add(file);
        }
        // 使用Directory Walker来遍历一个目录并进行相应操作步骤如下
        // 1:创建一个继承DirectoryWalker的类，并在构造函数调用super()
        // 2:定义一个业务入口方法，比如clean，这个方法调用walk方法
        // 3:重写handleDiretory方法  提供相应的业务逻辑
        // 4:重写handleFile方法，提供相应处理逻辑
        
        // 其中最为关键的是walk方法，该方法制定入口路径，
        // 并提供一个用于接受处理结构的参数。
        // 在walk方法的内部：针对目录对象调用handleDirectory
        //                       文件对象调用handleFile
        public static void main(String[] args)
        {
                // TODO 自动生成的方法存根
                TestCommonIODiretoryWalk dw = new TestCommonIODiretoryWalk() ;
                List l1 = dw.reName(new File(&amp;quot;e://b&amp;quot;));
                Iterator it = l1.iterator();
                while(it.hasNext())
                {
                        System.out.println(it.next());
                }
        }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;案例2：修改一个文件加下的所有以txt结尾的修改为doc结尾的
主要代码：（基本上 框架类似于案例1  主要修改handleFile的子程序 其他地方不需要怎么修改）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected void handleFile(File file,int depth, Collection results)
        {
                String banana = file.getName();
                String newFilename= file.getParent()+File.separator+banana.replaceAll(&amp;quot;.txt&amp;quot;+&amp;quot;[        DISCUZ_CODE_5        ]quot;, &amp;quot;.doc&amp;quot;);
                file.renameTo(new File(newFilename));
                results.add(file);
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4.Filters
过滤器：过滤在这边的意思是指保留那些满足某个条件的文件(而不是取消）
Org.apache.commons.io.filefilter 包定义了一个接口（IOFileFilter）用于连接java.io.FileFilter和java.io.FilenameFilter.除了这个之外，包中提供了一系列可以使用的IOFileFilter接口的实现，包括允许你连接其他过滤器的实现。这些过滤器可以被用于列出文件或者在FileDialog
全部代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
* @author 叶昭良
*
*/
import java.io.File;
import java.io.FilenameFilter;

import org.apache.commons.io.filefilter.SuffixFileFilter;
import org.apache.commons.io.filefilter.IOFileFilter;
import org.apache.commons.io.filefilter.NotFileFilter;
import org.apache.commons.io.filefilter.OrFileFilter;
import org.apache.commons.io.filefilter.AndFileFilter;
import org.apache.commons.io.filefilter.DirectoryFileFilter;

import java.io.*;
public class TestCommonIOgetTxtFiles
{

        /**
         * @param args
         */        
public static void main(String[] args)
        {
                // TODO 自动生成的方法存根
                
                File rootDir = new File(&amp;quot;e://&amp;quot;);
                // 列出所有的java结尾的所有文件（当前目录）
                // SuffixFileFilter的使用，定义了一个FilenameFilter接口
                FilenameFilter fileFilter = new SuffixFileFilter(&amp;quot;.java&amp;quot;); // 满足.java结尾的文件，这也正好符合过滤在当前情况下的定义。
                String[] txtFiles = rootDir.list(fileFilter);
                for(int i = 0 ; i &amp;lt; txtFiles.length; i++)
                {
                        System.out.println(rootDir+File.separator+txtFiles[i]);
                }
                // 列出所有的html和htm的文件（在当前文件目录下）
                // IOFileFilter、OrFileFilter、NotFileFilter、AndFileFilter的使用（and or 逻辑）
                IOFileFilter htmlFilter =   // 定义了一个IOFileFilter接口接口
                                new OrFileFilter(new SuffixFileFilter(&amp;quot;.html&amp;quot;),new SuffixFileFilter(&amp;quot;.htm&amp;quot;));  // 为什么有时候用IOFileFilter 而有时候用FilenameFilter?
                IOFileFilter notDirectory = new NotFileFilter(DirectoryFileFilter.INSTANCE);
                // 拒绝选择目录
                FilenameFilter fileFilter1= new AndFileFilter(htmlFilter,notDirectory); // 利用AndFileFilter连接两个过滤器接口
                File[] htmlfiles = rootDir.listFiles(fileFilter1);
                for(int i = 0; i&amp;lt; htmlfiles.length; i++)
                {
                        System.out.println(htmlfiles[i]);
                }
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码说明：
接口是一个更高级别的类，所以可以定义类型变量。具体看filename.gif&lt;/p&gt;

&lt;p&gt;案例2： 当前文件夹下的一天前的所有文件
AgeFileFilter : 通过一个cutoff截止时间来过滤文件，可以过滤出更新的 更旧的 或者就是某一个时间点的信息。
比如下面的  打印所有当前文件夹内的早于一天前创建的文件和文件夹
主要代码：
查看主要代码的图片。&lt;/p&gt;

&lt;p&gt;案例3： 获取文件夹下的可读 可写   目录文件（普通文件类似） 空文件  隐藏文件
说明：最好是在打印时候(for 循环)加上异常的判断（NullPointerException)
主要代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import org.apache.commons.io.filefilter.CanReadFileFilter;
import org.apache.commons.io.filefilter.CanWriteFileFilter;
import org.apache.commons.io.filefilter.DirectoryFileFilter;
import org.apache.commons.io.filefilter.EmptyFileFilter;
import org.apache.commons.io.filefilter.HiddenFileFilter;
                // TODO 自动生成的方法存根
                 File dirBanana = new File(&amp;quot;E:\\测试目录&amp;quot;);
                 String[] filesBanana = dirBanana.list(CanReadFileFilter.CAN_READ);
                 for(int i = 0; i &amp;lt; filesBanana.length; i++)
                 {
                         System.out.println(&amp;quot;Banana可读文件:&amp;quot;+filesBanana[i]);
                 }
                 System.out.println(&amp;quot;分割线--------------------------&amp;quot;);
                 File dirOrange = new File(&amp;quot;E:\\测试目录&amp;quot;);
                 String[] filesOrange = dirOrange.list(CanReadFileFilter.READ_ONLY);
                 for(int i = 0; i &amp;lt; filesOrange.length; i++)
                 {
                         System.out.println(&amp;quot;Orange只读文件:&amp;quot;+filesOrange[i]);
                 }
                 
                 System.out.println(&amp;quot;分割线--------------------------&amp;quot;);
                 File dirApple = new File(&amp;quot;E:\\测试目录&amp;quot;);
                 String[] filesApple = dirApple.list(CanReadFileFilter.CANNOT_READ);
                 if(filesApple.length == 0)
                 {
                          System.out.println(&amp;quot;Apple未找到不可读文件&amp;quot;);
                 }else
                 {
                         for(int i = 0; i &amp;lt; filesApple.length; i++)
                         {
                                 System.out.println(&amp;quot;Apple不可读文件:&amp;quot;+filesApple[i]);
                         }
                 }
                 
                 
                 File dirEgg = new File(&amp;quot;E:\\测试目录&amp;quot;);
                 String[] filesEgg = dirEgg.list(CanWriteFileFilter.CAN_WRITE);
                 for(int i = 0 ; i &amp;lt; filesEgg.length; i++)
                 {
                         System.out.println(&amp;quot;Egg 找到了可写文件:&amp;quot;+filesEgg[i]);
                 }
                 
                 File dirChichen = new File(&amp;quot;E:\\测试目录&amp;quot;);
                 String[] filesChichen = dirChichen.list(CanWriteFileFilter.CANNOT_WRITE);
                 for(int i = 0 ; i &amp;lt; filesChichen.length; i++)
                 {
                         System.out.println(&amp;quot;Chichen 找到了不可写文件:&amp;quot;+filesChichen[i]);
                 }
                 
                 File dirDirectory = new File(&amp;quot;E:\\&amp;quot;);
                 String[] filesDirectory = dirDirectory.list(DirectoryFileFilter.INSTANCE);
                 for(int i = 0; i &amp;lt; filesDirectory.length; i++)
                 {
                         System.out.println(&amp;quot;列出所有E盘下的文件夹名字:&amp;quot;+filesDirectory[i]);
                 }
                 
                 File dirEmpty = new File(&amp;quot;E:\\&amp;quot;);
                 String[] filesEmpty = dirEmpty.list(EmptyFileFilter.EMPTY);
                 for(int i = 0; i &amp;lt; filesEmpty.length; i++)
                 {
                         System.out.println(&amp;quot;dirEmpty列出所有E盘下的空文件名字（包括空文件夹）:&amp;quot;+filesEmpty[i]);
                 }
                 
                 File dirNotEmpty = new File(&amp;quot;E:\\&amp;quot;);
                 String[] filesNotEmpty = dirNotEmpty.list(EmptyFileFilter.NOT_EMPTY);
                 for(int i = 0; i &amp;lt; filesNotEmpty.length; i++)
                 {
                         System.out.println(&amp;quot;dirNotEmpty列出所有E盘下的非空文件名字（包括空文件夹）:&amp;quot;+filesNotEmpty[i]);
                 }
                 
                 File dirHidden = new File(&amp;quot;E:\\测试目录&amp;quot;);
                 String[] filesHidden = dirHidden.list(HiddenFileFilter.HIDDEN);
                 try
                 {
                         for(int i = 0; i &amp;lt; filesHidden.length; i++)
                         {
                                 System.out.println(&amp;quot;dirHidden列出所有E盘下的隐藏名字（包括空文件夹）:&amp;quot;+filesHidden[i]);
                         }
                 }catch(NullPointerException e)
                 {
                         System.out.println(&amp;quot;未找到任何隐藏文件 在测试目录下&amp;quot;);
                 }
                 
                 File dirVisible = new File(&amp;quot;E:\\测试目录&amp;quot;);
                 String[] filesVisible = dirHidden.list(HiddenFileFilter.VISIBLE);
                 try
                 {
                         for(int i = 0; i &amp;lt; filesVisible.length; i++)
                         {
                                 System.out.println(&amp;quot;dirHidden列出所有E盘下的隐藏名字（包括空文件夹）:&amp;quot;+filesHidden[i]);
                         }
                 }catch(NullPointerException e)
                 {
                         System.out.println(&amp;quot;未找到任何隐藏文件 在测试目录下&amp;quot;);
                 }

        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;文件过滤器的规律是: 都是以FileFilter结尾的 比如SuffixFileFilter   AndFileFilter,OrFileFilter, NotFileFilter,AgeFileFilter,CanWriteFileFilter,CanReadFileFilter,DirectoryFileFilter,FileFileFilter,NameFileFilter,WildcardFileFilter。。。
有些接口需要new出来一个对象，比如new  SuffixFileFilter(&amp;ldquo;.txt&amp;rdquo;)  ,new NameFileFilter(&amp;ldquo;TestFile&amp;rdquo;) 、new SizeFileFilter(1024*1024) 、new And,Or,NotFileFilter&amp;hellip;等有些接口是直接使用，比如HiddenFileFilter.HIDDEN|VISIBLE   CanReadFileFilter.CANREAD|CANNOTREAD     CanWriteFileFilter.CANWRITE|CANNOTWRITE   EmptyFileFilter.EMPTY|NOTEMPTY   DirectoryFileFilter.INSTANCE   FileFileFilter.FILE等&lt;/p&gt;

&lt;p&gt;5.Stream部分：
主要测试了CountingInputStream 、  CountingOutputStream、TeeOutputStream、TeeInputStream&lt;/p&gt;

&lt;p&gt;CountingInputStream :统计输出流的字节个数（Counting InputStream），可用于网络收费
CountingOutputStream:测量输入流的统计，可用于网络收费
TeeOutputStream:需要输入两个OutputStreams，同时输出到两个硬盘文件
TeeOutputStream：一个inputStream 一个OutputStream,在读取InputStream的同时，也输出到硬盘上的另一个文件，充当备份。&lt;/p&gt;

&lt;p&gt;TeeInputStream:
CommonsIO刚刚接触，只是一些浅显的知识，跟大家分享了,可以通过比较传统的IO流的实现，
CommonsIO流的确为我们封装了很多有用而且快捷的类方法，当然前提是得对基本的IO流有一定的基础性认识。
有问题的，求指教。
&lt;img src=&#34;https://jueqingsizhe66.github.io/images/java/filename.gif&#34; alt=&#34;过滤器接口的说明&#34; /&gt;
&lt;img src=&#34;https://jueqingsizhe66.github.io/images/java/主要代码.gif&#34; alt=&#34;打印所有当前文件夹内的早于一天前创建的文件和文件夹&#34; /&gt;&lt;/p&gt;

&lt;p&gt;另外的,WildcardFileFilter类似于RegexFileFilter可以模糊的定位当前文件夹下的所有符合模糊条件的文件，
比如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;WildcardFileFilter
         //列出所有的文件大小大于*test*.java*的文件
                 File dirWildcard = new File(&amp;quot;E:\\测试目录&amp;quot;);
                 String[] filesWildcard = dirWildcard.list(new WildcardFileFilter(&amp;quot;*test*.java*&amp;quot;)); //正则表达式
                 try
                 {
                         for(int i = 0; i &amp;lt; filesWildcard.length; i++)
                         {
                                 System.out.println(&amp;quot;dirWildcard列出所有E盘下的隐藏名字（包括空文件夹）:&amp;quot;+filesWildcard[i]);
                         }
                 }catch(NullPointerException e)
                 {
                         System.out.println(&amp;quot;未找到任何普通文件 在测试目录下&amp;quot;);
                 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;RegexFileFilter:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//列出所有的文件包含*test*.java的文件
                 File dirRegex = new File(&amp;quot;E:\\测试目录&amp;quot;);
                 FileFilter ff = new RegexFileFilter(&amp;quot;.*test.*\\.java.*&amp;quot;); //正则表达式 不能写成*test*
                 File[] filesRegex = dirRegex.listFiles(ff);
                 try
                 {
                         for(int i = 0; i &amp;lt; filesRegex.length; i++)
                         {
                                 System.out.println(&amp;quot;dirRegex列出所有E盘下的隐藏名字（包括空文件夹）:&amp;quot;+filesRegex[i]);
                         }
                 }catch(NullPointerException e)
                 {
                         System.out.println(&amp;quot;未找到任何普通文件 在测试目录下&amp;quot;);
                 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：FileFilter ff = new RegexFileFilter(&amp;ldquo;.&lt;em&gt;test.&lt;/em&gt;\.java&amp;rdquo;);  ff可以作为listFiles的参数类型，但是RegexFileFilter这个FileFilter的子类产生的对象无法充当listFiles的参数，这边体现着多态的概念，而且是接口的多态。有一个问题：不明白为什么不能用RegexFileFilter 的对象？？？？ RegexFileFilter查阅源码的确是继承FileFilter和FilenameFilter的，难道是说多态一般只是使用在赋值语句，而在构造函数必须使用对应的类型   listFiles函数的声明为 public File[] listFiles(FileFilter filter){..}  或者public File[] listFiles(FilenameFilter filter){..} ）   求指教~-~&lt;/p&gt;

&lt;p&gt;首先感谢杨老师的远控解决了我的一个困惑。
其实自己也应该猜到，分享一下讲解过程
public class RegexFileFilter extends AbstractFileFilter&lt;br /&gt;
复制代码
RegexFileFilter继承了AbstractFileFilter&lt;/p&gt;

&lt;p&gt;public abstract class AbstractFileFilter implements IOFileFilter
复制代码&lt;/p&gt;

&lt;p&gt;AbstractFileFilter实现了IOFileFilter  接口可以实现多继承，于是进一步观看了IOFileFilter
public interface IOFileFilter extends FileFilter, FilenameFilter
复制代码&lt;/p&gt;

&lt;p&gt;IOFileFilter又继承了FileFilter和FilenameFilter这两个接口，并且这两个接口已经是祖先级的接口&lt;/p&gt;

&lt;p&gt;之前我一直用RegexFileFilter定义ff变量，传到listFiles()中死活报错，如下：
RegexFileFilter ff = new RegexFileFilter(&amp;ldquo;.&lt;em&gt;test.&lt;/em&gt;\.java.*&amp;ldquo;);
复制代码
原因是RegexFileFilter继承了两个接口FileFilter,FilenameFilter,而listFiles也是实现了两种方式的重载（可以进入listFiles类，利用神健组合ctrl+o观看到   listFiles(FileFilte)  listFiles(FileFilename))
所以如果ff不显示指定的话，listFiles怎么知道要重载哪个函数？&lt;/p&gt;

&lt;p&gt;三种解决方法：
1：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   File[] filesRegex = dirRegex.listFiles((FilenameFilter)ff);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   File[] filesRegex = dirRegex.listFiles((FileFilter)ff);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;都是可以的，也可以用上面的多态的方法
3：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   FileFilter ff = new RegexFileFilter(&amp;quot;.*test.*\\.java&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;问题的根源：重载+显示指定类型&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;学习了    /**  然后摁下 Enter键 在eclipse中自动加入注释段，并且 敲击@可以产生想要的注释字段。
较专业写法，代码的注释，必须学习
/**
         * 输入流中的内容到输出流去
         * @param input
         * @param out
         * @throws Exception
         */&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>1月26日Java班笔记</title>
      <link>https://jueqingsizhe66.github.io/blog/2015/05/11/1yue-26ri-javaban-bi-ji/</link>
      <pubDate>Mon, 11 May 2015 14:58:40 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/blog/2015/05/11/1yue-26ri-javaban-bi-ji/</guid>
      <description>&lt;p&gt;进一步针对com.rupeng.gtk.GTK主类进行了分析
第一部分：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class GTK
{

        static
        {
                Utils.unZipShared();
                Utils.loadGtkLibs();
                Utils.loadDll(&amp;quot;gtk4j.dll&amp;quot;);
        }
.....
        /**
         * 初始化gtk环境
         */
        public static native void gtk_init();//
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在GTK类中包含主要两个部分，一个是静态代码段Static部分，主要用于做前期工作，产生dll文件以及解压缩，文件流的复制等
另一部分主要是静态代码的声明；&lt;/p&gt;

&lt;p&gt;针对第一部分静态代码段需要分为三个部分 unZipShare()部分、loadGtkLibs和loadDll，他们三个分别是Utils类的主要静态方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Utils.unZipShare():
        public static void unZipShared()
        {
                File gtkDir = new File(System.getProperty(&amp;quot;user.dir&amp;quot;), &amp;quot;gtk&amp;quot;);// *.dll放的文件夹
                if (!gtkDir.exists())
                {
                        gtkDir.mkdirs();
                }
                InputStream inStream = Utils.class.getResourceAsStream(&amp;quot;/gtkshare.zip&amp;quot;);
                if (inStream == null)
                {
                        throw new UnsatisfiedLinkError(&amp;quot;没找到gtkshare.zip&amp;quot;);
                }
                try
                {                        
                        unZip(inStream, gtkDir.toString());
                } catch (IOException e)
                {
                        System.err.println(&amp;quot;解压缩gtkshare.zip失败&amp;quot; + toFullString(e));
                }
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码的主要功能是：
1.利用File(System.getProperties(&amp;ldquo;User.dir&amp;rdquo;,&amp;ldquo;gtk&amp;rdquo;)创建主要文件夹gtk，用于存放dll文件
2.利用Utils类的反射（不清楚，和之前的Properties的当前类TestProperties.class.getClassLoader().getResourceAsStream()的效果一样） 都是获取一个输入流。在这边获取的是一个当前文件夹下的gtkshare.zip输入流附上Properties的语法，当做复习&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;inStream = TestProperties.class.getClassLoader().getResourceAsStream(&amp;quot;b.properties&amp;quot;);
                // 用于提取项目文件中的文件  默认如果没有包名字  就只写项目里面的文件即可！
            System.out.println(inStream.getClass());
                Properties prop  = new Properties();//修正图片中存在的错误  TestProperties是一个当前类
类似于图片中的Utils类！ 有所不同的是class之后还需要调用getClassLoader 。 当前的dll载入，rupeng的
包是采用System.load而Properities是采用prop.load(inStream);的方式。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.最后通过unZip方式打开，为此还需要进一步研究unZip代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;        public static void unZip(InputStream streamToZip,String destDir)throws IOException
        {  
                ZipInputStream zipStream = new ZipInputStream(streamToZip);
                try
                {
                        ZipEntry zipEntry = null;
                        while((zipEntry=zipStream.getNextEntry())!=null)
                        {
                                if(zipEntry.isDirectory())
                                {
                                        File dir = new File(destDir,zipEntry.getName());
                                        if(!dir.exists())
                                        {
                                                dir.mkdirs();
                                        }
                                }
                                else
                                {
                                        FileOutputStream fileOutStream = new FileOutputStream(new File(destDir,zipEntry.getName()));
                                        try
                                        {
                                                copy(zipStream, fileOutStream);
                                        }
                                        finally
                                        {
                                                close(fileOutStream);
                                        }
                                }
                        }
                }
                finally
                {
                        close(zipStream);
                }
                
    }  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码的主要作用是
1：把一个输入的压缩流zipStream 利用压缩流特有的ZipEntry（类似容器当中的Iterator ）逐个从流中解压缩，
      1.1 如果该流文件夹，则创建文件夹
      1.2 如果该流是文件夹 ，则利用文件输出流（FileOutputStream），把解压缩流的信息存到输出流中。
所以也就是说：解压缩流的文件的结构也是和为解压缩时候的结构是一样的，既有文件夹文件，又有普通文件（另外文件File是一个比较宽泛的定义，File定义的对象既可以是文件夹文件对戏那个，也可以是普通文件，或者管道文件，索引文件，设备文件 ，即File可以代表文件夹、普通文件、管道文件、索引文件、设备文件等。)&lt;/p&gt;

&lt;p&gt;为了进一步研究Utils.unZip(),我们需要进一步研究Utils.copy()：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;        static void copy(InputStream inStream, OutputStream outStream)
                        throws IOException
        {
                byte[] buffer = new byte[512 * 1024];// 0.5MB 的缓冲区
                int len;
                while ((len = inStream.read(buffer)) &amp;gt;= 0)
                {
                        outStream.write(buffer, 0, len);
                }
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明: 如鹏网先通过建立0.5MB的缓冲区，用于载入输入的压缩流，当达到0.5MB的时候，再利用文件输出流写出压缩流信息到先前创建的gtk/bin目录下。
我想着是不是可以用BufferedInputStream和BufferedOutputStream,于是修改代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;        static void copy(InputStream inStream, OutputStream outStream)
                        throws IOException
        {
BufferedInputStream bis = null;
BufferedOutputStream bos = null;
try
{
bis = new BufferedInputStream(inStream);
bos = new BufferedOutputStream(outStream);

                byte[] buffer = new byte[512 * 1024];// 0.5MB 的缓冲区(rupeng采用的策略)
                int len;
       
                while ((len = bis.read(buffer)) &amp;gt;= 0) //最后一个返回的是-1
                {
                        bos.write(buffer, 0, len);
                }
}catch(IOException e)
{   System.out.println(“读取错误”);
}        
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;并未做测试。只是想着为什么不用缓冲流？当然两者的效果一样
于是我做了下面的测试 针对BufferedInputStream BufferedOutputStream 以及FileInputstream ,FileOutputStream（不是如鹏gtk4j的ZipInputStream 和FileOutputStream）&lt;/p&gt;

&lt;p&gt;测试代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
* 
*/

/**
* @author 叶昭良
*
*/
import java.io.*;
import java.util.Arrays;
public class TestBufferedInputStream
{

        /**
         * @param args
         */
        public static void main(String[] args)
        {
                long t1 = System.currentTimeMillis();
                TestBufferedInputStream();
                //System.out.printf(&amp;quot;BufferedInputStream总共用时:&amp;quot;+Long.toString((System.currentTimeMillis() - t1)));
                System.out.println(&amp;quot;BufferedInputStream总共用时:&amp;quot;+(System.currentTimeMillis() - t1));
                //System.out.printf(&amp;quot;BufferedInputStream总共用时:%ld&amp;quot;,(System.currentTimeMillis() - t1));
                
                
                long t2 = System.currentTimeMillis();
                TestFileInputStream();
                //System.out.printf(&amp;quot;FileInputStream总共用时:&amp;quot;+Long.toString((System.currentTimeMillis() - t2)));
                System.out.println(&amp;quot;FileInputStream总共用时:&amp;quot;+(System.currentTimeMillis() - t2));
                //System.out.printf(&amp;quot;FileInputStream总共用时:%ld&amp;quot;,(System.currentTimeMillis() - t2));
                
        }
        public static void TestBufferedInputStream()        
        {
                // TODO 自动生成的方法存根
                BufferedInputStream bis = null;
                BufferedOutputStream  bos = null;
                byte[] fileToFile = new byte[512*1024];
                int len = 0;
                try
                {
                        bis = new BufferedInputStream(new FileInputStream(&amp;quot;E:\\测试目录\\MindManager.exe&amp;quot;));
                        bos = new BufferedOutputStream(new FileOutputStream(&amp;quot;E:\\测试目录\\Mind1.exe&amp;quot;));
                        
                        len  = bis.read(fileToFile);
                        while(-1 != len)
                        {
                                //System.out.printf(&amp;quot;%s&amp;quot;,new String(fileToFile));
                                //System.out.printf(&amp;quot;%s&amp;quot;,Arrays.toString(fileToFile));
                                bos.write(fileToFile,0,len);
                                bos.flush();
                                len = bis.read(fileToFile);
                                
                        }
                }catch(Exception e)
                {
                        e.printStackTrace();
                }
                finally
                {
                        try
                        {
                                bis.close();
                                bos.close();
                        }catch(Exception e)
                        {
                                e.printStackTrace();
                        }
                }
        }
        
        
        public static void TestFileInputStream()        
        {
                // TODO 自动生成的方法存根
                FileInputStream fis = null;
                FileOutputStream  fos = null;
                byte[] fileToFile = new byte[512*1024];
                int len = 0;
                try
                {
                        fis = new FileInputStream(&amp;quot;E:\\测试目录\\MindManager.exe&amp;quot;);
                        fos = new FileOutputStream(&amp;quot;E:\\测试目录\\Mind2.exe&amp;quot;);
                        
                        len  = fis.read(fileToFile);
                        while(-1 != len)
                        {
                                //System.out.printf(&amp;quot;%s&amp;quot;,fileToFile);
                                //System.out.printf(&amp;quot;%s&amp;quot;,Arrays.toString(fileToFile));
                                fos.write(fileToFile,0,len);
                                fos.flush();
                                len = fis.read(fileToFile);
                                
                        }
                }catch(Exception e)
                {
                        e.printStackTrace();
                }
                finally
                {
                        try
                        {
                                fis.close();
                                fos.close();
                        }catch(Exception e)
                        {
                                e.printStackTrace();
                        }
                }
        }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;基本上保持上下的代码的一致性，除了输入流和输出流的不一样，并比较时间&lt;/p&gt;

&lt;p&gt;说明：测试对象 MindManage.exe 大概是126MB ，
测试结果：第一阶段测试：
第一次：
BufferedInputStream总共用时:301
FileInputStream总共用时:369
第二次再运行:
BufferedInputStream总共用时:296
FileInputStream总共用时:319
第三次
BufferedInputStream总共用时:280
FileInputStream总共用时:278
第四次
BufferedInputStream总共用时:337
FileInputStream总共用时:305&lt;/p&gt;

&lt;p&gt;分析发现，前两次基本上是Buffered方式较好，后两种基本上是File较好，这有可能是eclipse已经帮你载入了缓存的原因，于是删掉测试目录下的Mind1.exe Mind2.exe&lt;/p&gt;

&lt;p&gt;进行第二次测试阶段：
第一次：
BufferedInputStream总共用时:251
FileInputStream总共用时:261&lt;/p&gt;

&lt;p&gt;第二次：
BufferedInputStream总共用时:286
FileInputStream总共用时:303&lt;/p&gt;

&lt;p&gt;第三次： 报错，提示Mind1.exe被占用，问题不是主要的，于是再次删掉Mind1.exe Mind2.exe&lt;/p&gt;

&lt;p&gt;第三阶段测试：
第一次：
BufferedInputStream总共用时:304
FileInputStream总共用时:431
第二次：
又提醒Mind1.exe被占用，估计还未写完，但其实文件的大小已经是和MindMange.exe相等。
第三次：
BufferedInputStream总共用时:299   ，变长了
FileInputStream总共用时:284&lt;/p&gt;

&lt;p&gt;经过三个阶段测试发现: 如果单以第一次为标准的话，Buffered的方式是比FileInputStream的方式快一些。&lt;/p&gt;

&lt;p&gt;回到主题，已经从Utils.unZipShared()&amp;mdash;-&amp;gt;Utils.unZip()&amp;mdash;-&amp;gt;Utils.copy()这条线走通了一遍，基本上完成的是
1.创建主目录gtk ,并解压缩gtkshare.zip,并调用unzip
2.创建gtk底下的子目录bin和share以及其他，并导入其中的一些dll文件（暂时不清楚具体是哪个dll)(导入的方式是通过文件流的复制过程，当然其实也是可以用IOUtils.copy(inStream,outStream）的方式&lt;/p&gt;

&lt;p&gt;第二部分：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Utils.loadGtkLibs();
        static void loadGtkLibs()
        {
                // 如果这些dll放到user.dir根目录下，则只要在gtk4j.dll加载之前把libffi-6.dll等这些被依赖的放到user.dir根目录下即可
                // 但是如果放到其他目录下（放到根目录下在项目里看到一堆dll文件，太难看，所以放到gtkbin下），就要注意加载顺序
                // 要先加载被依赖的dll。使用DependencyWalker可以看dll的依赖关系

                loadDll(&amp;quot;libffi-6.dll&amp;quot;);
                loadDll(&amp;quot;libpixman-1-0.dll&amp;quot;);
                loadDll(&amp;quot;zlib1.dll&amp;quot;);
                loadDll(&amp;quot;liblzma-5.dll&amp;quot;);
                loadDll(&amp;quot;libiconv-2.dll&amp;quot;);
                loadDll(&amp;quot;pthreadGC2.dll&amp;quot;);

                loadDll(&amp;quot;libxml2-2.dll&amp;quot;);// 依赖于libiconv-2.dll、liblzma-5.dll

                loadDll(&amp;quot;libpng15-15.dll&amp;quot;);// 依赖于zlib1.dll
。。。。
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明： 原来这个函数主要是用于载入存在于gtk/bin目录下的大多数的dll文件 ，但是不包含gtk4j.dll (这是在第三步的时候单独实现，为什么分开不明白？）&lt;/p&gt;

&lt;p&gt;为此进一步追踪了loadDll的实现：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;        static void loadDll(String dllName)
        {
                // 把dll拷贝到项目根目录下
                File gtkBinDir = new File(System.getProperty(&amp;quot;user.dir&amp;quot;), &amp;quot;gtk/bin&amp;quot;);// *.dll放的文件夹
                if (!gtkBinDir.exists())
                {
                        gtkBinDir.mkdirs();
                }
                File destDllFile = new File(gtkBinDir, dllName);

                // dll位于项目的lib目录下，并且把lib设定为“源码文件夹”，这样这些dll就会生成到jar的根目录下了
                InputStream inStream = Utils.class.getResourceAsStream(&amp;quot;/&amp;quot; + dllName);
                if (inStream == null)
                {
                        throw new UnsatisfiedLinkError(&amp;quot;没找到&amp;quot; + dllName);
                }

                // 如果dll已经存在，则尝试删除，再拷贝新的，这样保证能自动升级
                if (destDllFile.exists())
                {
                        // 如果文件已经存在，则不覆盖，提高运行效率，如果需要升级，则需要手动清理dll
                        System.out.println(dllName + &amp;quot;已经存在，默认加载。如果需要采用新版本dll，请先删除文件夹&amp;quot;
                                        + gtkBinDir + &amp;quot;下所有的*.dll&amp;quot;);
                } else
                {
                        // 拷贝来新的
                        FileOutputStream fileOutStream = null;
                        try
                        {
                                fileOutStream = new FileOutputStream(destDllFile);
                                copy(inStream, fileOutStream);
                        } catch (IOException e)
                        {
                                throw new RuntimeException(&amp;quot;拷贝&amp;quot; + dllName + &amp;quot;失败&amp;quot;, e);
                        } finally
                        {
                                close(inStream);
                                close(fileOutStream);
                        }
                }
                System.load(destDllFile.toString());
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：正如源代码的注释拷贝dll文件到gtk/bin目录下。
1：先创建一个主目录gtk/bin
2:  根据gtk/bin这个file对象和dll文件名字创建一个File对象，并判断是否存在，如果不存在则复制到gtk/bin中，如果存在，则会发现一句我们比较熟悉的“已经存在，默认加载。如果需要采用新版本dll，请先删除文件夹&amp;rdquo;+ gtkBinDir + &amp;ldquo;下所有的&lt;em&gt;.dll”
3.拷贝dll文件方式  基本上也是利用FileOutputStream 和copy函数
4.载入dll文件到系统当中，通过System.load(&lt;/em&gt;.dll);&lt;/p&gt;

&lt;p&gt;到这里为止，基本上完成了GTK.class和Utils.class中主要使用到的类的实现和调用学习。&lt;/p&gt;

&lt;p&gt;后来经赵帅提醒原来GTK里面其实是有很多的native的静态类的声明，但是并没有对应的实现，那么实现到底去哪里？ 当然这个是dll载入和JNI接口的问题（而之所以用dll动态链接库载入文件，是因为原先的gtk源代码是通过c语言编写，在java中可以利用jni接口方便的调用c语言产生的动态链接库的实现，而具体的调用规范可以见下面的五个步骤），为此我用最简单的hello、hi程序进行模拟。&lt;/p&gt;

&lt;p&gt;主要分为五步（感谢帅帅）：
1.建立一个hello.java模仿GTK class的方式 建立了静态代码快 导入待生成的dll文件，然后创建了一个类对象调用dll实现的方法  javac hello.java 生成一个java.class
2.利用javah -jni hello 生成hello.h ，这个hello.h是关键，提示hello.c的函数头的书写
3.利用hello.h内部的函数头，新建hello.c文件 ，并按照函数头的形式实现三个函数&lt;br /&gt;
4.利用 gcc -shared hello.c -o hello.dll的形式生成dll 文件
5.java hello&lt;/p&gt;

&lt;p&gt;分解第一步：创建了hello.java&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class hello
{
    public native void sayHello(); // 3个native函数声明，表明需要有3个c语言的实现
    public native void sayHi();
    public native int max(int a ,int  b);
    static // 静态代码块
    {
        System.loadLibrary(&amp;quot;hello&amp;quot;);
    }

    public static void main(String[] args)
    {
        new hello().sayHello();
        new hello().sayHi();
        int  a = new hello().max(3,5);
        System.out.println(&amp;quot;the maximum value of 3 and 5 is &amp;quot;+a);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的过程基本上和GTK.class有点像，
1.三个非静态函数的声明（这边不用静态 ，如果是静态也可以直接加上一个native），
2.然后是一个静态代码快载入dll文件，
3.紧接着是main函数调用当前对象的方法，实现java调用c语言的实现&lt;/p&gt;

&lt;p&gt;编译1：
javac hello.java
复制代码&lt;/p&gt;

&lt;p&gt;编译2：
javah -jni  hello
复制代码&lt;/p&gt;

&lt;p&gt;在编译2中生成了hello.h ,打开了，文件内容为：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/* DO NOT EDIT THIS FILE - it is machine generated */
#include &amp;lt;jni.h&amp;gt;
/* Header for class hello */

#ifndef _Included_hello
#define _Included_hello
#ifdef __cplusplus
extern &amp;quot;C&amp;quot; {
#endif
/*
* Class:     hello
* Method:    sayHello
* Signature: ()V
*/
JNIEXPORT void JNICALL Java_hello_sayHello
  (JNIEnv *, jobject);

/*
* Class:     hello
* Method:    sayHi
* Signature: ()V
*/
JNIEXPORT void JNICALL Java_hello_sayHi
  (JNIEnv *, jobject);

/*
* Class:     hello
* Method:    max
* Signature: (II)I
*/
JNIEXPORT jint JNICALL Java_hello_max
  (JNIEnv *, jobject, jint, jint);

#ifdef __cplusplus
}
#endif
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的c语言编译指令，暂时不管，因为我们关心的是函数的声明，把他们一一拷贝到hello.c
当然首先你得用记事本新建一个hello.c文件，然后一一拷贝上面的三个函数头声明，并在里面写上实现（当时我也是蒙着写着那些实现，猜的），注意导入jni.h(我是直接拷贝%JAVA_HOME%/include/jni.h到当前目录下) 和
hello.h 以及stdio.h（printf函数的声明）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;jni.h&amp;gt;
#include &amp;quot;hello.h&amp;quot;
#include &amp;lt;stdio.h&amp;gt;
JNIEXPORT void JNICALL Java_hello_sayHello(JNIEnv * env, jclass obj)
{
    printf(&amp;quot;say Hello to you\n&amp;quot;);
}

JNIEXPORT void JNICALL Java_hello_sayHi(JNIEnv * env, jclass obj)
{
    printf(&amp;quot;say hi to you\n&amp;quot;);
}

JNIEXPORT jint JNICALL Java_hello_max(JNIEnv * env, jclass obj, jint a , jint b)
{
    int  max =  a;
    if(max &amp;lt; b)
    {
        return b;
    }else
    {
        return  a;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;于是我们得到了c语言的实现，并进一步整理为一个dll文件
编译3：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;gcc -I. -LD --add-stdcall-alias -shared hello.c -o hello.dll
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再用gcc进行编译成java可以使用的dll文件时候一定要加入&amp;ndash;add-stdcall-alias,否则报UnsatisfiedLinkError  ,如果查过loadDLL的实现会发现，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;                if (inStream == null)
                {
                        throw new UnsatisfiedLinkError(&amp;quot;没找到&amp;quot; + dllName);
                }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个异常的出现和编译指令&amp;ndash;add-stdcall-alias惊人的对应，一个产生，一个消去。&lt;/p&gt;

&lt;p&gt;完成了编译3之后，我们就得到了hello.dll(动态链接库是什么，就是你在运行时候java会导入的函数实现，供java进行c语言函数调用，当然这个过程不用管，只需要hello.dll在当前的项目文件夹下即可）&lt;/p&gt;

&lt;p&gt;运行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;java hello
E:\testDLL\testJavaDll&amp;gt;java hello
say Hello to you
say hi to you
the maximum value of 3 and 5 is 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可见已经连接成功。&lt;/p&gt;

&lt;p&gt;另外如果大家觉得编译过程麻烦，我也附上一个makefile&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;JC=javac
JH=javah
JHOption=-jni
JRun=java
CC=gcc
# I had put the jni.h into current directory
DLLOPTION  = -I.  -LD -Wl,--add-stdcall-alias -shared
CFLAGS = -c


src = hello.java
srctemp = hello.c
srcClass = $(basename $(src))
# generate  the hello.java
# generate hello.h
#NOw you need to write your hello.c according to hello.h

Dll1 =$(addsuffix .dll,$(basename $(src))) 
HeadTarget:
        $(JC)  $(src)
        $(JH)  $(JHOption) $(srcClass) 

AppTarget:
        $(CC) $(DLLOPTION) -o $(Dll1) $(srctemp)
        $(JRun) $(srcClass)

.PHONY:clean
clean:
        del $(Dll1) /s
        del $(srcClass).class /s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先是运行：
1：make  HeadTarget
      会得到hello.h,然后得去编写hello.c文件
2:  make AppTarget
      会得到hello.dll文件，并运行java hello&lt;/p&gt;

&lt;p&gt;前提你得安装gnu make.&lt;/p&gt;

&lt;p&gt;附上loadDLL的实现：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://jueqingsizhe66.github.io/images/java/4.png&#34; alt=&#34;loadDLL的注释&#34; /&gt;
&lt;img src=&#34;https://jueqingsizhe66.github.io/images/java/5.gif&#34; alt=&#34;hello.c hello.java Makefile&#34; /&gt;
&lt;img src=&#34;https://jueqingsizhe66.github.io/images/java/5.png&#34; alt=&#34;unZipShare&#34; /&gt;
&lt;img src=&#34;https://jueqingsizhe66.github.io/images/java/6.gif&#34; alt=&#34;unZip的注释&#34; /&gt;&lt;/p&gt;

&lt;p&gt;认识界面！
控制台程序
界面程序（GUI）
网站程序（HTML+JavaScript+JSP）
手机程序（Android）&lt;/p&gt;

&lt;p&gt;学GTK不是主要目的
学工具是低层次，学思想才是王道，后期学习javaee的ssh的架构思想。&lt;/p&gt;

&lt;p&gt;GTK的学习目的是深刻理解面向对象的意义，而不是学会GTK的使用
名字中没有gtk的都是通用的java知识。&lt;/p&gt;

&lt;p&gt;案例1：带有彻底关闭对话框功能的简单对话框，并设置对话框的名字为“冰封”&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
* @author 叶昭良
*
*/
import com.rupeng.gtk4j.GTK;
import com.rupeng.gtk4j.IGCallBack;

public class TestGtk
{

        /**
         * @param args
         */
        public static void main(String[] args)
        {
                // TODO 自动生成的方法存根
        GTK.gtk_init(); // initialize
        int window  = GTK.gtk_window_new(GTK.GTK_WINDOW_TOPLEVEL); //创建一个新窗口的顶级标        识，在c语言也叫做文件句柄，这边应该叫做窗口句柄。 句柄其实就是一串唯一标识一个资源的数字
        // 设置窗口的名字，通过调用GTK类的静态方法
        GTK.gtk_window_set_title(window,&amp;quot;冰封&amp;quot;);// 
        // 设置窗口的显示位置
        GTK.gtk_window_set_position(window,GTK.GTK_WIN_POS_CENTER_ALWAYS);
        //每一个空间都得show出来
        GTK.gtk_widget_show(window); // show it
        //事件的创建，当点击删除按钮时候 摧毁对话框
//IGCallBack中的代码块是“回调”的，在发生“destroy”事件的时候才执行。回调是一个操作系统的机制
//同时解决无法彻底关闭GTK对话框
//解释：在唯一标识的当前窗口，绑定一个destroy的事件，当发生destroy信号的时候，则调用
//一个匿名类，匿名类是一个回调类，JVM负责执行内部的内代码
        GTK.g_signal_connect(window,&amp;quot;destroy&amp;quot;,new IGCallBack()
                {
                    @Override
                    public void execute(int instance,int eventData,Object object)
                    {
                        GTK.gtk_main_quit();
                    }
                },null);
        //创建一个box用于盛放控件
        int box = GTK.gtk_box_new(GTK.GTK_ORIENTATION_HORIZONTAL,0);
        // 在gtk_container_add只能盛放一个容器或者控件
        GTK.gtk_container_add(window,box);
        //显示box
        GTK.gtk_widget_show(box);
        //GTK的主循环程序 gtk_main();如果不添加则闪退。
        GTK.gtk_main();
//一般在GTK.gtk_main()之后不能有程序
        }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行效果为：&lt;/p&gt;

&lt;p&gt;通过本例：
1.可以学习com.rupeng.gtk4j.GTK和IGCallback的简答使用
2.GTK的静态方法库的调用
3.以及彻底关闭时候涉及到的对于特殊的匿名类的创建和回调函数的使用。
4.并归纳出简单的GTK制作流程为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   a. GTK.gtk_init();
   b. 中间的额外过程
   c. GTK.gtk_widget_show(window) 以及GTK.gtk_widget_show(其他控件)
   d.   GTK.g_signal_connect(window,&amp;quot;destroy&amp;quot;,new IGCallBack()
            {
                @Override
                public void execute(int instance,int eventData,Object object)
                {
                    GTK.gtk_main_quit();
                }
            },null);   来关闭窗口
 e:  GTK.gtk_container_add（window,box) 并show一下。
 f:   GTK.gtk_main();   启动循环线程
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://jueqingsizhe66.github.io/images/java/1.png&#34; alt=&#34;GTK的冰封对话框&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在使用com.rupeng.gtk4j.Utils遇到如下问题：
import com.rupeng.gtk4j.Utils;  一直倒不进去(这也说明一点 我们在使用com.rupeng.gtk4j的时候，不需要使用Utils这个类)
于是查了一下Utils类的实现
class Utils
{
   &amp;hellip;
}
复制代码&lt;/p&gt;

&lt;p&gt;原来不是公有类，并且不处于同一个包下，相互之间不能访问。默认的Utils是 default修饰符（default限制在同包内（同一山寨）），对于我们使用者需要管两个问题1：可否继承？ 2：可否访问   不管他们如何进行分包。如果站在更高的高度，就需要有座山雕的风范，统一东北18座山寨（假设座山雕拥有此技能，山寨之间如何访问，如何继承由他说了算）。&lt;/p&gt;

&lt;p&gt;在使用类的时候，得问自己，“哪个山寨的？” “可否继承？” “可否访问”（只有public支持不同包的访问（访问是指直接可以new &amp;hellip;），protected是在不同包的情况允许继承(j继承是指可以extends)）&lt;/p&gt;

&lt;p&gt;大部分情况我们是在不同包下进行调用，所以一般是public和protected。&lt;br /&gt;
小部分情况下 我们在自己建包的时候，使用 default或者private&lt;/p&gt;

&lt;p&gt;在复习了一下包的机制，找到了一张好的总结图：
&lt;img src=&#34;https://jueqingsizhe66.github.io/images/java/包的控制机制.png&#34; alt=&#34;包的控制机制&#34; /&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>1月28日Java班笔记提交帖</title>
      <link>https://jueqingsizhe66.github.io/blog/2015/05/11/1yue-28ri-javaban-bi-ji-ti-jiao-tie/</link>
      <pubDate>Mon, 11 May 2015 14:58:40 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/blog/2015/05/11/1yue-28ri-javaban-bi-ji-ti-jiao-tie/</guid>
      <description>&lt;p&gt;第一部分：笔记
引用杨老师笔记，的确经典
1、GTK命名规则
     1）一般以gtk_开头
     2）gtk_widget_代表这个函数可以应用于GtkWidget及所有子类。gtk_container&lt;em&gt;代表这个函数可以应用于GtkContainer及所有子类。
     3）gtk&lt;/em&gt;***_new，创建一个控件并且返回它的标识(编号)。
     4）gtk_AAA_get_BBB，从AAA类型的控件的标识获得控件的BBB属性的值；gtk_AAA_set_BBB，设置指定标识的类型为AAA的控件的BBB属性的值&lt;/p&gt;

&lt;p&gt;分析上述结论：
     a.        的确原始的gtk程序都是以gtk_开头的  ，而现在com.rupeng.gtk4j.*，则是利用GTK这个类封装起来这些方法。
     b.        一般的规律都是gtk_widget_开头表示继承GtkWidget及所有子类，所以需要有一张GTK的总体继承图
       看 总体继承图.gif
      说明：也就是说在思考widget的时候，一般接着思考Container、Entry、Label,针对Container有需要思考Bin\Box\Grid\Fixed，针对Bin有需要接着思      考Window|NoteBook|,ScrolledWindow|Button,针对Window有需要接着思考Dialog&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; c. 之所以是gtk_***_new_*** 是因为***既可以代表 gtk_window_new  也可以代表gtk_progress_bar_new                   gtk_check_box_new   gtk_button_new_with_label   gtk_toggle_button_new等。
     d.  Gtk_AAA_get|set_BBB   其实AAA一般代表控件   BBB一般代表属性，也可以代表地方  比如  gtk_screen_get_width()   gtk_entry_set_max_length   gtk_widget_set_visible()
 Gtk_tool_item_set_toolkit_item   AAA也可以有两个_连接。
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;GTK的使用框架：
             //初始化
            GTK.gtk_init();
            //建立窗口  设置成static int window变量
            window = GTK.gtk_window_new(GTK.GTK_WINDOW_TOPLEVEL);
            //设置窗口名称
            GTK.gtk_window_set_title(window, &amp;ldquo;计算器v1.0&amp;rdquo;);
            //添加窗口
            GTK.gtk_widget_show(window);&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        //关闭对话框
        GTK.g_signal_connect(window, &amp;quot;destroy&amp;quot;, new IGCallBack() 
        {
                @Override
                public void execute(int instance, int eventData, Object object)
                {
                        // TODO 自动生成的方法存根
                        GTK.gtk_main_quit();
                }
        }, null);

        //网格布局  盒子布局   固定布局。。。 当前选择网格布局
    int houseGrid = GTK.gtk_grid_new();
    //载入控件
    //省略 一万行代码。。。。

    //载入到windows当中
        GTK.gtk_container_add(window, houseGrid);
        //启动循环
        GTK.gtk_main();
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;GTK.gtk_container_add(window,box1) ;在一个main中只能使用一次gtk_container_add..&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;CheckBox
int gtk_check_button_new_with_label(String label)
CheckButton继承自ToggleButton
所以可以使用 void gtk_toggle_button_set_active(int toggle_button, boolean is_active) 设置是否选中
boolean gtk_toggle_button_get_active(int toggle_button) 获得是否选中&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;5.gtk_entry_new
基本的文本框设置
使用void gtk_label_set_text(int label, String str)修改Label的文本内容
void gtk_entry_set_max_length(int entry, int max)设置输入框最大的宽度
void gtk_entry_set_text(int entry, String text)设置输入框的文本
String gtk_entry_get_text(int entry)获得输入框的文本值&lt;/p&gt;

&lt;p&gt;密码文本框设置：
void gtk_entry_set_visibility(int entry,boolean visible)当把visible设置为false的时候输入的内容都会显示成 gtk_entry_set_invisible_char(int entry,char inv_char)设置的字符。用于实现密码框&lt;/p&gt;

&lt;p&gt;第二部分： 作业&lt;/p&gt;

&lt;p&gt;case1: 固定布局的测试&lt;/p&gt;

&lt;p&gt;/**
* @author 叶昭良
* @version  v1.0
*/
import com.rupeng.gtk4j.GTK;
import com.rupeng.gtk4j.IGCallBack;
//import com.rupeng.gtk4j.Utils;
public class TestGtkWidgetFixedLayout
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /**
     * @param args
     */
    public static void main(String[] args)
    {
            // TODO 自动生成的方法存根
            GTK.gtk_init();
        int window = GTK.gtk_window_new(GTK.GTK_WINDOW_TOPLEVEL); // 原来还有个POPUP估计是右键菜单
        GTK.gtk_widget_show(window);

        GTK.gtk_window_set_title(window, &amp;quot;霜雪&amp;quot;); // widget下没有 只有在window下有。
       // GTK.gtk_window_set_position(window, GTK.GTK_WIN_POS_CENTER);

        GTK.gtk_window_set_position(window, GTK.GTK_WIN_POS_CENTER_ALWAYS);
        //GTK.gtk_window_set_resizable(window, true);  //默认可以拉伸
        // 默认的窗口可以最大化， GTK.gtk_widget_set_maximize(widget)

        //新建了一个文本框
        int entry1  = GTK.gtk_entry_new();
        GTK.gtk_widget_show(entry1);
        //新建了一个button 
        int button1 = GTK.gtk_button_new_with_label(&amp;quot;click me&amp;quot;);
        GTK.gtk_widget_show(button1);

        //新建了一个标签
        int label1 =  GTK.gtk_label_new(&amp;quot;请输入：&amp;quot;);
        GTK.gtk_widget_show(label1);

        // 安静的关闭对话框
        GTK.g_signal_connect(window, &amp;quot;destroy&amp;quot;, new IGCallBack()
        {
                @Override
                public void execute(int instance, int eventData, Object object)
                {
                        // TODO 自动生成的方法存根
                        GTK.gtk_main_quit();
                }
        }, null);

        //int box1= GTK.gtk_box_new(GTK., spacing)
        //新加了一个house  用来整租给文本框 +button+label
        int house = GTK.gtk_fixed_new();
        GTK.gtk_fixed_put(house, entry1,0,0);
        GTK.gtk_fixed_put(house,button1,50,0);
        GTK.gtk_fixed_put(house,label1,0,100); //很难适应屏幕大小！！所以一般很少用
        GTK.gtk_widget_show(house);

        GTK.gtk_container_add(window,house);

        GTK.gtk_main();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
复制代码&lt;/p&gt;

&lt;p&gt;case2 盒子布局的测试&lt;/p&gt;

&lt;p&gt;/**
* @author 叶昭良
* @version  v1.0
*/
import java.awt.AWTException;
import java.awt.Robot;&lt;/p&gt;

&lt;p&gt;import com.rupeng.gtk4j.GTK;
import com.rupeng.gtk4j.IGCallBack;
//import com.rupeng.gtk4j.Utils;
public class TestGtkWidgetBoxLayout
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /**
     * @param args
     */
    public static void main(String[] args)
    {
            // TODO 自动生成的方法存根
            GTK.gtk_init();
        int window = GTK.gtk_window_new(GTK.GTK_WINDOW_TOPLEVEL); // 原来还有个POPUP估计是右键菜单
        GTK.gtk_widget_show(window);

        GTK.gtk_window_set_title(window, &amp;quot;霜雪&amp;quot;); // widget下没有 只有在window下有。
       // GTK.gtk_window_set_position(window, GTK.GTK_WIN_POS_CENTER);

        GTK.gtk_window_set_position(window, GTK.GTK_WIN_POS_CENTER_ALWAYS);
        //GTK.gtk_window_set_resizable(window, true);  //默认可以拉伸
        // 默认的窗口可以最大化， GTK.gtk_widget_set_maximize(widget)

        //新建了一个文本框
        int entry1  = GTK.gtk_entry_new();
        GTK.gtk_widget_show(entry1);
        //新建了一个button 
        int button1 = GTK.gtk_button_new_with_label(&amp;quot;click me&amp;quot;);
        GTK.gtk_widget_show(button1);

        //新建了一个标签
        int label1 =  GTK.gtk_label_new(&amp;quot;请输入：&amp;quot;);
        int label2 =  GTK.gtk_label_new(&amp;quot;&amp;quot;);
        int label3 =  GTK.gtk_label_new(&amp;quot;&amp;quot;);

        // 显示标签
        GTK.gtk_widget_show(label1);
        GTK.gtk_widget_show(label2);
        GTK.gtk_widget_show(label3);
        // 安静的关闭对话框
        GTK.g_signal_connect(window, &amp;quot;destroy&amp;quot;, new IGCallBack()
        {
                @Override
                public void execute(int instance, int eventData, Object object)
                {
                        // TODO 自动生成的方法存根
                        GTK.gtk_main_quit();
                }
        }, null);

        //int box1= GTK.gtk_box_new(GTK., spacing)
        //新加了一个house  用来整租给文本框 +button+label
        // gtk_box_new 的第一个参数 一般是两种赋值方式GTK.GTK_ORIENTATION_HORIZONTAL和_VERTICAL
        // 第二个参数表示的间隔space,如果设置为5则为5pt的间隔
        int houseApple = GTK.gtk_box_new(GTK.GTK_ORIENTATION_HORIZONTAL, 0);
        int houseBanana = GTK.gtk_box_new(GTK.GTK_ORIENTATION_HORIZONTAL, 0);
        int houseTree = GTK.gtk_box_new(GTK.GTK_ORIENTATION_VERTICAL, 0);
        //水平house
        GTK.gtk_box_pack_start(houseApple, label1, true, true, 0);
        GTK.gtk_box_pack_start(houseApple,entry1 , true, true, 0);
        GTK.gtk_box_pack_start(houseBanana,label2 , true, true, 0);
        GTK.gtk_box_pack_start(houseBanana,button1 , true, true, 0);
        GTK.gtk_box_pack_start(houseBanana,label3 , true, true, 0);
        //垂直house
        GTK.gtk_box_pack_start(houseTree, houseApple, true, true, 0);
        GTK.gtk_box_pack_start(houseTree, houseBanana, true, true, 0);


        // 显示三个容器 的house
        GTK.gtk_widget_show(houseApple);
        GTK.gtk_widget_show(houseBanana);
        GTK.gtk_widget_show(houseTree);

        GTK.gtk_container_add(window,houseTree);

        GTK.gtk_main();


    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
复制代码&lt;/p&gt;

&lt;p&gt;case3 网格布局的测试&lt;/p&gt;

&lt;p&gt;/**
* @author 叶昭良
* @version v1.0
* @version v1.1 改进了密码框&lt;br /&gt;
*/
import java.awt.AWTException;
import java.awt.Robot;&lt;/p&gt;

&lt;p&gt;import com.rupeng.gtk4j.GTK;
import com.rupeng.gtk4j.IGCallBack;
//import com.rupeng.gtk4j.Utils;
public class TestGtkWidgetGridLayout
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /**
     * @param args
     */
    public static void main(String[] args)
    {
            // TODO 自动生成的方法存根
            GTK.gtk_init();
        int window = GTK.gtk_window_new(GTK.GTK_WINDOW_TOPLEVEL); // 原来还有个POPUP估计是右键菜单
        GTK.gtk_widget_show(window);

        GTK.gtk_window_set_title(window, &amp;quot;霜雪&amp;quot;); // widget下没有 只有在window下有。
       // GTK.gtk_window_set_position(window, GTK.GTK_WIN_POS_CENTER);

        GTK.gtk_window_set_position(window, GTK.GTK_WIN_POS_CENTER_ALWAYS);
        //GTK.gtk_window_set_resizable(window, true);  //默认可以拉伸
        // 默认的窗口可以最大化， GTK.gtk_widget_set_maximize(widget)


        // 安静的关闭对话框
        GTK.g_signal_connect(window, &amp;quot;destroy&amp;quot;, new IGCallBack()
        {
                @Override
                public void execute(int instance, int eventData, Object object)
                {
                        // TODO 自动生成的方法存根
                        GTK.gtk_main_quit();
                }
        }, null);

        //int box1= GTK.gtk_box_new(GTK., spacing)
        //新加了一个网格屋子
        int houseGrid = GTK.gtk_grid_new();




        // 显示 的houseGrid
        GTK.gtk_widget_show(houseGrid);
        // 0开头是程序员的惯例
        testGtk(houseGrid,0);
        landInternet(houseGrid,2);



        GTK.gtk_container_add(window,houseGrid);
        GTK.gtk_main();


    }
    //新建一个测试的界面
    /**
     * 
     * @param houseGrid  整租的大房子  表示gtk_grid_new的返回值
     * @param start      在houseGrid分配到的第几行开始编号
     */
    public static void testGtk(int houseGrid,int start)
    {
               //新建了一个文本框
        int entry1  = GTK.gtk_entry_new();
        GTK.gtk_widget_show(entry1);
        //新建了一个button 
        int button1 = GTK.gtk_button_new_with_label(&amp;quot;click me&amp;quot;);
        GTK.gtk_widget_show(button1);

        //新建了一个标签
        int label1 =  GTK.gtk_label_new(&amp;quot;请输入：&amp;quot;);
        int label2 =  GTK.gtk_label_new(&amp;quot;&amp;quot;);
        int label3 =  GTK.gtk_label_new(&amp;quot;&amp;quot;);

        // 显示标签
        GTK.gtk_widget_show(label1);
        GTK.gtk_widget_show(label2);
        GTK.gtk_widget_show(label3);

        //整租到housegrid
        // gtk_grid_attach(int grid, int child, int left,int top, int width, int height);
        GTK.gtk_grid_attach(houseGrid, label1, 0, start, 1, 1);
        GTK.gtk_grid_attach(houseGrid, entry1, 1, start, 1, 1);

        GTK.gtk_grid_attach(houseGrid, button1, 1, start+1, 1, 1);
    }

//新建一个登陆界面的GTK
    public static void landInternet(int houseGrid,int start) 
    {
               //新建了一个文本框
        int entry1  = GTK.gtk_entry_new();

        int entry2  = GTK.gtk_entry_new();

        //增加了文本框的密码框的设置y2, false);
        //可以设置显示的
        GTK.gtk_entry_set_visibility(entry2,false);  //字符 默认的密码框为*
        GTK.gtk_entry_set_invisible_char(entry2, &#39;1&#39;); //只能是字符  不能是&amp;quot;1&amp;quot;

        //新建了一个button 
        int buttonEnter = GTK.gtk_button_new_with_label(&amp;quot;登陆&amp;quot;);

        int buttonClosed = GTK.gtk_button_new_with_label(&amp;quot;取消&amp;quot;);

        int checkbox1= GTK.gtk_check_button_new_with_label(&amp;quot;是否保存密码&amp;quot;);
        //新建了一个标签
        int label1 =  GTK.gtk_label_new(&amp;quot;用户名：&amp;quot;);
        int label2 =  GTK.gtk_label_new(&amp;quot;密码  ：&amp;quot;);

        //为什么要声明为final暂时不是特别清楚
        final int label3 =  GTK.gtk_label_new(&amp;quot;&amp;quot;);

        // 显示标签
        GTK.gtk_widget_show(entry1);
        GTK.gtk_widget_show(entry2);
        GTK.gtk_widget_show(label1);
        GTK.gtk_widget_show(label2);
        GTK.gtk_widget_show(label3);
        GTK.gtk_widget_show(checkbox1);
        GTK.gtk_widget_show(buttonEnter);
        GTK.gtk_widget_show(buttonClosed);

        //整租到houseGrid
        GTK.gtk_grid_attach(houseGrid, label1, 0, start, 1, 1);
        GTK.gtk_grid_attach(houseGrid, entry1, 1, start, 1, 1);
        GTK.gtk_grid_attach(houseGrid, label2, 0, start+1, 1, 1);
        GTK.gtk_grid_attach(houseGrid, entry2, 1, start+1, 1, 1);
        GTK.gtk_grid_attach(houseGrid, checkbox1, 1, start+2, 1, 1);
        GTK.gtk_grid_attach(houseGrid, buttonEnter, 1, start+3, 1, 1);
        GTK.gtk_grid_attach(houseGrid, buttonClosed, 2, start+3, 1, 1);
        GTK.gtk_grid_attach(houseGrid, label3, 1, start+5, 1, 1);


        // 进行按钮的事件连接
        GTK.g_signal_connect(buttonEnter,&amp;quot;clicked&amp;quot;,new IGCallBack()
        {
                @Override
                public void execute(int instance, int eventData, Object object)
                {
                        // TODO 自动生成的方法存根
                        System.out.println(&amp;quot;你点击了登陆&amp;quot;);
                        GTK.gtk_label_set_text(label3, &amp;quot;你点击了登陆&amp;quot;);
                }
        },null);

        GTK.g_signal_connect(buttonClosed,&amp;quot;clicked&amp;quot;,new IGCallBack()
        {
                @Override
                public void execute(int instance, int eventData, Object object)
                {
                        // TODO 自动生成的方法存根
                        System.out.println(&amp;quot;你点击了关闭&amp;quot;);
                        GTK.gtk_label_set_text(label3, &amp;quot;你点击了关闭&amp;quot;);
                }
        },null);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
复制代码&lt;/p&gt;

&lt;p&gt;case4 checkBox模拟 安装界面
import com.rupeng.gtk4j.GTK;
import com.rupeng.gtk4j.IGCallBack;
/**
*
*/&lt;/p&gt;

&lt;p&gt;/**
* @author 叶昭良
* @version  v1.0
*/
public class TestGtkCheckBox
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /**
     * @param args
     */
    private static int window ;
    private static int box;
    public static void main(String[] args)
    {
            // TODO 自动生成的方法存根

    //        gtkHead(window,&amp;quot;gtkCheckbox测试&amp;quot;);
            GTK.gtk_init();
            window = GTK.gtk_window_new(GTK.GTK_WINDOW_TOPLEVEL);
            GTK.gtk_window_set_title(window, &amp;quot;hello&amp;quot;);
            GTK.gtk_widget_show(window);
            GTK.g_signal_connect(window,&amp;quot;destroy&amp;quot;,new IGCallBack() 
            {

                    @Override
                    public void execute(int instance, int eventData, Object object)
                    {
                            // TODO 自动生成的方法存根
                            GTK.gtk_main_quit();
                    }

            },null);
            box = GTK.gtk_box_new(GTK.GTK_ORIENTATION_VERTICAL, 0);
            int box2= GTK.gtk_box_new(GTK.GTK_ORIENTATION_VERTICAL,0);
            int box1= GTK.gtk_box_new(GTK.GTK_ORIENTATION_VERTICAL,0);
            testGtkCheckBox(window,box2);
            testGtkCheckBoxInstall(window,box1);
            GTK.gtk_box_pack_start(box, box2, false, false, 0);
            GTK.gtk_box_pack_start(box, box1, false, false, 0);

            GTK.gtk_container_add(window, box);
            GTK.gtk_widget_show(box);
            GTK.gtk_main();

    }


    public static void testGtkCheckBox(int window,int box2)
    {

            int cbMan = GTK.gtk_check_button_new_with_label(&amp;quot;男&amp;quot;);
            int cbWoman = GTK.gtk_check_button_new_with_label(&amp;quot;女&amp;quot;);


            GTK.gtk_box_pack_start(box2, cbMan, false,false        , 0);
            GTK.gtk_box_pack_start(box2, cbWoman, false,false        , 0);


            GTK.gtk_widget_show(cbMan);
            GTK.gtk_widget_show(cbWoman);
            GTK.gtk_widget_show(box2);

    }
    public static void testGtkCheckBoxInstall(int window,int box1)
    {
            int entryLicense = GTK.gtk_entry_new();
            GTK.gtk_entry_set_text(entryLicense, &amp;quot;产品使用声明:\n 尊重ISIS国际标准&amp;quot;);

            //定义控件
            int boxInner = GTK.gtk_box_new(GTK.GTK_ORIENTATION_HORIZONTAL, 0);
            //为什么要修改为终态
            final int cbAgree = GTK.gtk_check_button_new_with_label(&amp;quot;我同意上面的协议&amp;quot;);
            final int btnInstall = GTK.gtk_button_new_with_label(&amp;quot;install&amp;quot;);
            int btnClosed  = GTK.gtk_button_new_with_label(&amp;quot;close&amp;quot;);
            GTK.gtk_widget_set_sensitive(btnInstall, false);

            //添加控件
            GTK.gtk_box_pack_start(box1, entryLicense, false,false        , 0);
            GTK.gtk_box_pack_start(box1, cbAgree, false,false, 0);
            GTK.gtk_box_pack_start(boxInner, btnInstall, false,false,0);
            GTK.gtk_box_pack_start(boxInner, btnClosed, false,false,0);
            GTK.gtk_box_pack_start(box1, boxInner, false,false        , 0);

            //显示控件
            GTK.gtk_widget_show(entryLicense);
            GTK.gtk_widget_show(cbAgree);
            GTK.gtk_widget_show(btnInstall);
            GTK.gtk_widget_show(btnClosed);
            GTK.gtk_widget_show(boxInner);
            GTK.gtk_widget_show(box1);

            //添加事件
            GTK.g_signal_connect(cbAgree, &amp;quot;clicked&amp;quot;, new IGCallBack() 
            {
                    @Override
                    public void execute(int instance, int eventData, Object object)
                    {
                            // TODO 自动生成的方法存根
                            boolean isChecked =  GTK.gtk_toggle_button_get_active(cbAgree);

                            //写了gtk_checkbox发现没有set命令 于是用了widget..
                            GTK.gtk_widget_set_sensitive(btnInstall, isChecked);
                    }
            }, null);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
复制代码&lt;/p&gt;

&lt;p&gt;通过上面的练习： 学习了GTK框架的编程方式，掌握了 label,entry,checkbox(继承toggle_button),Box Layout, Grid Layout , Fixed Layout的基本使用方法，包括clicked,destroy这两个信号的事件处理。  另外拓展的学习了匿名类 new IGCallback(){..}的使用方法。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://jueqingsizhe66.github.io/images/java/checkbox.gif&#34; alt=&#34;checkbox的结果&#34; /&gt;
&lt;img src=&#34;https://jueqingsizhe66.github.io/images/java/盒子.gif&#34; alt=&#34;盒子布局的结果&#34; /&gt;
&lt;img src=&#34;https://jueqingsizhe66.github.io/images/java/固定.gif&#34; alt=&#34;固定布局的结果&#34; /&gt;
&lt;img src=&#34;https://jueqingsizhe66.github.io/images/java/网格布局.gif&#34; alt=&#34;网格布局的结果&#34; /&gt;
&lt;img src=&#34;https://jueqingsizhe66.github.io/images/java/总体框架图.gif&#34; alt=&#34;GTK的总体框架图&#34; /&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>1月31日Java班笔记作业</title>
      <link>https://jueqingsizhe66.github.io/blog/2015/05/11/1yue-31ri-javaban-bi-ji-zuo-ye/</link>
      <pubDate>Mon, 11 May 2015 14:58:40 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/blog/2015/05/11/1yue-31ri-javaban-bi-ji-zuo-ye/</guid>
      <description>&lt;p&gt;第一部分：笔记
First: SpinBox
背景：spinButton 控制了文本框的数字，所以不需要研究entry的数字限制形式&lt;/p&gt;

&lt;p&gt;第一点：微调按钮（SpinButton）从GtkEntry继承，只能输入数字。
基本函数使用说明：
1.         int gtk_spin_button_new_with_range(double  min,double  max,double  step)  创建实例。min最小值、max最大值、单步变化值。double可以用来表示小数。
2.        double gtk_spin_button_get_value(int spin_button)  获得double类型的值。
int gtk_spin_button_get_value_as_int(int spin_button) 以整数类型获得值，小数部分忽略。
void gtk_spin_button_set_value(int spin_button,double value)  设置值&lt;/p&gt;

&lt;p&gt;学会：解决问题的能力。1 .查文档  2.google+baidu  3.FAQ&lt;/p&gt;

&lt;p&gt;Second: ComboBox
第一点：GtkComboBoxText从GtkComboBox继承，GtkComboBoxText子类定义ComboBox.
基本函数：(使用说明)
第一步： int gtk_combo_box_text_new()创建一个ComboBoxText；
第二部： void gtk_combo_box_text_append(int combo_box,String id, String text) 附加一个文本，并且给它设定一个自定义id（String类型）。
第三步：
String gtk_combo_box_get_active_id(int combo_box)得到选中行的自定义id
gtk_combo_box_set_active_id(int combo_box,String active_id)设定自定义id等于active_id的项被选中
void gtk_combo_box_text_remove_all(int combo_box)清除所有内容
第四步  当选中一行的时候会发出“changed”信号 GTK.g_signal_connect(….);&lt;/p&gt;

&lt;p&gt;Third: GTKIMAGE
第一点：GtkImage 可以分为三种方式加载图片资源，包括：磁盘文件（file），项目资源（resource），内置图片（STOCK），对应三个
家在函数gtk_image_set_from_file，gtk_image_set_from_resource，gtk_image_set_from_stock。&lt;/p&gt;

&lt;p&gt;基本函数使用说明：
1.        void gtk_image_set_from_file(int image, String filename)从文件全路径为filename的文件中加载图片。注意文件路径的转义问题，“\”因为“\”有特殊含义，后面讲字符串会详细讲。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;void gtk_image_set_from_resource(int image, String resName)从项目资源中加载图片，格式&amp;rdquo;com/rupeng/1.jpg&amp;rdquo;（其中com/rupeng表示com.rupeng包），不要以/开头，把资源放在src里面！！！
png可以背景透明，jpg、jpege压缩图片, Gif  动态图片&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;GTK.gtk_image_new_from_stock(GTK.GTK_STOCK_ABOUT, GTK.GTK_ICON_SIZE_LARGE_TOOLBAR); 从GTK的内置图片载入图片。
设置按钮图片一般是    GTK.GTK_STOCK*
设置大小的时候  利用GTK.GTK_ICON就可以弹出几个。。。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Fourth: GTKIMAGE的简单调研
        /**
         * 把资源resName保存到临时文件夹，返回值为临时文件的全路径
         *
         * @param resName
         *            com/rupeng/a.mp3这样的格式，注意不以/开头
         * @return
         */
        public synchronized static String saveResourceToTemp(String resName)
        {
                // 如果resname之前释放到过临时文件，并且临时文件还存在，则不再重复释放，直接返回之前的文件，以提高性能
                if (resourceCache.containsKey(resName)) //资源缓存中判断是否存在图片
                {
                        String cachedFileName = resourceCache.get(resName);//从资源缓存中获取图片
                        if (new File(cachedFileName).exists())
                        {
                                return cachedFileName;
                        } else
                        {
                                resourceCache.remove(resName);
                        }
                }
                // 获取文件扩展名
                String[] strs = resName.split(&amp;rdquo;\.&amp;ldquo;); //利用字符串的split函数
                String extesion = strs[strs.length - 1]; //获取最后一个&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;            InputStream inStream = GTK.class.getClassLoader().getResourceAsStream(resName);//ClassLoader.getSystemResourceAsStream(resName);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;//通过反射机制 自动载入图片资源的ＩｎｐｕｔＳｔｒｅａｍ ！！！利用文件名字，这也是一个悬念&lt;br /&gt;
        if (inStream == null)
                {
                        throw new RuntimeException(&amp;ldquo;找不到资源&amp;rdquo; + resName);
                }
                try
                {&lt;br /&gt;
                        //java 1.6后，运行在Windows下，如果启用了Guest账户，则由于createTempFile调用了SecureRandom 会卡5秒钟
                        //因此第一次运行createTempFile会非常慢
                        //参考：&lt;a href=&#34;http://stackoverflow.com/questions/2608763/why-does-first-call-to-java-io-file-createtempfilestring-string-file-take-5-se&#34; target=&#34;_blank&#34;&gt;http://stackoverflow.com/questions/2608763/why-does-first-call-to-java-io-file-createtempfilestring-string-file-take-5-se&lt;/a&gt;
                        //File tempFile = File.createTempFile(&amp;ldquo;temp&amp;rdquo;, &amp;ldquo;.&amp;rdquo; + extesion);
                        //因此不用createTempFile，改用存到项目的restemp文件夹下
                        File resDir = new File(System.getProperty(&amp;ldquo;user.dir&amp;rdquo;), &amp;ldquo;gtk/temp&amp;rdquo;);// *.dll放的文件夹
                        if (!resDir.exists())
                        {
                                resDir.mkdirs();//创建临时文件夹
                        }
                        inStream.mark(Integer.MAX_VALUE);　／／不清楚作何用
                        String md5 = Utils.getMD5(inStream);//用md5值做文件名
                        inStream.reset();//指针复位到mark标记的位置，便于后面保存文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                    // 如果不加扩展名，mci_send_command则无法识别文件类型
                    File tempFile = new File(resDir,md5+&amp;quot;.&amp;quot;+extesion); //创建一个File
                    FileOutputStream outStream = new FileOutputStream(tempFile); //写出一个文件
                    Utils.copy(inStream,outStream); //把当前的图片资源靠背出去
                    inStream.close();
                    outStream.close();

                    resourceCache.put(resName, tempFile.getAbsolutePath());//放到绝对路径下
                    return tempFile.getAbsolutePath(); //最终返回图片
            } catch (IOException e)
            {
                    throw new RuntimeException(e);
            }
    }

    /**
     * 从java资源中加载资源图片生成image。不是gtk提供的native方法
     * 
     * @param resName
     * @return
     */
    public static int gtk_image_new_from_resource(String resName)
    {
            return gtk_image_new_from_file(saveResourceToTemp(resName));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;复制代码&lt;/p&gt;

&lt;p&gt;Fifth: TextView
背景：先前entry是当行文本框
TextView基本函数使用说明：
第一步： 创建多行文本夹
            int gtk_text_view_new()创建多行文本
第二步： 进行接本的设置
          void gtk_text_view_set_wrap_mode(int text_view,int wrap_mode) 设置自动换行模式。wrap_mode可选值：GTK_WRAP_NONE(不自动换行)；GTK_WRAP_CHAR(在任意字符换行)；GTK_WRAP_WORD(保持单词完整性换行，)；GTK_WRAP_WORD_CHAR (尽量保持单词完整性，实在不行也可以在任意字符换行)&lt;/p&gt;

&lt;p&gt;第三步：  添加文字和读取文字
        读取文字
        String text = GTK.gtk_text_buffer_get_text(textbuffer);
   添加文字
GTK.gtk_text_buffer_set_text(textbuffer, loveWords)
额外的标注：
      一般第三步采用的方式适合比较小的String，对于较大的情况可以再加一个TextIter类似可以在多行文本或者对话框
添加一个滚动条ScrolledBar
TextIter使用说明：
1：TextIter是对TextBuffer遍历的遍历器。
2： int gtk_text_iter_new()创建一个空的TextIter，使用完后用gtk_text_iter_free(int iter)释放。
3： void gtk_text_buffer_get_start_iter(int buffer,int iter)用buffer这个TextBuffer的开始位置去初始化iter这个TextIter（开头插入  或者用backward指针  向后读）
     void gtk_text_buffer_get_end_iter(int buffer, int iter)用buffer这个TextBuffer的结束位置去初始化iter这个TextIter（结尾插入  或者也可以用forward指针 向前读）
     (*)用gtk_text_buffer_get&lt;em&gt;iter&lt;/em&gt;*系列方法移动迭代器的位置。
4.   void gtk_text_buffer_insert(int buffer, int iter,String text)在buffer这个TextBuffer的iter这个TextIter的当前位置插入文本text&lt;/p&gt;

&lt;p&gt;5          gtk_text_iter_free(int iter)  释放textIter资源&lt;/p&gt;

&lt;p&gt;Sixth: Cairo
1： 画布板   是一个框架，一般仅仅在第一步创建的时候使用 GTK.gtk_drawing_area();
2： 画布环境(Cairo_t)，缺不了，在java的Cairo中直接在GTK.g_signal_connect中的draw时间中使用，对应execute函数的
eventsData 即使Cairo_t ,基本上每一个Cairo函数都少不了ct
3:  com.rupeng.gtk4j.Cairo简化了绘画的步骤，一般是
3.1        设置画笔的大小  Cairo.cairo_set_font…
3.2        设置画笔的颜色
3.3        Cairo.cairo_move_to(cr…)
3.4        Cairo.cairo_line_to(cr,,,)画直线
3.5        Cairo.cairo_arc(cr,…)画圆弧   记住最好是分段绘制也就是每画一个加入 GTK.gtk_stroke() 或者GTK.gtk_fill();
3.6        Cairo.cairo_rec  画矩形
3.7        文字的绘制
3.7.1        //画文字
3.7.2        Cairo.cairo_move_to(eventData, 180, 260);
3.7.3        Cairo.cairo_set_source_rgb(eventData, 0.4, 0.3, 0.2);
3.7.4        Cairo.cairo_set_font_size(eventData, 16);
3.7.5        //选择文字类型
3.7.6        Cairo.cairo_select_font_face(eventData, &amp;ldquo;宋体&amp;rdquo;, Cairo.CAIRO_FONT_SLANT_ITALIC, Cairo.CAIRO_FONT_WEIGHT_BOLD);
3.7.7        Cairo.cairo_show_text(eventData,&amp;ldquo;三毛的自画像&amp;rdquo;);
3.7.8        //Cairo.cairo_stroke(eventData);  //不需要这句话也可以&lt;/p&gt;

&lt;p&gt;第二部分：作业
First: SpinBox 的使用
case1: 使用控件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import com.rupeng.gtk4j.GTK;
import com.rupeng.gtk4j.IGCallBack;

/**
* @author 叶昭良
* @version SpinBoxv1.0
*/
public class TestGTKSPinBox
{

        /**
         * @param args
         *  
         */
        static int window;
        static int gridHouse;
        public static void main(String[] args)
        {
                // TODO 自动生成的方法存根
                GTK.gtk_init();
                window  = GTK.gtk_window_new(GTK.GTK_WINDOW_TOPLEVEL);
                GTK.gtk_window_set_title(window, &amp;quot;测试SpinBox&amp;quot;);
                GTK.g_signal_connect(window, &amp;quot;destroy&amp;quot;, new IGCallBack() 
                {
                        @Override
                        public void execute(int instance, int eventData, Object object)
                        {
                                // TODO 自动生成的方法存根
                                GTK.gtk_main_quit();
                        }
                }, null);
                GTK.gtk_widget_show(window);
                
                
                //开始建立布局
                 gridHouse = GTK.gtk_grid_new();
                GTK.gtk_widget_show(gridHouse);
                //开始插入控件
                int start = 0 ;
                createSpinbox(window,gridHouse,start);
                
                GTK.gtk_container_add(window, gridHouse);
                GTK.gtk_main();
        }
        /**
         * 
         * @param window     窗口标识
         * @param gridHouse  整租房标识
         * @param start      整租房的起始位置
         */
        public static void createSpinbox(int window,int gridHouse,int start)
        {
                //定义控件
                int label1 = GTK.gtk_label_new(&amp;quot;数字：0-9&amp;quot;);
                int label2 = GTK.gtk_label_new(&amp;quot;范围: -10~10&amp;quot;);
                final int labelSpinbox = GTK.gtk_label_new(&amp;quot;&amp;quot;);
                final int labelSpinboxApple = GTK.gtk_label_new(&amp;quot;&amp;quot;);
                final int spinbox = GTK.gtk_spin_button_new_with_range(0, 9, 1);
                final int spinboxApple = GTK.gtk_spin_button_new_with_range(-10, 10, 0.1);
                
        
                //添加控件到整租房间
                GTK.gtk_grid_attach(gridHouse, label1, 0, start, 1, 1); 
                GTK.gtk_grid_attach(gridHouse, spinbox, 1, start, 1, 1); 
                GTK.gtk_grid_attach(gridHouse, label2, 0, start+1, 1, 1); 
                GTK.gtk_grid_attach(gridHouse, spinboxApple, 1, start+1, 1, 1);
                
                GTK.gtk_grid_attach(gridHouse, labelSpinbox, 0, start+3, 1, 1);
                GTK.gtk_grid_attach(gridHouse, labelSpinboxApple, 0, start+4, 1, 1);
                //显示控件
                GTK.gtk_widget_show(label1);
                GTK.gtk_widget_show(spinbox);
                GTK.gtk_widget_show(label2);
                GTK.gtk_widget_show(spinboxApple);
                GTK.gtk_widget_show(labelSpinbox);
                GTK.gtk_widget_show(labelSpinboxApple);
                GTK.gtk_widget_show(gridHouse);
                
                
                //添加事件
                GTK.g_signal_connect(spinbox, &amp;quot;changed&amp;quot;, new IGCallBack()
                {
                        @Override
                        public void execute(int instance, int eventData, Object object)
                        {
                                // TODO 自动生成的方法存根
                                double apple = GTK.gtk_spin_button_get_value(spinbox);
                                GTK.gtk_label_set_text(labelSpinbox, &amp;quot;您当前选择的数字式：&amp;quot;+Double.toString(apple));
                                
                        }
                }, null);
                
                GTK.g_signal_connect(spinboxApple, &amp;quot;changed&amp;quot;, new IGCallBack()
                {
                        @Override
                        public void execute(int instance, int eventData, Object object)
                        {
                                // TODO 自动生成的方法存根
                                double apple = GTK.gtk_spin_button_get_value(spinboxApple);
                                GTK.gtk_label_set_text(labelSpinboxApple, &amp;quot;您当前选择的数字式：&amp;quot;+Double.toString(apple));
                                
                        }
                }, null);
        }

}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;case2 ：建议四则运算器，加上指数和取余&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import com.rupeng.gtk4j.GTK;
import com.rupeng.gtk4j.IGCallBack;

/**
* @author 叶昭良
* @version SpinBoxv1.0
*/
public class TestGTKSPinBox
{

        /**
         * @param args
         *  
         */
        static int window;
        static int gridHouse;
        public static void main(String[] args)
        {
                // TODO 自动生成的方法存根
                GTK.gtk_init();
                window  = GTK.gtk_window_new(GTK.GTK_WINDOW_TOPLEVEL);
                GTK.gtk_window_set_title(window, &amp;quot;测试SpinBox&amp;quot;);
                GTK.g_signal_connect(window, &amp;quot;destroy&amp;quot;, new IGCallBack() 
                {
                        @Override
                        public void execute(int instance, int eventData, Object object)
                        {
                                // TODO 自动生成的方法存根
                                GTK.gtk_main_quit();
                        }
                }, null);
                GTK.gtk_widget_show(window);
                
                
                //开始建立布局
                 gridHouse = GTK.gtk_grid_new();
                GTK.gtk_widget_show(gridHouse);
                //开始插入控件
                int start = 0 ;
                createSpinbox(window,gridHouse,start);
                
                GTK.gtk_container_add(window, gridHouse);
                GTK.gtk_main();
        }
        /**
         * 
         * @param window     窗口标识
         * @param gridHouse  整租房标识
         * @param start      整租房的起始位置
         */
        public static void createSpinbox(int window,int gridHouse,int start)
        {
                //定义控件
                int label1 = GTK.gtk_label_new(&amp;quot;数字：0-9&amp;quot;);
                int label2 = GTK.gtk_label_new(&amp;quot;范围: -10~10&amp;quot;);
                final int labelSpinbox = GTK.gtk_label_new(&amp;quot;&amp;quot;);
                final int labelSpinboxApple = GTK.gtk_label_new(&amp;quot;&amp;quot;);
                final int spinbox = GTK.gtk_spin_button_new_with_range(0, 9, 1);
                final int spinboxApple = GTK.gtk_spin_button_new_with_range(-10, 10, 0.1);
                
        
                //添加控件到整租房间
                GTK.gtk_grid_attach(gridHouse, label1, 0, start, 1, 1); 
                GTK.gtk_grid_attach(gridHouse, spinbox, 1, start, 1, 1); 
                GTK.gtk_grid_attach(gridHouse, label2, 0, start+1, 1, 1); 
                GTK.gtk_grid_attach(gridHouse, spinboxApple, 1, start+1, 1, 1);
                
                GTK.gtk_grid_attach(gridHouse, labelSpinbox, 0, start+3, 1, 1);
                GTK.gtk_grid_attach(gridHouse, labelSpinboxApple, 0, start+4, 1, 1);
                //显示控件
                GTK.gtk_widget_show(label1);
                GTK.gtk_widget_show(spinbox);
                GTK.gtk_widget_show(label2);
                GTK.gtk_widget_show(spinboxApple);
                GTK.gtk_widget_show(labelSpinbox);
                GTK.gtk_widget_show(labelSpinboxApple);
                GTK.gtk_widget_show(gridHouse);
                
                
                //添加事件
                GTK.g_signal_connect(spinbox, &amp;quot;changed&amp;quot;, new IGCallBack()
                {
                        @Override
                        public void execute(int instance, int eventData, Object object)
                        {
                                // TODO 自动生成的方法存根
                                double apple = GTK.gtk_spin_button_get_value(spinbox);
                                GTK.gtk_label_set_text(labelSpinbox, &amp;quot;您当前选择的数字式：&amp;quot;+Double.toString(apple));
                                
                        }
                }, null);
                
                GTK.g_signal_connect(spinboxApple, &amp;quot;changed&amp;quot;, new IGCallBack()
                {
                        @Override
                        public void execute(int instance, int eventData, Object object)
                        {
                                // TODO 自动生成的方法存根
                                double apple = GTK.gtk_spin_button_get_value(spinboxApple);
                                GTK.gtk_label_set_text(labelSpinboxApple, &amp;quot;您当前选择的数字式：&amp;quot;+Double.toString(apple));
                                
                        }
                }, null);
        }

}

    ```

Second: ComboBox

case1: 你想要购买的是什么水果？  combobox
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java
import com.rupeng.gtk4j.GTK;
import com.rupeng.gtk4j.IGCallBack;&lt;/p&gt;

&lt;p&gt;/**
* @author 叶昭良
* @version ComboBoxText v1.0
*
*/
public class TestGtkComboBoxText
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /**
     * @param args
     */
    static int window;
    //static int box;
    static int gridHouse;
    public static void main(String[] args)
    {
            // TODO 自动生成的方法存根
            GTK.gtk_init();
            window = GTK.gtk_window_new(GTK.GTK_WINDOW_TOPLEVEL); 
            GTK.gtk_window_set_title(window, &amp;quot;SpinBoxV1.0&amp;quot;);
            GTK.gtk_widget_show(window);
            //安全关闭GTK
            GTK.g_signal_connect(window, &amp;quot;destroy&amp;quot;, new IGCallBack() 
            {
                    @Override
                    public void execute(int instance, int eventData, Object object)
                    {
                            // TODO 自动生成的方法存根
                            GTK.gtk_main_quit();
                    }
            }, null);
            String names[] = {&amp;quot;Andy&amp;quot;,&amp;quot;Jerry&amp;quot;,&amp;quot;laulence&amp;quot;,&amp;quot;Lucy&amp;quot;,&amp;quot;jack&amp;quot;};
            // 创建布局
            gridHouse =  GTK.gtk_grid_new();
            GTK.gtk_widget_show(gridHouse);
            createComboBoxText(window,gridHouse,0);  //yij
            loadComboBox(window, names, gridHouse, 2); //之所以从2开始 是因为 0 1已经被使用
            GTK.gtk_container_add(window,gridHouse);
            //启动循环
            GTK.gtk_main();
    }

    public static void createComboBoxText(int window,int gridHouse,int start)
    {
            final int comboBoxBig = GTK.gtk_combo_box_text_new();
            GTK.gtk_combo_box_text_append_text(comboBoxBig, &amp;quot;苹果&amp;quot;);
            GTK.gtk_combo_box_text_append_text(comboBoxBig, &amp;quot;香蕉&amp;quot;);
            GTK.gtk_combo_box_text_append_text(comboBoxBig, &amp;quot;葡萄&amp;quot;);
            GTK.gtk_combo_box_text_append_text(comboBoxBig, &amp;quot;橘子&amp;quot;);
            GTK.gtk_combo_box_text_append_text(comboBoxBig, &amp;quot;蜜柚&amp;quot;);
            final int comboBoxApple = GTK.gtk_combo_box_text_new();
            GTK.gtk_combo_box_text_append_text(comboBoxApple, &amp;quot;红苹果&amp;quot;);
            GTK.gtk_combo_box_text_append_text(comboBoxApple, &amp;quot;青苹果&amp;quot;);
            GTK.gtk_combo_box_text_append_text(comboBoxApple, &amp;quot;小苹果&amp;quot;);
            final int comboBoxBanana = GTK.gtk_combo_box_text_new();
            GTK.gtk_combo_box_text_append_text(comboBoxBanana, &amp;quot;天宝蕉&amp;quot;);
            GTK.gtk_combo_box_text_append_text(comboBoxBanana, &amp;quot;竹蕉&amp;quot;);
            GTK.gtk_combo_box_text_append_text(comboBoxBanana, &amp;quot;大香蕉&amp;quot;);
            final int comboBoxGrape = GTK.gtk_combo_box_text_new();
            GTK.gtk_combo_box_text_append_text(comboBoxGrape, &amp;quot;青葡萄&amp;quot;);
            GTK.gtk_combo_box_text_append_text(comboBoxGrape, &amp;quot;玫瑰香&amp;quot;);
            GTK.gtk_combo_box_text_append_text(comboBoxGrape, &amp;quot;巨峰&amp;quot;);
            GTK.gtk_combo_box_text_append_text(comboBoxGrape, &amp;quot;夏黑&amp;quot;);
            final int comboBoxOrange = GTK.gtk_combo_box_text_new();
            GTK.gtk_combo_box_text_append_text(comboBoxOrange, &amp;quot;小橘子&amp;quot;);
            GTK.gtk_combo_box_text_append_text(comboBoxOrange, &amp;quot;大橘子&amp;quot;);
            GTK.gtk_combo_box_text_append_text(comboBoxOrange, &amp;quot;年橘&amp;quot;);
            final int comboBoxYouzi = GTK.gtk_combo_box_text_new();
            GTK.gtk_combo_box_text_append_text(comboBoxYouzi, &amp;quot;白心蜜柚&amp;quot;);
            GTK.gtk_combo_box_text_append_text(comboBoxYouzi, &amp;quot;红心蜜柚&amp;quot;);
            GTK.gtk_combo_box_text_append_text(comboBoxYouzi, &amp;quot;臭蜜柚&amp;quot;);

    /*        int label1 = GTK.gtk_label_new(&amp;quot;您当前想要购买的是&amp;quot;+GTK.gtk_combo_box_text_get_active_text(comboBoxBig)
                            +&amp;quot;下的&amp;quot;+GTK.gtk_combo_box_text_get_active_text(comboBoxApple));*/
            final int label1 = GTK.gtk_label_new(&amp;quot;您当前想要购买的是?&amp;quot;);

            // 添加控件到整租房间

            GTK.gtk_grid_attach(gridHouse, comboBoxBig, 0, start, 1, 1);
            GTK.gtk_grid_attach(gridHouse, comboBoxApple, 1, start, 1, 1);
            GTK.gtk_grid_attach(gridHouse, comboBoxBanana, 1, start, 1, 1);
            GTK.gtk_grid_attach(gridHouse, comboBoxGrape, 1, start, 1, 1);
            GTK.gtk_grid_attach(gridHouse, comboBoxOrange, 1, start, 1, 1);
            GTK.gtk_grid_attach(gridHouse, comboBoxYouzi, 1, start, 1, 1);
            GTK.gtk_grid_attach(gridHouse, label1, 0, start+1, 1, 1);

            //显示控件
            GTK.gtk_widget_show(comboBoxBig);
            GTK.gtk_widget_show(comboBoxApple);
            GTK.gtk_widget_show(label1);

            //设置combobox的激活状态
            GTK.gtk_combo_box_set_active(comboBoxBig, 0);
            GTK.gtk_combo_box_set_active(comboBoxApple, 0);

            //添加事件
            GTK.g_signal_connect(comboBoxBig, &amp;quot;changed&amp;quot;, new IGCallBack()
            {
                    @Override
                    public void execute(int instance, int eventData, Object object)
                    {
                            // TODO 自动生成的方法存根
                            String fruit = GTK.gtk_combo_box_text_get_active_text(comboBoxBig);
                            if(fruit.equalsIgnoreCase(&amp;quot;苹果&amp;quot;))
                            {
                                    helpFunction(comboBoxApple,label1);
                                    GTK.gtk_widget_hide(comboBoxBanana);
                                    GTK.gtk_widget_hide(comboBoxGrape);
                                    GTK.gtk_widget_hide(comboBoxOrange);
                                    GTK.gtk_widget_hide(comboBoxYouzi);
                            }else if(fruit.equalsIgnoreCase(&amp;quot;香蕉&amp;quot;))
                            {
                                    helpFunction(comboBoxBanana,label1);
                                    GTK.gtk_widget_hide(comboBoxApple);
                                    GTK.gtk_widget_hide(comboBoxGrape);
                                    GTK.gtk_widget_hide(comboBoxOrange);
                                    GTK.gtk_widget_hide(comboBoxYouzi);
                            }else if(fruit.equalsIgnoreCase(&amp;quot;葡萄&amp;quot;))
                            {
                                    helpFunction(comboBoxGrape,label1);
                                    GTK.gtk_widget_hide(comboBoxApple);
                                    GTK.gtk_widget_hide(comboBoxBanana);
                                    GTK.gtk_widget_hide(comboBoxOrange);
                                    GTK.gtk_widget_hide(comboBoxYouzi);
                            }else if(fruit.equalsIgnoreCase(&amp;quot;橘子&amp;quot;))
                            {
                                    helpFunction(comboBoxOrange,label1);
                                    GTK.gtk_widget_hide(comboBoxApple);
                                    GTK.gtk_widget_hide(comboBoxBanana);
                                    GTK.gtk_widget_hide(comboBoxGrape);
                                    GTK.gtk_widget_hide(comboBoxYouzi);        
                            }
                            else if(fruit.equalsIgnoreCase(&amp;quot;蜜柚&amp;quot;))
                            {
                                    helpFunction(comboBoxYouzi,label1);
                                    GTK.gtk_widget_hide(comboBoxApple);
                                    GTK.gtk_widget_hide(comboBoxBanana);
                                    GTK.gtk_widget_hide(comboBoxGrape);
                                    GTK.gtk_widget_hide(comboBoxOrange);        
                            }
                    }
            }, null);

    }

    public static void helpFunction(final int comboBoxText,final int label1)
    {
            GTK.gtk_widget_show(comboBoxText);
            GTK.gtk_combo_box_set_active(comboBoxText, 0);
            GTK.g_signal_connect(comboBoxText, &amp;quot;changed&amp;quot;, new IGCallBack() 
            {
                    @Override
                    public void execute(int instance, int eventData, Object object) 
                    {
                            String fruit = GTK.gtk_combo_box_text_get_active_text(comboBoxText);
                            GTK.gtk_label_set_text(label1, &amp;quot;您想要购买的&amp;quot;+fruit+&amp;quot;没有了！请到别家购买&amp;quot;);
                    };
            }, null);
    }

    public static void loadComboBox(int window,String[] names, int gridHouse,int start)
    {
            int cmbApple = GTK.gtk_combo_box_text_new();
            for(int  i = 0 ; i &amp;lt; names.length; i++)
            {
                    GTK.gtk_combo_box_text_append_text(cmbApple, names[i]);
            }

            GTK.gtk_widget_show(cmbApple);
            GTK.gtk_grid_attach(gridHouse, cmbApple, 0, start, 1, 1);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
case2: 省市联动器 （上一次的水果选择器，未使用id方法。。）
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java
import com.rupeng.gtk4j.GTK;
import com.rupeng.gtk4j.IGCallBack;
/**
*
*/&lt;/p&gt;

&lt;p&gt;/**
* @author 叶昭良
* @version 省市联动器 V1.0
*
*/
public class ProvincedSelect
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /**
     * @param args
     */
    static int window;
    static int gridHouse;
    static int cmbProvince;
    static int cmbCity;
    static int labelShow;
    public static void main(String[] args)
    {
            // TODO 自动生成的方法存根
            //初始化
            GTK.gtk_init();
            //建立窗口
            window = GTK.gtk_window_new(GTK.GTK_WINDOW_TOPLEVEL);
            //显示窗口
            GTK.gtk_widget_show(window);
            // 安静关闭
            GTK.g_signal_connect(window, &amp;quot;destroy&amp;quot;, new IGCallBack()
            {

                    @Override
                    public void execute(int instance, int eventData, Object object)
                    {
                            // TODO 自动生成的方法存根
                            GTK.gtk_main_quit();
                    }

            }, null);
            //布局设置
            gridHouse = GTK.gtk_grid_new();                        
            GTK.gtk_widget_show(gridHouse);        
            //包含整租房
            GTK.gtk_container_add(window, gridHouse);
            //创建控件
            //
            labelShow = GTK.gtk_label_new(&amp;quot;&amp;quot;);
            cmbProvince = GTK.gtk_combo_box_text_new();
            cmbCity     = GTK.gtk_combo_box_text_new();


            int start =  0;
            //添加控件
            GTK.gtk_grid_attach(gridHouse, cmbProvince, 0, start, 1, 1);
            GTK.gtk_grid_attach(gridHouse, cmbCity, 0,start+1, 1, 1);
            GTK.gtk_grid_attach(gridHouse, labelShow, 1,start+2, 1, 1);

            //显示控件

            GTK.gtk_widget_show(cmbProvince);
            GTK.gtk_widget_show(cmbCity);
            GTK.gtk_widget_show(labelShow);
            createProvince(window);



            //启动循环
            GTK.gtk_main();

    }

    public static void createProvince(int window)
    {


            GTK.gtk_combo_box_text_append(cmbProvince, &amp;quot;fj&amp;quot;, &amp;quot;福建&amp;quot;);
            GTK.gtk_combo_box_text_append(cmbProvince, &amp;quot;bj&amp;quot;, &amp;quot;北京&amp;quot;);
            //GTK.gtk_combo_box_text_append(cmbProvince, &amp;quot;sh&amp;quot;, &amp;quot;上海&amp;quot;);
            GTK.gtk_combo_box_text_append(cmbProvince, &amp;quot;hn&amp;quot;, &amp;quot;河南&amp;quot;);
            GTK.gtk_combo_box_text_append(cmbProvince, &amp;quot;hb&amp;quot;, &amp;quot;河北&amp;quot;);
            GTK.gtk_combo_box_text_append(cmbProvince, &amp;quot;sd&amp;quot;,&amp;quot;山东&amp;quot;);

            GTK.gtk_combo_box_set_active_id(cmbProvince, &amp;quot;bj&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;//添加事件
                GTK.g_signal_connect(cmbProvince, &amp;ldquo;changed&amp;rdquo;, new IGCallBack()
                {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                    @Override
                    public void execute(int instance, int eventData, Object object)
                    {
                            // TODO 自动生成的方法存根

                            String province  =  GTK.gtk_combo_box_get_active_id(cmbProvince);
                            if(province==null)return;
                            System.out.println(province);
                            GTK.gtk_combo_box_text_remove_all(cmbCity); //删除所有项
                            //GTK.gtk_combo_box_text_remove_all(cmbCity); //删除所有项
                            if(province.equals(&amp;quot;fj&amp;quot;))
                            {
                                    System.out.println(&amp;quot;福建测试中&amp;quot;);
                                    GTK.gtk_combo_box_text_append(cmbCity, &amp;quot;zhz&amp;quot;, &amp;quot;漳州&amp;quot;);
                                    GTK.gtk_combo_box_text_append(cmbCity, &amp;quot;xm&amp;quot;, &amp;quot;厦门&amp;quot;);
                                    GTK.gtk_combo_box_text_append(cmbCity, &amp;quot;fz&amp;quot;, &amp;quot;福州&amp;quot;);
                                    GTK.gtk_combo_box_text_append(cmbCity, &amp;quot;qz&amp;quot;, &amp;quot;泉州&amp;quot;);

                            }else if(province.equals(&amp;quot;bj&amp;quot;))
                            {
                                    System.out.println(&amp;quot;福建测试中&amp;quot;);
                                    GTK.gtk_combo_box_text_append(cmbCity, &amp;quot;cp&amp;quot;, &amp;quot;昌平区&amp;quot;);
                                    GTK.gtk_combo_box_text_append(cmbCity, &amp;quot;hd&amp;quot;, &amp;quot;海淀区&amp;quot;);
                                    GTK.gtk_combo_box_text_append(cmbCity, &amp;quot;tz&amp;quot;, &amp;quot;通州区&amp;quot;);
                                    GTK.gtk_combo_box_text_append(cmbCity, &amp;quot;cy&amp;quot;, &amp;quot;朝阳区&amp;quot;);
                            }else if(province.equals(&amp;quot;hn&amp;quot;))
                            {
                                    System.out.println(&amp;quot;福建测试中&amp;quot;);
                           GTK.gtk_combo_box_text_append(cmbCity, &amp;quot;zz&amp;quot;, &amp;quot;郑州&amp;quot;);
                           GTK.gtk_combo_box_text_append(cmbCity, &amp;quot;zmd&amp;quot;, &amp;quot;驻马店&amp;quot;);
                           GTK.gtk_combo_box_text_append(cmbCity, &amp;quot;ny&amp;quot;, &amp;quot;南阳&amp;quot;);
                            }else if(province.equals(&amp;quot;hb&amp;quot;))
                            {
                                    System.out.println(&amp;quot;福建测试中&amp;quot;);
                           GTK.gtk_combo_box_text_append(cmbCity, &amp;quot;sjz&amp;quot;, &amp;quot;石家庄&amp;quot;);
                           GTK.gtk_combo_box_text_append(cmbCity, &amp;quot;ts&amp;quot;, &amp;quot;唐山&amp;quot;);
                           GTK.gtk_combo_box_text_append(cmbCity, &amp;quot;qhd&amp;quot;, &amp;quot;秦皇岛&amp;quot;);
                            }else if(province.equals(&amp;quot;sd&amp;quot;))
                            {
                                    System.out.println(&amp;quot;福建测试中&amp;quot;);
                               GTK.gtk_combo_box_text_append(cmbCity, &amp;quot;jn&amp;quot;, &amp;quot;济南&amp;quot;);
                           GTK.gtk_combo_box_text_append(cmbCity, &amp;quot;qd&amp;quot;, &amp;quot;青岛&amp;quot;);
                           GTK.gtk_combo_box_text_append(cmbCity, &amp;quot;yt&amp;quot;, &amp;quot;烟台&amp;quot;);
                            }
                    }        
            }, null);

            //原来remove之后 也是会促发cmbCity的 信号  而导致改变 ，根源在于这个
            GTK.g_signal_connect(cmbCity, &amp;quot;changed&amp;quot;, new IGCallBack()
            {
                    @Override
                    public void execute(int instance, int eventData, Object object)
                    {
                            // TODO 自动生成的方法存根
                             String tempProvince = GTK.gtk_combo_box_text_get_active_text(cmbProvince);

                            int  apple  = GTK.gtk_combo_box_get_active(cmbCity);
                            if(apple &amp;lt; 0)
                            {
                                    System.out.println(&amp;quot;nothing in the city&amp;quot;);
                                    return;
                            }

                            String tempCity = GTK.gtk_combo_box_text_get_active_text(cmbCity);
                            if(tempProvince==null||tempCity==null)return;
                            //GTK.gtk_label_set_text(labelShow, &amp;quot;你准备去&amp;quot;+tempProvince+tempCity);
                            GTK.gtk_label_set_text(labelShow,tempProvince+tempCity);
                            System.out.println(tempProvince);
                            System.out.println(tempCity);

                    }
            }, null);


    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Third: GTKIMAGE

case1  三种方式读入Image
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java
import com.rupeng.gtk4j.GTK;
import com.rupeng.gtk4j.IGCallBack;&lt;/p&gt;

&lt;p&gt;/**
* @author 叶昭良
* @version GtkImage v1.0
*
*/
public class TestGtkImage
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /**
     * @param args
     */
    static int window;
    static int gridHouse;
    public static void main(String[] args)
    {
            // TODO 自动生成的方法存根
            // TODO 自动生成的方法存根
            GTK.gtk_init();
            window = GTK.gtk_window_new(GTK.GTK_WINDOW_TOPLEVEL); 
            GTK.gtk_window_set_title(window, &amp;quot;GtkImage V1.0&amp;quot;);
            GTK.gtk_widget_show(window);
            //安全关闭GTK
            GTK.g_signal_connect(window, &amp;quot;destroy&amp;quot;, new IGCallBack() 
            {
                    @Override
                    public void execute(int instance, int eventData, Object object)
                    {
                            // TODO 自动生成的方法存根
                            GTK.gtk_main_quit();
                    }
            }, null);
            // 创建布局
            gridHouse =  GTK.gtk_grid_new();
            GTK.gtk_widget_show(gridHouse);

            int start  = 0;
            createGtkImage(window,gridHouse,start);
            GTK.gtk_container_add(window,gridHouse);
            //启动循环
            GTK.gtk_main();
    }

    public static void createGtkImage(int window,int gridHouse,int start)
    {
            int imgWall = GTK.gtk_image_new_from_file(&amp;quot;E:\\娱乐频道\\图片频道\\xin\\greatWall.jpg&amp;quot;);
            int imgHun = GTK.gtk_image_new_from_resource(&amp;quot;yumufeng.jpg&amp;quot;);
            int imgStock = GTK.gtk_image_new_from_stock(GTK.GTK_STOCK_ABOUT, GTK.GTK_ICON_SIZE_LARGE_TOOLBAR);


            int labelWall = GTK.gtk_label_new(&amp;quot;通过磁盘文件读入长城照片&amp;quot;);
            int labelHun = GTK.gtk_label_new(&amp;quot;通过项目文件读入婚纱照片&amp;quot;);
            int labelStock = GTK.gtk_label_new(&amp;quot;通过GTK内置图片文件读入关于照片&amp;quot;);

            //添加到整租房间
            GTK.gtk_grid_attach(gridHouse, imgWall, 0, start+1, 1, 1);
            GTK.gtk_grid_attach(gridHouse, imgHun, 1, start+1, 1, 1);
            GTK.gtk_grid_attach(gridHouse, imgStock, 2, start+1, 1, 1);
            GTK.gtk_grid_attach(gridHouse, labelWall, 0, start, 1, 1);
            GTK.gtk_grid_attach(gridHouse, labelHun, 1, start, 1, 1);
            GTK.gtk_grid_attach(gridHouse, labelStock, 2, start, 1, 1);

            //显示控件
            GTK.gtk_widget_show(imgWall);
            GTK.gtk_widget_show(imgHun);
            GTK.gtk_widget_show(imgStock);
            GTK.gtk_widget_show(labelWall);
            GTK.gtk_widget_show(labelHun);
            GTK.gtk_widget_show(labelStock);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
case2  按钮图片
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java
import com.rupeng.gtk4j.GTK;
import com.rupeng.gtk4j.IGCallBack;&lt;/p&gt;

&lt;p&gt;/**
* @author 叶昭良
* @version ButtonImage v1.0
*
*/
public class TestGtkButtonImage
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /**
     * @param args
     */
    static int window;
    static int gridHouse;
    public static void main(String[] args)
    {
            // TODO 自动生成的方法存根
            // TODO 自动生成的方法存根
            // TODO 自动生成的方法存根
            GTK.gtk_init();
            window = GTK.gtk_window_new(GTK.GTK_WINDOW_TOPLEVEL); 
            GTK.gtk_window_set_title(window, &amp;quot;ButtonImage V1.0&amp;quot;);
            GTK.gtk_widget_show(window);
            //安全关闭GTK
            GTK.g_signal_connect(window, &amp;quot;destroy&amp;quot;, new IGCallBack() 
            {
                    @Override
                    public void execute(int instance, int eventData, Object object)
                    {
                            // TODO 自动生成的方法存根
                            GTK.gtk_main_quit();
                    }
            }, null);
            // 创建布局
            gridHouse =  GTK.gtk_grid_new();
            GTK.gtk_widget_show(gridHouse);

            int start  = 0;
            createButtonImage(window,gridHouse,start);
            GTK.gtk_container_add(window,gridHouse);
            //启动循环
            GTK.gtk_main();
    }

    public static void createButtonImage(int window,int gridHouse,int start)
    {
            int imgOpen = GTK.gtk_image_new_from_stock(GTK.GTK_STOCK_OPEN, GTK.GTK_ICON_SIZE_BUTTON);
            int imgClosed = GTK.gtk_image_new_from_stock(GTK.GTK_STOCK_CLOSE, GTK.GTK_ICON_SIZE_BUTTON);
            int imgFile = GTK.gtk_image_new_from_stock(GTK.GTK_STOCK_FILE, GTK.GTK_ICON_SIZE_BUTTON);
            int btnCommon = GTK.gtk_button_new_with_label(&amp;quot;普通按钮&amp;quot;);
            int btnOpen = GTK.gtk_button_new_with_label(&amp;quot;打开&amp;quot;);
            int btnClosed = GTK.gtk_button_new_with_label(&amp;quot;关闭&amp;quot;);
            int btnFile = GTK.gtk_button_new_with_label(&amp;quot;文件&amp;quot;);
            GTK.gtk_button_set_image(btnOpen, imgOpen);
            GTK.gtk_button_set_image(btnClosed, imgClosed);
            GTK.gtk_button_set_image(btnFile, imgFile);
            //添加控件 
            //GTK.gtk_grid_attach(gridHouse, imgOpen, 0, start, 1, 1);
            GTK.gtk_grid_attach(gridHouse, btnCommon, 0, start, 1, 1);
            GTK.gtk_grid_attach(gridHouse, btnOpen, 1, start, 1, 1);
            GTK.gtk_grid_attach(gridHouse, btnClosed,2, start, 1, 1);
            GTK.gtk_grid_attach(gridHouse, btnFile,3, start, 1, 1);
            //显示控件
            GTK.gtk_widget_show(btnOpen);
            GTK.gtk_widget_show(btnClosed);
            GTK.gtk_widget_show(btnCommon);
            GTK.gtk_widget_show(btnFile);

            GTK.gtk_button_set_image_position(btnClosed, GTK.GTK_POS_TOP); //GTK_POS
            GTK.gtk_button_set_image_position(btnFile, GTK.GTK_POS_RIGHT);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Fourth: TextView

case1 女神表达神器：Love you !My Girl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java
import com.rupeng.gtk4j.GTK;
import com.rupeng.gtk4j.IGCallBack;&lt;/p&gt;

&lt;p&gt;/**
* @author 叶昭良
* @version  TestView v1.0
*/
public class GTKTestTextView
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /**
     * @param args
     */
    static int window;
    static int gridHouse;
    public static void main(String[] args)
    {
            // TODO 自动生成的方法存根
            GTK.gtk_init();
            window = GTK.gtk_window_new(GTK.GTK_WINDOW_TOPLEVEL); 
            GTK.gtk_window_set_title(window, &amp;quot;女朋友告白神器 V1.0&amp;quot;);
            GTK.gtk_widget_show(window);
            //安全关闭GTK
            GTK.g_signal_connect(window, &amp;quot;destroy&amp;quot;, new IGCallBack() 
            {
                    @Override
                    public void execute(int instance, int eventData, Object object)
                    {
                            // TODO 自动生成的方法存根
                            GTK.gtk_main_quit();
                    }
            }, null);
            // 创建布局
            gridHouse =  GTK.gtk_grid_new();
            GTK.gtk_widget_show(gridHouse);

            int start  = 0;
            createTextView(window,gridHouse,start);
            GTK.gtk_container_add(window,gridHouse);
            //启动循环
            GTK.gtk_main();
    }

    public static void createTextView(int window, int gridHouse, int start)
    {
            int imgYumu = GTK.gtk_image_new_from_resource(&amp;quot;yumufeng.jpg&amp;quot;);
            int tvGirl = GTK.gtk_text_view_new();
            final int label = GTK.gtk_label_new(&amp;quot;&amp;quot;);
            int btnShow = GTK.gtk_button_new_with_label(&amp;quot;显示&amp;quot;);
            GTK.gtk_text_view_set_wrap_mode(tvGirl, GTK.GTK_WRAP_WORD);

            //添加控件
            GTK.gtk_grid_attach(gridHouse, imgYumu, 0, start, 1, 1);
            GTK.gtk_grid_attach(gridHouse, tvGirl, 0, start+1, 1, 1);
            GTK.gtk_grid_attach(gridHouse, label, 0 ,start+2, 1,1);
            GTK.gtk_grid_attach(gridHouse, btnShow, 1 ,start+2, 1,1);
            //显示控件
            GTK.gtk_widget_show(imgYumu);
            GTK.gtk_widget_show(tvGirl);
            GTK.gtk_widget_show(label);
            GTK.gtk_widget_show(btnShow);

            //读取文本框里面的内容 ，只适用小量的文本，一般用迭代器
            //方法1   先从TextView获取int TextBuffer 
                //    然后再从TextBuffer获取text
            final int textbuffer= GTK.gtk_text_view_get_buffer(tvGirl);
            String loveWords = &amp;quot;你就像那天上星星，点缀着我们两的星空，璀璨夺目；&amp;quot;
                            + &amp;quot;我愿与你携手共同奋进，原因和你共育我们的sons and grils,&amp;quot;
                            + &amp;quot;建立起一个幸福的家庭&amp;quot;;

            //可以直接通过缓冲区编号  设置信息
            GTK.gtk_text_buffer_set_text(textbuffer, loveWords);
            //添加按钮事件
            GTK.g_signal_connect(btnShow, &amp;quot;clicked&amp;quot;, new IGCallBack() 
            {
                    @Override
                    public void execute(int instance, int eventData, Object object)
                    {
                            // TODO 自动生成的方法存根
                            String text = GTK.gtk_text_buffer_get_text(textbuffer);
                            GTK.gtk_label_set_text(label, text);
                    }
            }, null);


    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
case2 : TextIter  实现添加love you 字符串  并加入了滚动条，实现女神表达器的升级版
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java
import com.rupeng.gtk4j.GTK;
import com.rupeng.gtk4j.IGCallBack;&lt;/p&gt;

&lt;p&gt;/**
* @author 叶昭良
* @version  TestView+TestIter v1.0
* @version  TestView+TestIter v2.0 加入了滚动条操作。
*/
public class GTKTestTextIter
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /**
     * @param args
     */
    static int window;
    static int gridHouse;
    static int scrolledBar;
    public static void main(String[] args)
    {
            // TODO 自动生成的方法存根
            GTK.gtk_init();
            window = GTK.gtk_window_new(GTK.GTK_WINDOW_TOPLEVEL); 
            GTK.gtk_window_set_title(window, &amp;quot;女朋友告白神器 V1.0&amp;quot;);
            GTK.gtk_widget_show(window);
            //安全关闭GTK
            GTK.g_signal_connect(window, &amp;quot;destroy&amp;quot;, new IGCallBack() 
            {
                    @Override
                    public void execute(int instance, int eventData, Object object)
                    {
                            // TODO 自动生成的方法存根
                            GTK.gtk_main_quit();
                    }
            }, null);
            // 创建布局
            gridHouse =  GTK.gtk_grid_new();
            GTK.gtk_widget_show(gridHouse);

            int start  = 0;
            createTextView(window,gridHouse,start);
            GTK.gtk_container_add(window,gridHouse);
            //启动循环
            GTK.gtk_main();
    }

    public static void createTextView(int window, int gridHouse, int start)
    {
            int imgYumu = GTK.gtk_image_new_from_resource(&amp;quot;yumufeng.jpg&amp;quot;);
            final int tvGirl = GTK.gtk_text_view_new();
            final int label = GTK.gtk_label_new(&amp;quot;&amp;quot;);
            final int labelIter = GTK.gtk_label_new(&amp;quot;&amp;quot;);
            int btnShow = GTK.gtk_button_new_with_label(&amp;quot;显示&amp;quot;);
            int btnShowIter = GTK.gtk_button_new_with_label(&amp;quot;迭代器插入&amp;quot;);
            GTK.gtk_text_view_set_wrap_mode(tvGirl, GTK.GTK_WRAP_WORD);
            int scrollBar = 0 ;
            //添加控件
            GTK.gtk_grid_attach(gridHouse, imgYumu, 0, start, 1, 1);
            createScrollBar(scrollBar,tvGirl,gridHouse,start);
            //GTK.gtk_grid_attach(gridHouse, tvGirl, 0, start+1, 1, 1);
            GTK.gtk_grid_attach(gridHouse, label, 0 ,start+2, 1,1);
            GTK.gtk_grid_attach(gridHouse, labelIter, 0 ,start+3, 1,1);
            GTK.gtk_grid_attach(gridHouse, btnShow, 1 ,start+2, 1,1);
            GTK.gtk_grid_attach(gridHouse, btnShowIter, 1 ,start+3, 1,1);
            //显示控件
            GTK.gtk_widget_show(imgYumu);
            GTK.gtk_widget_show(tvGirl);
            GTK.gtk_widget_show(label);
            GTK.gtk_widget_show(btnShow);
            GTK.gtk_widget_show(labelIter);
            GTK.gtk_widget_show(btnShowIter);

            //读取文本框里面的内容 ，只适用小量的文本，一般用迭代器
            //方法1   先从TextView获取int TextBuffer 
                //    然后再从TextBuffer获取text
            final int textbuffer= GTK.gtk_text_view_get_buffer(tvGirl);
            String loveWords = &amp;quot;你就像那天上星星，点缀着我们两的星空，璀璨夺目；&amp;quot;
                            + &amp;quot;我愿与你携手共同奋进，原因和你共育我们的sons and grils,&amp;quot;
                            + &amp;quot;建立起一个幸福的家庭&amp;quot;;

            //可以直接通过缓冲区编号  设置信息
            GTK.gtk_text_buffer_set_text(textbuffer, loveWords);
            //添加按钮事件
            GTK.g_signal_connect(btnShow, &amp;quot;clicked&amp;quot;, new IGCallBack() 
            {
                    @Override
                    public void execute(int instance, int eventData, Object object)
                    {
                            // TODO 自动生成的方法存根
                            String text = GTK.gtk_text_buffer_get_text(textbuffer);
                            GTK.gtk_label_set_text(label, text);
                    }
            }, null);


            GTK.g_signal_connect(btnShowIter, &amp;quot;clicked&amp;quot;, new IGCallBack() 
            {
                    @Override
                    public void execute(int instance, int eventData, Object object)
                    {
                            // TODO 自动生成的方法存根
                            helpFunction(tvGirl);
                    }
            }, null);

    }
    //如何遍历读取textview信息？？ 当前只能插入？
    public static void helpFunction(int textview)
    {
            //TextIter是一个TextView的迭代器。
            int textBuffer =  GTK.gtk_text_view_get_buffer(textview);
            int textIter = GTK.gtk_text_iter_new();  //这是一个空的iter，需要用textBuffer进行赋值
            GTK.gtk_text_buffer_get_end_iter(textBuffer, textIter);// 或者textview的textBuffer的末尾！
            GTK.gtk_text_buffer_insert(textBuffer, textIter, &amp;quot;I love you! Xinran&amp;quot;);

            //GTK.gtk_text_buffer_g
            GTK.gtk_text_iter_free(textIter);

    }

    public static void createScrollBar(int scrolledBar,int textview,int gridHouse,int start)
    {
            scrolledBar = GTK.gtk_scrolled_window_new();
            GTK.gtk_widget_show(scrolledBar);
            GTK.gtk_grid_attach(gridHouse, scrolledBar, 0, start+1, 1, 1);
            GTK.gtk_widget_set_size_request(scrolledBar, 300, 50);
            GTK.gtk_container_add(scrolledBar,textview);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
case3 : 计算器version 3.0   加入了一些Sin等计算符   以及TextView   

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java
/**
* @author 叶昭良
* @version : 计算器v1.0
* @version : 计算器v 2.0  替换掉entry 采用了SpinBox和ComboBox
* @version : 计算器v 3.0&lt;br /&gt;
*              1.使用button触发计算事件  加入了三角函数、对数函数等的计算，
*              2.使用TextView  and TextIter把结果输入到其中。。
*              3.对于&lt;br /&gt;
*
*/
import javax.swing.JOptionPane;&lt;/p&gt;

&lt;p&gt;import com.rupeng.gtk4j.GTK;
import com.rupeng.gtk4j.IGCallBack;
//import java.math.*;&lt;/p&gt;

&lt;p&gt;public class TestCalc3
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /**
     * @param args
     */
    static int window;
    static boolean isEnter = false;

    public static void main(String[] args)
    {
            // TODO 自动生成的方法存根
            //初始化
            GTK.gtk_init();
            //建立窗口  设置成static int window变量
            window = GTK.gtk_window_new(GTK.GTK_WINDOW_TOPLEVEL);
            //设置窗口名称
            GTK.gtk_window_set_title(window, &amp;quot;计算器v3.0&amp;quot;);
            //添加窗口
            GTK.gtk_widget_show(window);

            //关闭对话框
            GTK.g_signal_connect(window, &amp;quot;destroy&amp;quot;, new IGCallBack() 
            {
                    @Override
                    public void execute(int instance, int eventData, Object object)
                    {
                            // TODO 自动生成的方法存根
                            GTK.gtk_main_quit();
                    }
            }, null);

            //网格布局
        int houseGrid = GTK.gtk_grid_new();
        //载入计算机控件

        Calc(window,houseGrid,0); //有两行
        specialCal(window,houseGrid,2); //有两行
        //载入到windows当中
            GTK.gtk_container_add(window, houseGrid);
            //启动循环
            GTK.gtk_main();

    }
    /**
     * 
     * @param window     窗口的标识
      * @param houseGrid  整租房间的标识
     * @param start      设置整租房间的起始行数
     */
    public static void Calc(int window,int houseGrid,int start)
    {
            final int sbOne = GTK.gtk_spin_button_new_with_range(-32768, 32767, 1);
            final int sbAnother = GTK.gtk_spin_button_new_with_range(-32768, 32767, 1);
            GTK.gtk_spin_button_set_value(sbOne, 12.0);
            GTK.gtk_spin_button_set_value(sbAnother, 4.0);
            final int cbbOperator = GTK.gtk_combo_box_text_new();
            GTK.gtk_combo_box_text_append_text(cbbOperator, &amp;quot;+&amp;quot;);
            GTK.gtk_combo_box_text_append_text(cbbOperator, &amp;quot;-&amp;quot;);
            GTK.gtk_combo_box_text_append_text(cbbOperator, &amp;quot;*&amp;quot;);
            GTK.gtk_combo_box_text_append_text(cbbOperator, &amp;quot;/&amp;quot;);
            GTK.gtk_combo_box_text_append_text(cbbOperator, &amp;quot;%&amp;quot;);
            GTK.gtk_combo_box_text_append_text(cbbOperator, &amp;quot;^&amp;quot;);

            GTK.gtk_combo_box_set_active(cbbOperator, 0);
            int btnEquals = GTK.gtk_button_new_with_label(&amp;quot;=&amp;quot;);
            final int label2 = GTK.gtk_label_new(&amp;quot;我知道答案是什么&amp;quot;);

            int labelCommon = GTK.gtk_label_new(&amp;quot;普通的四则运算：&amp;quot;);
            // Box用于存储  + - operator



            //加入整租
            GTK.gtk_grid_attach(houseGrid, labelCommon, 0, start, 1, 1);
            //在下一行再添加
            start= start + 1;
            GTK.gtk_grid_attach(houseGrid, sbOne, 0, start, 1, 1);
            GTK.gtk_grid_attach(houseGrid, cbbOperator, 1, start, 1, 1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;//                GTK.gtk_grid_attach(houseGrid, buttonPlus, 1, start, 1, 1);
//                GTK.gtk_grid_attach(houseGrid, buttonMinus, 1, start+1, 1, 1);
                GTK.gtk_grid_attach(houseGrid, sbAnother, 2, start, 1, 1);
                GTK.gtk_grid_attach(houseGrid, btnEquals, 3, start, 1, 1);
                GTK.gtk_grid_attach(houseGrid, label2, 4, start, 1, 1);&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;            //显示控件
            GTK.gtk_widget_show(labelCommon);
            GTK.gtk_widget_show(sbOne);
            GTK.gtk_widget_show(sbAnother);
            GTK.gtk_widget_show(cbbOperator);

            GTK.gtk_widget_show(btnEquals);
            GTK.gtk_widget_show(label2);
            //GTK.gtk_widget_show(box);
            GTK.gtk_widget_show(houseGrid);


            //加入事件控制机制 
            GTK.g_signal_connect(btnEquals, &amp;quot;clicked&amp;quot;, new IGCallBack()
            {
                    @Override
                    public void execute(int instance, int eventData, Object object)
                    {

                            // TODO 自动生成的方法存根
                            double plus1 = GTK.gtk_spin_button_get_value(sbOne);
                            double plus2 = GTK.gtk_spin_button_get_value(sbAnother);

                            //增加一个 只读模式的entry
                            //GTK.gtk_editable_set_editable(entryOne, false); //只读不能写入。

                            String cbbString = GTK.gtk_combo_box_text_get_active_text(cbbOperator);
                            //panduan(plus1,entryOne);
                            panduan(plus2,sbAnother);
                            double sum1 = 0;
                            if(cbbString.equalsIgnoreCase(&amp;quot;+&amp;quot;))
                            {
                                     sum1 = plus1 + plus2;
                                    GTK.gtk_label_set_text(label2, Double.toString(sum1));
                            }else if(cbbString.equalsIgnoreCase(&amp;quot;-&amp;quot;))
                            {
                                    sum1 = plus1 -plus2;
                                    GTK.gtk_label_set_text(label2, Double.toString(sum1));
                            }else if(cbbString.equalsIgnoreCase(&amp;quot;*&amp;quot;))
                            {
                                    sum1 = plus1 * plus2;
                                    GTK.gtk_label_set_text(label2, Double.toString(sum1));
                            }else if(cbbString.equalsIgnoreCase(&amp;quot;/&amp;quot;))
                            {
                                    panduan(plus2,sbAnother);
                                    sum1 = plus1 / plus2;
                                    GTK.gtk_label_set_text(label2, Double.toString(sum1));
                            }else if(cbbString.equalsIgnoreCase(&amp;quot;%&amp;quot;))
                            {
                                    panduan(plus2,sbAnother);
                                    sum1 = plus1 % plus2;
                                    GTK.gtk_label_set_text(label2, Double.toString(sum1));
                            }else if(cbbString.equalsIgnoreCase(&amp;quot;^&amp;quot;))
                            {
                                    //String temp = Double.toString(plus2);

                                    sum1 = Math.pow(plus1,plus2);
                                    GTK.gtk_label_set_text(label2, Double.toString(sum1));
                            }
                    }
            }, null);        

    }
    /**
     * 
     * @param plus1  entry1的数字字符串
     * @param entry1 entry1的标识
     */
    public static void panduan(double plus1,int sbAnother)
    {
            if(plus1 == 0)
            {
                    JOptionPane.showMessageDialog(null, &amp;quot;被除数不能为0,已经置为空 请重新输入&amp;quot;);
                    GTK.gtk_spin_button_set_value(sbAnother, 1.0);;
                    return;
            }
    }
    /**
     * 
     * @param window     计算器窗口的标识
     * @param gridHouse  整租房的标识
     * @param start      整租房的编号
     */
    public static void specialCal(int window,int gridHouse,int start)
    {
            // 建立控件
            final int btnSin = GTK.gtk_button_new_with_label(&amp;quot;sin&amp;quot;);
            final int btnCos = GTK.gtk_button_new_with_label(&amp;quot;cos&amp;quot;);
            final int btnTan = GTK.gtk_button_new_with_label(&amp;quot;tan&amp;quot;);
            final int btnAsin = GTK.gtk_button_new_with_label(&amp;quot;asin&amp;quot;);
            final int btnAcos = GTK.gtk_button_new_with_label(&amp;quot;acos&amp;quot;);
            final int btnAtan = GTK.gtk_button_new_with_label(&amp;quot;atan&amp;quot;);
            final int btnLog = GTK.gtk_button_new_with_label(&amp;quot;log&amp;quot;);
            final int btnSqrt = GTK.gtk_button_new_with_label(&amp;quot;sqrt&amp;quot;);
            final int btnabs = GTK.gtk_button_new_with_label(&amp;quot;abs&amp;quot;);
            final int btnFloor = GTK.gtk_button_new_with_label(&amp;quot;floor&amp;quot;);
            final int btnCeil = GTK.gtk_button_new_with_label(&amp;quot;ceil&amp;quot;);
            final int btnToDegree = GTK.gtk_button_new_with_label(&amp;quot;弧度变角度&amp;quot;);
            final int btnToRadius = GTK.gtk_button_new_with_label(&amp;quot;角度变弧度&amp;quot;);
            final int spinbox= GTK.gtk_spin_button_new_with_range(-32767, 32767, 0.1);
            final int btnEquals = GTK.gtk_button_new_with_label(&amp;quot;=&amp;quot;);
            final int tv1 = GTK.gtk_text_view_new();
            final int labelSpecial = GTK.gtk_label_new(&amp;quot;特殊的四则运算：(先点击运算符，再敲值，最后等号)&amp;quot;);
            //设置GTK TextView的模式
            GTK.gtk_text_view_set_wrap_mode(tv1, GTK.GTK_WRAP_WORD);
            //设置滚动条
            final int scrolledBar = 0 ;


            GTK.gtk_spin_button_set_value(spinbox, 44.0);
            int innerGrid = GTK.gtk_grid_new();
            //添加控件
            GTK.gtk_grid_attach(innerGrid, btnSin, 0, 0, 1, 1);
            GTK.gtk_grid_attach(innerGrid, btnCos, 1, 0, 1, 1);
            GTK.gtk_grid_attach(innerGrid, btnTan, 2, 0, 1, 1);
            GTK.gtk_grid_attach(innerGrid, btnAsin, 0, 1, 1, 1);
            GTK.gtk_grid_attach(innerGrid, btnAcos, 1, 1, 1, 1);
            GTK.gtk_grid_attach(innerGrid, btnAtan, 2, 1, 1, 1);
            GTK.gtk_grid_attach(innerGrid, btnLog, 0, 2, 1, 1);
            GTK.gtk_grid_attach(innerGrid, btnSqrt, 1, 2, 1, 1);
            GTK.gtk_grid_attach(innerGrid, btnabs, 2, 2, 1, 1);
            GTK.gtk_grid_attach(innerGrid, btnFloor, 0, 3, 1, 1);
            GTK.gtk_grid_attach(innerGrid, btnCeil, 1, 3, 1, 1);
            GTK.gtk_grid_attach(innerGrid, btnToDegree, 0, 4, 1, 1);
            GTK.gtk_grid_attach(innerGrid, btnToRadius, 1, 4, 1, 1);

            GTK.gtk_grid_attach(gridHouse,labelSpecial,0,start,1,1);

            start = start + 1; //跳到下一行
            GTK.gtk_grid_attach(gridHouse, innerGrid, 0, start, 3, 5);
            GTK.gtk_grid_attach(gridHouse, spinbox, 3, start, 1, 1);
            GTK.gtk_grid_attach(gridHouse, btnEquals, 4, start, 1, 1);
            // GTK.gtk_grid_attach(gridHouse, tv1, 4, start+1, 1, 1);
            createScrollBar(scrolledBar,tv1,gridHouse,start);


            //显示控件
            GTK.gtk_widget_show(labelSpecial);
            GTK.gtk_widget_show(btnSin);
            GTK.gtk_widget_show(btnCos);
            GTK.gtk_widget_show(btnTan);
            GTK.gtk_widget_show(btnAsin);
            GTK.gtk_widget_show(btnAcos);
            GTK.gtk_widget_show(btnAtan);
            GTK.gtk_widget_show(btnSqrt);
            GTK.gtk_widget_show(btnLog);
            GTK.gtk_widget_show(btnabs);
            GTK.gtk_widget_show(btnCeil);
            GTK.gtk_widget_show(btnFloor);
            GTK.gtk_widget_show(btnToDegree);
            GTK.gtk_widget_show(btnToRadius);
            GTK.gtk_widget_show(tv1); //还是得先是  必须show 否则看不到
            GTK.gtk_widget_show(spinbox);
            GTK.gtk_widget_show(btnEquals);
            //GTK.gtk_widget_show(scrolledBar);  //不要在这边show只在scrollbar区域，不然报错
            GTK.gtk_widget_show(innerGrid);



            //添加按钮事件
            insertButtonEvent( btnSin,tv1);
            insertButtonEvent( btnCos,tv1);
            insertButtonEvent( btnTan,tv1);
            insertButtonEvent( btnAsin,tv1);
            insertButtonEvent( btnAcos,tv1);
            insertButtonEvent( btnAtan,tv1);
            insertButtonEvent( btnLog,tv1);
            insertButtonEvent( btnabs,tv1);
            insertButtonEvent( btnCeil,tv1);
            insertButtonEvent( btnFloor,tv1);
            insertButtonEvent( btnToDegree,tv1);
            insertButtonEvent( btnToRadius,tv1);


            GTK.g_signal_connect(spinbox,&amp;quot;changed&amp;quot;,new IGCallBack() 
            {
                    @Override
                    public void execute(int instance, int eventData, Object object)
                    {
                            // TODO 自动生成的方法存根
                            isEnter = true;
                    }
            },null);

            GTK.g_signal_connect(btnEquals, &amp;quot;clicked&amp;quot;, new IGCallBack() 
            {
                    @Override
                    public void execute(int instance, int eventData, Object object)
                    {
                            // TODO 自动生成的方法存根
                            double sum1  = 0 ;
                            double apple = GTK.gtk_spin_button_get_value(spinbox);
                            if(isEnter == false)
                            {
                                    JOptionPane.showMessageDialog(null, &amp;quot;您未选择特殊操作符，请重新选择，并输入数字，进行运算&amp;quot;);
                                    GTK.gtk_spin_button_set_value(spinbox, 44.0);
                                    return;
                            }else
                            {
                                    String temp = GetStringFromTextViewFunction(tv1);
                                    if(temp.equals(&amp;quot;sin&amp;quot;))
                                    {
                                            double orange = Math.toRadians(apple);
                                            sum1  = Math.sin(orange);
                                            String finalResult = &amp;quot;(&amp;quot;+apple+&amp;quot;)&amp;quot;+&amp;quot; = &amp;quot;+sum1+&amp;quot;\n&amp;quot;;
                                            InsertStringToTextViewFunction(tv1,finalResult);
                                    }else if(temp.equals(&amp;quot;cos&amp;quot;))
                                    {
                                            double orange = Math.toRadians(apple);
                                            sum1  = Math.cos(orange);
                                            String finalResult = &amp;quot;(&amp;quot;+apple+&amp;quot;)&amp;quot;+&amp;quot; = &amp;quot;+sum1+&amp;quot;\n&amp;quot;;
                                            InsertStringToTextViewFunction(tv1,finalResult);
                                    }else if(temp.equals(&amp;quot;tan&amp;quot;))
                                    {
                                            double orange = Math.toRadians(apple);
                                            sum1  = Math.tan(orange);
                                            String finalResult = &amp;quot;(&amp;quot;+apple+&amp;quot;)&amp;quot;+&amp;quot; = &amp;quot;+sum1+&amp;quot;\n&amp;quot;;
                                            InsertStringToTextViewFunction(tv1,finalResult);
                                    }else if(temp.equals(&amp;quot;asin&amp;quot;))
                                    {
                                            double orange = Math.toRadians(apple);
                                            sum1  = Math.asin(orange);
                                            String finalResult = &amp;quot;(&amp;quot;+apple+&amp;quot;)&amp;quot;+&amp;quot; = &amp;quot;+sum1+&amp;quot;\n&amp;quot;;
                                            InsertStringToTextViewFunction(tv1,finalResult);
                                    }else if(temp.equals(&amp;quot;acos&amp;quot;))
                                    {
                                            double orange = Math.toRadians(apple);
                                            sum1  = Math.acos(orange);
                                            String finalResult = &amp;quot;(&amp;quot;+apple+&amp;quot;)&amp;quot;+&amp;quot; = &amp;quot;+sum1+&amp;quot;\n&amp;quot;;
                                            InsertStringToTextViewFunction(tv1,finalResult);
                                    }else if(temp.equals(&amp;quot;atan&amp;quot;))
                                    {
                                            double orange = Math.toRadians(apple);
                                            sum1  = Math.atan(orange);
                                            String finalResult = &amp;quot;(&amp;quot;+apple+&amp;quot;)&amp;quot;+&amp;quot; = &amp;quot;+sum1+&amp;quot;\n&amp;quot;;
                                            InsertStringToTextViewFunction(tv1,finalResult);
                                    }else if(temp.equals(&amp;quot;log&amp;quot;))
                                    {
                                            sum1  = Math.log(apple);
                                            String finalResult = &amp;quot;(&amp;quot;+apple+&amp;quot;)&amp;quot;+&amp;quot; = &amp;quot;+sum1+&amp;quot;\n&amp;quot;;
                                            InsertStringToTextViewFunction(tv1,finalResult);
                                    }else if(temp.equals(&amp;quot;sqrt&amp;quot;))
                                    {
                                            sum1  = Math.sqrt(apple);
                                            String finalResult = &amp;quot;(&amp;quot;+apple+&amp;quot;)&amp;quot;+&amp;quot; = &amp;quot;+sum1+&amp;quot;\n&amp;quot;;
                                            InsertStringToTextViewFunction(tv1,finalResult);
                                    }else if(temp.equals(&amp;quot;abs&amp;quot;))
                                    {
                                            sum1  = Math.abs(apple);
                                            String finalResult = &amp;quot;(&amp;quot;+apple+&amp;quot;)&amp;quot;+&amp;quot; = &amp;quot;+sum1+&amp;quot;\n&amp;quot;;
                                            InsertStringToTextViewFunction(tv1,finalResult);
                                    }else if(temp.equals(&amp;quot;floor&amp;quot;))
                                    {
                                            sum1  = Math.floor(apple);
                                            String finalResult = &amp;quot;(&amp;quot;+apple+&amp;quot;)&amp;quot;+&amp;quot; = &amp;quot;+sum1+&amp;quot;\n&amp;quot;;
                                            InsertStringToTextViewFunction(tv1,finalResult);
                                    }else if(temp.equals(&amp;quot;ceil&amp;quot;))
                                    {
                                            sum1  = Math.ceil(apple);
                                            String finalResult = &amp;quot;(&amp;quot;+apple+&amp;quot;)&amp;quot;+&amp;quot; = &amp;quot;+sum1+&amp;quot;\n&amp;quot;;
                                            InsertStringToTextViewFunction(tv1,finalResult);
                                    }else if(temp.equals(&amp;quot;弧度变角度&amp;quot;))
                                    {
                                            sum1  = Math.toDegrees(apple);
                                            String finalResult = &amp;quot;(&amp;quot;+apple+&amp;quot;)&amp;quot;+&amp;quot; = &amp;quot;+sum1+&amp;quot;\n&amp;quot;;
                                            InsertStringToTextViewFunction(tv1,finalResult);
                                    }else if(temp.equals(&amp;quot;角度变弧度&amp;quot;))
                                    {
                                            sum1  = Math.toRadians(apple);
                                            String finalResult = &amp;quot;(&amp;quot;+apple+&amp;quot;)&amp;quot;+&amp;quot; = &amp;quot;+sum1+&amp;quot;\n&amp;quot;;
                                            InsertStringToTextViewFunction(tv1,finalResult);
                                    }
                            }
                    }
            }, null);

    }

    /**
     * 
     * @param scrolledBar  滚动条标识
     * @param textview     多行文本标识
     * @param gridHouse    整租房的标识
     * @param start        整租房的初始开始处
     */
    public static void createScrollBar(int scrolledBar,int textview,int gridHouse,int start)
    {
            scrolledBar = GTK.gtk_scrolled_window_new();
            GTK.gtk_widget_show(scrolledBar);
            //滚动条是更大的容器
            GTK.gtk_grid_attach(gridHouse, scrolledBar, 4, start+1, 1, 1); // 4改为0 报错
            GTK.gtk_widget_set_size_request(scrolledBar, 300, 50);
            GTK.gtk_container_add(scrolledBar,textview); // 添加textview到滚动条容器当中
    }

    /**
     * 
     * @param textview  多行文本TextView的标识
     * @param temp      插入TextView 的字符串。
     */
    public static void InsertStringToTextViewFunction(int textview,String temp)
    {
            //TextIter是一个TextView的迭代器。
            int textBuffer =  GTK.gtk_text_view_get_buffer(textview);
            int textIter = GTK.gtk_text_iter_new();  //这是一个空的iter，需要用textBuffer进行赋值
            //GTK.gtk_text_iter_forward_to_end(textIter);
            GTK.gtk_text_buffer_get_end_iter(textBuffer, textIter);// 或者textview的textBuffer的末尾！
            GTK.gtk_text_buffer_insert(textBuffer, textIter, temp);

            //GTK.gtk_text_buffer_g
            GTK.gtk_text_iter_free(textIter);

    }
    /**
     * 
     * @param textview   TextView的多行文本的标识
     * @return           返回的字符串
     */
    public static String GetStringFromTextViewFunction(int textview)
    {
            //TextIter是一个TextView的迭代器。
            int textBuffer =  GTK.gtk_text_view_get_buffer(textview);
            int textIter = GTK.gtk_text_iter_new();  //这是一个空的iter，需要用textBuffer进行赋值
            GTK.gtk_text_buffer_get_end_iter(textBuffer, textIter);// 或者textview的textBuffer的末尾！
            String temp = GTK.gtk_text_buffer_get_text(textBuffer);

            String[] splitArray = temp.split(&amp;quot;\\n&amp;quot;);
            temp = splitArray[splitArray.length-1];
            System.out.println(temp);
            return temp;
            //GTK.gtk_text_buffer_g
            //GTK.gtk_text_iter_free(textIter);

    }
    /**
     * 
     * @param btnSin   按钮的标识
     * @param tv1      textview的标识
     */
    public static void insertButtonEvent(final int btnSin,final int tv1)
    {
            GTK.g_signal_connect(btnSin, &amp;quot;clicked&amp;quot;,new IGCallBack()
            {
                    @Override
                    public void execute(int instance, int eventData, Object object)
                    {
                            // TODO 自动生成的方法存根
                            //double sbValue = GTK.gtk_spin_button_get_value(spinbox);
                            String temp = GTK.gtk_button_get_label(btnSin);
                            InsertStringToTextViewFunction(tv1,temp);
                            isEnter = false;
                    }
            }, null);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Fifth: Cairo

case1 : 三毛头部自画像 V1.0

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java
/**
* @author 叶昭良
* @version GTK+Cairo v1.0
*/
import com.rupeng.gtk4j.GTK;
import com.rupeng.gtk4j.IGCallBack;
import com.rupeng.gtk4j.Cairo;
public class GTKTestCairo
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /**
     * @param args
     */
    static int window;
    static int gridHouse;
    public static void main(String[] args)
    {
            // TODO 自动生成的方法存根
            //GTK初始化
            GTK.gtk_init();
            //窗口标识
            window = GTK.gtk_window_new(GTK.GTK_WINDOW_TOPLEVEL);
            //窗口标题
            GTK.gtk_window_set_title(window, &amp;quot;简易画图板v1.0&amp;quot;);
            //显示窗口
            GTK.gtk_widget_show(window);

            GTK.g_signal_connect(window, &amp;quot;destroy&amp;quot;, new IGCallBack()
            {
                    @Override
                    public void execute(int instance, int eventData, Object object)
                    {
                            // TODO 自动生成的方法存根
                            GTK.gtk_main_quit();
                    }
            }, null);


            //设置布局方式
            gridHouse = GTK.gtk_grid_new();


            //创建控件
            int start = 0;
            createDraw(window, gridHouse, start);
            //circlePoint 原点设置为180
            createDrawLaughFace(window,gridHouse,start+1,180);


            GTK.gtk_widget_show(gridHouse);

            GTK.gtk_container_add(window,gridHouse);
            //启动循环
            GTK.gtk_main();
    }


    public static void createDraw(int window,int gridHouse,int start) 
    {
            //创建画图板 或者叫画布
            int  dan  = GTK.gtk_drawing_area_new();

            int label = GTK.gtk_label_new(&amp;quot;三毛&amp;quot;);
            //创建源
            //添加控件
            GTK.gtk_grid_attach(gridHouse, label, 0, start, 1, 1);
            GTK.gtk_grid_attach(gridHouse, dan, 1, start, 1, 1);
            //显示画布
            GTK.gtk_widget_show(dan);
            GTK.gtk_widget_show(label);

            //设置画布的大小
            GTK.gtk_widget_set_size_request(dan, 300, 300);


            //开始绘制  利用事件draw 来不断的绘制

            GTK.g_signal_connect(dan, &amp;quot;draw&amp;quot;,new IGCallBack() 
            {
                    @Override
                    public void execute(int instance, int eventData, Object object)
                    {
                            // TODO 自动生成的方法存根
                            //eventDate才是画布源
                            //设置画笔的颜色
                            Cairo.cairo_set_source_rgb(eventData, 0.5, 0.6, 0.3);
                            //设置画笔的大小
                            Cairo.cairo_set_line_width(eventData, 3);



                            //移动画笔点   画笔默认位置不是在（0,0）move_to不可少
                            //Cairo.cairo_move_to(eventData, 0, 0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;/*                                //画一条线七点
                                Cairo.cairo_line_to(eventData, 50, 50);
                                //画一条线重点
                                Cairo.cairo_line_to(eventData,100,100);
                                //接着划线
                                Cairo.cairo_line_to(eventData, 120, 120);*/
                                //画一个圆
                                Cairo.cairo_arc(eventData, 180, 180, 60, 0, 2*3.1415926);
                                //画一个圆弧
                                //Cairo.cairo_arc(eventData, 200, 200, 70,1.5*3.1415925, 2*3.1415926);
                                //显示画笔
                                Cairo.cairo_stroke(eventData); //Cairo.cairo_fill(eventData)不同的效果&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                            //画一个圆弧  有下面实验知道是从x轴沿顺时针开始画图
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;/*                                Cairo.cairo_arc(eventData, 220, 220, 30,0, 0.5*3.1415926);&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                            Cairo.cairo_fill(eventData); //Cairo.cairo_fill(eventData)不同的效果

                            Cairo.cairo_arc(eventData, 220, 100, 30,0, 3.1415926);
                            Cairo.cairo_stroke(eventData);
                            Cairo.cairo_arc(eventData, 220, 30, 30,0, 1.5*3.1415926);
                            Cairo.cairo_fill(eventData);*/
                            //嘴巴的绘制
                            double Pi = 3.1415926;
                            Cairo.cairo_arc(eventData, 180, 180, 40, 0.25*Pi, 0.75*Pi);
                            Cairo.cairo_fill(eventData);

                            //绘制两只眼睛
                            Cairo.cairo_arc(eventData, 160, 160, 10, 0, 2*Pi);
                            Cairo.cairo_arc(eventData, 200, 160, 10, 0, 2*Pi);
                            Cairo.cairo_fill(eventData);


                            //绘制胡须
                            Cairo.cairo_arc(eventData, 130, 160, 50, 0.166667*Pi, 0.6777777*Pi);

                            Cairo.cairo_stroke(eventData);

                            Cairo.cairo_arc(eventData, 230, 160, 50, 0.333333*Pi, 0.8333333*Pi);
                            Cairo.cairo_stroke(eventData);

                            //绘制头发
                            Cairo.cairo_arc(eventData, 133.6, 136.72, 30,1.3333333*Pi ,1.833333*Pi );

                            Cairo.cairo_stroke(eventData);

                            Cairo.cairo_arc(eventData, 224.4, 136.72, 30, 1.166667*Pi, 1.6777777*Pi);
                            Cairo.cairo_stroke(eventData);


                            //移动画笔点   画笔默认位置不是在（0,0）move_to不可少
                            Cairo.cairo_move_to(eventData, 180, 120);
                        //画一条线七点
                            Cairo.cairo_line_to(eventData, 180, 90);
                            Cairo.cairo_stroke(eventData);
                    }
            }, null);


    }

    public static void createDrawLaughFace(int window,int gridHouse,int start,final int circlePoint) 
    {
            //创建画图板 或者叫画布
            int  dan  = GTK.gtk_drawing_area_new();
            int label = GTK.gtk_label_new(&amp;quot;笑脸&amp;quot;);
            //创建源
            //添加控件
            GTK.gtk_grid_attach(gridHouse, label, 0, start, 1, 1);
            GTK.gtk_grid_attach(gridHouse, dan, 1, start, 1, 1);
            //显示画布
            GTK.gtk_widget_show(dan);
            GTK.gtk_widget_show(label);


            //设置画布的大小
            GTK.gtk_widget_set_size_request(dan, 300, 300);


            //开始绘制  利用事件draw 来不断的绘制

            GTK.g_signal_connect(dan, &amp;quot;draw&amp;quot;,new IGCallBack() 
            {
                    @Override
                    public void execute(int instance, int eventData, Object object)
                    {
                            // TODO 自动生成的方法存根
                            //eventDate才是画布源
                            //设置画笔的颜色
                            Cairo.cairo_set_source_rgb(eventData, 0.5, 0.6, 0.3);
                            //设置画笔的大小
                            Cairo.cairo_set_line_width(eventData, 3);                        

                            //画一个圆
                            Cairo.cairo_arc(eventData, circlePoint, circlePoint, 60, 0, 2*3.1415926);
                            //画一个圆弧
                            //Cairo.cairo_arc(eventData, 200, 200, 70,1.5*3.1415925, 2*3.1415926);
                            //显示画笔
                            Cairo.cairo_stroke(eventData); //Cairo.cairo_fill(eventData)不同的效果


                            //画一个圆弧  有下面实验知道是从x轴沿顺时针开始画图

                            //嘴巴的绘制
                            double Pi = 3.1415926;
                            Cairo.cairo_arc(eventData, circlePoint, circlePoint, 40, 0.25*Pi, 0.75*Pi);
                            Cairo.cairo_fill(eventData);

                            //绘制两只眼睛
                            Cairo.cairo_arc(eventData, circlePoint-20, circlePoint-20, 10, 0, 2*Pi);
                            Cairo.cairo_arc(eventData, circlePoint+20, circlePoint-20, 10, 0, 2*Pi);
                            Cairo.cairo_fill(eventData);
                    }
            }, null);


    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;case2  三毛头部自画像  加入了文字的绘制
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java
import com.rupeng.gtk4j.Cairo;
import com.rupeng.gtk4j.GTK;
import com.rupeng.gtk4j.IGCallBack;&lt;/p&gt;

&lt;p&gt;/**
*
*/&lt;/p&gt;

&lt;p&gt;/**
* @author 叶昭良
* @version GTKCairoText V1.0
*
*/
public class GTKTestCairoText
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /**
     * @param args
     */
    static int window;
    static int gridHouse;
    public static void main(String[] args)
    {
            // TODO 自动生成的方法存根
            //GTK初始化
            GTK.gtk_init();
            //窗口标识
            window = GTK.gtk_window_new(GTK.GTK_WINDOW_TOPLEVEL);
            //窗口标题
            GTK.gtk_window_set_title(window, &amp;quot;简易画图板v2.0&amp;quot;);
            //显示窗口
            GTK.gtk_widget_show(window);

            GTK.g_signal_connect(window, &amp;quot;destroy&amp;quot;, new IGCallBack()
            {
                    @Override
                    public void execute(int instance, int eventData, Object object)
                    {
                            // TODO 自动生成的方法存根
                            GTK.gtk_main_quit();
                    }
            }, null);


            //设置布局方式
            gridHouse = GTK.gtk_grid_new();


            //创建控件
            int start = 0;
            createDraw(window, gridHouse, start);
            //circlePoint 原点设置为180



            GTK.gtk_widget_show(gridHouse);

            GTK.gtk_container_add(window,gridHouse);
            //启动循环
            GTK.gtk_main();
    }

    public static void createDraw(int window,int gridHouse,int start) 
    {
            //创建画图板 或者叫画布
            int  dan  = GTK.gtk_drawing_area_new();

            int label = GTK.gtk_label_new(&amp;quot;三毛&amp;quot;);
            //创建源
            //添加控件
            GTK.gtk_grid_attach(gridHouse, label, 0, start, 1, 1);
            GTK.gtk_grid_attach(gridHouse, dan, 1, start, 1, 1);
            //显示画布
            GTK.gtk_widget_show(dan);
            GTK.gtk_widget_show(label);

            //设置画布的大小
            GTK.gtk_widget_set_size_request(dan, 300, 300);


            //开始绘制  利用事件draw 来不断的绘制

            GTK.g_signal_connect(dan, &amp;quot;draw&amp;quot;,new IGCallBack() 
            {
                    @Override
                    public void execute(int instance, int eventData, Object object)
                    {
                            // TODO 自动生成的方法存根
                            //eventDate才是画布源
                            //设置画笔的颜色
                            Cairo.cairo_set_source_rgb(eventData, 0.5, 0.6, 0.3);
                            //设置画笔的大小
                            Cairo.cairo_set_line_width(eventData, 3);



                            //移动画笔点   画笔默认位置不是在（0,0）move_to不可少
                            //Cairo.cairo_move_to(eventData, 0, 0);

                            //画一个圆
                            Cairo.cairo_arc(eventData, 180, 180, 60, 0, 2*3.1415926);
                            //画一个圆弧
                            //Cairo.cairo_arc(eventData, 200, 200, 70,1.5*3.1415925, 2*3.1415926);
                            //显示画笔
                            Cairo.cairo_stroke(eventData); //Cairo.cairo_fill(eventData)不同的效果


                            //画一个圆弧  有下面实验知道是从x轴沿顺时针开始画图

                            //嘴巴的绘制
                            double Pi = 3.1415926;
                            Cairo.cairo_arc(eventData, 180, 180, 40, 0.25*Pi, 0.75*Pi);
                            Cairo.cairo_fill(eventData);

                            //绘制两只眼睛
                            Cairo.cairo_arc(eventData, 160, 160, 10, 0, 2*Pi);
                            Cairo.cairo_arc(eventData, 200, 160, 10, 0, 2*Pi);
                            Cairo.cairo_fill(eventData);


                            //绘制胡须
                            Cairo.cairo_arc(eventData, 130, 160, 50, 0.166667*Pi, 0.6777777*Pi);

                            Cairo.cairo_stroke(eventData);

                            Cairo.cairo_arc(eventData, 230, 160, 50, 0.333333*Pi, 0.8333333*Pi);
                            Cairo.cairo_stroke(eventData);

                            //绘制头发
                            Cairo.cairo_arc(eventData, 133.6, 136.72, 30,1.3333333*Pi ,1.833333*Pi );

                            Cairo.cairo_stroke(eventData);

                            Cairo.cairo_arc(eventData, 224.4, 136.72, 30, 1.166667*Pi, 1.6777777*Pi);
                            Cairo.cairo_stroke(eventData);


                            //移动画笔点   画笔默认位置不是在（0,0）move_to不可少
                            Cairo.cairo_move_to(eventData, 180, 120);
                        //画一条线七点
                            Cairo.cairo_line_to(eventData, 180, 90);
                            Cairo.cairo_stroke(eventData);


                            //画文字
                            Cairo.cairo_move_to(eventData, 180, 260);
                            Cairo.cairo_set_source_rgb(eventData, 0.4, 0.3, 0.2);
                            Cairo.cairo_set_font_size(eventData, 16);
                            //选择文字类型
                            Cairo.cairo_select_font_face(eventData, &amp;quot;宋体&amp;quot;, Cairo.CAIRO_FONT_SLANT_ITALIC, Cairo.CAIRO_FONT_WEIGHT_BOLD);
                            Cairo.cairo_show_text(eventData,&amp;quot;三毛的自画像&amp;quot;);
                            //Cairo.cairo_stroke(eventData);  //不需要这句话也可以
                    }
            }, null);


    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;case3  折线图  复习了数组  + 对称折线

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java
/**
* @author    叶昭良
* @time      2015年2月1日上午11:30:12
* @version   TestLine V1.0
*/
import com.rupeng.gtk4j.GTK;
import com.rupeng.gtk4j.IGCallBack;
import com.rupeng.gtk4j.Cairo;&lt;/p&gt;

&lt;p&gt;public class TestLine
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /**
     * @param args
     */
    static int window;
    static int gridHouse;
    static int scrolledBar;
    public static void main(String[] args)
    {
            // TODO 自动生成的方法存根
            //初始化
            GTK.gtk_init();
            window = GTK.gtk_window_new(GTK.GTK_WINDOW_TOPLEVEL);
            //添加窗口
            GTK.gtk_widget_show(window);
            //安静关闭
            GTK.g_signal_connect(window, &amp;quot;destroy&amp;quot;, new IGCallBack()
            {
                    @Override
                    public void execute(int instance, int eventData, Object object)
                    {
                            // TODO 自动生成的方法存根
                            GTK.gtk_main_quit();
                    }
            }, null);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;/*                //创建布局：
                gridHouse = GTK.gtk_grid_new();*/&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;            int drawArea = GTK.gtk_drawing_area_new();
            GTK.gtk_widget_set_size_request(drawArea, 500, 500);
            //GTK.gtk_container_add(window, gridHouse);
            GTK.gtk_container_add(window, drawArea);
            GTK.g_signal_connect(drawArea, &amp;quot;draw&amp;quot;, new IGCallBack()
            {

                    @Override
                    public void execute(int instance, int eventData, Object object)
                    {
                            // TODO 自动生成的方法存根
                            Cairo.cairo_move_to(eventData, 0, 500);
                            int[] arrApple = {50, 90, 80, 120, 10, 50};

                            // 获取最大值
                            int max = arrApple[0];
                            for(int i = 1; i &amp;lt; arrApple.length; i++)
                            {
                                    if(max &amp;lt; arrApple[i])
                                    {
                                            max = arrApple[i];
                                    }
                            }
                            // 
                            for(int i = 0; i&amp;lt;  arrApple.length; i++)
                            {
                                    // 获取坐标(x,y)
                                    int  x =  (i+1)*50;
                                    int  y =  500 - 500*arrApple[i]/max;
                                    // 绘制坐标点
                                    Cairo.cairo_line_to(eventData, x, y);
                            }
                            // 创建绘画
                            Cairo.cairo_stroke(eventData);
                    }

            }, null);
             createDraw( window, drawArea, gridHouse,0);
            GTK.gtk_widget_show(drawArea);
            //添加循环
            GTK.gtk_main();
    }

    public static void createDraw(int window, int drawArea,int gridHouse,int start)
    {
            GTK.g_signal_connect(drawArea, &amp;quot;draw&amp;quot;, new IGCallBack()
            {

                    @Override
                    public void execute(int instance, int eventData, Object object)
                    {
                            // TODO 自动生成的方法存根
                            Cairo.cairo_move_to(eventData, 0, 0);
                            int[] arrApple = {50, 90, 80, 120, 10, 50};

                            // 获取最大值
                            int max = arrApple[0];
                            for(int i = 1; i &amp;lt; arrApple.length; i++)
                            {
                                    if(max &amp;lt; arrApple[i])
                                    {
                                            max = arrApple[i];
                                    }
                            }
                            // 
                            for(int i = 0; i&amp;lt;  arrApple.length; i++)
                            {
                                    // 获取坐标(x,y)
                                    int  x =  (i+1)*50;
                                    //int  y =  300 - 300*arrApple[i]/max;
                                    int  y =  500*arrApple[i]/max;
                                    // 绘制坐标点
                                    Cairo.cairo_line_to(eventData, x, y);
                            }
                            // 创建绘画
                            Cairo.cairo_stroke(eventData);
                    }

            }, null);
            //createScrolledBar(window,drawArea,scrolledBar,start);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;/*         //滚动条无法用于drawArea
        public static void createScrolledBar(int window,int drawArea,int scrolledBar,int start)
        {
                scrolledBar = GTK.gtk_scrolled_window_new();
                GTK.gtk_widget_set_size_request(scrolledBar, 300, 100);
                GTK.gtk_widget_show(scrolledBar);
                GTK.gtk_container_add(scrolledBar,drawArea);
                GTK.gtk_grid_attach(gridHouse, scrolledBar, 0, start, 1, 1);&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    }*/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
```
&lt;img src=&#34;https://jueqingsizhe66.github.io/images/java/sanmao.gif&#34; alt=&#34;三毛的自画像&#34; /&gt;
&lt;img src=&#34;https://jueqingsizhe66.github.io/images/java/jianyi.gif&#34; alt=&#34;三毛+笑脸&#34; /&gt;
&lt;img src=&#34;https://jueqingsizhe66.github.io/images/java/ButtonImage.gif&#34; alt=&#34;图片按钮&#34; /&gt;
&lt;img src=&#34;https://jueqingsizhe66.github.io/images/java/calc2.gif&#34; alt=&#34;计算器v2.0 使用spinbox&#34; /&gt;
&lt;img src=&#34;https://jueqingsizhe66.github.io/images/java/spinbox1.gif&#34; alt=&#34;spinbox的数字范围&#34; /&gt;
&lt;img src=&#34;https://jueqingsizhe66.github.io/images/java/nvshen2.gif&#34; alt=&#34;女神告白神器2 加入了迭代插入&#34; /&gt;
&lt;img src=&#34;https://jueqingsizhe66.github.io/images/java/nvshen.gif&#34; alt=&#34;女神告白神奇 TextView的初次使用&#34; /&gt;
&lt;img src=&#34;https://jueqingsizhe66.github.io/images/java/shuiguo.gif&#34; alt=&#34;水果购买选择器&#34; /&gt;
&lt;img src=&#34;https://jueqingsizhe66.github.io/images/java/province.gif&#34; alt=&#34;省市联动器&#34; /&gt;
&lt;img src=&#34;https://jueqingsizhe66.github.io/images/java/huizhide.png&#34; alt=&#34;笑脸的绘制测量&#34; /&gt;
&lt;img src=&#34;https://jueqingsizhe66.github.io/images/java/symmetry.gif&#34; alt=&#34;对称折线图&#34; /&gt;&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
