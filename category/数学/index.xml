<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>数学 | 30年磨一剑</title>
    <link>https://jueqingsizhe66.github.io/category/%E6%95%B0%E5%AD%A6/</link>
      <atom:link href="https://jueqingsizhe66.github.io/category/%E6%95%B0%E5%AD%A6/index.xml" rel="self" type="application/rss+xml" />
    <description>数学</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><copyright>©2022</copyright><lastBuildDate>Thu, 29 Sep 2016 03:27:34 +0800</lastBuildDate>
    <image>
      <url>https://jueqingsizhe66.github.io/media/icon_hua2ec155b4296a9c9791d015323e16eb5_11927_512x512_fill_lanczos_center_3.png</url>
      <title>数学</title>
      <link>https://jueqingsizhe66.github.io/category/%E6%95%B0%E5%AD%A6/</link>
    </image>
    
    <item>
      <title>Physics and Maths</title>
      <link>https://jueqingsizhe66.github.io/archives/physics-and-maths/</link>
      <pubDate>Thu, 29 Sep 2016 03:27:34 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/archives/physics-and-maths/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://baike.baidu.com/link?url=EAjClF31Nh45czy0-8dYscX-hkcI8qOxCzsmWWiXN6yDdhQh18-Avf_UAiwFBNk9F3vKh0dKTSBzitXzqYgmvn6w5e9hwmZ5_yvYP7g9ARnJbDG8vH9jEkSDwL7y8rIK&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;濮祖荫&lt;/a&gt;(歌手朴树的父亲):&amp;ldquo;数学背后有物理，物理需要通过数学来表达&amp;rdquo;。数学方程(表达式)需要你通过物理直觉去思考，去书写。&lt;/p&gt;
&lt;p&gt;濮说做研究的过程都是提出一个模型，找到问题的本质，针对围绕本质的几个变量进行研究，来近似替代现实的复杂模型（这个简化的思想对我有帮助）&lt;/p&gt;
&lt;p&gt;Only some links for physics and maths,&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://product.dangdang.com/22704132.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;数学物理方程 张鲁明&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://zhidao.baidu.com/share/ffccde3e883cc1bfe96567f02492e004.html%e3%80%80&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;数学物理方程 复旦&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://vdisk.weibo.com/s/uGXsmIpCxv5Ow&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;数学物理 微盘丛书&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://wenku.baidu.com/link?url=zGOuK59qswS4oDW1W9aqndBgisaitwkHxeix_5_O7Elp3rBH3pidQd1V8KEubrCXeuE8p0Aw_P-FbfOK2stL3uraiUOoZiUCIcBHKUpLeHq&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;空间物理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://v.youku.com/v_show/id_XNzYwMDgyNjg=.html?spm=a2h0j.8191423.module_basic_relation.5~5!2~5~5!8~5!2~1~3~A&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;梁灿彬老师的微分流形和相对论&lt;/a&gt;, &amp;ldquo;以不变应万变，找出不变量(心领神会学科技术的不变量)，从而应问题领域中变化的东西,抓住不变的东西，反复琢磨(为什么还要反复琢磨)&amp;rdquo;. &amp;ldquo;相似矩阵的trace迹不变(矩阵对角元不变)&amp;rdquo;
也就是需要通过不变的东西把所有变化的独立体（关系）都连接起来，形成一条链。&lt;/p&gt;
&lt;p&gt;学任何东西，都得首先明确他的重点和意义（当然首先得基于你得有大局观，大的方向，大的框架 也就是不变的东西）。&lt;/p&gt;
&lt;p&gt;从数学物理过程去解释现实中的现象，从大的误差逐步缩小他，直到能够清楚的解释现实中的现象，从理论上去解释实际的问题，也就是梁灿彬老师说的
天地连通(天:定义特别清楚地(并矢:张量积运算, ) 地:实际(现实)发生的现象,不清晰的，定义不明(并矢:两个矢量并排在一起,他是一个二阶张量,9个分量v1u1 v1u2 v1u3 v2u1 v2u2 v2u3 v3u1 v3u2 v3u3 列举出来)。 也就是说不清晰的版本肯定能够存在清晰的版本)。&lt;/p&gt;
&lt;p&gt;更要紧的是，还得考虑&lt;a href=&#34;http://jueqingsizhe66.github.io/blog/2016/09/28/jump-out-of-ontology/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;物理之内和物理之外&lt;/a&gt;的问题&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>TurbSim 8个湍流模型的对比</title>
      <link>https://jueqingsizhe66.github.io/archives/turbsim-8ge-tuan-liu-mo-xing-de-dui-bi/</link>
      <pubDate>Mon, 10 Aug 2015 01:00:47 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/archives/turbsim-8ge-tuan-liu-mo-xing-de-dui-bi/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://nwtc.nrel.gov/TurbSim&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;TurbSim&lt;/a&gt;,是NREL提供的一个小的开源工具， 用于产生湍流风，设置的时候可能对于不同模型会有不同的参数，基于范本进行了一番分析。当然测试文件在TurbSim的Test文件下的inp文件夹下。&lt;/p&gt;
&lt;p&gt;如果对那些湍流模型做一个对比，那样是否可以更加清晰的看出不同呢？
于是就有了下面的shell分析脚本。&lt;/p&gt;
&lt;p&gt;TurbSim产生的风力机一圈的入流截面模型（仅仅一个截面，全场是因为捕捉了很多个截面）&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://jueqingsizhe66.github.io/images/fast/turbsim.png&#34; alt=&#34;Turbsim&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;shell解析脚本&#34;&gt;Shell解析脚本&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#!/bin/bash - 
#===============================================================================
#
#          FILE: a.sh
# 
#         USAGE: ./a.sh 
# 
#   DESCRIPTION: 
# 
#       OPTIONS: ---
#  REQUIREMENTS: ---
#          BUGS: ---
#         NOTES: ---
#        AUTHOR: Ye Zhaoliang (), zhaoturkkey@163.com
#  ORGANIZATION: YZL
#       CREATED: 2015年08月10日 00:26
#      REVISION:  ---
#===============================================================================

#---  FUNCTION  ----------------------------------------------------------------
#          NAME:  _repeat1
#   DESCRIPTION:  优化版本
#    PARAMETERS:  
#       RETURNS:  
#-------------------------------------------------------------------------------
_repeat1()
{
    #@ 使用方式： _repeat 要重复的字符串  重复次数
    #@  Usage : _repeat string number
    _REPEAT1=$1  #set and not empty, or unlimit recycle
    while [[ ${#_REPEAT1} -lt $2 ]]
    do
        _REPEAT1=$_REPEAT1$_REPEAT1$_REPEAT1 ## 3次优化
    done
    _REPEAT1=${_REPEAT1:0:$2} ##Trim到我们需要的长度
}

alert() #@ Description    产生一个方框的注释
{       #@ Usage    alert &amp;quot;话语&amp;quot;
    _repeat1 &amp;quot;${2:-#}&amp;quot; $(( ${#1} + 8 )) ## ${2:-#} 如果$2未定义则使用#
    printf &#39;%s\n&#39; &amp;quot;$_REPEAT1&amp;quot; ## \a=BEL
    printf &#39;%2.2s %s %2.2s\n&#39; &amp;quot;$_REPEAT1&amp;quot; &amp;quot;$1&amp;quot; &amp;quot;$_REPEAT1&amp;quot; ## \a=BEL
    printf &#39;%s\n&#39; &amp;quot;$_REPEAT1&amp;quot;
}


#alert &amp;quot;Do you really want to delete all the files?&amp;quot;


## RandSeed1 在不同湍流模型配置的不同
{
alert  &amp;quot;RandSeed1&amp;quot; 
grep -n &amp;quot;RandSeed1&amp;quot; *.inp|awk -F: &#39;{print $1,$3}&#39;|awk &#39;{print substr($1,0,length($1)-4),&amp;quot;\t\t&amp;quot;,$2}&#39;|column -t
alert  &amp;quot;RandSeed2&amp;quot; 
grep -n &amp;quot;RandSeed2&amp;quot; *.inp|awk -F: &#39;{print $1,$3}&#39;|awk &#39;{print substr($1,0,length($1)-4),&amp;quot;\t\t&amp;quot;,$2}&#39;|column -t
alert  &amp;quot;WrBHHTP&amp;quot; 
grep -n &amp;quot;WrBHHTP&amp;quot; *.inp|awk -F: &#39;{print $1,$3}&#39;|awk &#39;{print substr($1,0,length($1)-4),&amp;quot;\t\t&amp;quot;,$2}&#39;|column -t
alert  &amp;quot;WrFHHTP&amp;quot; 
grep -n &amp;quot;WrFHHTP&amp;quot; *.inp|awk -F: &#39;{print $1,$3}&#39;|awk &#39;{print substr($1,0,length($1)-4),&amp;quot;\t\t&amp;quot;,$2}&#39;|column -t
alert  &amp;quot;WrADHH&amp;quot; 
grep -n &amp;quot;WrADHH&amp;quot; *.inp|awk -F: &#39;{print $1,$3}&#39;|awk &#39;{print substr($1,0,length($1)-4),&amp;quot;\t\t&amp;quot;,$2}&#39;|column -t
alert  &amp;quot;WrADFF&amp;quot; 
grep -n &amp;quot;WrADFF&amp;quot; *.inp|awk -F: &#39;{print $1,$3}&#39;|awk &#39;{print substr($1,0,length($1)-4),&amp;quot;\t\t&amp;quot;,$2}&#39;|column -t
alert  &amp;quot;WrBLFF&amp;quot; 
grep -n &amp;quot;WrBLFF&amp;quot; *.inp|awk -F: &#39;{print $1,$3}&#39;|awk &#39;{print substr($1,0,length($1)-4),&amp;quot;\t\t&amp;quot;,$2}&#39;|column -t
alert  &amp;quot;WrADTWR&amp;quot; 
grep -n &amp;quot;WrADTWR&amp;quot; *.inp|awk -F: &#39;{print $1,$3}&#39;|awk &#39;{print substr($1,0,length($1)-4),&amp;quot;\t\t&amp;quot;,$2}&#39;|column -t
alert  &amp;quot;WrFMTFF&amp;quot; 
grep -n &amp;quot;WrFMTFF&amp;quot; *.inp|awk -F: &#39;{print $1,$3}&#39;|awk &#39;{print substr($1,0,length($1)-4),&amp;quot;\t\t&amp;quot;,$2}&#39;|column -t
alert  &amp;quot;WrACT&amp;quot; 
grep -n &amp;quot;WrACT&amp;quot; *.inp|awk -F: &#39;{print $1,$3}&#39;|awk &#39;{print substr($1,0,length($1)-4),&amp;quot;\t\t&amp;quot;,$2}&#39;|column -t
alert  &amp;quot;NumGrid_Z&amp;quot; 
grep -n &amp;quot;NumGrid_Z&amp;quot; *.inp|awk -F: &#39;{print $1,$3}&#39;|awk &#39;{print substr($1,0,length($1)-4),&amp;quot;\t\t&amp;quot;,$2}&#39;|column -t
alert  &amp;quot;NumGrid_Y&amp;quot; 
grep -n &amp;quot;NumGrid_Y&amp;quot; *.inp|awk -F: &#39;{print $1,$3}&#39;|awk &#39;{print substr($1,0,length($1)-4),&amp;quot;\t\t&amp;quot;,$2}&#39;|column -t
alert  &amp;quot;HubHt&amp;quot; 
grep -n &amp;quot;HubHt&amp;quot; *.inp|awk -F: &#39;{print $1,$3}&#39;|awk &#39;{print substr($1,0,length($1)-4),&amp;quot;\t\t&amp;quot;,$2}&#39;|column -t
alert  &amp;quot;GridHeight&amp;quot; 
grep -n &amp;quot;GridHeight&amp;quot; *.inp|awk -F: &#39;{print $1,$3}&#39;|sed &#39;/HubHt/d&#39;|awk &#39;{print substr($1,0,length($1)-4),&amp;quot;\t\t&amp;quot;,$2}&#39;|column -t
alert  &amp;quot;GridWidth&amp;quot; 
grep -n &amp;quot;GridWidth&amp;quot; *.inp|awk -F: &#39;{print $1,$3}&#39;|sed &#39;/HubHt/d&#39;|awk &#39;{print substr($1,0,length($1)-4),&amp;quot;\t\t&amp;quot;,$2}&#39;|column -t
alert  &amp;quot;VFlowAng&amp;quot; 
grep -n &amp;quot;VFlowAng&amp;quot; *.inp|awk -F: &#39;{print $1,$3}&#39;|awk &#39;{print substr($1,0,length($1)-4),&amp;quot;\t\t&amp;quot;,$2}&#39;|column -t
alert  &amp;quot;HFlowAng&amp;quot; 
grep -n &amp;quot;HFlowAng&amp;quot; *.inp|awk -F: &#39;{print $1,$3}&#39;|awk &#39;{print substr($1,0,length($1)-4),&amp;quot;\t\t&amp;quot;,$2}&#39;|column -t
alert  &amp;quot;TurbModel&amp;quot; 
grep -n &amp;quot;TurbModel&amp;quot; *.inp|awk -F: &#39;{print $1,$3}&#39;|awk &#39;{print substr($1,0,length($1)-4),&amp;quot;\t\t&amp;quot;,$2}&#39;|column -t
alert  &amp;quot;IECstandard&amp;quot; 
grep -n &amp;quot;IECstandard&amp;quot; *.inp|awk -F: &#39;{print $1,$3}&#39;|awk &#39;{print substr($1,0,length($1)-4),&amp;quot;\t\t&amp;quot;,$2}&#39;|column -t
alert  &amp;quot;IECturbc&amp;quot; 
grep -n &amp;quot;IECturbc&amp;quot; *.inp|awk -F: &#39;{print $1,$3}&#39;|awk &#39;{print substr($1,0,length($1)-4),&amp;quot;\t\t&amp;quot;,$2}&#39;|column -t
alert  &amp;quot;IEC_WindType&amp;quot; 
grep -n &amp;quot;IEC_WindType&amp;quot; *.inp|awk -F: &#39;{print $1,$3}&#39;|awk &#39;{print substr($1,0,length($1)-4),&amp;quot;\t\t&amp;quot;,$2}&#39;|column -t
alert  &amp;quot;ETMc&amp;quot; 
grep -n &amp;quot;ETMc&amp;quot; *.inp|awk -F: &#39;{print $1,$3}&#39;|awk &#39;{print substr($1,0,length($1)-4),&amp;quot;\t\t&amp;quot;,$2}&#39;|column -t
alert  &amp;quot;WindProfileType&amp;quot; 
grep -n &amp;quot;WindProfileType&amp;quot; *.inp|awk -F: &#39;{print $1,$3}&#39;|awk &#39;{print substr($1,0,length($1)-4),&amp;quot;\t\t&amp;quot;,$2}&#39;|column -t
alert  &amp;quot;RefHt&amp;quot; 
grep -n &amp;quot;RefHt&amp;quot; *.inp|awk -F: &#39;{print $1,$3}&#39;|awk &#39;{print substr($1,0,length($1)-4),&amp;quot;\t\t&amp;quot;,$2}&#39;|column -t
alert  &amp;quot;URef&amp;quot; 
grep -n &amp;quot;URef&amp;quot; *.inp|awk -F: &#39;{print $1,$3}&#39;|awk &#39;{print substr($1,0,length($1)-4),&amp;quot;\t\t&amp;quot;,$2}&#39;|column -t
alert  &amp;quot;ZJetMax&amp;quot; 
grep -n &amp;quot;ZJetMax&amp;quot; *.inp|awk -F: &#39;{print $1,$3}&#39;|awk &#39;{print substr($1,0,length($1)-4),&amp;quot;\t\t&amp;quot;,$2}&#39;|column -t
alert  &amp;quot;PLExp&amp;quot; 
grep -n &amp;quot;PLExp&amp;quot; *.inp|awk -F: &#39;{print $1,$3}&#39;|awk &#39;{print substr($1,0,length($1)-4),&amp;quot;\t\t&amp;quot;,$2}&#39;|column -t
alert  &amp;quot;Z0&amp;quot; 
grep -n &amp;quot;Z0&amp;quot; *.inp|awk -F: &#39;{print $1,$3}&#39;|awk &#39;{print substr($1,0,length($1)-4),&amp;quot;\t\t&amp;quot;,$2}&#39;|column -t
alert  &amp;quot;RICH_NO&amp;quot; 
grep -n &amp;quot;RICH_NO&amp;quot; *.inp|awk -F: &#39;{print $1,$3}&#39;|awk &#39;{print substr($1,0,length($1)-4),&amp;quot;\t\t&amp;quot;,$2}&#39;|column -t
alert  &amp;quot;ZI&amp;quot; 
grep -n &amp;quot;ZI&amp;quot; *.inp|awk -F: &#39;{print $1,$3}&#39;|awk &#39;{print substr($1,0,length($1)-4),&amp;quot;\t\t&amp;quot;,$2}&#39;|column -t
alert  &amp;quot;PC_UW&amp;quot; 
grep -n &amp;quot;PC_UW&amp;quot; *.inp|awk -F: &#39;{print $1,$3}&#39;|awk &#39;{print substr($1,0,length($1)-4),&amp;quot;\t\t&amp;quot;,$2}&#39;|column -t
alert  &amp;quot;PC_UV&amp;quot; 
grep -n &amp;quot;PC_UV&amp;quot; *.inp|awk -F: &#39;{print $1,$3}&#39;|awk &#39;{print substr($1,0,length($1)-4),&amp;quot;\t\t&amp;quot;,$2}&#39;|column -t
alert  &amp;quot;PC_VW&amp;quot; 
grep -n &amp;quot;PC_VW&amp;quot; *.inp|awk -F: &#39;{print $1,$3}&#39;|awk &#39;{print substr($1,0,length($1)-4),&amp;quot;\t\t&amp;quot;,$2}&#39;|column -t
alert  &amp;quot;CohExp&amp;quot; 
grep -n &amp;quot;CohExp&amp;quot; *.inp|awk -F: &#39;{print $1,$3}&#39;|awk &#39;{print substr($1,0,length($1)-4),&amp;quot;\t\t&amp;quot;,$2}&#39;|column -t
alert  &amp;quot;CTEventPath&amp;quot; 
grep -n &amp;quot;CTEventPath&amp;quot; *.inp|awk -F: &#39;{print $1,$3}&#39;|awk &#39;{print substr($1,0,length($1)-4),&amp;quot;\t\t&amp;quot;,$2}&#39;|column -t
alert  &amp;quot;CTEventFile&amp;quot; 
grep -n &amp;quot;CTEventFile&amp;quot; *.inp|awk -F: &#39;{print $1,$3}&#39;|awk &#39;{print substr($1,0,length($1)-4),&amp;quot;\t\t&amp;quot;,$2}&#39;|column -t
alert  &amp;quot;Randomize&amp;quot; 
grep -n &amp;quot;Randomize&amp;quot; *.inp|awk -F: &#39;{print $1,$3}&#39;|awk &#39;{print substr($1,0,length($1)-4),&amp;quot;\t\t&amp;quot;,$2}&#39;|column -t
alert  &amp;quot;DistScl&amp;quot; 
grep -n &amp;quot;DistScl&amp;quot; *.inp|awk -F: &#39;{print $1,$3}&#39;|awk &#39;{print substr($1,0,length($1)-4),&amp;quot;\t\t&amp;quot;,$2}&#39;|column -t
alert  &amp;quot;CTLy&amp;quot; 
grep -n &amp;quot;CTLy&amp;quot; *.inp|awk -F: &#39;{print $1,$3}&#39;|awk &#39;{print substr($1,0,length($1)-4),&amp;quot;\t\t&amp;quot;,$2}&#39;|column -t
alert  &amp;quot;CTLz&amp;quot; 
grep -n &amp;quot;CTLz&amp;quot; *.inp|awk -F: &#39;{print $1,$3}&#39;|awk &#39;{print substr($1,0,length($1)-4),&amp;quot;\t\t&amp;quot;,$2}&#39;|column -t
alert  &amp;quot;CTStartTime&amp;quot; 
grep -n &amp;quot;CTStartTime&amp;quot; *.inp|awk -F: &#39;{print $1,$3}&#39;|awk &#39;{print substr($1,0,length($1)-4),&amp;quot;\t\t&amp;quot;,$2}&#39;|column -t
} &amp;gt; summary.out

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;改进&#34;&gt;改进&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;去除无用的Turbulence and Boundary&lt;/li&gt;
&lt;li&gt;增加了对GridWidth and GridHeight的处理&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;grep -n &amp;quot;GridHeight&amp;quot; *.inp|awk -F: &#39;{print $1,$3}&#39;|sed &#39;/HubHt/d&#39;|awk &#39;{print substr($1,0,length($1)-4),&amp;quot;\t\t&amp;quot;,$2}&#39;|column -t
grep -n &amp;quot;GridWidth&amp;quot; *.inp|awk -F: &#39;{print $1,$3}&#39;|sed &#39;/HubHt/d&#39;|awk &#39;{print substr($1,0,length($1)-4),&amp;quot;\t\t&amp;quot;,$2}&#39;|column -t

&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;shell产生的结果如下&#34;&gt;shell产生的结果如下：&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#################
## RandSeed1 ##
#################
GPLLJ        234516
HYDRO_TIDAL  2318573
Kaimal_15    123456
Kaimal       123456
KHtest       123456
smooth       4433456
vonKarm_15   123456
vonKarm      123456
#################
## RandSeed2 ##
#################
GPLLJ        789012
HYDRO_TIDAL  RANLUX
Kaimal_15    789012
Kaimal       789012
KHtest       &amp;quot;RanLux&amp;quot;
smooth       &amp;quot;RanLux&amp;quot;
vonKarm_15   789012
vonKarm      789012
###############
## WrBHHTP ##
###############
GPLLJ        False
HYDRO_TIDAL  False
Kaimal_15    False
Kaimal       False
KHtest       False
smooth       True
vonKarm_15   False
vonKarm      False
###############
## WrFHHTP ##
###############
GPLLJ        True
HYDRO_TIDAL  True
Kaimal_15    False
Kaimal       False
KHtest       False
smooth       False
vonKarm_15   True
vonKarm      True
##############
## WrADHH ##
##############
GPLLJ        False
HYDRO_TIDAL  True
Kaimal_15    False
Kaimal       False
KHtest       False
smooth       False
vonKarm_15   True
vonKarm      True
##############
## WrADFF ##
##############
GPLLJ        True
HYDRO_TIDAL  False
Kaimal_15    False
Kaimal       False
KHtest       False
smooth       False
vonKarm_15   False
vonKarm      False
##############
## WrBLFF ##
##############
GPLLJ        False
HYDRO_TIDAL  True
Kaimal_15    False
Kaimal       False
KHtest       True
smooth       True
vonKarm_15   False
vonKarm      False
###############
## WrADTWR ##
###############
GPLLJ        False
HYDRO_TIDAL  False
Kaimal_15    False
Kaimal       False
KHtest       False
smooth       False
vonKarm_15   False
vonKarm      False
###############
## WrFMTFF ##
###############
GPLLJ        False
HYDRO_TIDAL  False
Kaimal_15    True
Kaimal       True
KHtest       False
smooth       False
vonKarm_15   False
vonKarm      False
#############
## WrACT ##
#############
GPLLJ        True
HYDRO_TIDAL  False
Kaimal_15    False
Kaimal       False
KHtest       True
smooth       True
vonKarm_15   False
vonKarm      False
#################
## NumGrid_Z ##
#################
GPLLJ        5
HYDRO_TIDAL  5
Kaimal_15    5
Kaimal       5
KHtest       5
smooth       5
vonKarm_15   5
vonKarm      5
#################
## NumGrid_Y ##
#################
GPLLJ        5
HYDRO_TIDAL  5
Kaimal_15    5
Kaimal       5
KHtest       5
smooth       5
vonKarm_15   5
vonKarm      5
#############
## HubHt ##
#############
GPLLJ        90.00
HYDRO_TIDAL  10
Kaimal_15    37.00
Kaimal       37.00
KHtest       37.00
smooth       84.00
vonKarm_15   37.00
vonKarm      37.00
##################
## GridHeight ##
##################
GPLLJ        80.00
HYDRO_TIDAL  9.00
Kaimal_15    30.00
Kaimal       30.00
KHtest       50.00
smooth       70.00
vonKarm_15   30.00
vonKarm      30.00
#################
## GridWidth ##
#################
GPLLJ        600.0
GPLLJ        90.0
GPLLJ        80.00
HYDRO_TIDAL  600
HYDRO_TIDAL  40
HYDRO_TIDAL  9.00
Kaimal_15    600.0
Kaimal_15    55.8
Kaimal_15    30.00
Kaimal       600.0
Kaimal       55.8
Kaimal       30.00
KHtest       600.0
KHtest       100.0
KHtest       50.00
smooth       600.0
smooth       100.0
smooth       70.00
vonKarm_15   600.0
vonKarm_15   55.8
vonKarm_15   30.00
vonKarm      600.0
vonKarm      55.8
vonKarm      30.00
################
## VFlowAng ##
################
GPLLJ        0
HYDRO_TIDAL  0
Kaimal_15    5
Kaimal       5
KHtest       0
smooth       0
vonKarm_15   5
vonKarm      0
################
## HFlowAng ##
################
GPLLJ        0
HYDRO_TIDAL  0
Kaimal_15    10
Kaimal       10
KHtest       0
smooth       0
vonKarm_15   10
vonKarm      0
#################
## TurbModel ##
#################
GPLLJ        &amp;quot;GP_LLJ&amp;quot;
HYDRO_TIDAL  &amp;quot;TIDAL&amp;quot;
Kaimal_15    &amp;quot;IECKAI&amp;quot;
Kaimal       &amp;quot;IECKAI&amp;quot;
KHtest       &amp;quot;NWTCUP&amp;quot;
smooth       &amp;quot;SMOOTH&amp;quot;
vonKarm_15   &amp;quot;IECVKM&amp;quot;
vonKarm      &amp;quot;IECVKM&amp;quot;
###################
## IECstandard ##
###################
GPLLJ        1
HYDRO_TIDAL  &amp;quot;1-ED3&amp;quot;
Kaimal_15    &amp;quot;1-ED2&amp;quot;
Kaimal       1
KHtest       1
smooth       1
vonKarm_15   1
vonKarm      1
################
## IECturbc ##
################
GPLLJ        &amp;quot;A&amp;quot;
HYDRO_TIDAL  &amp;quot;A&amp;quot;
Kaimal_15    &amp;quot;18.0&amp;quot;
Kaimal       &amp;quot;C&amp;quot;
KHtest       &amp;quot;KHtest&amp;quot;
smooth       &amp;quot;A&amp;quot;
vonKarm_15   16.0
vonKarm      &amp;quot;A&amp;quot;
####################
## IEC_WindType ##
####################
GPLLJ        NTM
HYDRO_TIDAL  &amp;quot;NTM&amp;quot;
Kaimal_15    NTM
Kaimal       NTM
KHtest       NTM
smooth       NTM
vonKarm_15   NTM
vonKarm      NTM
############
## ETMc ##
############
GPLLJ        default
HYDRO_TIDAL  default
Kaimal_15    default
Kaimal       default
KHtest       default
smooth       default
vonKarm_15   default
vonKarm      default
#######################
## WindProfileType ##
#######################
GPLLJ        default
HYDRO_TIDAL  &amp;quot;H2L&amp;quot;
Kaimal_15    default
Kaimal       default
KHtest       default
smooth       default
vonKarm_15   default
vonKarm      default
#############
## RefHt ##
#############
GPLLJ        85.00
HYDRO_TIDAL  18
Kaimal_15    10.00
Kaimal       10.00
KHtest       37.00
smooth       84.00
vonKarm_15   10.00
vonKarm      10.00
############
## URef ##
############
GPLLJ        12.0
HYDRO_TIDAL  18
HYDRO_TIDAL  1.2
Kaimal_15    15.0
Kaimal       6.0
KHtest       13.0
smooth       17.0
vonKarm_15   15.0
vonKarm      6.0
###############
## ZJetMax ##
###############
GPLLJ        350
HYDRO_TIDAL  default
Kaimal_15    350
Kaimal       350
KHtest       350
smooth       350
vonKarm_15   350
vonKarm      260
#############
## PLExp ##
#############
GPLLJ        default
HYDRO_TIDAL  default
Kaimal_15    default
Kaimal       default
KHtest       default
smooth       1.527
vonKarm_15   default
vonKarm      default
##########
## Z0 ##
##########
GPLLJ        default
HYDRO_TIDAL  default
Kaimal_15    default
Kaimal       default
KHtest       default
smooth       default
vonKarm_15   default
vonKarm      default
###############
## RICH_NO ##
###############
GPLLJ        0.05
HYDRO_TIDAL  0.05
Kaimal_15    0.05
Kaimal       0.05
KHtest       0.02
smooth       0.05
vonKarm_15   0.05
vonKarm      0.05
##########
## ZI ##
##########
GPLLJ        default
HYDRO_TIDAL  default
Kaimal_15    default
Kaimal       default
KHtest       default
smooth       default
vonKarm_15   default
vonKarm      default
#############
## PC_UW ##
#############
GPLLJ        default
HYDRO_TIDAL  default
Kaimal_15    default
Kaimal       default
KHtest       default
smooth       default
vonKarm_15   default
vonKarm      default
#############
## PC_UV ##
#############
GPLLJ        default
HYDRO_TIDAL  default
Kaimal_15    default
Kaimal       default
KHtest       default
smooth       default
vonKarm_15   default
vonKarm      default
#############
## PC_VW ##
#############
GPLLJ        default
HYDRO_TIDAL  default
Kaimal_15    default
Kaimal       default
KHtest       default
smooth       default
vonKarm_15   default
vonKarm      default
##############
## CohExp ##
##############
GPLLJ        default
HYDRO_TIDAL  default
Kaimal_15    default
Kaimal       default
KHtest       default
smooth       default
vonKarm_15   default
vonKarm      default
###################
## CTEventPath ##
###################
GPLLJ        &amp;quot;.\EventData&amp;quot;
HYDRO_TIDAL  &amp;quot;/home/lkilcher/work/nwtc/turbsim/trunk/Test/EventData/&amp;quot;
Kaimal_15    &amp;quot;.\EventData&amp;quot;
Kaimal       &amp;quot;.\EventData&amp;quot;
KHtest       &amp;quot;.\EventData&amp;quot;
smooth       &amp;quot;.\EventData&amp;quot;
vonKarm_15   &amp;quot;.\EventData&amp;quot;
vonKarm      &amp;quot;.\EventData&amp;quot;
###################
## CTEventFile ##
###################
GPLLJ        LES
HYDRO_TIDAL  &amp;quot;Random&amp;quot;
Kaimal_15    random
Kaimal       random
KHtest       &amp;quot;les&amp;quot;
smooth       &amp;quot;les&amp;quot;
vonKarm_15   random
vonKarm      random
#################
## Randomize ##
#################
GPLLJ        true
HYDRO_TIDAL  true
HYDRO_TIDAL  1.0
HYDRO_TIDAL  0.5
HYDRO_TIDAL  0.5
Kaimal_15    true
Kaimal       true
KHtest       true
smooth       true
vonKarm_15   true
vonKarm      true
###############
## DistScl ##
###############
GPLLJ        1.0
HYDRO_TIDAL  1.0
Kaimal_15    1.0
Kaimal       1.0
KHtest       1.0
smooth       1.0
vonKarm_15   1.0
vonKarm      1.0
############
## CTLy ##
############
GPLLJ        0.5
HYDRO_TIDAL  0.5
Kaimal_15    0.5
Kaimal       0.5
KHtest       0.5
smooth       0.5
vonKarm_15   0.5
vonKarm      0.5
############
## CTLz ##
############
GPLLJ        0.5
HYDRO_TIDAL  0.5
Kaimal_15    0.5
Kaimal       0.5
KHtest       0.5
smooth       0.5
vonKarm_15   0.5
vonKarm      0.5
###################
## CTStartTime ##
###################
GPLLJ        30.0
HYDRO_TIDAL  30.0
Kaimal_15    30.0
Kaimal       30.0
KHtest       0.0
smooth       10.0
vonKarm_15   30.0
vonKarm      30.0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;进一步的细节可以参考&lt;a href=&#34;https://nwtc.nrel.gov/system/files/TurbSim.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Turbsim UserGuide&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Incompact3d的Makefile及DNS算法</title>
      <link>https://jueqingsizhe66.github.io/archives/incompact3dde-makefileji-dnssuan-fa/</link>
      <pubDate>Mon, 22 Jun 2015 16:52:20 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/archives/incompact3dde-makefileji-dnssuan-fa/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://code.google.com/p/incompact3d&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Incompact3d&lt;/a&gt;是一个开源的基于fortran语言编写的DNS求解器，也是我研究生期间使用的开源源代码。
Incompact3d整体框架的介绍可以参考软件的&lt;a href=&#34;https://code.google.com/p/incompact3d/downloads/detail?name=user_guide_incompact3d_V1-1.pdf&amp;amp;can=2&amp;amp;q=&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;user-guide&lt;/a&gt;和文献&lt;a href=&#34;http://www.imperial.ac.uk/media/imperial-college/research-centres-and-groups/turbulence-mixing-and-flow-control-group/2009_LAIZET_JCP.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;High-order-compact schemes for incompressible flows: a simple and effcient method with the quasi-spectral accuary&lt;/a&gt;,还可以搜索&lt;a href=&#34;http://www.imperial.ac.uk/tmfc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;sylvain Laziet&lt;/a&gt; 相关的文章 ，只不过他并不是成熟的软件，很多的编译和后处理都可能出现问题，下面是我使用过程遇到的一些问题。
当然主要过程是，通过makefile编译，然后运行incompact3d，最后处理计算结果。&lt;/p&gt;
&lt;p&gt;#1 如何模拟？&lt;/p&gt;
&lt;p&gt;以周期性槽道流动(当然我也就会这么一种，其他都只是走了一小半）为例。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先是得到(不得不说，我也有点忘记)一个完全发展的旋转槽道流动(注意旋转源项的添加) (一般设置20000步可以了，只要收敛即可 大概一天)&lt;/li&gt;
&lt;li&gt;然后是获得完全发展槽道流动(也就是不加上旋转源项)(估计得三万步以上 大概一天)&lt;/li&gt;
&lt;li&gt;最后是获得统计的完全发展槽道流动.因为DNS获得的结果是非定常的，所以你得进行时均处理(当然时均程序得打开时均统计项 umean等)(我统计了20万步，大概花了4天时间。)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;步骤就是这样,大概一个较小的流程需要一周左右。&lt;/p&gt;
&lt;p&gt;Incompact3d比较特殊的是收敛性判定问题，上面的几个过程都需要使用实时&lt;a href=&#34;http://jueqingsizhe66.github.io/blog/2015/05/31/u-plus-y-plus/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;监控小程序&lt;/a&gt;
来观看速度散度和质量流量(质量流量是周期性槽道流动所特有的，所以最好进行实时显示)的收敛情况.另外你可以通过python的一个小脚本
来获得实时显示的图片，这样就能看到程序模拟得怎么样了，具体查看&lt;a href=&#34;http://jueqingsizhe66.github.io/blog/2015/06/11/ji-yu-pythonde-ju-yu-wang-wen-jian-gong-xiang-ruan-jian-simplehttpserverwithupload/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;python局域网上传和下载&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;#2 后处理方法
参考我的&lt;a href=&#34;http://jueqingsizhe66.github.io/blog/2015/06/22/incompact3dru-he-tong-guo-jie-guo-chu-li-chu-ji-xian&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;pathline处理方法&lt;/a&gt;
一定要注意(real 8) 否则得到的结果肯定是错误的，这也是困扰我几星期的问题。&lt;/p&gt;
&lt;p&gt;#3 关于Makefile编译&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;#=======================================================================
# Makefile for Imcompact3D
#=======================================================================

# Choose pre-processing options
#   -DSHM	   - enable shared-memory implementation
#   -DDOUBLE_PREC  - use double-precision
OPTIONS = -DDOUBLE_PREC

# Choose an FFT engine, available options are:
#   essl       - IBM Blue Gene ESSL Library
#   fftw3      - FFTW version 3.x
#   generic    - A general FFT algorithm (no 3rd-party library needed)
#FFT= essl # I ignore
FFT = generic

# Paths to FFTW 3
FFTW3_PATH=   # full path of FFTW installation if using fftw3 engine above
FFTW3_INCLUDE = -I$(FFTW3_PATH)/include
FFTW3_LIB = -L$(FFTW3_PATH)/lib -lfftw3 -lfftw3f

# Paths to ESSL
ESSL_PATH=/bgsys/drivers/ppcfloor/comm/xl
ESSL_INCLUDE =
ESSL_LIB = -L$(ESSL_PATH)/lib -L/opt/ibmmath/lib64 -lesslbg

# Specify Fortran and C compiler names and flags here
# Normally, use MPI wrappers rather than compilers themselves 
# Supply a Fortran pre-processing flag together with optimisation level flags
# Some examples are given below:

#FC =  
#OPTFC = 
#CC = 
#CFLAGS = 

# PGI
#FC = ftn
#OPTFC = -fast -O3 -Mpreprocess
#CC = cc
#CFLAGS = -O3

# PathScale
#FC = ftn
#OPTFC = -Ofast -cpp
#CC = cc
#CFLAGS = -O3

# GNU 选用mpif90进行编译
FC = mpif90
OPTFC = -O0 -g  -fdefault-real-8 -fdefault-double-8 -funroll-loops -ftree-vectorize -fcray-pointer -cpp
CC = mpicc
CFLAGS = -O0
PLATFORM=gnu

#Blue Gene/Q : EDF R&amp;amp;D
#PREP=/bgsys/drivers/ppcfloor/comm/xl/bin/
#FC = $(PREP)mpixlf95_r
#OPTFC= -O3 -qsuffix=cpp=f90 -qinitauto -qautodbl=dbl4
##OPT_LK= -O3 -qinitauto -qautodbl=dbl4
#CFLAGS= -O3 -qinitauto -qautodbl=dbl4
#CC=$(PREP)mpixlc_r
#PLATFORM=bgq_xlf

# Cray
#FC = ftn
#OPTFC = -e Fm
#CC = cc
#CFLAGS = 

#-----------------------------------------------------------------------
# Normally no need to change anything below

# include PATH 
ifeq ($(FFT),generic)
  INC=
else ifeq ($(FFT),fftw3)
  INC=$(FFTW3_INCLUDE)
else ifeq ($(FFT),essl)
  INC=$(ESSL_INCLUDE)
endif

# library path
ifeq ($(FFT),generic)
   LIBFFT=
else ifeq ($(FFT),fftw3)
   LIBFFT=$(FFTW3_LIB)
else ifeq ($(FFT),essl)
   LIBFFT=$(ESSL_LIB)
endif

# List of source files
# 注意这边编译的模块，一般是需要的mod生成放在前面首先编译，如果不放前面会报错，解决办法 就是文件名放在前面即可,具体可以查看关于Makefile Fortran
SRC = decomp_2d.f90 glassman.f90 fft_$(FFT).f90 module_param.f90 io.f90 variables.f90 poisson.f90 schemes.f90 implicit.f90 convdiff.f90 user_module.f90 incompact3d.f90 navier.f90 derive.f90 parameters.f90 tools.f90 visu.f90

#-----------------------------------------------------------------------
# Normally no need to change anything below

ifneq (,$(findstring DSHM,$(OPTIONS)))
SRC := FreeIPC.f90 $(SRC)  
OBJ =	$(SRC:.f90=.o) alloc_shm.o FreeIPC_c.o
else
OBJ =	$(SRC:.f90=.o)
endif	

OPTION=$(OPTIONS)
from:=-D
to:=-WF,-D
TMP=$(subst $(from),$(to),$(OPTIONS))
ifeq ($(PLATFORM),bgp_xlf)
   OPTION=$(TMP)
endif
ifeq ($(PLATFORM),bgq_xlf)
   OPTION=$(TMP)
endif

all: incompact3d

alloc_shm.o: alloc_shm.c
	$(CC) $(CFLAGS) -c $&amp;lt;

FreeIPC_c.o: FreeIPC_c.c
	$(CC) $(CFLAGS) -c $&amp;lt;

incompact3d : $(OBJ)
	$(FC) -O0 -g -o $@ $(OBJ) $(LIBFFT)

%.o : %.f90
	$(FC) $(OPTFC) $(OPTION) $(INC) -c $&amp;lt;

.PHONY: clean 
clean:
	rm -f *~ *.o *.mod incompact3d

.PHONY: realclean
realclean: clean
	rm -f *~ \#*\#
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行方式:
我的电脑刚好是8线程，就用8线程运行，你也可以选用4或者更多.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;mpirun -np 8  incompact3d  &amp;gt; tail.out &amp;amp;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;#4 The Algorithm of the DNS in Incompact3d&lt;/p&gt;
&lt;p&gt;Incompact3d的执行流程基本上是下面几个(当然得仔细阅读，并反复比对).我写得这段英文大体能够对得上.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;1. Initial the velocity field with noise(init subroutine).
2. Start the iterative process by guessing the pressure field. First we use convdiff subroutine take convection and diffusion of the flow into consideration.And then use pre_correc subroutine to correction the velocity value with the specified boundary condition.
3. Use the values of u,v,and w to get the initialize of the pp3 in the spectral space from subroutine divergence(…pp3,1…)(first sign to turbulent spot).Then we use poisson solver decomp_2d_poisson_stag to get the value of the pp3 in the spectral space.
4. Since they were obtained from the guessed values of u,v,w,the values pp3,when substituted into the divergence equation,will not necessarily satisfy that that equation.Hence ,using the gradp subroutine,get the pressure gradients in the physics space,then using corgp subroutine ,get the velocity correction by the pressure gradient in the physics space.Use subroutine divergence(…dv3,2…) to do another monitor for turbulent spot(second sign to turbulent spot) .At the end of the current step, we go to step2 again until the simulation have been fully developed.
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Incompact3d如何通过结果处理出迹线</title>
      <link>https://jueqingsizhe66.github.io/archives/incompact3dru-he-tong-guo-jie-guo-chu-li-chu-ji-xian/</link>
      <pubDate>Mon, 22 Jun 2015 16:20:48 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/archives/incompact3dru-he-tong-guo-jie-guo-chu-li-chu-ji-xian/</guid>
      <description>&lt;p&gt;Incompact3D获得的数据都是二进制的数据文件，为了获得内部的文件
需要进一步通过编程获得，下面是一个获得pathline的源代码。&lt;/p&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过 module.f90文件读取 nx ny nz的值&lt;/li&gt;
&lt;li&gt;把下面的源代码编译并放在ux uy uz所在的文件夹当中&lt;/li&gt;
&lt;li&gt;进一步的相关信息，可以参考注释。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-fortran&#34;&gt;PROGRAM b
IMPLICIT NONE
Integer,parameter :: nx=128,ny=129,nz=84 
INTEGER :: I,J,K,COUNT,LN=128,COL=129,VOL=84
REAL(8),DIMENSION(nx,ny,nz) :: ux,uy,uz
CHARACTER(len=12)::NAME1=&amp;quot;Incompact3d&amp;quot;,NAME2=&amp;quot;ux&amp;quot;,NAME3=&amp;quot;uy&amp;quot;,NAME4=&amp;quot;uz&amp;quot;
character(len=15) :: temp,temp1,temp2,temp3
CHARACTER(len=20) :: CFILEux
integer :: num

real,dimension(nx):: y1
real,dimension(ny):: y2
real,dimension(nz):: y3

!generation of the mesh
do i=1,nx
   y1(i)=(i-1)*0.098174770425 !0.8 is DX ! incompact3d.prm的配置长度除以网格尺度即可。
enddo


do j=1,ny
   y2(j)=(j-1)*0.015503875968992248 !0.8 is DY
enddo


do k=1,nz
   y3(k)=(k-1)*0.04986655005702381!0.8 is DZ
enddo


! 下面只是对于读取文件进行的一个后处理，只是为了方便批处理而已
22 format(I1)
23 format(I2)
DO num=1,30
    if(num .lt. 10) then
        write(temp,22) num
        temp1 =trim(NAME2)//trim(&#39;00&#39;)//trim(temp)
        temp2 =trim(NAME3)//trim(&#39;00&#39;)//trim(temp)
        temp3 =trim(NAME4)//trim(&#39;00&#39;)//trim(temp)
    else 
        write(temp,23) num
        temp1 =trim(NAME2)//trim(&#39;0&#39;)//trim(temp)
        temp2 =trim(NAME3)//trim(&#39;0&#39;)//trim(temp)
        temp3 =trim(NAME4)//trim(&#39;0&#39;)//trim(temp)
    end if
    
! 产生实际的文件名
CFILEux=trim(&#39;./pathchange/&#39;)//trim(temp1)//&#39;.dat&#39;
!read the ux 读取ux00*的数据
OPEN(10,FILE=temp1,FORM=&#39;UNFORMATTED&#39;,&amp;amp;
ACCESS=&#39;DIRECT&#39;, RECL=8, STATUS=&#39;OLD&#39;)

! read the uy
OPEN(11,FILE=temp2,FORM=&#39;UNFORMATTED&#39;,&amp;amp;
ACCESS=&#39;DIRECT&#39;, RECL=8, STATUS=&#39;OLD&#39;)
!read the uz
OPEN(12,FILE=temp3,FORM=&#39;UNFORMATTED&#39;,&amp;amp;
ACCESS=&#39;DIRECT&#39;, RECL=8, STATUS=&#39;OLD&#39;)

! 新建一个结果文件，并添加上tecplot的数据头

OPEN(20,FILE=CFILEux,FORM=&#39;FORMATTED&#39;)
WRITE (20,&#39;(A6,A12)&#39;)               &#39;TITLE=&#39;,TRIM(ADJUSTL(NAME1))
 WRITE (20,&#39;(A36)&#39;)    &#39;VARIABLES=&amp;quot;X&amp;quot;,&amp;quot;Y&amp;quot;,&amp;quot;Z&amp;quot;,&amp;quot;VX&amp;quot;,&amp;quot;VY&amp;quot;,&amp;quot;VZ&amp;quot;&#39;
      WRITE (20,&#39;(A7,I4,A1,A2,I4,A1,A2,I4,A1,A7)&#39;) &#39;ZONE I=&#39;,LN,&#39;,&#39;,&#39;J=&#39;,COL,&#39;,&#39;,&#39;K=&#39;,VOL,&#39;,&#39;,&#39;F=POINT&#39;

COUNT = 1
DO K=1,nz
    DO J=1,ny
        DO I=1,nx
            READ(10,REC=COUNT) ux(I,J,K)
            READ(11,REC=COUNT) uy(I,J,K)
            READ(12,REC=COUNT) uz(I,J,K)
        !    WRITE(20,30) I,J,K,ux(I,J,K),uy(I,J,K),uz(I,J,K)
             WRITE(20,30) y1(i),y2(j),y3(k),ux(I,J,K),uy(I,J,K),uz(I,J,K)
            30 format(I3,1X,I3,1X,I3,1X,E11.4,1x,E11.4,1x,E11.4)
            COUNT = COUNT + 1
        ENDDO
    ENDDO
ENDDO
ENDDO
CLOSE(10)
CLOSE(11)
CLOSE(10)
CLOSE(20)
END PROGRAM b
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>U&#43;-Y&#43;</title>
      <link>https://jueqingsizhe66.github.io/archives/u-plus-y-plus/</link>
      <pubDate>Sun, 31 May 2015 09:31:05 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/archives/u-plus-y-plus/</guid>
      <description>&lt;p&gt;这个gnuplot脚本是我用于处理Incompact3d产生出来的统计结果(如何统计部分，暂时未写)的画图脚本。&lt;/p&gt;
&lt;h2 id=&#34;数据段&#34;&gt;数据段&lt;/h2&gt;
&lt;p&gt;注意gnuplot处理数据文件按照空行划分index部分。所以下面的部分总共有四个index，调用方式是&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;plot &amp;ldquo;文件名&amp;rdquo; index 0   第一部分文件信息的打印&lt;/li&gt;
&lt;li&gt;plot &amp;ldquo;文件名&amp;rdquo; index 1&lt;/li&gt;
&lt;li&gt;plot &amp;ldquo;文件名&amp;rdquo; index 2&lt;/li&gt;
&lt;li&gt;plot &amp;ldquo;文件名&amp;rdquo; index 3&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体看gnuplot脚本部分。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;0 2.9684e-24
0.7369 0.73552
1.4746 1.4677
2.2139 2.195
2.9556 2.915
3.7005 3.6242
4.4495 4.3184
5.2034 4.9934
5.9631 5.6455
6.7295 6.2713
7.5034 6.8686
8.2859 7.4358
9.078 7.9722
9.8806 8.4777
10.695 8.9528
11.522 9.3986
12.363 9.8162
13.219 10.207
14.092 10.573
14.983 10.916
15.894 11.236
16.825 11.537
17.779 11.819
18.759 12.084
19.764 12.334
20.799 12.569
21.864 12.791
22.963 13.001
24.099 13.201
25.273 13.391
26.49 13.572
27.753 13.745
29.065 13.911
30.431 14.071
31.855 14.225
33.343 14.374
34.899 14.52
36.529 14.661
38.24 14.8
40.04 14.936
41.936 15.07
43.936 15.202
46.052 15.333
48.292 15.464
50.669 15.594
53.196 15.725
55.887 15.856
58.756 15.989
61.819 16.124
65.096 16.262
68.603 16.402
72.361 16.544
76.389 16.69
80.706 16.838
85.33 16.988
90.276 17.139
95.557 17.288
101.18 17.434
107.14 17.572
113.42 17.7
120 17.813
126.85 17.906
133.91 17.975
141.11 18.017
148.4 18.03


5 0
5 20


30 0
30 20


120 0
120 20

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;gnuplot处理部分&#34;&gt;gnuplot处理部分&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-gnuplot&#34;&gt;set ter &#39;png&#39;
set out &#39;fit1.png&#39;

set xlabel &amp;quot;Y+&amp;quot;
set ylabel &amp;quot;U+&amp;quot;
set xtics font &#39;Times-Roman, 15&#39;
f(x)=a*x+b
g(x)=1/k*log(x)+B
fit [0:5] f(x) &amp;quot;umfit.dat&amp;quot; index 0 via a,b
print &amp;quot;a:=&amp;quot;,a,&amp;quot;b=&amp;quot;,b
fit [30:148] g(x) &amp;quot;umfit.dat&amp;quot; index 0 via k,B
print &amp;quot;k=&amp;quot;,k,&amp;quot;B=&amp;quot;,B
set xtics 20
set samples 1280
set key right bottom box
set arrow from 20,5 to  5,2 
set label  sprintf(&amp;quot;viscous sub-layer fit:\n f(x)=%g*x +%g&amp;quot;, a,b)  at 20,6 
set arrow from 90,12 to  70,16
set label sprintf(&amp;quot;logarithm range fit:\n f(x)=1/%g*log(x) +%g&amp;quot;,k,B) at 90,11 

#set logscale x
#set xrange
#set yrange [0:0.5]
#[0:220][0:0.04]   # the most important place is here
plot  [0:148][0:20]  &amp;quot;umfit.dat&amp;quot; index 0 w lp pt 1  t &amp;quot;U+--Y+&amp;quot;,f(x) w l lt -1 lw 2 t &amp;quot;linear-fit&amp;quot;,g(x)  w  l lt 3 lw 2 t &amp;quot;log-fit&amp;quot;,\
 &amp;quot;&amp;quot; index 1 w l lt 0 t &amp;quot;linear-fit-end&amp;quot;,&amp;quot;&amp;quot; index 2 w l lt 0 t &amp;quot;log-law-start&amp;quot;,&amp;quot;&amp;quot; index 3 w l lt 0 t &amp;quot;log-law-end&amp;quot;

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;处理结果&#34;&gt;处理结果&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://jueqingsizhe66.github.io/images/incompact3d/fit1.png&#34; alt=&#34;处理结果&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;一些实时监测部分&#34;&gt;一些实时监测部分&lt;/h2&gt;
&lt;h3 id=&#34;执行部分&#34;&gt;执行部分：&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;a.sh&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;mpirun -np 8  incompact3d  &amp;gt;&amp;gt; tail.out &amp;amp;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;获取信息部分&#34;&gt;获取信息部分&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;image.sh&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;more tail.out | grep DIV | grep U* |grep Max|sed &#39;/final/d&#39;| awk -F&#39;=&#39; &#39;{print $2}&#39; |sed &#39;1,3d&#39;&amp;gt; divu
more tail.out | grep UT | awk  &#39;{print $4}&#39;|sed &#39;1,2d&#39; &amp;gt; flow-rate-correction-factor

#more tail.out | grep zhao | awk &#39;{print $2,$3,$4}&#39; &amp;gt; stretching

more tail.out | grep PHI | grep max|awk -F&#39;=&#39; &#39;{print $2}&#39; &amp;gt; PHImax

more tail.out | grep PHI|grep MOYEN | awk  -F&amp;quot;:&amp;quot; &#39;{print $2*10^4}&#39;&amp;gt; PHImoyen
#gnuplot monitorFLOWRATE.gnu

bash monitor.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;打印部分&#34;&gt;打印部分&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;monitor.sh&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#!/bin/bash
#===============================================================================
#
#          FILE:  monitor.sh
# 
#         USAGE:  ./monitor.sh 
# 
#   DESCRIPTION:  
# 
#       OPTIONS:  ---
#  REQUIREMENTS:  ---
#          BUGS:  ---
#         NOTES:  ---
#        AUTHOR:  Ye Zhaoliang (YZL), zhaoturkkey@163.com
#       COMPANY:  NCEPU
#       VERSION:  1.0
#       CREATED:  2014年10月28日 09时42分15秒 CST
#      REVISION:  ---
#===============================================================================

# set yrange [0:2]
# set xlabel
# set ylabel
function mainpoint()
{
 #   echo $0;
#    echo $1;
gnuplot&amp;lt;&amp;lt;EOF
set ter &#39;png&#39;
set out &#39;$1.png&#39;
set grid
plot &#39;$1&#39; w p pt 2
EOF

}

function mainline()
{
 #   echo $0;
 #   echo $1;
gnuplot&amp;lt;&amp;lt;EOF
set ter &#39;png&#39;
set out &#39;$1.png&#39;
set grid
set yrange [0:2]
plot &#39;$1&#39; w l lt 2
EOF


}

#mainpoint ux2
#mainpoint uy2
#mainpoint uz2
#mainpoint ux5
#mainpoint uy5
#mainpoint uz5
#mainline uy2
mainpoint divu
mainpoint flow-rate-correction-factor
#mainpoint stretching
mainpoint PHImax
mainpoint PHImoyen
#mainpoint averageux2
#mainpoint averageux5
#mainpoint rxx2
#mainpoint rxx5
#mainpoint dudy_bottom_spatial_only
#mainpoint dudy_top_spatial_only
#mainpoint dudy_bottom_spatial_time
#mainpoint dudy_top_spatial_time

#new add  stress
#mainpoint umean
#mainpoint vmean
#mainpoint wmean
##mainpoint uu
##mainpoint vv
#mainpoint ww

#mainpoint stressu
#mainpoint stressv
#mainpoint stressw
#mainpoint stressuv
#mainpoint stressuw
#mainpoint stressvw
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;整合部分&#34;&gt;整合部分&lt;/h3&gt;
&lt;p&gt;cut -c的目的是获取具体对应的时间步,然后把所有的png相关信息 放到对应时间步文件夹中。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cd /home/Cedric/diric/src &amp;amp;&amp;amp; more tail.out |grep Time|awk &#39;{print $4}&#39; |tail -1|cut -c 1-6 |awk &#39;{cmd=&amp;quot;mkdir step&amp;quot;$1;system(cmd);system(&amp;quot;sh image.sh&amp;quot;);cmd2=&amp;quot;mv *.png step&amp;quot;$1;system(cmd2);} &#39;

# END{cmd3=&amp;quot;mv dudy* umean stress step&amp;quot;$1;system(cmd3)}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;实时浏览&#34;&gt;实时浏览&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;切换到对应的文件夹
$ python -m SimpleHTTPServer 

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后就可以打开 127.0.0.1:8000进行浏览了。&lt;/p&gt;
&lt;h3 id=&#34;you-can-also-use-crontab-to-execute-program-in-real-time&#34;&gt;You can also use crontab to execute program in real time&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;
crontab -e
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then you can copy the info below,but modified the datatime.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0 23 19 6 * sh /home/simulation2_128-117-128Re4200/main.sh 
30 23 19 6 * sh /home/simulation2_128-117-128Re4200/main.sh 
0 0 20 6 * sh /home/simulation2_128-117-128Re4200/main.sh 
30 0 20 6 * sh /home/simulation2_128-117-128Re4200/main.sh 
0 1 20 6 * sh /home/simulation2_128-117-128Re4200/main.sh 
30 1 20 6 * sh /home/simulation2_128-117-128Re4200/main.sh 
0 2 20 6 * sh /home/simulation2_128-117-128Re4200/main.sh 
30 2 20 6 * sh /home/simulation2_128-117-128Re4200/main.sh 
0 3 20 6 * sh /home/simulation2_128-117-128Re4200/main.sh 
30 3 20 6 * sh /home/simulation2_128-117-128Re4200/main.sh 
0 4 20 6 * sh /home/simulation2_128-117-128Re4200/main.sh 
30 4 20 6 * sh /home/simulation2_128-117-128Re4200/main.sh 
0 5 20 6 * sh /home/simulation2_128-117-128Re4200/main.sh 
30 5 20 6 * sh /home/simulation2_128-117-128Re4200/main.sh 
0 6 20 6 * sh /home/simulation2_128-117-128Re4200/main.sh 
30 6 20 6 * sh /home/simulation2_128-117-128Re4200/main.sh 
0 7 20 6 * sh /home/simulation2_128-117-128Re4200/main.sh 
30 7 20 6 * sh /home/simulation2_128-117-128Re4200/main.sh 
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>The greatest weapons</title>
      <link>https://jueqingsizhe66.github.io/archives/the-greatest-weapons/</link>
      <pubDate>Sun, 17 May 2015 19:01:59 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/archives/the-greatest-weapons/</guid>
      <description>&lt;p&gt;Everything in Haskell has a Type
Here are some Type declarations.&lt;/p&gt;
&lt;p&gt;These are your greatest weapons.&lt;/p&gt;
&lt;p&gt;head :: [a] -&amp;gt; a &amp;ndash; gets the first element of a list&lt;/p&gt;
&lt;p&gt;tail :: [a] -&amp;gt; [a] &amp;ndash; gets everything but the first element&lt;/p&gt;
&lt;p&gt;last :: [a] -&amp;gt; a &amp;ndash; gets the last element of a list&lt;/p&gt;
&lt;p&gt;init :: [a] -&amp;gt; [a] &amp;ndash; gets everything but the last element&lt;/p&gt;
&lt;p&gt;(++) :: [a] -&amp;gt; [a] -&amp;gt; [a] &amp;ndash; concatenates two lists together&lt;/p&gt;
&lt;p&gt;(:) :: a -&amp;gt; [a] -&amp;gt; [a] &amp;ndash; prepends an element to a list&lt;/p&gt;
&lt;p&gt;fst  :: (a,b) -&amp;gt; a &amp;ndash; gets the first element of a tuple&lt;/p&gt;
&lt;p&gt;snd  :: (a,b) -&amp;gt; b &amp;ndash; gets the second element of a tuple&lt;/p&gt;
&lt;p&gt;(!!) :: [a]-&amp;gt;Int a&lt;/p&gt;
&lt;h3 id=&#34;数学中λ-calculus的表示法为&#34;&gt;数学中λ-calculus的表示法为：&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;λx.t&lt;/li&gt;
&lt;li&gt;λx[t]&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;“λ”不具有任何特殊意思，标识着其表达式中的可取一数值x带入。
t是表达式（例如x+3、x^2+2x+1等）。&lt;/p&gt;
&lt;h3 id=&#34;代入数值p的表示法为&#34;&gt;代入数值p的表示法为：&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;(λx.t)p&lt;/li&gt;
&lt;li&gt;(λx[t])p&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&#34;lispscheme的λ表示法与数值代入&#34;&gt;Lisp|scheme的λ表示法与数值代入：&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(lambda (x) (+ x 1))
((lambda (x) (+ x 1) 10))
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;haskell&#34;&gt;Haskell：&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;\x -&amp;gt; x+1
(\x -&amp;gt; x+1)10

Prelude&amp;gt; map (\x-&amp;gt;x+1) [1..10]
[2,3,4,5,6,7,8,9,10,11]

\ para1 para2-&amp;gt;(return value) 
\ (para1,para2) -&amp;gt; (return value)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;lambda-calculus&#34;&gt;Lambda Calculus&lt;/h3&gt;
&lt;p&gt;前面提到了Haskell是基于__Lambda Calculus__的，所以在学习Haskell之前，我们有必要了解一下Lambda Caculus的一些基本的内容，方便我们后面正式介绍Haskell。其实，Lambda Calculus是所有函数式语言的基础，要学习FP，最好都了解一下Lambda Calculus。下面对Lambda Calculus做一个简单的介绍：&lt;/p&gt;
&lt;h4 id=&#34;基本的语法lambda-calculus的核心是表达式expression用fp语言写的程序执行的过程本质上就是对表达式求值的过程&#34;&gt;基本的语法：Lambda Calculus的核心是表达式(Expression)，用FP语言写的程序执行的过程，本质上就是对表达式求值的过程&lt;/h4&gt;
&lt;p&gt;expression := variable | function | application
funciton := λvariable.expression (.前面部分为定义(definition)，后面部分为函数体(body))
application := expression expression&lt;/p&gt;
&lt;p&gt;另外一种表述方法:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;&amp;lt;expr&amp;gt; ::= &amp;lt;identifier&amp;gt; 
&amp;lt;expr&amp;gt; ::= lambda &amp;lt;identifier-list&amp;gt;. &amp;lt;expr&amp;gt; 
&amp;lt;expr&amp;gt; ::= (&amp;lt;expr&amp;gt; &amp;lt;expr&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;前两条语法用于生成lambda表达式（lambda函数），如：
lambda x y. x + y
haskell里面为了简洁起见用“\”来代替希腊字母lambda，它们形状比较相似。故而上面的定义也可以写成：
\ x y. x + y&lt;/p&gt;
&lt;h4 id=&#34;变量的bound与free&#34;&gt;变量的bound与free:&lt;/h4&gt;
&lt;p&gt;λx.xy →x is bound, y is free&lt;/p&gt;
&lt;h4 id=&#34;表达式化简reduction的基本法则&#34;&gt;表达式化简（Reduction)的基本法则:&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;α−reduction: λx.E→λy.E[y/x]
β−reduction:((λx.E)z)→E[z/x]
η−reduction(if x is not free in E): λx.(Ex)→E
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Alpha转换公理：例如，“lambda x y. x + y”转换为“lambda a b. a + b”。换句话说，函数的参数起什么名字没有关系，可以随意替换，只要函数体里面对参数的使用的地方也同时注意相应替换掉就是了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Beta转换公理：例如，“(lambda x y. x + y) 2 3”转换为“2 + 3”。这个就更简单了，也就是说，当把一个lambda函数用到参数身上时，只需用实际的参数来替换掉其函数体中的相应变量即可。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;http://mindhacks.cn/2006/10/15/cantor-godel-turing-an-eternal-golden-diagonal/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;软件工程里面的一条黄金定律：“任何问题都可以通过增加一个间接层来解决&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;变量替换&#34;&gt;变量替换&lt;/h4&gt;
&lt;p&gt;[y/x]E →  substitute  all occurrences of x in E to y&lt;/p&gt;
&lt;p&gt;以上是Lambda Calculus的一些基础知识，读者朋友现在不理解没有关系，等后面讲到Haskell中相关的部分就可以理解了。对于抑制不住自已的好奇心的朋友，可以在这里：&lt;a href=&#34;http://en.wikipedia.org/wiki/Lambda_calculus&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://en.wikipedia.org/wiki/Lambda_calculus&lt;/a&gt;做进一步的了解。&lt;/p&gt;
&lt;p&gt;在之前做的&lt;a href=&#34;http://jueqingsizhe66.github.io/blog/2015/05/17/cong-lambdadao-simple-plus-complexjie-shi-qi-zai-dao-shu-xing-chou-xiang/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;lambda的推导&lt;/a&gt;其实都只是针对单个参数，包括&lt;a href=&#34;http://shuklan.com/haskell/lec03.html#/0/15&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Haskell也是强调单参数的调用&lt;/a&gt;，如果多惨数那就是用curry来解决(funny多参数)
关于多参数的lambda推到比较少见，但是多参数都是可以通过curry实现。&lt;/p&gt;
&lt;p&gt;比如Haskell的实现:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;Prelude&amp;gt; :type take
take :: Int -&amp;gt; [a] -&amp;gt; [a]
Prelude&amp;gt; let takeFive = take 5
Prelude&amp;gt; :type takeFive
takeFive :: [a] -&amp;gt; [a]
Prelude&amp;gt; takeFive [1..]
[1,2,3,4,5]
	   
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Haskell几个基本概念--学而无用--无以为用</title>
      <link>https://jueqingsizhe66.github.io/archives/haskellji-ge-ji-ben-gai-nian-xue-er-wu-yong-wu-yi-wei-yong/</link>
      <pubDate>Sat, 16 May 2015 21:11:50 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/archives/haskellji-ge-ji-ben-gai-nian-xue-er-wu-yong-wu-yi-wei-yong/</guid>
      <description>&lt;ol&gt;
&lt;li&gt;模式匹配
= +起着一种模式匹配，=不要翻译成等于 最好翻译为如果匹配前面+ 则他的值为后面.-&amp;gt; 也起着一种类型的模式匹配。&lt;/li&gt;
&lt;li&gt;分支
|在创建函数的时候 体现着一种分支的效果。
if-else  这其实是一种控制语句，不能说Haskell放掉了控制语句，而应该是循环语句。&lt;/li&gt;
&lt;li&gt;一切都是函数。
根据monad的内置结构，函数可以组合生成类似于数学的组合函数（埋藏内部的lambda结构）&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;函数只是关系的表示可以说它是过程变换运动从泛函的角度解释&#34;&gt;函数只是关系的表示，可以说它是过程、变换、运动（从泛函的角度解释）&lt;/h3&gt;
&lt;p&gt;本来函数式变成是不考虑空间的， 而面向对象则是引入不必要的空间问题，来挂上函数，最终都是为了实现函数变换或者函数过程，或者统称为运动。
假如宇宙存在根节点，越靠近根节点的肯定越抽象，我们现在是工作在底层的具象节点下。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;面向对象属于分解，函数编程属于组合。有以为 利，通过面向对象我们将一分解为多个，数量多了，“有”，而函数编程则是将多个组合成一个，数量少了  ，“无”，无才能用，只有忽略事物内部的细节，我们才 能用它，否则陷入细节迷失方向。换句话说：数学分数考得好，不代表在实际中用数学用的好，牛    顿没有发明几何学，但是用了几何学，创造了微积分，用它们推导 出万有引力；爱因斯坦用了非几何学推导了相对论。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简洁才能落地！&lt;/p&gt;
&lt;p&gt;###从有至无方为用，有乃分，无乃合，宇宙的起点源于无&lt;/p&gt;
&lt;p&gt;学习是一种分解能力，使用是一种组合能力，这是两种不同的能力。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;再看看老子道德经的一段：三十幅共一毂，当其无，有车之用。埏埴以为器，当其无，有器之用。凿户牖以为室，当其无，有室之用。故有之以为利，无之   以为用。
这段话意思是：三十根棍子做成的圆轱辘，只有忽视圆轱辘内部这种结构，着眼于圆轱辘外部，才会发现它原来是可以做车的轮子这一用处，两个轱辘与车    架组合成一辆车。比如门窗，只有忽视其内部如何结构的构建，才会从外部想到用它在房间组合中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;树形结构抽象细节&#34;&gt;树形结构抽象细节&lt;/h3&gt;
&lt;p&gt;我们之所以使用树形结构，用一个根节点代表其聚合群体，用组长代表所有组员，用名字代表人的全部，等等这些组合抽象的办法就是让我们大脑去除大量   对象内部的细节，用一个符号代替它们，这样我们才能基于这个树的根节点再组合成新的树形结构。&lt;/p&gt;
&lt;h2 id=&#34;范畴理论-交际的互联网&#34;&gt;范畴理论-交际的互联网&lt;/h2&gt;
&lt;p&gt;范畴理论(Category)总是鼓励我们从对象内部细节中转移开来，在范畴理论中 一个对象是一个抽象模糊的实体，你所有需要知道的只是它如何和其他对象交互(关系)，它是怎么使用箭头和其他对象连接的，这就是为什么互联网搜索引擎 Google Baidu等能够通过分析链入和链出的链接来排名网站一样。&lt;/p&gt;
&lt;h2 id=&#34;无以为用--组合思想&#34;&gt;无以为用&amp;ndash;组合思想&lt;/h2&gt;
&lt;p&gt;归根到底，还是“无以为用”这个范畴的组合本质很多人都没有搞清楚。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只有忘记对象的细节才能用好它。两个原因总结一下：
&lt;ul&gt;
&lt;li&gt;首先，首先人脑短时记忆有限，如果大量对象内部细节占据大脑，而我们需要从对象外部组合它们，    这些细节是干扰。&lt;/li&gt;
&lt;li&gt;其次，范畴也认为组合对象只要将对象看成模糊实体，注重它们之间关系。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;忘记学习对象的细节才能用好它，无以为用，事物的制造者都不一定能用好它，除非事先有目标制造它。
因此，学并不能致用，数理化学得好不一定用得好，博士给老板打工，老板赚大头。因为他把你的学问用处发挥了。自己学自己用因为智力限制也不可能。&lt;/li&gt;
&lt;li&gt;中国教育的典型
在学生阶段,中国学生数理化很好，但是毕业后诺贝尔奖获得者几乎没有，世界自然科学领军人物很少，那些高考状元 学神都哪儿去了？学得好不      一定用得好，中国教育制度是以学习能力评价学生，各种考试充斥大量 知识细节，让学生耗费18年于这些可能以后无用的细节中，最终他们已经没有智力空间来思考如何使用这些大量的知识细节了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;面向对象的分解能力是强，但是组合能力很弱！
实际上从函数运算的角度，不存在单纯的“值”，1应该是=&amp;amp; gt;1，或者说，所谓的常量值也是函数，只是每次不管输入什么都输出同样的结果。这样世界就只有运算，值是没必&amp;gt;要的，更没有状态。但这是神的视角，而一 旦人开始思考时，由于不具备神的无限的能力，只能在每个瞬间试图去把握世界，就看到了值和状态以及状态呈现时的context/stage/&amp;gt;舞台。但人希 望能像神一样去理解世界，就只好从这每个瞬间呈现的一切中去寻找变与不变的东西，当他们历尽艰辛找到“不变”的“变换”时就迫不及待地将之命名为定律。&lt;/p&gt;
&lt;p&gt;关于上述思想，计算机邀请Haskell带领领略（Haskell可以学习，但是需要投入很多时间，坚持&amp;hellip;）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.zhihu.com/question/20193745&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;综合性帖子&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.jdon.com/47271&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这边也有一些课程介绍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;dev.stephendiehl.com/hask/&#34;&gt; What I Wish I Knew When Learning Haskell 2.2 ( Stephen Diehl )&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://acm.wustl.edu/functional/haskell.php&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;How to learn haskell&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://learnyouahaskell.com/chapters&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;相当棒的趣味指南&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;从现实世界走入计算机经过计算机思考再从计算机走出并融入现实世界这就是-函数式思维httpwwwjdoncom45608&#34;&gt;从现实世界走入计算机，经过计算机思考，再从计算机走出并融入现实世界，这就是&lt;a href=&#34;http://www.jdon.com/45608&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt; 函数式思维&lt;/a&gt;。&lt;/h3&gt;
&lt;p&gt;函数的context引入了时间的关系。&lt;a href=&#34;http://www.jdon.com/45608&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt; 我们思考逻辑的时候，定义已经是确定的了。也正因为是确定的，才可以逻辑思考&lt;/a&gt;。
函数不存在状态，所以计算机加入了一个特殊的东西：时钟。值++时间=状态++，在可以忽视时序问题时，可以直接有值=状态。忽视时序问题，就相当于我们平时说的异步。若果单单使用锁，只是一种耗费资源手段。而我们看到无论是唤醒线程，还是延时读取，都是依赖时钟
##+ 小结：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://jueqingsizhe66.github.io/images/desk.jpg&#34; alt=&#34;桌子&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;

一张桌子为案例，分解思维的人看到后首先想到这张桌子由什么构成，长宽高和材质，这些都是桌子的内部细节；而组合思维的人看到后，环顾四周，看看其处于什么环境，如果放在教室中，他判断这是一张课桌，如果放在食堂，他判断这是一张饭桌。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;从这个例子可以看出组合是从行为（运动、变化、时间）角度看待 世界的，“课桌”、“饭桌”中的“课”和“饭”在这里是动词，意为“上课用”、“吃饭用”的意思，“用”是动词，同一个桌子出现在不同的环境中发挥不同的 作用。而分解思维只研究空间，只研究桌子的空间结构是什么，甚至不研究为什么是四条腿，为什么每条腿长度相同，分解思维根本不考虑这些，不用考虑任何桌子 之外的世界，在分解思维中没有万有引力、没有地面的水平、没有书房和餐厅，只有空间，分解只考虑空间的组成结构。看来分解和组合是相互依存的，分解时研究 的是空间，组合时研究的是行为，把桌子放进餐厅的意义是期待使用它吃饭这样一种运动[组合运动？]。 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;范畴英文是Category，也是++分类++的意思，打个比喻，Google能根据哪些网站引用你的网站这个外部信息进行PageRank评分，从而对你的网站权重进行排序，这个道理和我们评价一个人有些类似，看一个不认识的人怎么样，那就看看他交往的什么朋友，什么环境，近墨者黑，人以群分，物以类聚，这些都是从事物所在的分类类别中判断其价值，而不是从事物内部细节。（评判个人的价值标准跟不同的人在一起，意味着你的价值不一样.）&lt;/p&gt;
&lt;h3 id=&#34;monad-隐藏lambda&#34;&gt;monad 隐藏lambda&lt;/h3&gt;
&lt;p&gt;Monad是一种结构，这种结构能够将一个值放入一个可计算的上下文中。因为Lambda是一个和上下文环境有关的表达式，所以，这里对Monad的上下文理解就比较容易。
monad是从范畴论引入， 范畴其实就是一个集合，只不过对这个集合有一些约束定义，如果 熟悉业务建模的人可能对这种思维方式不陌生，经常我们会对抽象的事物进行定义，数学上基本就是用集合概念，实际上从罗素悖论拯救了数学开始，数学离不开集合，对于一个国家社会，个人与社会也是不同的概念，社会是一个++集合++概念，从++集合角度++考虑问题和从__个人元素角度__考虑问题是两种截然不同的思路，如果你平时注 重这种区别，你可能会有两种人生观。祝你脑洞大开。&lt;/p&gt;
&lt;h3 id=&#34;函数式替代sql&#34;&gt;函数式替代sql？&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;http://www.jdon.com/44842&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;函数的逻辑性&lt;/a&gt;与关系数据库的是一致的，而逻辑在不同语言之间是自然贯穿的，也就是说若果所有都用函数来表达的，可以使sql消失，那么由于sql引发的问题自然就消失。
数据库 = 一个集合,这就是面向集合，mongodb就是这样的思想&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>尾递归</title>
      <link>https://jueqingsizhe66.github.io/archives/wei-di-gui/</link>
      <pubDate>Wed, 13 May 2015 20:56:12 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/archives/wei-di-gui/</guid>
      <description>&lt;p&gt;尾递归的好处就是快速计算，尾递归实际上是在递归计算的过程中，
（印象中递归过程[表示语法形式-调用自己]和递归计算过程[表正线性方式 和非线性方式]是不一样的）, 加入了迭代的思想，不断的修改了product和counter的值，
不需要树形展开。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define (fact n)
  (cond
    ((= n 1) 1)
    (else (* n (fact (- n 1))))))

(define (fact1 n)
  (define (fact-iter product counter)
    (cond
      ((= counter 1) product)
      (else (fact-iter (* product counter) (- counter 1)))))
  (fact-iter 1 n))
;;;Solve 4!
(fact 4)
(fact1 4)

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;;;; 求幂&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define (expr b n)
  (if (= n 0)
     1
     (* b (expt b (- n 1)))))

;;;iter form
(define (expr1 b n)
  (define (expr-iter b counter product)
    (if (= counter 0)
       product
       (expr-iter b (- counter 1) (* b product))))
  (expr-iter b  n 1))

(expr 4 5)
(expr1 4 5)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;===&amp;gt;另外还有一种更快速的方法
;; b^n =(b^(n/2))^2, n is even
;; b^n =(b*b^(n-1)) , n is odd&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define (fast-iter b n)
 (cond 
  ((= n 0) 1)
  ((even? n) (square (fast)))
  (else (* b (fast-iter b (- n 1))))))

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;====&amp;gt;并最终得到尾递归的一般形式
结合&lt;a href=&#34;jueqingsizhe66.github.io/2015/05/13/qiu-ding-ji-fen/&#34;&gt;求定积分&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;===&amp;gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define (sum term a  next b)
    (define (sum-iter a result)
     (if &amp;lt;???&amp;gt;
       &amp;lt;???&amp;gt; 
       (iter &amp;lt;???&amp;gt; &amp;lt;???&amp;gt;)))
    (sum-iter &amp;lt;???&amp;gt; &amp;lt;???&amp;gt;)
)
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>求定积分</title>
      <link>https://jueqingsizhe66.github.io/archives/qiu-ding-ji-fen/</link>
      <pubDate>Wed, 13 May 2015 19:27:40 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/archives/qiu-ding-ji-fen/</guid>
      <description>&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://jueqingsizhe66.github.io/images/maths/dingjifen.jpg&#34; alt=&#34;定积分&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;

















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://jueqingsizhe66.github.io/images/maths/dingjifen3.jpg&#34; alt=&#34;定积分的数值计算&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;

















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://jueqingsizhe66.github.io/images/maths/dingjifen2.jpg&#34; alt=&#34;定积分的图形示意&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;
 (define (cube  x) (* x  x x))
 ;;;累加
(define (sum-integer a b)
  (if (&amp;gt; a b)
     0
     (+ a (sum-integer (+ a 1) b))))

(sum-integer 1 10)
;;;立方累加
(define (sum-cube a b)
  (if (&amp;gt; a b)
     0
     (+ (cube a) (sum-cube (+ a 1)  b))))
(sum-cube 1 3)
;;; 求Pi 值 分数累加
(define (sum-pi a b)
  (if (&amp;gt; a b)
     0
     (+ (/ 1.0 (* a (+ a 2))) (sum-pi (+ a 4) b))))
(sum-pi 1 9)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;观察上面的积分过程
##最终提取出公共的形式 Sum&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;
;; (define (&amp;lt;name&amp;gt; a b)
;;  (if (&amp;gt; a b)
;;  0
;;  (+ (&amp;lt;term&amp;gt; a) (&amp;lt;name&amp;gt; (&amp;lt;next&amp;gt;a) b))))

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;于是我们可以得到&#34;&gt;于是我们可以得到&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;
(define (sum term a next b)
  (if (&amp;gt;  a b)
     0
     (+ (term a) (sum term (next a)  next b))))

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;and-apply-the-sum--to-get-the-sum-integer2-sum-cube2-sum-pi2&#34;&gt;And Apply the sum  to get the sum-integer2 sum-cube2 sum-pi2&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define (sum-integer2 a b) (sum (lambda (x) x) ((lambda (x) (+ x 1)) a) (lambda (x) (+ x 1)) b)) ;;;--&amp;gt;There is some problems

;&amp;gt; (sum-integer2 1 10)
;54  ------------------------&amp;gt;Why
;&amp;gt; (sum-integer 1 10)
;55

(define (identity x) x)
(define (inc x) (+ x 1))
(define (sum-integer3 a b) (sum identity a inc b))
(sum-integer3 1 3)
(define (sum-cube2 a b) (sum cube a inc b))
(sum-cube2 1 3)
(define (sum-pi2 a b) 
  (define (pi-term x)
    (/ 1.0 (* x (+ x 2))))
  (define (pi-next x)
    (+ x 4))
  (sum pi-term a pi-next b))
(sum-pi2 1 9)
(* 8 (sum-pi2 1 1000))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也就是我们现在可以计算积分了！
我们的问题是求解下面的定积分：
















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://jueqingsizhe66.github.io/images/maths/integral.png&#34; alt=&#34;定积分&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;;;;; So now we can do the integrate computing

;;Because integrate will have the same function but different next function
;;;a-b 之间关于f函数的定积分的求法
(define (integral f a b dx)
  (define (add-dx x) (+ x dx))
  (define (update-a a dx) (+ a (/ dx 2.0)))
  (* (sum f (update-a a dx) add-dx b) dx))
(integral cube 0 1 0.01)
(integral cube 0 1 0.001)
(integral cube 0 1 0.0001)
(/ 1 4.0)
(/ (* 1 (cube 1)) 4.0)


;result:
;0.24998750000000042
;0.249999875000001
;0.24999999874993412
;0.25
;0.25

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为了更精确的求解积分，我们使用更为精妙的辛普森积分
















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://jueqingsizhe66.github.io/images/maths/xinpusen1.jpg&#34; alt=&#34;辛普森的抛物线积分方法&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;

















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://jueqingsizhe66.github.io/images/maths/xinpusen2.jpg&#34; alt=&#34;辛普森的数学公式&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;

















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://jueqingsizhe66.github.io/images/maths/xinpusen3.jpg&#34; alt=&#34;最终简化&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;

###包含奇数的两倍 和偶数的四倍，两边不加倍&lt;/p&gt;
&lt;ol start=&#34;0&#34;&gt;
&lt;li&gt;h = (b-a)/n&lt;/li&gt;
&lt;li&gt;yk= f(a+kh) &amp;mdash;&amp;gt; next&lt;/li&gt;
&lt;li&gt;(even? k)  (odd? k)&lt;/li&gt;
&lt;li&gt;y0 =a  yn= b&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;a. 设计的过程遇到的问题是 参数的问题 需要设置k？
b. 中间过程的问题，如何划分三种情况
b.1  k为0和n的情况
b.2  k为奇数的情况
b.3  k为偶数的情况&lt;/p&gt;
&lt;p&gt;最终, 利用Fact的思想 进行求积分&lt;/p&gt;
&lt;p&gt;;;; 下面是一个较为混乱的设计，且没有考虑使用sum&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define (simpson-integral f a b n)
(let ((h (/ (- b a) n))
      (k 0))
(define inc (+ a (* k h)))
(define inc2 (* 2 f(inc)))
(define inc4 (* 4 f(inc)))
  (cond
    ((= k 0) (f a))
    ((= k n) (f b))
    ((even? k) (+ (* 2 f((+ a (* k h))))  
)))

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;补充，好思想:保证最后一个为偶数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define (round-to-next-even x)
 (+ x (remainder x 2))
)

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;于是有了下面较好的版本，思考，之前的Sum其实是已经提供了inc递增的a
以及范围，我们主要的目的就是写好term即可！而
term其实就是涉及到你需要思考的三种情况
之前你之所以回想不清楚，因为你没有斩断念头，term只接受一个参数，
这个参数其实就是你一直想的k，所以simpson-term的一个参数就是k，利用它
开始做文章即可&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define (simpson-integral f a b n)
    (define (round-to-next-even x)  (+ x (remainder x 2)))
    (define fixed-n (round-to-next-even n))
    (define h (/ (- b a) fixed-n))
    (define (simpson-term k) 
      (define y (f (+ a (* k h))))
      (cond 
          ((or (= k 0) (= k fixed-n))
            (* 1 y))
          ((even? k) (* 2 y))
          (else (* 4 y))))
    (* (/ h 3) (sum simpson-term 0 inc fixed-n))
 ))

;(simpson-integral cube 0 1 10)
;1/4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另外还有几种变体，只不过总体思路都在上面类似。&lt;/p&gt;
&lt;p&gt;a1:breaking the problem into four parts: (f y0), (f yn) and two sums,one over even k and another over odd k&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define (another-simpson-integral f a b n) 
   (define h (/ (- b a) n))  
   (define (add-2h x) (+ x (* 2 h))) 
   (* (/ h 3.0) (+ (f a)  
                   (* 4.0 (sum f (+ a h) add-2h (- b h)))  
                   (* 2.0 (sum f (add-2h a) add-2h (- b h)))  
                   (f (+ a (* h n)))))) 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;a2:Here&amp;rsquo;s a version that sums over pairs of terms (2 y_k + 4 y_k+1). No conditionals or special cases are needed anywhere, but there&amp;rsquo;s an extra term [f(b) - f(a)] to be added to the final count.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt; (define (simpson f a b n) 
   (define h (/ (- b a) n)) 
    
   (define (y k) 
     (f (+ a (* k h)))) 
    
   (define (ypair k) 
     (+ (* 2 (y k)) 
        (* 4 (y (+ k 1))))) 
    
   (define (add-2 k) 
     (+ k 2)) 
    
   (* (/ h 3) (+ (sum ypair 0 add-2 (- n 1)) 
                 (- (f b) (f a))))) 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然也可以写成下面的格式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt; (define (sim-integral f a b n) 
     (define h (/ (- a b) n)) 
     (define (y k) (f (+ a (* k h)))) 
     (define (coeff k) (if (is-even? k) 2 4)) 
     (define (part-term k) (* (coeff k) (y k))) 
     (define part-value (sum part-term 1 inc (- n 1))) 
     (* (/ h 3) (+ (y 0) (y n) part-value))) 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;##下面是我重新写的一遍，包含一些计算问题的修正&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;加入了n的修正&lt;/li&gt;
&lt;li&gt;重新认识了simpson算法的，当然还有些问题没有理解，比如f(b)-f(a),
在simpson-anthother-integrate中&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;新的源码如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;
;;; (let &amp;lt;var&amp;gt; &amp;lt;bindings&amp;gt; &amp;lt;body&amp;gt;)

(define (cube x) (* x  x  x))
(define (sum-integer a b)
  (if (&amp;gt; a b)
     0
     (+ a (sum-integer (+ a 1) b))))
(sum-integer 1 10)

(define (sum-cube a b)
  (if (&amp;gt; a b)
     0
     (+ (cube a) (sum-cube (+ a 1) b))))
(sum-cube  1 3)

(define (sum-pi a b)
  (if (&amp;gt; a b)
     0 
     (+ (/ 1.0 (* a (+ a 2))) (sum-pi (+ a 4) b))))
(sum-pi 1 10)
(sum-pi 1 100)

(define (sum term a next b)
  (if (&amp;gt; a b)
     0
     (+ (term a) (sum term  (next a) next b))))

(define (sum-integer2 a b)
  (define (identity x) x)
  (define (inc x) (+ x 1))
  (sum identity a inc b))
(sum-integer2 1 10)

(define (sum-cube2  a b)
  (define (cube x) (* x x x))
  (define (inc x) (+ x 1))
  (sum cube a inc b))
(sum-cube2 1 3)

(define (sum-pi2 a b)
  (define (pi-term x) (/ 1.0 (* x (+ x 2))))
  (define (pi-next x) (+ x 4))
  (sum pi-term a pi-next b))
(sum-pi2 1 10)

(define (integral f a b dx)
  (define const_a (+ a (/ dx 2.0)))
  (define (add_dx x) (+ x dx))
  (* (sum f const_a add_dx b) dx))

(integral cube 0 1 0.001)

(define (simpson-integral f a b n)
  (define (round-to-next-even x) (+ x (remainder x 2)))
  (define fixed-n (round-to-next-even n))
  (define (inc x) (+ x 1))
  (define h (/ (- b a) fixed-n))
  (define (simpson-term k)
    (define y (f (+ a (* h k))))
    (cond 
      ((or (= k 0) (= k fixed-n))
       (*  1  y))
      ((even? k)
       (* 2  y))
      (else (* 4 y))))
 ; (* (/ h 3) (sum simpson-term 0 inc b))) ;;; 0的意思表示从k=0开始,不能写成b，如果写成b表示你没有理解，因为0 fixed-n都代表的是K
  ;;这是次数的说法，而不是代表着a-b之间的求值范围，而是指求职的次数！
 (* (/ h 3) (sum simpson-term 0 inc fixed-n)))
(simpson-integral cube 0 1 10)
(simpson-integral cube 0 1 11)


;;一种变体 思路同上
;; 比较有趣的地方是分为四个节点出
;; 1  f(a)  ----》 y0
;; 2  f(a+h) 奇数的开始地方   add-2h方式累加都是奇数 同时终点是b-h  为什么？因为b在下面被暂用--》把它看待是一个奇数累加的过程 y1 y3 y5
;; 3  f(a+2h) 偶数的开始地方 add-2h方式累加都是偶数 同时终点是b-h--》把它看待是一个偶数累加的过程 y2 y4 y6..
;; 4  f(b)    最后一部分  yn
(define (simpson-another-integral f  a b n)
  (define h (/ (- b a) n))
  (define (add-2h x) (+  x (* 2.0 h)))  ;;; 
  (* (/ h 3.0) (+ (f a)
                          (* 4.0 (sum f (+ a h) add-2h (- b h)))  ;;; (+a h)表示起始点  (- b h) 表示的是终点
                          (* 2.0 (sum f (add-2h a) add-2h (- b h))) ;; 注意这边的(add2h a)表示的是起始点
                          (f (+ a (* h n))))))  ;; 也可以是(f b) 

;&amp;gt; (simpson-another-integral cube 0 1 11)
;0.1782892789654623
;&amp;gt; (simpson-another-integral cube 0 1 12)
;0.2499999999999999&#39;

(define (simpson-another-integral-improve f  a b n)
  (define (round-to-next-even x) (+ x (remainder x 2)))
  (define fixed-n  (round-to-next-even n))
  (define h (/ (- b a) fixed-n))
  (define (add-2h x) (+  x (* 2.0 h)))  ;;; 
  (* (/ h 3.0) (+ (f a)
                          (* 4.0 (sum f (+ a h) add-2h (- b h)))  ;;; (+a h)表示起始点  (- b h) 表示的是终点
                          (* 2.0 (sum f (add-2h a) add-2h (- b h))) ;; 注意这边的(add2h a)表示的是起始点
                          (f (+ a (* h fixed-n)))))) ;;; (f b)的效果是一样  但是不正确！ 现在
  
  (simpson-another-integral cube 0 1 11)
   (simpson-another-integral cube 0 1 12)
    (simpson-another-integral cube 0 1 111);;; 如果是奇数的话，现在解决的办法就是多增加一些计算！
   ;;;;;过程没错！！！ 不知道哪边多加了！
   
    
 (define (simpson-pair-integral f a b n)
   (define (round-to-next-even x) (+ x (remainder x 2)))
   (define fixed-n  (round-to-next-even n))
   (define h (/ (- b a) fixed-n))
   (define (y k) ( f  (+ a (* k h))))
   (define (ypair k)
     (+ (* 2 (y k))
          (* 4 (y (+ k 1)))))
   (define (add-2 k)
     (+ k 2))
   (* (/ h 3) (+ (sum ypair 0 add-2 (- fixed-n 1))  
                (- (f b) (f a)))))  ;;; 为什么是减号  你可以看到这边的思想是抽出中间的偶数对的数据（奇数加上偶数 理当是加起来的)
                                          ;;;因为最后一个  为什么要计算 [f(b) - f(a)] 
 (simpson-pair-integral cube 1 3 1)
 (simpson-pair-integral cube 1 3 2)
 
 ;;;sim-integral 提高版  加入了 round-to-next-even使得计算准确，先前的sim-integral有问题
 (define (sim-integral f a b n)
   (define (round-to-next-even x) (+ x (remainder x 2))) ;;;得加上这个 才可以算准！！
   (define fixed-n  (round-to-next-even n))
   (define h (/ (- b a) fixed-n))
   (define (y k) (f (+ a (* k h))))
   (define (coeff k) (if (even? k) 2 4))
   (define (part-term k) (* (coeff k) (y k)))
   (define (inc x) (+ x 1))
   (define part-value (sum part-term 1 inc (- fixed-n 1)))
   (* (/ h 3) (+ (y 0) (y n) part-value)))
 (sim-integral cube 1 3 10)  ;;; 有问题 已解决
 (sim-integral cube 1 3 11) ;;; 有问题  已解决
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>找出函数的不动点--Navier-Stokes方程</title>
      <link>https://jueqingsizhe66.github.io/archives/zhao-chu-han-shu-de-bu-dong-dian-navier-stokesfang-cheng/</link>
      <pubDate>Tue, 12 May 2015 03:13:50 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/archives/zhao-chu-han-shu-de-bu-dong-dian-navier-stokesfang-cheng/</guid>
      <description>&lt;p&gt;##Beautiful code!&lt;/p&gt;
&lt;p&gt;数x为函数的f的不动点（f可以代表N-S方程），如果满足f(x)=x,则称x
为函数f的不动点。
性质 f(x),f(f(x)),f(f(f(x)))&amp;hellip;., change the x&amp;rsquo;s value if f(x)=x,then
you found!&lt;/p&gt;
&lt;h2 id=&#34;source-code&#34;&gt;Source code&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define tolerance 0.000001)
(define (fixed-point f first-guess)
  (define (close-enough? v1 v2)
    (&amp;lt; (abs (-  v1 v2)) tolerance))
  (define (try guess)
    (let ((next (f guess)))
      (if (close-enough? guess next)
         next
         (try next))))
  (try first-guess))

;;;solve cos(x)=x
(fixed-point cos 1.0)


;;(cos 0.7390855263619245)
;;0.7390848683867142
;;(abs (-  (cos 0.7390855263619245) 0.7390855263619245))
;;6.579752103164083e-07


;;;solve y=siny+cosy   x=f(x) ====&amp;gt; Navier Stokes equation
(fixed-point (lambda (y) (+ (sin y) (cos y))) 1.0)

;;It is what we want!!!
;;;(abs (- ((lambda (y) (+ (sin y) (cos y))) 1.2587277968014188) 1.2587277968014188)) 
;;6.26112570678572e-07


;;;;One method to calculate the square value
;;because x^2 = y  so x = y/x (x =f (x) next we  will use the fixed-point thinking) we should continue change the x&#39;s value!
(define (sqrt-iter guess x)
  (if (good-enough? guess x)
     guess
     (sqrt-iter (improve guess x)
               x)))

(define (square x)
  (* x x))
;;;good-enough? is similar to close-enough？
(define (good-enough? x y)
  (&amp;lt; (abs (- (square x) y)) 0.00001))

;;x^2=y   x=y/x   x+x=y/x+x  x=(y/x+x)/2
(define (improve guess x)
  (average guess (/ x guess)))

(define (mysqrt x)
  (sqrt-iter 1.0 x))


;;(mysqrt 4)
;;2.0000000929222947

;;;Use fixed-point thinking 

(define (mysqrt_death_fixed x)
  (fixed-point (lambda (y) (/ x y))
              1.0))

;;(mysqrt_death_fixed 4)
;;;wrong !!!  can not convenge!!!! why?

;;because   y2= x/y1  y3=x/y2=x/(x/y1)=y1 ====&amp;gt;death recycle===&amp;gt; so we use average

(define (mysqrt_fixed x)
  (fixed-point (lambda (y) (average y (/  x y)))
              1.0))

(mysqrt_fixed 4)

;;;ok fine
;;2.000000000000002====&amp;gt;这也叫做平均阻尼定义！常用于数值计算当中
;;在不动点的搜寻中，作为帮助收敛的手段！！！！
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>折半查找有条件</title>
      <link>https://jueqingsizhe66.github.io/archives/zhe-ban-chao-zhao-you-tiao-jian/</link>
      <pubDate>Tue, 12 May 2015 02:46:03 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/archives/zhe-ban-chao-zhao-you-tiao-jian/</guid>
      <description>&lt;p&gt;You want to solve F(x)=0,
if f(a)&amp;lt;0&amp;lt;f(b), so the value must be inside the [a,b].&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;#lang racket
(define (close-enough? x  y)
  (&amp;lt; (abs (-  x y)) 0.00001))

(define (average a b)
  (/ (+  a b) 2.0))
(define (search f neg-point pos-point)
   (let ((midpoint (average neg-point pos-point)))
     (if (close-enough? neg-point pos-point)
        midpoint
        (let ((test-value (f midpoint)))
          (cond ((positive? test-value)
                 (search f neg-point midpoint))
               ((negative? test-value) 
                (search f midpoint pos-point))
               (else midpoint))))))

;;必须判断一下，如果同号则无法使用折半查找
(define (half-interval-method f a b)
  (let ((a-value (f a))
          (b-value (f b)))
     (cond ((and (negative? a-value) (positive? b-value))
            (search f a b))
          ((and (negative? b-value) (positive? a-value))
           (search f  a b))
          (else
           (error &amp;quot;values are not of opposite sign&amp;quot; a b)))))

(half-interval-method (lambda (x) (- (* x x x) (* 2 x) 3))
                       1.0
                       2.0)
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>So beautiful code</title>
      <link>https://jueqingsizhe66.github.io/archives/so-beautiful-code/</link>
      <pubDate>Tue, 12 May 2015 02:29:11 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/archives/so-beautiful-code/</guid>
      <description>&lt;p&gt;So beautiful&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define (f x y)
(define (f-helper a b)
  (+ (* (square a))
      (* y b)
      (* a b)))
  (f-helper (+ 1 (* x y))
            (- 1 y)))

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;====&amp;gt; f(x,y)=x(1+xy)^2 + y(1-y)+(1+xy)(1-y)
==&amp;gt;  a= 1+xy
b= (1-y)
f(x,y)=xa^2+yb+ab&lt;/p&gt;
&lt;p&gt;====&amp;gt;Continue&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define (f x y)
  ((lambda (a b)
       (+ (* x (square a))
          (* y b)
          (* a b)))
    (+ 1 (* x y))
    (- 1 y)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;====&amp;gt;Use let to define the local variables&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define (f x y)
  (let ((a (+ 1 (* x y)))
         (b (- 1 y)))
       (+ (* x (square a))
          (* y b)
          (* a b))))

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;let is just the coat of the ((lambda (a b))&lt;/p&gt;
&lt;p&gt;Of course we can use define&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define (f x y)
   (define a (+ 1 (* x y)))
   (define b (- 1 y))
 (+ (* x (square a))
    (* y b)
    (* a b)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;SICP_P42&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
