<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>学术 | 30年磨一剑</title>
    <link>https://jueqingsizhe66.github.io/category/%E5%AD%A6%E6%9C%AF/</link>
      <atom:link href="https://jueqingsizhe66.github.io/category/%E5%AD%A6%E6%9C%AF/index.xml" rel="self" type="application/rss+xml" />
    <description>学术</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><copyright>©2020</copyright><lastBuildDate>Mon, 05 Oct 2015 10:04:47 +0800</lastBuildDate>
    <image>
      <url>https://jueqingsizhe66.github.io/images/icon_hua2ec155b4296a9c9791d015323e16eb5_11927_512x512_fill_lanczos_center_2.png</url>
      <title>学术</title>
      <link>https://jueqingsizhe66.github.io/category/%E5%AD%A6%E6%9C%AF/</link>
    </image>
    
    <item>
      <title>基于现实，抽象现实，模拟现实</title>
      <link>https://jueqingsizhe66.github.io/blog/2015/10/05/ji-yu-xian-shi-chou-xiang-xian-shi-mo-ni-xian-shi/</link>
      <pubDate>Mon, 05 Oct 2015 10:04:47 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/blog/2015/10/05/ji-yu-xian-shi-chou-xiang-xian-shi-mo-ni-xian-shi/</guid>
      <description>&lt;p&gt;信息与知识的不同在于，信息是暂时不被理解的知识，而当它被理解，并被组织，他也就成了知识。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;你的课题是什么&#34;&gt;你的课题是什么？&lt;/h2&gt;
&lt;p&gt;不再是老师布置的题目，而是基于现实，充分调研，提取你需要的信息，
进行分布式抽象，合理分类，构建知识系统，从而模拟你所expected的现实，
来论证理论……&lt;/p&gt;
&lt;p&gt;知识的存在就因为被interpreted or made sense,namely some what happened
have been interpreted and compared ,finnalys tored into your knowledge
system in the memory(in your head not in the world),更进一步可以阅读
《The Design of Everyday Things》.&lt;/p&gt;
&lt;h2 id=&#34;获取知识的途径&#34;&gt;获取知识的途径？&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;A goal &amp;ndash;&amp;gt;    Your expected things.What do you want?&lt;/li&gt;
&lt;li&gt;B plan &amp;ndash;&amp;gt;    what&amp;rsquo;s your actions to get what you want&lt;/li&gt;
&lt;li&gt;C specify  &amp;ndash;&amp;gt; what action can I do now? Design a conceptual model&lt;/li&gt;
&lt;li&gt;D perform  &amp;ndash;&amp;gt; How do I do it! Get affordance to execute the action&lt;/li&gt;
&lt;li&gt;E perceive &amp;ndash;&amp;gt; What happened after you done the action?&lt;/li&gt;
&lt;li&gt;F interpret &amp;ndash;&amp;gt; explain what happened?&lt;/li&gt;
&lt;li&gt;G compare   &amp;ndash;&amp;gt; it is okay? is it what you want? compare with what you want?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;BCD&lt;/code&gt; is called the stage of execute while &lt;code&gt;EFG&lt;/code&gt; is called the stage of evaluation. Also ,you can call &lt;code&gt;BCD&lt;/code&gt; stage as FeedForward which aid in understanding the process of what can you do.And &lt;code&gt;EFG&lt;/code&gt; stage can be also looked at as FeedBack stage which aid in understanding the process of what happened.&lt;/p&gt;
&lt;p&gt;In the stage of perceive, you can use some signifiers such as light,colors etc in order to communicate with people sucessfully.
In the stage of interpret, it means mapping the knowledge.&lt;/p&gt;
&lt;h2 id=&#34;大量文章的阅读方法&#34;&gt;大量文章的阅读方法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;前言（引言）的第三段讲述作者为什么要进行这项工作、依据、方法（可能一些结果）&lt;/li&gt;
&lt;li&gt;文章中的图表（提出的表征方法和性能变化）&amp;ndash;技术手段&amp;ndash;研究路线&lt;/li&gt;
&lt;li&gt;结论（这些表征方法是否实现了既定的目标以及是否还需要优化（产物的性能怎么样？模拟的精度？未发现的自然现象？）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;摘要的阅读方法&#34;&gt;摘要的阅读方法&lt;/h2&gt;
&lt;p&gt;一般分为三句话。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一句话对应引言第一段。比如说某个东西多NB。&lt;/li&gt;
&lt;li&gt;第二句化对应引言第二段。这个NB东西的工作机理激发了我们设计新的方案的灵感&lt;/li&gt;
&lt;li&gt;第三句话对应Here we report。。回答四个问题&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;我们到底做了什么？&lt;/li&gt;
&lt;li&gt;怎么做的?&lt;/li&gt;
&lt;li&gt;为什么能做到？&lt;/li&gt;
&lt;li&gt;结果怎么样？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;想把一个研究工作讲成一个好故事，最关键式该工作取得好的结果。上述过程也满足
SQCA原则，SQCA（situations&amp;mdash;conflict&amp;ndash;Questions&amp;mdash;Answers),很多人针对situations和conflicts基本上都不按章出牌。&lt;/p&gt;
&lt;p&gt;这些都是前人的一些经验，加油你的topic。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Incompact3d的Makefile及DNS算法</title>
      <link>https://jueqingsizhe66.github.io/blog/2015/06/22/incompact3dde-makefileji-dnssuan-fa/</link>
      <pubDate>Mon, 22 Jun 2015 16:52:20 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/blog/2015/06/22/incompact3dde-makefileji-dnssuan-fa/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://code.google.com/p/incompact3d&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Incompact3d&lt;/a&gt;是一个开源的基于fortran语言编写的DNS求解器，也是我研究生期间使用的开源源代码。
Incompact3d整体框架的介绍可以参考软件的&lt;a href=&#34;https://code.google.com/p/incompact3d/downloads/detail?name=user_guide_incompact3d_V1-1.pdf&amp;amp;can=2&amp;amp;q=&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;user-guide&lt;/a&gt;和文献&lt;a href=&#34;http://www.imperial.ac.uk/media/imperial-college/research-centres-and-groups/turbulence-mixing-and-flow-control-group/2009_LAIZET_JCP.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;High-order-compact schemes for incompressible flows: a simple and effcient method with the quasi-spectral accuary&lt;/a&gt;,还可以搜索&lt;a href=&#34;http://www.imperial.ac.uk/tmfc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;sylvain Laziet&lt;/a&gt; 相关的文章 ，只不过他并不是成熟的软件，很多的编译和后处理都可能出现问题，下面是我使用过程遇到的一些问题。
当然主要过程是，通过makefile编译，然后运行incompact3d，最后处理计算结果。&lt;/p&gt;
&lt;p&gt;#1 如何模拟？&lt;/p&gt;
&lt;p&gt;以周期性槽道流动(当然我也就会这么一种，其他都只是走了一小半）为例。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先是得到(不得不说，我也有点忘记)一个完全发展的旋转槽道流动(注意旋转源项的添加) (一般设置20000步可以了，只要收敛即可 大概一天)&lt;/li&gt;
&lt;li&gt;然后是获得完全发展槽道流动(也就是不加上旋转源项)(估计得三万步以上 大概一天)&lt;/li&gt;
&lt;li&gt;最后是获得统计的完全发展槽道流动.因为DNS获得的结果是非定常的，所以你得进行时均处理(当然时均程序得打开时均统计项 umean等)(我统计了20万步，大概花了4天时间。)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;步骤就是这样,大概一个较小的流程需要一周左右。&lt;/p&gt;
&lt;p&gt;Incompact3d比较特殊的是收敛性判定问题，上面的几个过程都需要使用实时&lt;a href=&#34;http://jueqingsizhe66.github.io/blog/2015/05/31/u-plus-y-plus/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;监控小程序&lt;/a&gt;
来观看速度散度和质量流量(质量流量是周期性槽道流动所特有的，所以最好进行实时显示)的收敛情况.另外你可以通过python的一个小脚本
来获得实时显示的图片，这样就能看到程序模拟得怎么样了，具体查看&lt;a href=&#34;http://jueqingsizhe66.github.io/blog/2015/06/11/ji-yu-pythonde-ju-yu-wang-wen-jian-gong-xiang-ruan-jian-simplehttpserverwithupload/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;python局域网上传和下载&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;#2 后处理方法
参考我的&lt;a href=&#34;http://jueqingsizhe66.github.io/blog/2015/06/22/incompact3dru-he-tong-guo-jie-guo-chu-li-chu-ji-xian&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;pathline处理方法&lt;/a&gt;
一定要注意(real 8) 否则得到的结果肯定是错误的，这也是困扰我几星期的问题。&lt;/p&gt;
&lt;p&gt;#3 关于Makefile编译&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;#=======================================================================
# Makefile for Imcompact3D
#=======================================================================

# Choose pre-processing options
#   -DSHM	   - enable shared-memory implementation
#   -DDOUBLE_PREC  - use double-precision
OPTIONS = -DDOUBLE_PREC

# Choose an FFT engine, available options are:
#   essl       - IBM Blue Gene ESSL Library
#   fftw3      - FFTW version 3.x
#   generic    - A general FFT algorithm (no 3rd-party library needed)
#FFT= essl # I ignore
FFT = generic

# Paths to FFTW 3
FFTW3_PATH=   # full path of FFTW installation if using fftw3 engine above
FFTW3_INCLUDE = -I$(FFTW3_PATH)/include
FFTW3_LIB = -L$(FFTW3_PATH)/lib -lfftw3 -lfftw3f

# Paths to ESSL
ESSL_PATH=/bgsys/drivers/ppcfloor/comm/xl
ESSL_INCLUDE =
ESSL_LIB = -L$(ESSL_PATH)/lib -L/opt/ibmmath/lib64 -lesslbg

# Specify Fortran and C compiler names and flags here
# Normally, use MPI wrappers rather than compilers themselves 
# Supply a Fortran pre-processing flag together with optimisation level flags
# Some examples are given below:

#FC =  
#OPTFC = 
#CC = 
#CFLAGS = 

# PGI
#FC = ftn
#OPTFC = -fast -O3 -Mpreprocess
#CC = cc
#CFLAGS = -O3

# PathScale
#FC = ftn
#OPTFC = -Ofast -cpp
#CC = cc
#CFLAGS = -O3

# GNU 选用mpif90进行编译
FC = mpif90
OPTFC = -O0 -g  -fdefault-real-8 -fdefault-double-8 -funroll-loops -ftree-vectorize -fcray-pointer -cpp
CC = mpicc
CFLAGS = -O0
PLATFORM=gnu

#Blue Gene/Q : EDF R&amp;amp;D
#PREP=/bgsys/drivers/ppcfloor/comm/xl/bin/
#FC = $(PREP)mpixlf95_r
#OPTFC= -O3 -qsuffix=cpp=f90 -qinitauto -qautodbl=dbl4
##OPT_LK= -O3 -qinitauto -qautodbl=dbl4
#CFLAGS= -O3 -qinitauto -qautodbl=dbl4
#CC=$(PREP)mpixlc_r
#PLATFORM=bgq_xlf

# Cray
#FC = ftn
#OPTFC = -e Fm
#CC = cc
#CFLAGS = 

#-----------------------------------------------------------------------
# Normally no need to change anything below

# include PATH 
ifeq ($(FFT),generic)
  INC=
else ifeq ($(FFT),fftw3)
  INC=$(FFTW3_INCLUDE)
else ifeq ($(FFT),essl)
  INC=$(ESSL_INCLUDE)
endif

# library path
ifeq ($(FFT),generic)
   LIBFFT=
else ifeq ($(FFT),fftw3)
   LIBFFT=$(FFTW3_LIB)
else ifeq ($(FFT),essl)
   LIBFFT=$(ESSL_LIB)
endif

# List of source files
# 注意这边编译的模块，一般是需要的mod生成放在前面首先编译，如果不放前面会报错，解决办法 就是文件名放在前面即可,具体可以查看关于Makefile Fortran
SRC = decomp_2d.f90 glassman.f90 fft_$(FFT).f90 module_param.f90 io.f90 variables.f90 poisson.f90 schemes.f90 implicit.f90 convdiff.f90 user_module.f90 incompact3d.f90 navier.f90 derive.f90 parameters.f90 tools.f90 visu.f90

#-----------------------------------------------------------------------
# Normally no need to change anything below

ifneq (,$(findstring DSHM,$(OPTIONS)))
SRC := FreeIPC.f90 $(SRC)  
OBJ =	$(SRC:.f90=.o) alloc_shm.o FreeIPC_c.o
else
OBJ =	$(SRC:.f90=.o)
endif	

OPTION=$(OPTIONS)
from:=-D
to:=-WF,-D
TMP=$(subst $(from),$(to),$(OPTIONS))
ifeq ($(PLATFORM),bgp_xlf)
   OPTION=$(TMP)
endif
ifeq ($(PLATFORM),bgq_xlf)
   OPTION=$(TMP)
endif

all: incompact3d

alloc_shm.o: alloc_shm.c
	$(CC) $(CFLAGS) -c $&amp;lt;

FreeIPC_c.o: FreeIPC_c.c
	$(CC) $(CFLAGS) -c $&amp;lt;

incompact3d : $(OBJ)
	$(FC) -O0 -g -o $@ $(OBJ) $(LIBFFT)

%.o : %.f90
	$(FC) $(OPTFC) $(OPTION) $(INC) -c $&amp;lt;

.PHONY: clean 
clean:
	rm -f *~ *.o *.mod incompact3d

.PHONY: realclean
realclean: clean
	rm -f *~ \#*\#
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行方式:
我的电脑刚好是8线程，就用8线程运行，你也可以选用4或者更多.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;mpirun -np 8  incompact3d  &amp;gt; tail.out &amp;amp;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;#4 The Algorithm of the DNS in Incompact3d&lt;/p&gt;
&lt;p&gt;Incompact3d的执行流程基本上是下面几个(当然得仔细阅读，并反复比对).我写得这段英文大体能够对得上.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;1. Initial the velocity field with noise(init subroutine).
2. Start the iterative process by guessing the pressure field. First we use convdiff subroutine take convection and diffusion of the flow into consideration.And then use pre_correc subroutine to correction the velocity value with the specified boundary condition.
3. Use the values of u,v,and w to get the initialize of the pp3 in the spectral space from subroutine divergence(…pp3,1…)(first sign to turbulent spot).Then we use poisson solver decomp_2d_poisson_stag to get the value of the pp3 in the spectral space.
4. Since they were obtained from the guessed values of u,v,w,the values pp3,when substituted into the divergence equation,will not necessarily satisfy that that equation.Hence ,using the gradp subroutine,get the pressure gradients in the physics space,then using corgp subroutine ,get the velocity correction by the pressure gradient in the physics space.Use subroutine divergence(…dv3,2…) to do another monitor for turbulent spot(second sign to turbulent spot) .At the end of the current step, we go to step2 again until the simulation have been fully developed.
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Incompact3d如何通过结果处理出迹线</title>
      <link>https://jueqingsizhe66.github.io/blog/2015/06/22/incompact3dru-he-tong-guo-jie-guo-chu-li-chu-ji-xian/</link>
      <pubDate>Mon, 22 Jun 2015 16:20:48 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/blog/2015/06/22/incompact3dru-he-tong-guo-jie-guo-chu-li-chu-ji-xian/</guid>
      <description>&lt;p&gt;Incompact3D获得的数据都是二进制的数据文件，为了获得内部的文件
需要进一步通过编程获得，下面是一个获得pathline的源代码。&lt;/p&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过 module.f90文件读取 nx ny nz的值&lt;/li&gt;
&lt;li&gt;把下面的源代码编译并放在ux uy uz所在的文件夹当中&lt;/li&gt;
&lt;li&gt;进一步的相关信息，可以参考注释。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-fortran&#34;&gt;PROGRAM b
IMPLICIT NONE
Integer,parameter :: nx=128,ny=129,nz=84 
INTEGER :: I,J,K,COUNT,LN=128,COL=129,VOL=84
REAL(8),DIMENSION(nx,ny,nz) :: ux,uy,uz
CHARACTER(len=12)::NAME1=&amp;quot;Incompact3d&amp;quot;,NAME2=&amp;quot;ux&amp;quot;,NAME3=&amp;quot;uy&amp;quot;,NAME4=&amp;quot;uz&amp;quot;
character(len=15) :: temp,temp1,temp2,temp3
CHARACTER(len=20) :: CFILEux
integer :: num

real,dimension(nx):: y1
real,dimension(ny):: y2
real,dimension(nz):: y3

!generation of the mesh
do i=1,nx
   y1(i)=(i-1)*0.098174770425 !0.8 is DX ! incompact3d.prm的配置长度除以网格尺度即可。
enddo


do j=1,ny
   y2(j)=(j-1)*0.015503875968992248 !0.8 is DY
enddo


do k=1,nz
   y3(k)=(k-1)*0.04986655005702381!0.8 is DZ
enddo


! 下面只是对于读取文件进行的一个后处理，只是为了方便批处理而已
22 format(I1)
23 format(I2)
DO num=1,30
    if(num .lt. 10) then
        write(temp,22) num
        temp1 =trim(NAME2)//trim(&#39;00&#39;)//trim(temp)
        temp2 =trim(NAME3)//trim(&#39;00&#39;)//trim(temp)
        temp3 =trim(NAME4)//trim(&#39;00&#39;)//trim(temp)
    else 
        write(temp,23) num
        temp1 =trim(NAME2)//trim(&#39;0&#39;)//trim(temp)
        temp2 =trim(NAME3)//trim(&#39;0&#39;)//trim(temp)
        temp3 =trim(NAME4)//trim(&#39;0&#39;)//trim(temp)
    end if
    
! 产生实际的文件名
CFILEux=trim(&#39;./pathchange/&#39;)//trim(temp1)//&#39;.dat&#39;
!read the ux 读取ux00*的数据
OPEN(10,FILE=temp1,FORM=&#39;UNFORMATTED&#39;,&amp;amp;
ACCESS=&#39;DIRECT&#39;, RECL=8, STATUS=&#39;OLD&#39;)

! read the uy
OPEN(11,FILE=temp2,FORM=&#39;UNFORMATTED&#39;,&amp;amp;
ACCESS=&#39;DIRECT&#39;, RECL=8, STATUS=&#39;OLD&#39;)
!read the uz
OPEN(12,FILE=temp3,FORM=&#39;UNFORMATTED&#39;,&amp;amp;
ACCESS=&#39;DIRECT&#39;, RECL=8, STATUS=&#39;OLD&#39;)

! 新建一个结果文件，并添加上tecplot的数据头

OPEN(20,FILE=CFILEux,FORM=&#39;FORMATTED&#39;)
WRITE (20,&#39;(A6,A12)&#39;)               &#39;TITLE=&#39;,TRIM(ADJUSTL(NAME1))
 WRITE (20,&#39;(A36)&#39;)    &#39;VARIABLES=&amp;quot;X&amp;quot;,&amp;quot;Y&amp;quot;,&amp;quot;Z&amp;quot;,&amp;quot;VX&amp;quot;,&amp;quot;VY&amp;quot;,&amp;quot;VZ&amp;quot;&#39;
      WRITE (20,&#39;(A7,I4,A1,A2,I4,A1,A2,I4,A1,A7)&#39;) &#39;ZONE I=&#39;,LN,&#39;,&#39;,&#39;J=&#39;,COL,&#39;,&#39;,&#39;K=&#39;,VOL,&#39;,&#39;,&#39;F=POINT&#39;

COUNT = 1
DO K=1,nz
    DO J=1,ny
        DO I=1,nx
            READ(10,REC=COUNT) ux(I,J,K)
            READ(11,REC=COUNT) uy(I,J,K)
            READ(12,REC=COUNT) uz(I,J,K)
        !    WRITE(20,30) I,J,K,ux(I,J,K),uy(I,J,K),uz(I,J,K)
             WRITE(20,30) y1(i),y2(j),y3(k),ux(I,J,K),uy(I,J,K),uz(I,J,K)
            30 format(I3,1X,I3,1X,I3,1X,E11.4,1x,E11.4,1x,E11.4)
            COUNT = COUNT + 1
        ENDDO
    ENDDO
ENDDO
ENDDO
CLOSE(10)
CLOSE(11)
CLOSE(10)
CLOSE(20)
END PROGRAM b
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
  </channel>
</rss>
