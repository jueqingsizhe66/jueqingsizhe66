<!DOCTYPE html><html lang="en-us"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="generator" content="Source Themes Academic 4.5.0"><meta name="author" content="Ye Zhaoliang"><meta name="description" content="一张来自fcode的有趣的静态和动态链接的比喻图，


静态库是需要直接和exe文件打包在一起的，而动态库则是需要运行的时候才执行dll文件，
dll文件也是一个exe文件，只不过只能由对应的exe文件执行，无法人工执行。


1. 静态链接
2. 动态链接
3. 两者比较
4. fortran与c混编
"><link rel="alternate" hreflang="en-us" href="/images/fortrandebug/%E4%B8%80%E7%AF%87%E6%9C%89%E8%B6%A3%E7%9A%84fortran%E9%9D%99%E6%80%81%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/"><meta name="theme-color" content="#2962ff"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.8.6/css/academicons.min.css" integrity="sha256-uFVgMKfistnJAfoCUQigIl+JfUaP47GrRKjf6CTPVmw=" crossorigin="anonymous"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.0/css/all.css" integrity="sha384-aOkxzJ5uQz7WBObEZcHvV5JvRW3TUc2rNPA7pe3AwnsUohiw1Vj2Rgx2KSOkF5+h" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" integrity="sha256-ygkqlh3CYSUri3LhQxzdcm0n1EQvH2Y+U5S2idbLtxs=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/github.min.css" crossorigin="anonymous" title="hl-light"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/github.min.css" crossorigin="anonymous" title="hl-dark" disabled="disabled"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.2.0/leaflet.css" integrity="sha512-M2wvCLH6DSRazYeZRIm1JnYyh22purTM+FDB5CsyxtQJYeKq83arPe5wgbNmcFXGqiSH2XR8dT/fJISVA1r/zQ==" crossorigin="anonymous"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Montserrat:400,700%7CRoboto:400,400italic,700%7CRoboto+Mono&display=swap"><link rel="stylesheet" href="/css/academic.min.e8d4d5fd376e67b34452ebe1cae16341.css"><link rel="manifest" href="/index.webmanifest"><link rel="icon" type="image/png" href="/img/icon-32.png"><link rel="apple-touch-icon" type="image/png" href="/img/icon-192.png"><link rel="canonical" href="/images/fortrandebug/%E4%B8%80%E7%AF%87%E6%9C%89%E8%B6%A3%E7%9A%84fortran%E9%9D%99%E6%80%81%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/"><meta property="twitter:card" content="summary"><meta property="twitter:site" content="@jueqingsizhe66"><meta property="twitter:creator" content="@jueqingsizhe66"><meta property="og:site_name" content="Macro Life"><meta property="og:url" content="/images/fortrandebug/%E4%B8%80%E7%AF%87%E6%9C%89%E8%B6%A3%E7%9A%84fortran%E9%9D%99%E6%80%81%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/"><meta property="og:title" content=" | Macro Life"><meta property="og:description" content="一张来自fcode的有趣的静态和动态链接的比喻图，


静态库是需要直接和exe文件打包在一起的，而动态库则是需要运行的时候才执行dll文件，
dll文件也是一个exe文件，只不过只能由对应的exe文件执行，无法人工执行。


1. 静态链接
2. 动态链接
3. 两者比较
4. fortran与c混编
"><meta property="og:image" content="/img/icon-192.png"><meta property="twitter:image" content="/img/icon-192.png"><meta property="og:locale" content="en-us"><title> | Macro Life</title></head><body id="top" data-spy="scroll" data-offset="70" data-target="#TableOfContents"><aside class="search-results" id="search"><div class="container"><section class="search-header"><div class="row no-gutters justify-content-between mb-3"><div class="col-6"><h1>Search</h1></div><div class="col-6 col-search-close"><a class="js-search" href="#"><i class="fas fa-times-circle text-muted" aria-hidden="true"></i></a></div></div><div id="search-box"> <input name="q" id="search-query" placeholder="Search..." autocapitalize="off" autocomplete="off" autocorrect="off" spellcheck="false" type="search"></div></section><section class="section-search-results"><div id="search-hits"></div></section></div></aside><nav class="navbar navbar-light fixed-top navbar-expand-lg py-0 compensate-for-scrollbar" id="navbar-main"><div class="container"> <a class="navbar-brand" href="/">Macro Life</a> <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation"><span><i class="fas fa-bars"></i></span></button><div class="collapse navbar-collapse" id="navbar"><ul class="navbar-nav mr-auto"><li class="nav-item"> <a class="nav-link" href="/#hero"><span>Demo</span></a></li><li class="nav-item"> <a class="nav-link" href="/#posts"><span>博客</span></a></li><li class="nav-item"> <a class="nav-link" href="/#projects"><span>项目</span></a></li><li class="nav-item"> <a class="nav-link" href="/#featured"><span>Publications</span></a></li><li class="nav-item"> <a class="nav-link" href="/about/"><span>About</span></a></li><li class="nav-item"> <a class="nav-link" href="/courses/"><span>课程</span></a></li><li class="nav-item"> <a class="nav-link" href="/archives"><span>Archives</span></a></li></ul><ul class="navbar-nav ml-auto"><li class="nav-item"><a class="nav-link js-search" href="#"><i class="fas fa-search" aria-hidden="true"></i></a></li><li class="nav-item"><a class="nav-link js-dark-toggle" href="#"><i class="fas fa-moon" aria-hidden="true"></i></a></li></ul></div></div></nav><article class="article"><div class="article-container pt-3"><h1></h1><div class="article-metadata"> <span class="article-date">Jan 1, 0001</span></div></div><div class="article-container"><div class="article-style"><p>一张来自<a href="http://fcode.cn/" target="_blank">fcode</a>的有趣的静态和动态链接的比喻图， <img src="/images/fortrandebug/usb.png" alt="staticdy"></p><p>静态库是需要直接和exe文件打包在一起的，而动态库则是需要运行的时候才执行dll文件， dll文件也是一个exe文件，只不过只能由对应的exe文件执行，无法人工执行。</p><ul><li><a href="#static">1. 静态链接</a></li><li><a href="#dynamic">2. 动态链接</a></li><li><a href="#compare">3. 两者比较</a></li><li><a href="#hun">4. fortran与c混编</a></li></ul><h2 id="static">静态链接</h2><p>静态库lib,实际上是obj文件的集合，可认为是打包在一起的若干obj，</p><p>因此他的编译过程为：</p><ol><li><font color="red">编译子程序(f90)源代码，得到若干obj文件</font></li><li><font color="red">打包这些obj文件，成为<strong>lib静态库</strong></font></li></ol><p>他的使用比较简单：</p><p><font color="red">编译主程序(或其他子程序),链接时，<strong>带上lib</strong>文件即可</font>。</p><hr><p><font color="red"><strong>注意</strong></font><br> 在上面的f90源代码中可能包含了module片段。若干静态库中使用了module,那么编译还会产生mod内件。 <font color="green">每一个module对应一个同名的mod文件。</font></p><p>mod是什么？ mod文件可认为是module的&rdquo;概述&rdquo;,与c语言的&rdquo;头文件&rdquo;的做哟个相似，但与C语言需要自己书写头文件不同， fortran的mod文件由编译器<font color="red"><strong>自动生成</strong></font>。</p><p>也就是说，当<code>use Module</code>时，编译器需<strong>能够</strong>找到对应的mod文件。因此有必要把静态库里产生的mod文件 保存起来，以便使用静态库时加载(<font color="red"><strong>mod文件一定得在lib目录下,这点很容易被遗忘。</strong></font>。</p><hr><p><font color="green">提前准备公用的源代码:</font></p><p>sub.90:</p><pre><code class="language-fortran">Subroutine sub()
  write(*,*) 'Xueqiu is a good man!'
End Subroutine sub

</code></pre><p>func.f90:</p><pre><code>MODULE FUNCMOD
  IMPLICIT NONE

CONTAINS

  INTEGER FUNCTION FUNC()
    WRITE(*,*) 'THIS IS A FUNC!'
    FUNC = 1
  END FUNCTION FUNC
END MODULE FUNCMOD

</code></pre><p>main.f90:</p><pre><code>Program testLib
  use funcmod
  Implicit None
  integer :: i
  i = func()
  call sub()
End Program testLib

</code></pre><hr><hr><hr><h3> gfortran技术解决方案</h3><ul><li><p>第一步: 编译生成obj[和mod] 文件,</p><pre><code>gfortran -c sub.f90 func.90
</code></pre></li></ul><p>生成文件列表如下:</p><pre><code>funcmod.mod
func.o
sub.o
</code></pre><ul><li><p>第二步: 然后再打包obj文件到lib文件</p><pre><code>ar rv my.lib func.o sub.o
</code></pre></li></ul><p>然后你现在就可以删掉func.o sub.o了(<code>rm -rf func.o sub.o</code>), 因为他们包含在my.lib中.</p><ul><li><p>第三步: 编译主文件，</p><pre><code>gfortran -c main.f90
gfortran main.o my.lib -o main.exe
</code></pre></li></ul><p>这样就会生成对应的main.exe了。</p><hr><hr><hr><h3> vs2015+ivf2017的技术解决方案:</h3><ul><li>第一步:</li></ul><p>新建一个static library项目,并添加sub.f90,func.f90到source文件夹下。</p><p><img src="/images/fortrandebug/static/1.png" alt="static"></p><ul><li>第二步: 生成解决方案</li></ul><p><img src="/images/fortrandebug/static/2.png" alt="static2"> 这样就在debug目录下得到*.lib文件</p><p>注意：链接需要二个文件*.obj 和*.mod文件，而myfirstLib.lib仅仅是把*.obj打包了一下，所以 还得再ivf的<font color="red"><strong>Additional Include</strong></font>中添加mod文件路径</p><ul><li>第三步:</li></ul><p>新建一个testLib console(/subsystem:console )的项目 用于测试myfirstlib</p><p><img src="/images/fortrandebug/static/3.png" alt="test"> 注意由于在一个解决方案中存在多个项目所以得把test(包含主程序)设置为<font color="red">启动项目</font>。 <img src="/images/fortrandebug/static/4.png" alt="启动"></p><ul><li>第四步:</li></ul><p>编译，生成解决方案。<font color="red"><strong>报错了</strong></font><br>。 <img src="/images/fortrandebug/static/5.png" alt="error"> 原因是没有找到*.o(func.o)包含的mod文件，解决方法是<font color="red">添加mod路径到additional include directories</font> <img src="/images/fortrandebug/static/6.png" alt="correct"></p><p>还有一个问题，我一般还需要<font color="red">生成的lib文件放在source目录下</font>，才可以编译成功，这点也需要小心。</p><p><font color="red"><strong>总结</strong></font> 设置lib路径的时候，在存在mod文件时候，一定得一同存在，否则未可能报符号丢失的错误。</p><hr><hr><hr><h2 id="dynamic"> 动态链接</h2><p>动态库DLL,实际上也是可执行文件，与exe本质上是一样的。只不过dll通常 没有主程序而已（自己不能运行，只能由对应的主程序运行),他必须由exe在运行以后调用。</p><p>DLL的好处? 具有良好的可维护性，节约内存等特点。在windows(dll)，linux(so),mac等操作系统上，都 大量使用了DLL动态库。</p><p>动态链接库dll的编译过程是:</p><ol><li>编译子程序源代码，得到若干obj文件。</li><li>链接这些obj文件，得到dll文件（有可能带lib文件，如果是静态加载则无lib，如果是动态加载则有lib）</li><li>部分平台的编译器会得到导入库lib</li></ol><p>他的使用由两种方法(显示调用(动态),隐式调用(静态)):</p><ol><li>编译主程序(或其他子程序),链接时，带上导入库lib文件。</li><li>动态的利用系统函数加载DLL,如windows下的LoadLibrary和GetProcAddress。</li></ol><hr><hr><p>提前准备好公用的fortran源代码：</p><p><font color="red">sub.f90:</font></p><pre><code class="language-fortran">Subroutine sub()
  !DEC$ ATTRIBUTES DLLEXPORT,ALIAS:&quot;sub&quot;::sub
  write(*,*) 'Xueqiu is a good man!'
End Subroutine sub

</code></pre><p><strong>注意，!DEC$ ATTRIBUTES DLLEXPORT, ALIAS:&ldquo;sub&rdquo;::sub，是有用的exe间的符号对接。</strong></p><p><font color="red">func.f90:</font></p><pre><code class="language-fortran">
Module funcmod
  Implicit none

contains

  Integer Function func()
    !DEC$ ATTRIBUTES DLLEXPORT,ALIAS:&quot;func&quot;::func
    write(*,*) 'This is a func!'
    func = 1
  End Function func
End Module funcmod

</code></pre><p><strong>注意，!DEC$ ATTRIBUTES DLLEXPORT, ALIAS:&ldquo;func&rdquo;::func，是有用的exe间的符号对接。</strong></p><p><font color="red">main.f90:</font>&gt;</p><pre><code class="language-fortran">Program testDll
  use funcmod
  Implicit None
  integer :: i
  i = func()
  call sub()
End Program testDll

</code></pre><h3> gfortran的技术解决方案:</h3><ul><li><p>第一步: 生成so文件(linux下面)</p><pre><code>gfotran sub.f90 func.f90 -shared -fPIC -o libmy.so
</code></pre></li><li><p>第二步: 直接引用即可</p><pre><code>gfortran main.f90 libmy.so -o main.exe
</code></pre></li><li><p>第三步:直接运行main.exe 有可能报错，在linux下可能需要 <code>export LD_LIBRARY_PATH=./</code> 也就是把当前目录也当作查找so文件的一个地方。</p></li></ul><h3> vs2015+ivf2017的技术解决方案:</h3><ul><li>第一步：新建一个Dll project 然后类似静态的方法，把func.f90,sub.f90当作一个项目，再新建一个testDll项目，并添加lib等，也要include进来目录 比如， <img src="/images/fortrandebug/dll/main.png" alt="main">再次基础上，在添加include路径（把mod文件添加进来） <img src="/images/fortrandebug/dll/include.png" alt="include"></li></ul><p>在运行的时候有可能出现运行错误<img src="/images/fortrandebug/dll/error.png" alt="error">,这时候需要在Working Directory添加 运行dll路径， <img src="/images/fortrandebug/dll/dll.png" alt="dll">,</p><h2 id="compare"> 动态链接的静态加载和动态加载</h2><p><font color="blue">总之，静态库lib和动态库dll，是很多第三方库的主要形式。因此他们是学习第三方 函数库的基础知识，也是学习多种语言混编的基础。</font></p><ul><li><p>静态加载和动态加载的区别:</p></li><li><p>静态加载:不依赖ifort的运行库（可以到没有安装ifort的机器 上运行dll文件） dll文件比较大</p></li><li><p>dll加载 :则会依赖ifort的运行库（dll比较小，但是如果没有ifort运行库 则会报dll错误（所以一般拷贝到别的机子的dll都是静态加载的 可采用depends walker这个软件，查看内部的dll信息。</p></li></ul><p>而我们可以用一张十分perfect的比较图，看出动态链接库的两种加载方式的不同，以及动态和静态的区别(10元) <img src="/images/fortrandebug/dynamicstatic.png" alt="dynamicstatic"></p><p>注意动态函数(subroutine)比静态多了一行<code>!DEC$ ATTRIBUTE DLLEXPORT,ALIAS:...</code></p><ul><li><p>动态加载例子 <img src="/images/fortrandebug/dll/load.png" alt="动态加载"></p><pre><code class="language-fortran">Module LoadDLL
Implicit None
Interface
FUNCTION GetProcAddress( hModule, lpProcName)
  !DEC$ ATTRIBUTES DEFAULT, STDCALL, DECORATE, ALIAS:'GetProcAddress' :: GetProcAddress
  use ISO_C_Binding
  type( C_FUNPTR ) :: GetProcAddress
  integer hModule
  character(C_CHAR) , dimension(*) :: lpProcName
END FUNCTION GetProcAddress
    
Integer Function F_func()
End Function F_func
    
Subroutine F_Sub()
End Subroutine F_Sub
End Interface
  
End Module LoadDLL
  
Program www_fcode_cn
use LoadDLL
use ISO_C_Binding
use Kernel32 , only : LoadLibrary
Implicit None
Procedure(F_func) , pointer :: func
Procedure(F_sub ) , pointer :: sub
type( C_FUNPTR ) :: c_pointer
integer :: hDLL , i
character(len=32) :: dllname , funcname
Do
write(*,*) '您要调用哪个DLL？'
read(*,*) dllname
hDLL = LoadLibrary( trim(dllname)//c_null_char )
if ( hDLL &lt;= 0 ) then
  write(*,*) '对不起，我好像无法找到 '//trim(dllname)//' 哦~~！^_^'
else
  exit
end if
End Do
Do
write(*,*) '您要调用哪个函数？'
read(*,*) funcname
if ( funcname==&quot;quit&quot; ) exit
c_pointer = GetProcAddress( hDLL , trim(funcname)//c_null_char )
if ( .not.C_ASSOCIATED(c_pointer) ) then
  write(*,*) trim(dllname)//' 里面好像没有 '//trim(funcname)//' 函数哦~~！^_^'
  cycle
end if
If ( funcname==&quot;func&quot; ) then
  call C_F_ProcPointer( c_pointer , func )
  i = func()
Else if ( funcname==&quot;sub&quot; ) then
  call C_F_ProcPointer( c_pointer , sub )
  call sub()
End If
End Do  
End Program www_fcode_cn

</code></pre></li></ul><h2 id="hun"> fortran与c混编</h2><p>源于此:<a href="http://bbs.fcode.cn/thread-1117-1-1.html" target="_blank">http://bbs.fcode.cn/thread-1117-1-1.html</a></p><p><img src="/images/fortrandebug/hunbian/main.png" alt="混编主界面"> 混编时候注意两点:</p><ol><li>c 和 fortran 混编不需要 include</li><li>c/c++ 里面没有 module</li></ol><p>另外注意vc项目也得添加引用目录 <img src="/images/fortrandebug/hunbian/vcinclude.png" alt="引用目录"></p><p>你也可能运行错误 <img src="/images/fortrandebug/hunbian/error.png" alt="errorV"> 注意上面红色的部分。 第一处：如果你强调必须 stdcall 协定，那么你需要在 fortran 中声明。（这个声明不是规范的，是IVF扩展的写法） 第二处：你的 C++ 里的 lens 是通过 strlen 计算出来的，而不是指针。所以 fortran 中必须加 value 修饰符，表示它是传值，而不是传址。（这是导致cpp_main.exe 中的 0x5d7005a9 (vlhm.dll) 处最可能的异常: 0xC0000005: 读取位置 0x00000021 时发生访问冲突）的原因。</p><p>最终正确结果如下: <img src="/images/fortrandebug/hunbian/final.png" alt="correctV"></p><p>源码信息如下:</p><p>TestFortranCpp.cpp</p><pre><code class="language-c++">// TestFortranCpp.cpp : 定义控制台应用程序的入口点。
//

#include &quot;stdafx.h&quot;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

extern &quot;C&quot; {void _stdcall   vlhm(char *, int); }
//extern &quot;C&quot; {void vlhm(char *,int); }
int _tmain(int argc, _TCHAR* argv[])
{
	char *inputfile = &quot;E:\\phase6-power.opj&quot;;
	//char *inputfile;
	//char str[] = &quot;C:\\Users\\www\\Desktop\\\\31005700.tem&quot;;
	//inputfile=&amp;str[0];
	vlhm(inputfile, strlen(inputfile));
	return 0;
}

</code></pre><p>fileNameCheck.f90:</p><pre><code class="language-fortran">subroutine vlhm(pfilename, lens) Bind(C,Name=&quot;vlhm&quot;)
!DEC$ ATTRIBUTES STDCALL,DLLEXPORT::vlhm

  use,  Intrinsic :: ISO_C_Binding
!character(len=*)::filename            !c++主程序中传递进来的“Inputfile”变量
!write(*,*)&quot;dll里的filename值是：&quot;
!write(*,*)filename

  type(C_PTR) , value :: pfilename !c++主程序中传递进来的“Inputfile”变量，是C语言的指针
  integer, value::lens                                      !传入的字符串长度
  character(len=lens), target :: filename_a
  !character(len=lens) :: filename_a !pointer &amp; target
  character(len=lens),pointer::filename                     !这是Fortran的字符串

  call c_f_pointer( pfilename , filename )                   !把c语言的指针转换成fortran字符串

  filename_a = filename
  write(*,*)filename
  write(*,*)filename_a

  
  write(*,*) 'fine ok'

end subroutine vlhm

</code></pre><p>进一步的细节资料可参考<a href="http://v.fcode.cn/video-library_dll.html" target="_blank">fcode视频官网</a>。</p></div><div class="share-box" aria-hidden="true"><ul class="share"><li><a href="https://twitter.com/intent/tweet?url=/images/fortrandebug/%E4%B8%80%E7%AF%87%E6%9C%89%E8%B6%A3%E7%9A%84fortran%E9%9D%99%E6%80%81%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/&amp;text=" target="_blank" rel="noopener" class="share-btn-twitter"><i class="fab fa-twitter"></i></a></li><li><a href="https://www.facebook.com/sharer.php?u=/images/fortrandebug/%E4%B8%80%E7%AF%87%E6%9C%89%E8%B6%A3%E7%9A%84fortran%E9%9D%99%E6%80%81%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/&amp;t=" target="_blank" rel="noopener" class="share-btn-facebook"><i class="fab fa-facebook"></i></a></li><li><a href="mailto:?subject=&amp;body=/images/fortrandebug/%E4%B8%80%E7%AF%87%E6%9C%89%E8%B6%A3%E7%9A%84fortran%E9%9D%99%E6%80%81%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/" target="_blank" rel="noopener" class="share-btn-email"><i class="fas fa-envelope"></i></a></li><li><a href="https://www.linkedin.com/shareArticle?url=/images/fortrandebug/%E4%B8%80%E7%AF%87%E6%9C%89%E8%B6%A3%E7%9A%84fortran%E9%9D%99%E6%80%81%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/&amp;title=" target="_blank" rel="noopener" class="share-btn-linkedin"><i class="fab fa-linkedin-in"></i></a></li><li><a href="https://web.whatsapp.com/send?text=%20/images/fortrandebug/%E4%B8%80%E7%AF%87%E6%9C%89%E8%B6%A3%E7%9A%84fortran%E9%9D%99%E6%80%81%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/" target="_blank" rel="noopener" class="share-btn-whatsapp"><i class="fab fa-whatsapp"></i></a></li><li><a href="https://service.weibo.com/share/share.php?url=/images/fortrandebug/%E4%B8%80%E7%AF%87%E6%9C%89%E8%B6%A3%E7%9A%84fortran%E9%9D%99%E6%80%81%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/&amp;title=" target="_blank" rel="noopener" class="share-btn-weibo"><i class="fab fa-weibo"></i></a></li></ul></div><div class="media author-card content-widget-hr"> <img class="portrait mr-3" src="/authors/admin/avatar_hu52a603635ecebd45650b162dadabb4e5_12861_250x250_fill_q90_lanczos_center.jpg" alt="Avatar"><div class="media-body"><h5 class="card-title"><a href="/">Ye Zhaoliang</a></h5><h6 class="card-subtitle">Phd of PHD</h6><p class="card-text">My research interests include distributed robotics, mobile computing and programmable matter.</p><ul class="network-icon" aria-hidden="true"><li><a href="/#contact"><i class="fas fa-envelope"></i></a></li><li><a href="https://twitter.com/jueqingsizhe66" target="_blank" rel="noopener"><i class="fab fa-twitter"></i></a></li><li><a href="https://scholar.google.co.uk/citations?user=sIwtMXoAAAAJ" target="_blank" rel="noopener"><i class="ai ai-google-scholar"></i></a></li><li><a href="https://github.com/jueqingsizhe66" target="_blank" rel="noopener"><i class="fab fa-github"></i></a></li></ul></div></div></div></article><script src="/js/mathjax-config.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/4.1.4/imagesloaded.pkgd.min.js" integrity="sha256-lqvxZrPLtfffUl2G/e7szqSvPBILGbwmsGE1MKlOi0Q=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.isotope/3.0.6/isotope.pkgd.min.js" integrity="sha256-CBrpuqrMhXwcLLUd5tvQ4euBHCdh7wGlDfNz8vbu/iI=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" integrity="sha256-X5PoE3KU5l+JcX+w09p/wHl9AzK333C4hJ2I9S5mD4M=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/highlight.min.js" integrity="sha256-aYTdUrn6Ow1DDgh5JTc3aDGnnju48y/1c8s1dgkYPQ8=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/languages/r.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS_CHTML-full" integrity="sha256-GhM+5JHb6QUzOQPXSJLEWP7R73CbkisjzK5Eyij4U9w=" crossorigin="anonymous" async></script><script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.2.0/leaflet.js" integrity="sha512-lInM/apFSqyy1o6s89K4iQUKg6ppXEgsVxT35HbzUupEVRh2Eu9Wdl4tHj7dZO0s1uvplcYGmt3498TtHq+log==" crossorigin="anonymous"></script><script>hljs.initHighlightingOnLoad()</script><script>
      const search_config = {"indexURI":"/index.json","minLength":1,"threshold":0.3};
      const i18n = {"no_results":"No results found","placeholder":"Search...","results":"results found"};
      const content_type = {
        'post': "Posts",
        'project': "Projects",
        'publication' : "Publications",
        'talk' : "Talks"
        };
    </script><script id="search-hit-fuse-template" type="text/x-template">
      <div class="search-hit" id="summary-{{key}}">
      <div class="search-hit-content">
        <div class="search-hit-name">
          <a href="{{relpermalink}}">{{title}}</a>
          <div class="article-metadata search-hit-type">{{type}}</div>
          <p class="search-hit-description">{{snippet}}</p>
        </div>
      </div>
      </div>
    </script><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/3.2.1/fuse.min.js" integrity="sha256-VzgmKYmhsGNNN4Ph1kMW+BjoYJM2jV5i4IlFoeZA9XI=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/jquery.mark.min.js" integrity="sha256-4HLtjeVgH0eIB3aZ9mLYF6E8oU5chNdjU6p6rrXpl9U=" crossorigin="anonymous"></script><script id="dsq-count-scr" src="https://https-jueqingsizhe66-github-io.disqus.com/count.js" async></script><script src="/js/academic.min.d6bd04fdad2ad213aa8111c5a3b72fc5.js"></script><div class="container"><footer class="site-footer"><p class="powered-by"> Powered by the <a href="https://sourcethemes.com/academic/" target="_blank" rel="noopener">Academic theme</a> for <a href="https://gohugo.io" target="_blank" rel="noopener">Hugo</a>.<span class="float-right" aria-hidden="true"><a href="#" class="back-to-top"><span class="button_icon"><i class="fas fa-chevron-up fa-2x"></i></span></a></span></p></footer></div><div id="modal" class="modal fade" role="dialog"><div class="modal-dialog"><div class="modal-content"><div class="modal-header"><h5 class="modal-title">Cite</h5> <button type="button" class="close" data-dismiss="modal" aria-label="Close"> <span aria-hidden="true">&times;</span></button></div><div class="modal-body"><pre><code class="tex hljs"></code></pre></div><div class="modal-footer"><a class="btn btn-outline-primary my-1 js-copy-cite" href="#" target="_blank"><i class="fas fa-copy"></i> Copy</a><a class="btn btn-outline-primary my-1 js-download-cite" href="#" target="_blank"><i class="fas fa-download"></i> Download</a><div id="modal-error"></div></div></div></div></div></body></html>