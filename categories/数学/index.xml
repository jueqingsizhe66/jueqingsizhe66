<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>数学 | Macro Life</title>
    <link>https://jueqingsizhe66.github.io/categories/%E6%95%B0%E5%AD%A6/</link>
      <atom:link href="https://jueqingsizhe66.github.io/categories/%E6%95%B0%E5%AD%A6/index.xml" rel="self" type="application/rss+xml" />
    <description>数学</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><copyright>©2019</copyright><lastBuildDate>Thu, 29 Sep 2016 03:27:34 +0800</lastBuildDate>
    <image>
      <url>https://jueqingsizhe66.github.io/img/icon-192.png</url>
      <title>数学</title>
      <link>https://jueqingsizhe66.github.io/categories/%E6%95%B0%E5%AD%A6/</link>
    </image>
    
    <item>
      <title>Physics and Maths</title>
      <link>https://jueqingsizhe66.github.io/blog/2016/09/29/physics-and-maths/</link>
      <pubDate>Thu, 29 Sep 2016 03:27:34 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/blog/2016/09/29/physics-and-maths/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://baike.baidu.com/link?url=EAjClF31Nh45czy0-8dYscX-hkcI8qOxCzsmWWiXN6yDdhQh18-Avf_UAiwFBNk9F3vKh0dKTSBzitXzqYgmvn6w5e9hwmZ5_yvYP7g9ARnJbDG8vH9jEkSDwL7y8rIK&#34; target=&#34;_blank&#34;&gt;濮祖荫&lt;/a&gt;(歌手朴树的父亲):&amp;ldquo;数学背后有物理，物理需要通过数学来表达&amp;rdquo;。数学方程(表达式)需要你通过物理直觉去思考，去书写。&lt;/p&gt;

&lt;p&gt;濮说做研究的过程都是提出一个模型，找到问题的本质，针对围绕本质的几个变量进行研究，来近似替代现实的复杂模型（这个简化的思想对我有帮助）&lt;/p&gt;

&lt;p&gt;Only some links for physics and maths,&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://product.dangdang.com/22704132.html&#34; target=&#34;_blank&#34;&gt;数学物理方程 张鲁明&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://zhidao.baidu.com/share/ffccde3e883cc1bfe96567f02492e004.html　&#34; target=&#34;_blank&#34;&gt;数学物理方程 复旦&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://vdisk.weibo.com/s/uGXsmIpCxv5Ow&#34; target=&#34;_blank&#34;&gt;数学物理 微盘丛书&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://wenku.baidu.com/link?url=zGOuK59qswS4oDW1W9aqndBgisaitwkHxeix_5_O7Elp3rBH3pidQd1V8KEubrCXeuE8p0Aw_P-FbfOK2stL3uraiUOoZiUCIcBHKUpLeHq&#34; target=&#34;_blank&#34;&gt;空间物理&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://v.youku.com/v_show/id_XNzYwMDgyNjg=.html?spm=a2h0j.8191423.module_basic_relation.5~5!2~5~5!8~5!2~1~3~A&#34; target=&#34;_blank&#34;&gt;梁灿彬老师的微分流形和相对论&lt;/a&gt;, &amp;ldquo;以不变应万变，找出不变量(心领神会学科技术的不变量)，从而应问题领域中变化的东西,抓住不变的东西，反复琢磨(为什么还要反复琢磨)&amp;rdquo;. &amp;ldquo;相似矩阵的trace迹不变(矩阵对角元不变)&amp;rdquo;
也就是需要通过不变的东西把所有变化的独立体（关系）都连接起来，形成一条链。&lt;/p&gt;

&lt;p&gt;学任何东西，都得首先明确他的重点和意义（当然首先得基于你得有大局观，大的方向，大的框架 也就是不变的东西）。&lt;/p&gt;

&lt;p&gt;从数学物理过程去解释现实中的现象，从大的误差逐步缩小他，直到能够清楚的解释现实中的现象，从理论上去解释实际的问题，也就是梁灿彬老师说的
天地连通(天:定义特别清楚地(并矢:张量积运算, ) 地:实际(现实)发生的现象,不清晰的，定义不明(并矢:两个矢量并排在一起,他是一个二阶张量,9个分量v1u1 v1u2 v1u3 v2u1 v2u2 v2u3 v3u1 v3u2 v3u3 列举出来)。 也就是说不清晰的版本肯定能够存在清晰的版本)。&lt;/p&gt;

&lt;p&gt;更要紧的是，还得考虑&lt;a href=&#34;http://jueqingsizhe66.github.io/blog/2016/09/28/jump-out-of-ontology/&#34; target=&#34;_blank&#34;&gt;物理之内和物理之外&lt;/a&gt;的问题&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Incompact3d的Makefile及DNS算法</title>
      <link>https://jueqingsizhe66.github.io/blog/2015/06/22/incompact3dde-makefileji-dnssuan-fa/</link>
      <pubDate>Mon, 22 Jun 2015 16:52:20 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/blog/2015/06/22/incompact3dde-makefileji-dnssuan-fa/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://code.google.com/p/incompact3d&#34; target=&#34;_blank&#34;&gt;Incompact3d&lt;/a&gt;是一个开源的基于fortran语言编写的DNS求解器，也是我研究生期间使用的开源源代码。
Incompact3d整体框架的介绍可以参考软件的&lt;a href=&#34;https://code.google.com/p/incompact3d/downloads/detail?name=user_guide_incompact3d_V1-1.pdf&amp;amp;can=2&amp;amp;q=&#34; target=&#34;_blank&#34;&gt;user-guide&lt;/a&gt;和文献&lt;a href=&#34;http://www.imperial.ac.uk/media/imperial-college/research-centres-and-groups/turbulence-mixing-and-flow-control-group/2009_LAIZET_JCP.pdf&#34; target=&#34;_blank&#34;&gt;High-order-compact schemes for incompressible flows: a simple and effcient method with the quasi-spectral accuary&lt;/a&gt;,还可以搜索&lt;a href=&#34;http://www.imperial.ac.uk/tmfc&#34; target=&#34;_blank&#34;&gt;sylvain Laziet&lt;/a&gt; 相关的文章 ，只不过他并不是成熟的软件，很多的编译和后处理都可能出现问题，下面是我使用过程遇到的一些问题。
当然主要过程是，通过makefile编译，然后运行incompact3d，最后处理计算结果。&lt;/p&gt;

&lt;p&gt;#1 如何模拟？&lt;/p&gt;

&lt;p&gt;以周期性槽道流动(当然我也就会这么一种，其他都只是走了一小半）为例。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;首先是得到(不得不说，我也有点忘记)一个完全发展的旋转槽道流动(注意旋转源项的添加) (一般设置20000步可以了，只要收敛即可 大概一天)&lt;/li&gt;
&lt;li&gt;然后是获得完全发展槽道流动(也就是不加上旋转源项)(估计得三万步以上 大概一天)&lt;/li&gt;
&lt;li&gt;最后是获得统计的完全发展槽道流动.因为DNS获得的结果是非定常的，所以你得进行时均处理(当然时均程序得打开时均统计项 umean等)(我统计了20万步，大概花了4天时间。)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;步骤就是这样,大概一个较小的流程需要一周左右。&lt;/p&gt;

&lt;p&gt;Incompact3d比较特殊的是收敛性判定问题，上面的几个过程都需要使用实时&lt;a href=&#34;http://jueqingsizhe66.github.io/blog/2015/05/31/u-plus-y-plus/&#34; target=&#34;_blank&#34;&gt;监控小程序&lt;/a&gt;
来观看速度散度和质量流量(质量流量是周期性槽道流动所特有的，所以最好进行实时显示)的收敛情况.另外你可以通过python的一个小脚本
来获得实时显示的图片，这样就能看到程序模拟得怎么样了，具体查看&lt;a href=&#34;http://jueqingsizhe66.github.io/blog/2015/06/11/ji-yu-pythonde-ju-yu-wang-wen-jian-gong-xiang-ruan-jian-simplehttpserverwithupload/&#34; target=&#34;_blank&#34;&gt;python局域网上传和下载&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;#2 后处理方法
参考我的&lt;a href=&#34;http://jueqingsizhe66.github.io/blog/2015/06/22/incompact3dru-he-tong-guo-jie-guo-chu-li-chu-ji-xian&#34; target=&#34;_blank&#34;&gt;pathline处理方法&lt;/a&gt;
一定要注意(real 8) 否则得到的结果肯定是错误的，这也是困扰我几星期的问题。&lt;/p&gt;

&lt;p&gt;#3 关于Makefile编译&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;#=======================================================================
# Makefile for Imcompact3D
#=======================================================================

# Choose pre-processing options
#   -DSHM	   - enable shared-memory implementation
#   -DDOUBLE_PREC  - use double-precision
OPTIONS = -DDOUBLE_PREC

# Choose an FFT engine, available options are:
#   essl       - IBM Blue Gene ESSL Library
#   fftw3      - FFTW version 3.x
#   generic    - A general FFT algorithm (no 3rd-party library needed)
#FFT= essl # I ignore
FFT = generic

# Paths to FFTW 3
FFTW3_PATH=   # full path of FFTW installation if using fftw3 engine above
FFTW3_INCLUDE = -I$(FFTW3_PATH)/include
FFTW3_LIB = -L$(FFTW3_PATH)/lib -lfftw3 -lfftw3f

# Paths to ESSL
ESSL_PATH=/bgsys/drivers/ppcfloor/comm/xl
ESSL_INCLUDE =
ESSL_LIB = -L$(ESSL_PATH)/lib -L/opt/ibmmath/lib64 -lesslbg

# Specify Fortran and C compiler names and flags here
# Normally, use MPI wrappers rather than compilers themselves 
# Supply a Fortran pre-processing flag together with optimisation level flags
# Some examples are given below:

#FC =  
#OPTFC = 
#CC = 
#CFLAGS = 

# PGI
#FC = ftn
#OPTFC = -fast -O3 -Mpreprocess
#CC = cc
#CFLAGS = -O3

# PathScale
#FC = ftn
#OPTFC = -Ofast -cpp
#CC = cc
#CFLAGS = -O3

# GNU 选用mpif90进行编译
FC = mpif90
OPTFC = -O0 -g  -fdefault-real-8 -fdefault-double-8 -funroll-loops -ftree-vectorize -fcray-pointer -cpp
CC = mpicc
CFLAGS = -O0
PLATFORM=gnu

#Blue Gene/Q : EDF R&amp;amp;D
#PREP=/bgsys/drivers/ppcfloor/comm/xl/bin/
#FC = $(PREP)mpixlf95_r
#OPTFC= -O3 -qsuffix=cpp=f90 -qinitauto -qautodbl=dbl4
##OPT_LK= -O3 -qinitauto -qautodbl=dbl4
#CFLAGS= -O3 -qinitauto -qautodbl=dbl4
#CC=$(PREP)mpixlc_r
#PLATFORM=bgq_xlf

# Cray
#FC = ftn
#OPTFC = -e Fm
#CC = cc
#CFLAGS = 

#-----------------------------------------------------------------------
# Normally no need to change anything below

# include PATH 
ifeq ($(FFT),generic)
  INC=
else ifeq ($(FFT),fftw3)
  INC=$(FFTW3_INCLUDE)
else ifeq ($(FFT),essl)
  INC=$(ESSL_INCLUDE)
endif

# library path
ifeq ($(FFT),generic)
   LIBFFT=
else ifeq ($(FFT),fftw3)
   LIBFFT=$(FFTW3_LIB)
else ifeq ($(FFT),essl)
   LIBFFT=$(ESSL_LIB)
endif

# List of source files
# 注意这边编译的模块，一般是需要的mod生成放在前面首先编译，如果不放前面会报错，解决办法 就是文件名放在前面即可,具体可以查看关于Makefile Fortran
SRC = decomp_2d.f90 glassman.f90 fft_$(FFT).f90 module_param.f90 io.f90 variables.f90 poisson.f90 schemes.f90 implicit.f90 convdiff.f90 user_module.f90 incompact3d.f90 navier.f90 derive.f90 parameters.f90 tools.f90 visu.f90

#-----------------------------------------------------------------------
# Normally no need to change anything below

ifneq (,$(findstring DSHM,$(OPTIONS)))
SRC := FreeIPC.f90 $(SRC)  
OBJ =	$(SRC:.f90=.o) alloc_shm.o FreeIPC_c.o
else
OBJ =	$(SRC:.f90=.o)
endif	

OPTION=$(OPTIONS)
from:=-D
to:=-WF,-D
TMP=$(subst $(from),$(to),$(OPTIONS))
ifeq ($(PLATFORM),bgp_xlf)
   OPTION=$(TMP)
endif
ifeq ($(PLATFORM),bgq_xlf)
   OPTION=$(TMP)
endif

all: incompact3d

alloc_shm.o: alloc_shm.c
	$(CC) $(CFLAGS) -c $&amp;lt;

FreeIPC_c.o: FreeIPC_c.c
	$(CC) $(CFLAGS) -c $&amp;lt;

incompact3d : $(OBJ)
	$(FC) -O0 -g -o $@ $(OBJ) $(LIBFFT)

%.o : %.f90
	$(FC) $(OPTFC) $(OPTION) $(INC) -c $&amp;lt;

.PHONY: clean 
clean:
	rm -f *~ *.o *.mod incompact3d

.PHONY: realclean
realclean: clean
	rm -f *~ \#*\#
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行方式:
我的电脑刚好是8线程，就用8线程运行，你也可以选用4或者更多.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;mpirun -np 8  incompact3d  &amp;gt; tail.out &amp;amp;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#4 The Algorithm of the DNS in Incompact3d&lt;/p&gt;

&lt;p&gt;Incompact3d的执行流程基本上是下面几个(当然得仔细阅读，并反复比对).我写得这段英文大体能够对得上.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;1. Initial the velocity field with noise(init subroutine).
2. Start the iterative process by guessing the pressure field. First we use convdiff subroutine take convection and diffusion of the flow into consideration.And then use pre_correc subroutine to correction the velocity value with the specified boundary condition.
3. Use the values of u,v,and w to get the initialize of the pp3 in the spectral space from subroutine divergence(…pp3,1…)(first sign to turbulent spot).Then we use poisson solver decomp_2d_poisson_stag to get the value of the pp3 in the spectral space.
4. Since they were obtained from the guessed values of u,v,w,the values pp3,when substituted into the divergence equation,will not necessarily satisfy that that equation.Hence ,using the gradp subroutine,get the pressure gradients in the physics space,then using corgp subroutine ,get the velocity correction by the pressure gradient in the physics space.Use subroutine divergence(…dv3,2…) to do another monitor for turbulent spot(second sign to turbulent spot) .At the end of the current step, we go to step2 again until the simulation have been fully developed.
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Incompact3d如何通过结果处理出迹线</title>
      <link>https://jueqingsizhe66.github.io/blog/2015/06/22/incompact3dru-he-tong-guo-jie-guo-chu-li-chu-ji-xian/</link>
      <pubDate>Mon, 22 Jun 2015 16:20:48 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/blog/2015/06/22/incompact3dru-he-tong-guo-jie-guo-chu-li-chu-ji-xian/</guid>
      <description>&lt;p&gt;Incompact3D获得的数据都是二进制的数据文件，为了获得内部的文件
需要进一步通过编程获得，下面是一个获得pathline的源代码。&lt;/p&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;通过 module.f90文件读取 nx ny nz的值&lt;/li&gt;
&lt;li&gt;把下面的源代码编译并放在ux uy uz所在的文件夹当中&lt;/li&gt;

&lt;li&gt;&lt;p&gt;进一步的相关信息，可以参考注释。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fortran&#34;&gt;PROGRAM b
IMPLICIT NONE
Integer,parameter :: nx=128,ny=129,nz=84 
INTEGER :: I,J,K,COUNT,LN=128,COL=129,VOL=84
REAL(8),DIMENSION(nx,ny,nz) :: ux,uy,uz
CHARACTER(len=12)::NAME1=&amp;quot;Incompact3d&amp;quot;,NAME2=&amp;quot;ux&amp;quot;,NAME3=&amp;quot;uy&amp;quot;,NAME4=&amp;quot;uz&amp;quot;
character(len=15) :: temp,temp1,temp2,temp3
CHARACTER(len=20) :: CFILEux
integer :: num

real,dimension(nx):: y1
real,dimension(ny):: y2
real,dimension(nz):: y3

!generation of the mesh
do i=1,nx
y1(i)=(i-1)*0.098174770425 !0.8 is DX ! incompact3d.prm的配置长度除以网格尺度即可。
enddo


do j=1,ny
y2(j)=(j-1)*0.015503875968992248 !0.8 is DY
enddo


do k=1,nz
y3(k)=(k-1)*0.04986655005702381!0.8 is DZ
enddo


! 下面只是对于读取文件进行的一个后处理，只是为了方便批处理而已
22 format(I1)
23 format(I2)
DO num=1,30
if(num .lt. 10) then
    write(temp,22) num
    temp1 =trim(NAME2)//trim(&#39;00&#39;)//trim(temp)
    temp2 =trim(NAME3)//trim(&#39;00&#39;)//trim(temp)
    temp3 =trim(NAME4)//trim(&#39;00&#39;)//trim(temp)
else 
    write(temp,23) num
    temp1 =trim(NAME2)//trim(&#39;0&#39;)//trim(temp)
    temp2 =trim(NAME3)//trim(&#39;0&#39;)//trim(temp)
    temp3 =trim(NAME4)//trim(&#39;0&#39;)//trim(temp)
end if
    
! 产生实际的文件名
CFILEux=trim(&#39;./pathchange/&#39;)//trim(temp1)//&#39;.dat&#39;
!read the ux 读取ux00*的数据
OPEN(10,FILE=temp1,FORM=&#39;UNFORMATTED&#39;,&amp;amp;
ACCESS=&#39;DIRECT&#39;, RECL=8, STATUS=&#39;OLD&#39;)

! read the uy
OPEN(11,FILE=temp2,FORM=&#39;UNFORMATTED&#39;,&amp;amp;
ACCESS=&#39;DIRECT&#39;, RECL=8, STATUS=&#39;OLD&#39;)
!read the uz
OPEN(12,FILE=temp3,FORM=&#39;UNFORMATTED&#39;,&amp;amp;
ACCESS=&#39;DIRECT&#39;, RECL=8, STATUS=&#39;OLD&#39;)

! 新建一个结果文件，并添加上tecplot的数据头

OPEN(20,FILE=CFILEux,FORM=&#39;FORMATTED&#39;)
WRITE (20,&#39;(A6,A12)&#39;)               &#39;TITLE=&#39;,TRIM(ADJUSTL(NAME1))
WRITE (20,&#39;(A36)&#39;)    &#39;VARIABLES=&amp;quot;X&amp;quot;,&amp;quot;Y&amp;quot;,&amp;quot;Z&amp;quot;,&amp;quot;VX&amp;quot;,&amp;quot;VY&amp;quot;,&amp;quot;VZ&amp;quot;&#39;
  WRITE (20,&#39;(A7,I4,A1,A2,I4,A1,A2,I4,A1,A7)&#39;) &#39;ZONE I=&#39;,LN,&#39;,&#39;,&#39;J=&#39;,COL,&#39;,&#39;,&#39;K=&#39;,VOL,&#39;,&#39;,&#39;F=POINT&#39;

COUNT = 1
DO K=1,nz
DO J=1,ny
    DO I=1,nx
        READ(10,REC=COUNT) ux(I,J,K)
        READ(11,REC=COUNT) uy(I,J,K)
        READ(12,REC=COUNT) uz(I,J,K)
    !    WRITE(20,30) I,J,K,ux(I,J,K),uy(I,J,K),uz(I,J,K)
         WRITE(20,30) y1(i),y2(j),y3(k),ux(I,J,K),uy(I,J,K),uz(I,J,K)
        30 format(I3,1X,I3,1X,I3,1X,E11.4,1x,E11.4,1x,E11.4)
        COUNT = COUNT + 1
    ENDDO
ENDDO
ENDDO
ENDDO
CLOSE(10)
CLOSE(11)
CLOSE(10)
CLOSE(20)
END PROGRAM b
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>Haskell几个基本概念--学而无用--无以为用</title>
      <link>https://jueqingsizhe66.github.io/blog/2015/05/16/haskellji-ge-ji-ben-gai-nian-xue-er-wu-yong-wu-yi-wei-yong/</link>
      <pubDate>Sat, 16 May 2015 21:11:50 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/blog/2015/05/16/haskellji-ge-ji-ben-gai-nian-xue-er-wu-yong-wu-yi-wei-yong/</guid>
      <description>&lt;ol&gt;
&lt;li&gt;模式匹配
= +起着一种模式匹配，=不要翻译成等于 最好翻译为如果匹配前面+ 则他的值为后面.-&amp;gt; 也起着一种类型的模式匹配。&lt;/li&gt;
&lt;li&gt;分支
|在创建函数的时候 体现着一种分支的效果。
if-else  这其实是一种控制语句，不能说Haskell放掉了控制语句，而应该是循环语句。&lt;/li&gt;
&lt;li&gt;一切都是函数。
根据monad的内置结构，函数可以组合生成类似于数学的组合函数（埋藏内部的lambda结构）&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;函数只是关系的表示-可以说它是过程-变换-运动-从泛函的角度解释&#34;&gt;函数只是关系的表示，可以说它是过程、变换、运动（从泛函的角度解释）&lt;/h3&gt;

&lt;p&gt;本来函数式变成是不考虑空间的， 而面向对象则是引入不必要的空间问题，来挂上函数，最终都是为了实现函数变换或者函数过程，或者统称为运动。
假如宇宙存在根节点，越靠近根节点的肯定越抽象，我们现在是工作在底层的具象节点下。
&amp;gt; 面向对象属于分解，函数编程属于组合。有以为 利，通过面向对象我们将一分解为多个，数量多了，“有”，而函数编程则是将多个组合成一个，数量少了  ，“无”，无才能用，只有忽略事物内部的细节，我们才 能用它，否则陷入细节迷失方向。换句话说：数学分数考得好，不代表在实际中用数学用的好，牛    顿没有发明几何学，但是用了几何学，创造了微积分，用它们推导 出万有引力；爱因斯坦用了非几何学推导了相对论。&lt;/p&gt;

&lt;p&gt;简洁才能落地！&lt;/p&gt;

&lt;p&gt;###从有至无方为用，有乃分，无乃合，宇宙的起点源于无&lt;/p&gt;

&lt;p&gt;学习是一种分解能力，使用是一种组合能力，这是两种不同的能力。
&amp;gt; 再看看老子道德经的一段：三十幅共一毂，当其无，有车之用。埏埴以为器，当其无，有器之用。凿户牖以为室，当其无，有室之用。故有之以为利，无之   以为用。
这段话意思是：三十根棍子做成的圆轱辘，只有忽视圆轱辘内部这种结构，着眼于圆轱辘外部，才会发现它原来是可以做车的轮子这一用处，两个轱辘与车    架组合成一辆车。比如门窗，只有忽视其内部如何结构的构建，才会从外部想到用它在房间组合中。&lt;/p&gt;

&lt;h3 id=&#34;树形结构抽象细节&#34;&gt;树形结构抽象细节&lt;/h3&gt;

&lt;p&gt;我们之所以使用树形结构，用一个根节点代表其聚合群体，用组长代表所有组员，用名字代表人的全部，等等这些组合抽象的办法就是让我们大脑去除大量   对象内部的细节，用一个符号代替它们，这样我们才能基于这个树的根节点再组合成新的树形结构。&lt;/p&gt;

&lt;h2 id=&#34;范畴理论-交际的互联网&#34;&gt;范畴理论-交际的互联网&lt;/h2&gt;

&lt;p&gt;范畴理论(Category)总是鼓励我们从对象内部细节中转移开来，在范畴理论中 一个对象是一个抽象模糊的实体，你所有需要知道的只是它如何和其他对象交互(关系)，它是怎么使用箭头和其他对象连接的，这就是为什么互联网搜索引擎 Google Baidu等能够通过分析链入和链出的链接来排名网站一样。&lt;/p&gt;

&lt;h2 id=&#34;无以为用-组合思想&#34;&gt;无以为用&amp;ndash;组合思想&lt;/h2&gt;

&lt;p&gt;归根到底，还是“无以为用”这个范畴的组合本质很多人都没有搞清楚。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;只有忘记对象的细节才能用好它。两个原因总结一下：

&lt;ul&gt;
&lt;li&gt;首先，首先人脑短时记忆有限，如果大量对象内部细节占据大脑，而我们需要从对象外部组合它们，    这些细节是干扰。&lt;/li&gt;
&lt;li&gt;其次，范畴也认为组合对象只要将对象看成模糊实体，注重它们之间关系。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;忘记学习对象的细节才能用好它，无以为用，事物的制造者都不一定能用好它，除非事先有目标制造它。
因此，学并不能致用，数理化学得好不一定用得好，博士给老板打工，老板赚大头。因为他把你的学问用处发挥了。自己学自己用因为智力限制也不可能。&lt;/li&gt;
&lt;li&gt;中国教育的典型
在学生阶段,中国学生数理化很好，但是毕业后诺贝尔奖获得者几乎没有，世界自然科学领军人物很少，那些高考状元 学神都哪儿去了？学得好不      一定用得好，中国教育制度是以学习能力评价学生，各种考试充斥大量 知识细节，让学生耗费18年于这些可能以后无用的细节中，最终他们已经没有智力空间来思考如何使用这些大量的知识细节了。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;面向对象的分解能力是强，但是组合能力很弱！
实际上从函数运算的角度，不存在单纯的“值”，1应该是=&amp;amp; gt;1，或者说，所谓的常量值也是函数，只是每次不管输入什么都输出同样的结果。这样世界就只有运算，值是没必&amp;gt;要的，更没有状态。但这是神的视角，而一 旦人开始思考时，由于不具备神的无限的能力，只能在每个瞬间试图去把握世界，就看到了值和状态以及状态呈现时的context/stage/&amp;gt;舞台。但人希 望能像神一样去理解世界，就只好从这每个瞬间呈现的一切中去寻找变与不变的东西，当他们历尽艰辛找到“不变”的“变换”时就迫不及待地将之命名为定律。&lt;/p&gt;

&lt;p&gt;关于上述思想，计算机邀请Haskell带领领略（Haskell可以学习，但是需要投入很多时间，坚持&amp;hellip;）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.zhihu.com/question/20193745&#34; target=&#34;_blank&#34;&gt;综合性帖子&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.jdon.com/47271&#34; target=&#34;_blank&#34;&gt;这边也有一些课程介绍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;dev.stephendiehl.com/hask/&#34; target=&#34;_blank&#34;&gt; What I Wish I Knew When Learning Haskell 2.2 ( Stephen Diehl )&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://acm.wustl.edu/functional/haskell.php&#34; target=&#34;_blank&#34;&gt;How to learn haskell&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://learnyouahaskell.com/chapters&#34; target=&#34;_blank&#34;&gt;相当棒的趣味指南&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;从现实世界走入计算机-经过计算机思考-再从计算机走出并融入现实世界-这就是-函数式思维-http-www-jdon-com-45608&#34;&gt;从现实世界走入计算机，经过计算机思考，再从计算机走出并融入现实世界，这就是&lt;a href=&#34;http://www.jdon.com/45608&#34; target=&#34;_blank&#34;&gt; 函数式思维&lt;/a&gt;。&lt;/h3&gt;

&lt;p&gt;函数的context引入了时间的关系。&lt;a href=&#34;http://www.jdon.com/45608&#34; target=&#34;_blank&#34;&gt; 我们思考逻辑的时候，定义已经是确定的了。也正因为是确定的，才可以逻辑思考&lt;/a&gt;。
函数不存在状态，所以计算机加入了一个特殊的东西：时钟。值++时间=状态++，在可以忽视时序问题时，可以直接有值=状态。忽视时序问题，就相当于我们平时说的异步。若果单单使用锁，只是一种耗费资源手段。而我们看到无论是唤醒线程，还是延时读取，都是依赖时钟
##+ 小结：&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://jueqingsizhe66.github.io/images/desk.jpg&#34; alt=&#34;桌子&#34; /&gt;
一张桌子为案例，分解思维的人看到后首先想到这张桌子由什么构成，长宽高和材质，这些都是桌子的内部细节；而组合思维的人看到后，环顾四周，看看其处于什么环境，如果放在教室中，他判断这是一张课桌，如果放在食堂，他判断这是一张饭桌。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;从这个例子可以看出组合是从行为（运动、变化、时间）角度看待 世界的，“课桌”、“饭桌”中的“课”和“饭”在这里是动词，意为“上课用”、“吃饭用”的意思，“用”是动词，同一个桌子出现在不同的环境中发挥不同的 作用。而分解思维只研究空间，只研究桌子的空间结构是什么，甚至不研究为什么是四条腿，为什么每条腿长度相同，分解思维根本不考虑这些，不用考虑任何桌子 之外的世界，在分解思维中没有万有引力、没有地面的水平、没有书房和餐厅，只有空间，分解只考虑空间的组成结构。看来分解和组合是相互依存的，分解时研究 的是空间，组合时研究的是行为，把桌子放进餐厅的意义是期待使用它吃饭这样一种运动[组合运动？]。 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;范畴英文是Category，也是++分类++的意思，打个比喻，Google能根据哪些网站引用你的网站这个外部信息进行PageRank评分，从而对你的网站权重进行排序，这个道理和我们评价一个人有些类似，看一个不认识的人怎么样，那就看看他交往的什么朋友，什么环境，近墨者黑，人以群分，物以类聚，这些都是从事物所在的分类类别中判断其价值，而不是从事物内部细节。（评判个人的价值标准跟不同的人在一起，意味着你的价值不一样.）&lt;/p&gt;

&lt;h3 id=&#34;monad-隐藏lambda&#34;&gt;monad 隐藏lambda&lt;/h3&gt;

&lt;p&gt;Monad是一种结构，这种结构能够将一个值放入一个可计算的上下文中。因为Lambda是一个和上下文环境有关的表达式，所以，这里对Monad的上下文理解就比较容易。
monad是从范畴论引入， 范畴其实就是一个集合，只不过对这个集合有一些约束定义，如果 熟悉业务建模的人可能对这种思维方式不陌生，经常我们会对抽象的事物进行定义，数学上基本就是用集合概念，实际上从罗素悖论拯救了数学开始，数学离不开集合，对于一个国家社会，个人与社会也是不同的概念，社会是一个++集合++概念，从++集合角度++考虑问题和从&lt;strong&gt;个人元素角度&lt;/strong&gt;考虑问题是两种截然不同的思路，如果你平时注 重这种区别，你可能会有两种人生观。祝你脑洞大开。&lt;/p&gt;

&lt;h3 id=&#34;函数式替代sql&#34;&gt;函数式替代sql？&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://www.jdon.com/44842&#34; target=&#34;_blank&#34;&gt;函数的逻辑性&lt;/a&gt;与关系数据库的是一致的，而逻辑在不同语言之间是自然贯穿的，也就是说若果所有都用函数来表达的，可以使sql消失，那么由于sql引发的问题自然就消失。
数据库 = 一个集合,这就是面向集合，mongodb就是这样的思想&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>求定积分</title>
      <link>https://jueqingsizhe66.github.io/blog/2015/05/13/qiu-ding-ji-fen/</link>
      <pubDate>Wed, 13 May 2015 19:27:40 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/blog/2015/05/13/qiu-ding-ji-fen/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://jueqingsizhe66.github.io/images/maths/dingjifen.jpg&#34; alt=&#34;定积分&#34; /&gt;
&lt;img src=&#34;https://jueqingsizhe66.github.io/images/maths/dingjifen3.jpg&#34; alt=&#34;定积分的数值计算&#34; /&gt;
&lt;img src=&#34;https://jueqingsizhe66.github.io/images/maths/dingjifen2.jpg&#34; alt=&#34;定积分的图形示意&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;
 (define (cube  x) (* x  x x))
 ;;;累加
(define (sum-integer a b)
  (if (&amp;gt; a b)
     0
     (+ a (sum-integer (+ a 1) b))))

(sum-integer 1 10)
;;;立方累加
(define (sum-cube a b)
  (if (&amp;gt; a b)
     0
     (+ (cube a) (sum-cube (+ a 1)  b))))
(sum-cube 1 3)
;;; 求Pi 值 分数累加
(define (sum-pi a b)
  (if (&amp;gt; a b)
     0
     (+ (/ 1.0 (* a (+ a 2))) (sum-pi (+ a 4) b))))
(sum-pi 1 9)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;观察上面的积分过程
##最终提取出公共的形式 Sum&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;
;; (define (&amp;lt;name&amp;gt; a b)
;;  (if (&amp;gt; a b)
;;  0
;;  (+ (&amp;lt;term&amp;gt; a) (&amp;lt;name&amp;gt; (&amp;lt;next&amp;gt;a) b))))

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;于是我们可以得到&#34;&gt;于是我们可以得到&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;
(define (sum term a next b)
  (if (&amp;gt;  a b)
     0
     (+ (term a) (sum term (next a)  next b))))

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;and-apply-the-sum-to-get-the-sum-integer2-sum-cube2-sum-pi2&#34;&gt;And Apply the sum  to get the sum-integer2 sum-cube2 sum-pi2&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define (sum-integer2 a b) (sum (lambda (x) x) ((lambda (x) (+ x 1)) a) (lambda (x) (+ x 1)) b)) ;;;--&amp;gt;There is some problems

;&amp;gt; (sum-integer2 1 10)
;54  ------------------------&amp;gt;Why
;&amp;gt; (sum-integer 1 10)
;55

(define (identity x) x)
(define (inc x) (+ x 1))
(define (sum-integer3 a b) (sum identity a inc b))
(sum-integer3 1 3)
(define (sum-cube2 a b) (sum cube a inc b))
(sum-cube2 1 3)
(define (sum-pi2 a b) 
  (define (pi-term x)
    (/ 1.0 (* x (+ x 2))))
  (define (pi-next x)
    (+ x 4))
  (sum pi-term a pi-next b))
(sum-pi2 1 9)
(* 8 (sum-pi2 1 1000))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也就是我们现在可以计算积分了！
我们的问题是求解下面的定积分：
&lt;img src=&#34;https://jueqingsizhe66.github.io/images/maths/integral.png&#34; alt=&#34;定积分&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;;;;; So now we can do the integrate computing

;;Because integrate will have the same function but different next function
;;;a-b 之间关于f函数的定积分的求法
(define (integral f a b dx)
  (define (add-dx x) (+ x dx))
  (define (update-a a dx) (+ a (/ dx 2.0)))
  (* (sum f (update-a a dx) add-dx b) dx))
(integral cube 0 1 0.01)
(integral cube 0 1 0.001)
(integral cube 0 1 0.0001)
(/ 1 4.0)
(/ (* 1 (cube 1)) 4.0)


;result:
;0.24998750000000042
;0.249999875000001
;0.24999999874993412
;0.25
;0.25

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了更精确的求解积分，我们使用更为精妙的辛普森积分
&lt;img src=&#34;https://jueqingsizhe66.github.io/images/maths/xinpusen1.jpg&#34; alt=&#34;辛普森的抛物线积分方法&#34; /&gt;
&lt;img src=&#34;https://jueqingsizhe66.github.io/images/maths/xinpusen2.jpg&#34; alt=&#34;辛普森的数学公式&#34; /&gt;
&lt;img src=&#34;https://jueqingsizhe66.github.io/images/maths/xinpusen3.jpg&#34; alt=&#34;最终简化&#34; /&gt;
###包含奇数的两倍 和偶数的四倍，两边不加倍&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;h = (b-a)/n&lt;/li&gt;
&lt;li&gt;yk= f(a+kh) &amp;mdash;&amp;gt; next&lt;/li&gt;
&lt;li&gt;(even? k)  (odd? k)&lt;/li&gt;
&lt;li&gt;y0 =a  yn= b&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;a. 设计的过程遇到的问题是 参数的问题 需要设置k？
b. 中间过程的问题，如何划分三种情况
      b.1  k为0和n的情况
      b.2  k为奇数的情况
      b.3  k为偶数的情况&lt;/p&gt;

&lt;p&gt;最终, 利用Fact的思想 进行求积分&lt;/p&gt;

&lt;p&gt;;;; 下面是一个较为混乱的设计，且没有考虑使用sum&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define (simpson-integral f a b n)
(let ((h (/ (- b a) n))
      (k 0))
(define inc (+ a (* k h)))
(define inc2 (* 2 f(inc)))
(define inc4 (* 4 f(inc)))
  (cond
    ((= k 0) (f a))
    ((= k n) (f b))
    ((even? k) (+ (* 2 f((+ a (* k h))))  
)))

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;补充，好思想:保证最后一个为偶数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define (round-to-next-even x)
 (+ x (remainder x 2))
)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;于是有了下面较好的版本，思考，之前的Sum其实是已经提供了inc递增的a
以及范围，我们主要的目的就是写好term即可！而
term其实就是涉及到你需要思考的三种情况
之前你之所以回想不清楚，因为你没有斩断念头，term只接受一个参数，
这个参数其实就是你一直想的k，所以simpson-term的一个参数就是k，利用它
开始做文章即可&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define (simpson-integral f a b n)
    (define (round-to-next-even x)  (+ x (remainder x 2)))
    (define fixed-n (round-to-next-even n))
    (define h (/ (- b a) fixed-n))
    (define (simpson-term k) 
      (define y (f (+ a (* k h))))
      (cond 
          ((or (= k 0) (= k fixed-n))
            (* 1 y))
          ((even? k) (* 2 y))
          (else (* 4 y))))
    (* (/ h 3) (sum simpson-term 0 inc fixed-n))
 ))

;(simpson-integral cube 0 1 10)
;1/4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外还有几种变体，只不过总体思路都在上面类似。&lt;/p&gt;

&lt;p&gt;a1:breaking the problem into four parts: (f y0), (f yn) and two sums,one over even k and another over odd k&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define (another-simpson-integral f a b n) 
   (define h (/ (- b a) n))  
   (define (add-2h x) (+ x (* 2 h))) 
   (* (/ h 3.0) (+ (f a)  
                   (* 4.0 (sum f (+ a h) add-2h (- b h)))  
                   (* 2.0 (sum f (add-2h a) add-2h (- b h)))  
                   (f (+ a (* h n)))))) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;a2:Here&amp;rsquo;s a version that sums over pairs of terms (2 y_k + 4 y_k+1). No conditionals or special cases are needed anywhere, but there&amp;rsquo;s an extra term [f(b) - f(a)] to be added to the final count.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt; (define (simpson f a b n) 
   (define h (/ (- b a) n)) 
    
   (define (y k) 
     (f (+ a (* k h)))) 
    
   (define (ypair k) 
     (+ (* 2 (y k)) 
        (* 4 (y (+ k 1))))) 
    
   (define (add-2 k) 
     (+ k 2)) 
    
   (* (/ h 3) (+ (sum ypair 0 add-2 (- n 1)) 
                 (- (f b) (f a))))) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然也可以写成下面的格式：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt; (define (sim-integral f a b n) 
     (define h (/ (- a b) n)) 
     (define (y k) (f (+ a (* k h)))) 
     (define (coeff k) (if (is-even? k) 2 4)) 
     (define (part-term k) (* (coeff k) (y k))) 
     (define part-value (sum part-term 1 inc (- n 1))) 
     (* (/ h 3) (+ (y 0) (y n) part-value))) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##下面是我重新写的一遍，包含一些计算问题的修正
1. 加入了n的修正
2. 重新认识了simpson算法的，当然还有些问题没有理解，比如f(b)-f(a),
   在simpson-anthother-integrate中&lt;/p&gt;

&lt;p&gt;新的源码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;
;;; (let &amp;lt;var&amp;gt; &amp;lt;bindings&amp;gt; &amp;lt;body&amp;gt;)

(define (cube x) (* x  x  x))
(define (sum-integer a b)
  (if (&amp;gt; a b)
     0
     (+ a (sum-integer (+ a 1) b))))
(sum-integer 1 10)

(define (sum-cube a b)
  (if (&amp;gt; a b)
     0
     (+ (cube a) (sum-cube (+ a 1) b))))
(sum-cube  1 3)

(define (sum-pi a b)
  (if (&amp;gt; a b)
     0 
     (+ (/ 1.0 (* a (+ a 2))) (sum-pi (+ a 4) b))))
(sum-pi 1 10)
(sum-pi 1 100)

(define (sum term a next b)
  (if (&amp;gt; a b)
     0
     (+ (term a) (sum term  (next a) next b))))

(define (sum-integer2 a b)
  (define (identity x) x)
  (define (inc x) (+ x 1))
  (sum identity a inc b))
(sum-integer2 1 10)

(define (sum-cube2  a b)
  (define (cube x) (* x x x))
  (define (inc x) (+ x 1))
  (sum cube a inc b))
(sum-cube2 1 3)

(define (sum-pi2 a b)
  (define (pi-term x) (/ 1.0 (* x (+ x 2))))
  (define (pi-next x) (+ x 4))
  (sum pi-term a pi-next b))
(sum-pi2 1 10)

(define (integral f a b dx)
  (define const_a (+ a (/ dx 2.0)))
  (define (add_dx x) (+ x dx))
  (* (sum f const_a add_dx b) dx))

(integral cube 0 1 0.001)

(define (simpson-integral f a b n)
  (define (round-to-next-even x) (+ x (remainder x 2)))
  (define fixed-n (round-to-next-even n))
  (define (inc x) (+ x 1))
  (define h (/ (- b a) fixed-n))
  (define (simpson-term k)
    (define y (f (+ a (* h k))))
    (cond 
      ((or (= k 0) (= k fixed-n))
       (*  1  y))
      ((even? k)
       (* 2  y))
      (else (* 4 y))))
 ; (* (/ h 3) (sum simpson-term 0 inc b))) ;;; 0的意思表示从k=0开始,不能写成b，如果写成b表示你没有理解，因为0 fixed-n都代表的是K
  ;;这是次数的说法，而不是代表着a-b之间的求值范围，而是指求职的次数！
 (* (/ h 3) (sum simpson-term 0 inc fixed-n)))
(simpson-integral cube 0 1 10)
(simpson-integral cube 0 1 11)


;;一种变体 思路同上
;; 比较有趣的地方是分为四个节点出
;; 1  f(a)  ----》 y0
;; 2  f(a+h) 奇数的开始地方   add-2h方式累加都是奇数 同时终点是b-h  为什么？因为b在下面被暂用--》把它看待是一个奇数累加的过程 y1 y3 y5
;; 3  f(a+2h) 偶数的开始地方 add-2h方式累加都是偶数 同时终点是b-h--》把它看待是一个偶数累加的过程 y2 y4 y6..
;; 4  f(b)    最后一部分  yn
(define (simpson-another-integral f  a b n)
  (define h (/ (- b a) n))
  (define (add-2h x) (+  x (* 2.0 h)))  ;;; 
  (* (/ h 3.0) (+ (f a)
                          (* 4.0 (sum f (+ a h) add-2h (- b h)))  ;;; (+a h)表示起始点  (- b h) 表示的是终点
                          (* 2.0 (sum f (add-2h a) add-2h (- b h))) ;; 注意这边的(add2h a)表示的是起始点
                          (f (+ a (* h n))))))  ;; 也可以是(f b) 

;&amp;gt; (simpson-another-integral cube 0 1 11)
;0.1782892789654623
;&amp;gt; (simpson-another-integral cube 0 1 12)
;0.2499999999999999&#39;

(define (simpson-another-integral-improve f  a b n)
  (define (round-to-next-even x) (+ x (remainder x 2)))
  (define fixed-n  (round-to-next-even n))
  (define h (/ (- b a) fixed-n))
  (define (add-2h x) (+  x (* 2.0 h)))  ;;; 
  (* (/ h 3.0) (+ (f a)
                          (* 4.0 (sum f (+ a h) add-2h (- b h)))  ;;; (+a h)表示起始点  (- b h) 表示的是终点
                          (* 2.0 (sum f (add-2h a) add-2h (- b h))) ;; 注意这边的(add2h a)表示的是起始点
                          (f (+ a (* h fixed-n)))))) ;;; (f b)的效果是一样  但是不正确！ 现在
  
  (simpson-another-integral cube 0 1 11)
   (simpson-another-integral cube 0 1 12)
    (simpson-another-integral cube 0 1 111);;; 如果是奇数的话，现在解决的办法就是多增加一些计算！
   ;;;;;过程没错！！！ 不知道哪边多加了！
   
    
 (define (simpson-pair-integral f a b n)
   (define (round-to-next-even x) (+ x (remainder x 2)))
   (define fixed-n  (round-to-next-even n))
   (define h (/ (- b a) fixed-n))
   (define (y k) ( f  (+ a (* k h))))
   (define (ypair k)
     (+ (* 2 (y k))
          (* 4 (y (+ k 1)))))
   (define (add-2 k)
     (+ k 2))
   (* (/ h 3) (+ (sum ypair 0 add-2 (- fixed-n 1))  
                (- (f b) (f a)))))  ;;; 为什么是减号  你可以看到这边的思想是抽出中间的偶数对的数据（奇数加上偶数 理当是加起来的)
                                          ;;;因为最后一个  为什么要计算 [f(b) - f(a)] 
 (simpson-pair-integral cube 1 3 1)
 (simpson-pair-integral cube 1 3 2)
 
 ;;;sim-integral 提高版  加入了 round-to-next-even使得计算准确，先前的sim-integral有问题
 (define (sim-integral f a b n)
   (define (round-to-next-even x) (+ x (remainder x 2))) ;;;得加上这个 才可以算准！！
   (define fixed-n  (round-to-next-even n))
   (define h (/ (- b a) fixed-n))
   (define (y k) (f (+ a (* k h))))
   (define (coeff k) (if (even? k) 2 4))
   (define (part-term k) (* (coeff k) (y k)))
   (define (inc x) (+ x 1))
   (define part-value (sum part-term 1 inc (- fixed-n 1)))
   (* (/ h 3) (+ (y 0) (y n) part-value)))
 (sim-integral cube 1 3 10)  ;;; 有问题 已解决
 (sim-integral cube 1 3 11) ;;; 有问题  已解决
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>So beautiful code</title>
      <link>https://jueqingsizhe66.github.io/blog/2015/05/12/so-beautiful-code/</link>
      <pubDate>Tue, 12 May 2015 02:29:11 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/blog/2015/05/12/so-beautiful-code/</guid>
      <description>&lt;p&gt;So beautiful&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define (f x y)
(define (f-helper a b)
  (+ (* (square a))
      (* y b)
      (* a b)))
  (f-helper (+ 1 (* x y))
            (- 1 y)))

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;====&amp;gt; f(x,y)=x(1+xy)^2 + y(1-y)+(1+xy)(1-y)
       ==&amp;gt;  a= 1+xy
            b= (1-y)
            f(x,y)=xa^2+yb+ab&lt;/p&gt;

&lt;p&gt;====&amp;gt;Continue&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define (f x y)
  ((lambda (a b)
       (+ (* x (square a))
          (* y b)
          (* a b)))
    (+ 1 (* x y))
    (- 1 y)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;====&amp;gt;Use let to define the local variables&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define (f x y)
  (let ((a (+ 1 (* x y)))
         (b (- 1 y)))
       (+ (* x (square a))
          (* y b)
          (* a b))))

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;let is just the coat of the ((lambda (a b))&lt;/p&gt;

&lt;p&gt;Of course we can use define&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define (f x y)
   (define a (+ 1 (* x y)))
   (define b (- 1 y))
 (+ (* x (square a))
    (* y b)
    (* a b)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SICP_P42&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
