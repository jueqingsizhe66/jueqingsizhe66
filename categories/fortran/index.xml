<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>fortran | Macro Life</title>
    <link>https://jueqingsizhe66.github.io/categories/fortran/</link>
      <atom:link href="https://jueqingsizhe66.github.io/categories/fortran/index.xml" rel="self" type="application/rss+xml" />
    <description>fortran</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><copyright>©2019</copyright><lastBuildDate>Wed, 08 Feb 2017 17:29:29 +0800</lastBuildDate>
    <image>
      <url>https://jueqingsizhe66.github.io/img/icon-192.png</url>
      <title>fortran</title>
      <link>https://jueqingsizhe66.github.io/categories/fortran/</link>
    </image>
    
    <item>
      <title>fortran读取csv文件</title>
      <link>https://jueqingsizhe66.github.io/blog/2017/02/08/fortrandu-qu-csvwen-jian/</link>
      <pubDate>Wed, 08 Feb 2017 17:29:29 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/blog/2017/02/08/fortrandu-qu-csvwen-jian/</guid>
      <description>&lt;p&gt;本文只是简单对一个文件读取模块DFile_mod的一个运用，并读取逗号分隔的csv文件。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://jueqingsizhe66.github.io/images/fortrandebug/csv/csv1.png&#34; alt=&#34;csvread&#34; /&gt;&lt;/p&gt;

&lt;p&gt;FileMod.f90:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fortran&#34;&gt;Module DFile_Mod
  Implicit None
  !!**************************************
  !*  识别文件的空格和逗号作为分隔符
  !!*************************************** 
contains 

subroutine binaryStreamType
implicit none
integer :: File_Unit
integer :: File_UnitOutput
   !!**************************************
    !* DFile_Mod 变量定义  100%
    !!*************************************** 
    Character(len=512) :: cLine
    integer :: nRow, nCol
    character(len=20) :: name=&amp;quot;yezhaoliang&amp;quot;,addr=&amp;quot;zhangzhou&amp;quot; 
    INTEGER :: I
type :: data_head
integer(kind=2) :: column
end type 

type(data_head) :: FileHead
!real,allocatable :: g(:,:)
real,allocatable :: firstColumn(:)
real,allocatable :: secondColumn(:)
real,allocatable :: thirdColumn(:)

 Open( NewUnit=File_Unit , File = &#39;./data/myfile.csv&#39; )
 Open( NewUnit=File_UnitOutput , File = &#39;./data/myfile12.csv&#39; )

  nRow = GetFileN( File_Unit )
  write( * , * ) &#39;文件共&#39;,nRow,&#39;行！&#39;
  read(File_Unit,*) FileHead
  write(*,*) &#39;m=&#39;,FileHead%column

  allocate(firstColumn(nRow-1))
  allocate(secondColumn(nRow-1))
  allocate(thirdColumn(nRow-1))
  
  !! 流方式读取
!  READ(File_Unit) g

250 format(3f10.4)  
251 format(I4,I4,f10.4)  
252 format (f10.4,A,f10.4,A,f10.4)
253 format (I4,A,I4,A,f10.4)
Do i = 1,nRow-1
    read(File_Unit,251) firstColumn(i),secondColumn(i),thirdColumn(i)
 end Do
  DO i = 1 ,nRow-1
   !write(*,&#39;(f10.4,A,f10.4,A,f10.4)&#39;)  firstColumn(i),&#39;,&#39;,secondColumn(i),&#39;,&#39;,thirdColumn(i)
   write(File_UnitOutput,253)  firstColumn(i)*2,&#39;,--&#39;,secondColumn(i)*2,&#39;,--&#39;,thirdColumn(i)
  end do

deallocate(firstColumn)
deallocate(secondColumn)
deallocate(thirdColumn)
close(File_Unit)
close(File_UnitOutput)

  !Do i = 1, nRow
  !  Do j = 1, FileHead%column
  !
  !  end do
  !end do
  
end subroutine binaryStreamType


subroutine testType
implicit none
integer :: File_Unit
integer :: File_UnitOutput
   !!**************************************
    !* DFile_Mod 变量定义  100%
    !!*************************************** 
    Character(len=512) :: cLine
    integer :: nRow, nCol
    character(len=20) :: name=&amp;quot;yezhaoliang&amp;quot;,addr=&amp;quot;zhangzhou&amp;quot; 
    INTEGER :: I
type :: data_head
integer(kind=2) :: column
end type 

type(data_head) :: FileHead
!real,allocatable :: g(:,:)
real,allocatable :: firstColumn(:)
real,allocatable :: secondColumn(:)
real,allocatable :: thirdColumn(:)

 Open( NewUnit=File_Unit , File = &#39;./data/A001.csv&#39; )
 Open( NewUnit=File_UnitOutput , File = &#39;./data/A0012.csv&#39; )

  nRow = GetFileN( File_Unit )
  write( * , * ) &#39;文件共&#39;,nRow,&#39;行！&#39;
  read(File_Unit,*) FileHead
  write(*,*) &#39;m=&#39;,FileHead%column

  allocate(firstColumn(nRow-1))
  allocate(secondColumn(nRow-1))
  allocate(thirdColumn(nRow-1))
  
  !! 流方式读取
!  READ(File_Unit) g

250 format(3f10.4)  
251 format(I4,I4,f10.4)  
252 format (f10.4,A,f10.4,A,f10.4)
253 format (I4,A,I4,A,f10.4)
Do i = 1,nRow-1
    read(File_Unit,251) firstColumn(i),secondColumn(i),thirdColumn(i)
 end Do
  DO i = 1 ,nRow-1
   !write(*,&#39;(f10.4,A,f10.4,A,f10.4)&#39;)  firstColumn(i),&#39;,&#39;,secondColumn(i),&#39;,&#39;,thirdColumn(i)
   write(File_UnitOutput,253)  firstColumn(i)*2,&#39;,--&#39;,secondColumn(i)*2,&#39;,--&#39;,thirdColumn(i)
  end do

deallocate(firstColumn)
deallocate(secondColumn)
deallocate(thirdColumn)
close(File_Unit)
close(File_UnitOutput)

  !Do i = 1, nRow
  !  Do j = 1, FileHead%column
  !
  !  end do
  !end do
  
end subroutine testType


  Integer Function GetDataN( cStr )
    Character( Len = * ) , Intent( IN ) :: cStr
    Integer :: i
    Logical :: bIsSeparator , bIsQuote
    GetDataN = 0
    bIsSeparator = .TRUE.
    bIsQuote = .FALSE.
    Do i = 1 , Len_Trim( cStr )
      Select Case( cStr(i:i) )
      Case( &#39;&amp;quot;&#39; , &amp;quot;&#39;&amp;quot; ) !// 如果遇到引号
        If ( .Not.bIsQuote ) GetDataN = GetDataN + 1  !//如果不在引号中，则增加一个数据
        bIsQuote = .Not.bIsQuote !// 引号结束或开始
        bIsSeparator = .FALSE.
      Case( &amp;quot; &amp;quot; , &amp;quot;,&amp;quot; , char(9) ) !// 如果遇到分隔符
        If ( .Not.bIsQuote ) then  !// 分隔符如果不在引号中
          bIsSeparator = .TRUE.
        End If
      Case Default      
        If ( bIsSeparator ) then
          GetDataN = GetDataN + 1
        End If
        bIsSeparator = .FALSE.
      End Select
    End Do
  End Function GetDataN
  
  Function f_numbervars(vars) result(numvars)
    character(len=*), intent(in) :: vars
    integer :: numvars
    character(len=len(vars)) :: tmpvars
    character(len=256) :: tmpvar
    tmpvars = trim(adjustl(vars))
    numvars = 0
    do while (len_trim(tmpvars) &amp;gt; 0)
      read(tmpvars, *) tmpvar
      numvars = numvars + 1
      tmpvars = tmpvars(index(tmpvars, trim(tmpvar))+len_trim(tmpvar):)
    end do
  End Function f_numbervars
  
  Integer Function GetFileN( iFileUnit )
  !// 此函数应在打开文件后立即调用。调用后读取位置返回文件起始位置
    Implicit None
    Integer , Intent( IN ) :: iFileUnit
    character( Len = 1 ) :: cDummy
    integer :: ierr
    GetFileN = 0
    Rewind( iFileUnit )
    Do
      Read( iFileUnit , * , ioStat = ierr ) cDummy
      If( ierr /= 0 ) Exit
      GetFileN = GetFileN + 1
    End Do
    Rewind( iFileUnit )
  End Function GetFileN 

End Module DFile_Mod


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;主函数main.f90:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fortran&#34;&gt;program Main

use DFile_Mod
Implicit none

   INTEGER :: I
   !!**************************************
    !* DFile_Mod 变量定义  100%
    !!*************************************** 
    !Character(len=512) :: cLine
    !integer :: nRow, nCol
    !character(len=20) :: name=&amp;quot;yezhaoliang&amp;quot;,addr=&amp;quot;zhangzhou&amp;quot; 
    !**************************************
    !*  测试DFile_Mod   100%
    !*************************************** 
    
 !Open( 53 , File = &#39;./data/in.txt&#39; )
  !Open( 53 , File = &#39;./data/myfile.csv&#39; )
  !
  !nRow = GetFileN( 53 )
  !write( * , * ) &#39;文件共&#39;,nRow,&#39;行！&#39;
  !Do i = 1 , nRow
  !  read( 53 , &#39;(a512)&#39; ) cLine
  !  nCol = GetDataN( cLine )
  !  !nCol = f_numbervars( cLine )
  !  write( * , * ) i,&#39;行有&#39;,nCol,&#39;个数据&#39;
  !End Do
  call binaryStreamType

  Close( 53 )
  end program Main

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置文件in.txt:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1 2 3 , fsd
4 5 6 7 : asd
8 9 10 11 12
13 f sadf ! gad
14 15

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;载入visual studio基本上就能运行。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>fortran宫殿</title>
      <link>https://jueqingsizhe66.github.io/blog/2015/08/09/fortrangong-dian/</link>
      <pubDate>Sun, 09 Aug 2015 15:06:38 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/blog/2015/08/09/fortrangong-dian/</guid>
      <description>&lt;p&gt;任何语言应该都可以有类似宫殿的想法，在纵横交错的街道中，能过找到进口和出口，
并可以使用很多条道路完成你想去的地方，而不是拘泥于一条道路。Fortran也是如此。
诞生于1951年左右的第一个面向对象的高级语言Fortran 语言，也已经65岁左右了，它以其
快速有效的科学数值计算，一直运用于科学研究领域中。
浅显针对fortran的理解&amp;mdash;-宫殿式的介绍.&lt;/p&gt;

&lt;h2 id=&#34;宫殿&#34;&gt;宫殿&lt;/h2&gt;

&lt;p&gt;宫殿蕴含着纵横交错，阡陌交通，但是确实零落有序，复合规律。通过宫殿群来认识这门科学语言。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://jueqingsizhe66.github.io/images/fortran/palace.jpg&#34; alt=&#34;宫殿&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;fortran&#34;&gt;fortran&lt;/h2&gt;

&lt;p&gt;fortran包含以下主要几个部分&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;#3.1&#34;&gt;进口(初始化)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3.2&#34;&gt;数组&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3.3&#34;&gt;过程定义(子程序和函数)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3.4&#34;&gt;模块&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3.5&#34;&gt;出口&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3.6&#34;&gt;文件组合&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;3.1&#34;&gt; 进口&lt;/h3&gt;

&lt;p&gt;程序在开始设计的时候，需要变量初始化，也就是进行进口的布置。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://jueqingsizhe66.github.io/images/fortran/wumen.jpg&#34; alt=&#34;input&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;3.2&#34;&gt; 数组arrays and allocatable &lt;/h3&gt;

&lt;p&gt;有时候我们发现一条街到应该相同的样式，于是我们采用数组把具有相同的
  数据形成放进一个一个的房屋。&lt;img src=&#34;https://jueqingsizhe66.github.io/images/fortran/wumen.jpg&#34; alt=&#34;arrays&#34; /&gt;
  fortran的dimension是相当常见的形式，因为他就是数组的体现。
  一般房屋的建造都是需要allocatable的属性，也就是政府指定的可用地，利用allocate建房，使用完，废弃了，就deallocate。&lt;img src=&#34;https://jueqingsizhe66.github.io/images/fortran/zhengdi.jpg&#34; alt=&#34;zhengdi&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;3.3&#34;&gt;subroutine and function&lt;/h3&gt;

&lt;p&gt;房屋一多我们发现没法管理，于是我们就把很多的房屋放在对应的街道中去,也就是
subroutine或者function当中。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://jueqingsizhe66.github.io/images/fortran/street.png&#34; alt=&#34;街道&#34; /&gt;&lt;/p&gt;

&lt;p&gt;另外有时候有一些已经在外建的subroutine和function一定得把他们的头和参数类型和end部分提交到program（政府）当中的INTERFACE当中，这样才能确定这块地的合法性等。
   这也是为什么fortran中有时会有额外的子程序的定义（和主文件不在同一个文件夹当中），为了让主文件能够识别，使用INTERFACE把它嵌入进来(后来引入module减少了interface的作用)。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://jueqingsizhe66.github.io/images/fortran/zhai.jpg&#34; alt=&#34;interface&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;3.4&#34;&gt; 升级版的module&lt;/h3&gt;

&lt;p&gt;为了管理和维护房间(arrays)和街道(subs)，于是我们把他们放在一个一个区域当中。&lt;img src=&#34;https://jueqingsizhe66.github.io/images/fortran/module.png&#34; alt=&#34;module&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;3.5&#34;&gt; 出口 &lt;/h3&gt;
   当我们绕过了整个宫殿后，还需要布置一个或多个的出口。 ![output][5]

&lt;h3 id=&#34;3.6&#34;&gt; 然而我们发现我们需要更大的进口说明&lt;/h3&gt;

&lt;p&gt;有时候我们进一步组装多个输入文件，而为了方便，我们把他们组装成一个更大的进口装置，放置在最前面。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://jueqingsizhe66.github.io/images/fortran/square.jpg&#34; alt=&#34;square&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;后续&#34;&gt;后续&lt;/h2&gt;

&lt;p&gt;无论模块化，还是函数化，亦或者模式化，都是基于原先大的过程式变成的改成，
   只不过是为了减少冗余、重复，同时简化和方便阅读，另外还有就是方便拓展。
   &lt;em&gt;从现在开始可以建立你自己的fortranlibrary modal&lt;/em&gt; (&lt;font color=&#34;red&#34;&gt;一个不错的建议&lt;/font&gt;)&lt;/p&gt;

&lt;p&gt;fortran2003出来了个type这个数据结构的创建，方便的把多个变量或者数组组合成为一种数据类型，这就有点像3D打印的功能：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  type creat_a
    real :: a
    integer :: b
    real,allocatable :: c(:)
  end type creat_a
  
  type(creat_a) :: creat_b,creat_c
  
  creat_b%a = 1.0
  creat_b%b = 2
  allocate (creat_b%c(3))
  creat_b%c = 6.0
  
  creat_c = creat_b
  creat_c%b = 8

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;type的作用类似Hashkell的data的作用，没有行为只有数据类型。
先开个头……&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>积累和重写对于程序员很重要</title>
      <link>https://jueqingsizhe66.github.io/blog/2015/06/22/ji-lei-he-zhong-xie-dui-yu-cheng-xu-yuan-hen-zhong-yao/</link>
      <pubDate>Mon, 22 Jun 2015 15:35:19 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/blog/2015/06/22/ji-lei-he-zhong-xie-dui-yu-cheng-xu-yuan-hen-zhong-yao/</guid>
      <description>&lt;p&gt;积累，你才能厚积而薄发。
重写，你才能进一步认识你的积累.
重写有时候会带来对于知识的进一步深入的理解.&lt;/p&gt;

&lt;p&gt;今天听了&lt;a href=&#34;http://www.fcode.cn&#34; target=&#34;_blank&#34;&gt;Fcode&lt;/a&gt;的一个视频讲座，一个立志于开源的非营利小团队，还有一个专门的Fortran Coder的qq群。听完感觉，自己真的很有缺点，之前上过一个java培训班，其实套路都一样，写代码，重复写，直到你睡觉醒来还能写，喝了半斤52度二锅头还能写。&lt;/p&gt;

&lt;p&gt;并且需要在一定的时间内回顾，重写之前你写过的东西，虽然听起来很简单，可是我经常也是忘记了这个该做的工作。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;积累&lt;/li&gt;
&lt;li&gt;重写&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这两项对于学习任何一个科目都至关重要和必不可少。武功再高,也要练操。&lt;/p&gt;

&lt;p&gt;fortran是简单，而且是基于解决数学、物理问题,擅长科学计算，而不是利用它做一个漂亮的界面。基本上fortran的很多算法都可以通过网络资源搜索得到，并进行适当修改，这也需要你去积累。但是fortran给你思维层次的改造不是特别明显，所以从这个角度来说，我并不觉得他是一门好的语言，但是他的计算能力还真的不错，特别是矩阵计算能力。也许我也该经常整理fortran相关的编程知识。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Ubuntu gtk-fortran</title>
      <link>https://jueqingsizhe66.github.io/blog/2015/05/19/ubuntu-gtk-fortran/</link>
      <pubDate>Tue, 19 May 2015 17:03:25 +0800</pubDate>
      <guid>https://jueqingsizhe66.github.io/blog/2015/05/19/ubuntu-gtk-fortran/</guid>
      <description>&lt;p&gt;Fortran：一门古老的&lt;a href=&#34;http://micro.ustc.edu.cn/Fortran/ZJDing/&#34; target=&#34;_blank&#34;&gt;计算机数值科学计算语言&lt;/a&gt;,1950.&lt;/p&gt;

&lt;p&gt;Fortran的强项就是数值计算，图形编程是一个鸡肋所在，但是有时候又需要做一些图形的展示，借助于&lt;a href=&#34;http://www.gtk.org/&#34; target=&#34;_blank&#34;&gt;GTK+ project&lt;/a&gt;可以方便我们达到目的.&lt;/p&gt;

&lt;p&gt;GTK是c语言编写的源程序，运用到fortran需要相应的库转换,在github上找到一个&lt;a href=&#34;https://github.com/jueqingsizhe66/gtk-fortran&#34; target=&#34;_blank&#34;&gt;gtk-fortran库&lt;/a&gt;.下面是ubuntu上面的搭建过程(windows 未实现,可以参考 gtk+makefile)&lt;/p&gt;

&lt;h2 id=&#34;ubuntu-搭建&#34;&gt;Ubuntu 搭建&lt;/h2&gt;

&lt;h3 id=&#34;环境搭建&#34;&gt;环境搭建&lt;/h3&gt;

&lt;p&gt;GTK3+是跨平台的，既可以在windows上使用，也可以在linux上使用
下面的代码可以直接打包进一个gtk.sh文件，直接运行sh gtk.sh进行安装&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#1 刚装好的Ubuntu系统中已经有GCC了，但是这个GCC几乎什么文件都不能编译，因为缺少一些必须的头文件，所以要安装build-essential这个软件包
sudo apt-get install build-essential
#2 安装GTK/GNOME开发环境  需要下载一系列的安装包，时间比较长
sudo apt-get install gnome-devel gnome-devel-docs 
#3 用于在编译GTK程序时自动找出头文件及库文件位置　　
sudo apt-get install pkg-config
#4安装 devhelp GTK文档查看程序 
sudo apt-get install devhelp
#5安装 gtk/glib 的API参考手册及其它帮助文档 
sudo apt-get install libglib2.0-doc libgtk2.0-doc
#6  安装基于GTK的界面GTK是开发Gnome窗口的c/c++语言图形库
sudo apt-get install glade libglade2-dev
##或者sudo apt-get install glade-gnome glade-common glade-doc 
#7安装gtk3.0 或者 将gtk+3.0所需的所有文件统通下载安装完毕 (安装时间较长)
sudo apt-get install libgtk3*

## 查看信息
# 查看 2.x 版本 
#pkg-config --modversion gtk+-3.0 
# 查看pkg-config的版本
#$pkg-config -version 
#查看是否安装了gtk 
#pkg-config --list-all | grep gtk 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个流程做完了，就可以进行gtk测试,当然仅仅是c语言的测试&lt;/p&gt;

&lt;h3 id=&#34;测试文件&#34;&gt;测试文件&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;//Helloworld.c

#include &amp;lt;gtk/gtk.h&amp;gt;  

int main(int argc,char *argv[])  
{  
    GtkWidget    *window;  
    GtkWidget    *label;  

    gtk_init(&amp;amp;argc,&amp;amp;argv);  

    /* create the main, top level, window */  
    window = gtk_window_new(GTK_WINDOW_TOPLEVEL);  

    /* give it the title */  
    gtk_window_set_title(GTK_WINDOW(window),&amp;quot;Hello World&amp;quot;);  

    /* connect the destroy signal of the window to gtk_main_quit 
     * when the window is about to be destroyed we get a notification and 
     * stop the main GTK+ loop 
     */  
    g_signal_connect(window,&amp;quot;destroy&amp;quot;,G_CALLBACK(gtk_main_quit),NULL);  

    /* create the &amp;quot;Hello, World&amp;quot; label */  
    label = gtk_label_new(&amp;quot;GTK可以运行了！&amp;quot;);  

    /* and insert it into the main window */  
    gtk_container_add(GTK_CONTAINER(window),label);  

    /* make sure that everything, window and label, are visible */  
    gtk_widget_show_all(window);  

    /* start the main loop, and let it rest until the application is closed */  
    gtk_main();  

    return 0;  
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;编译&#34;&gt;编译&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;gcc -o Helloworld Helloworld.c `pkg-config --cflags --libs gtk+-3.0`
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;运行&#34;&gt;运行&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;./Helloworld

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你得到一个小窗口&amp;rdquo;GTK可以运行了&amp;rdquo; 证明你的gtk环境是正确的。&lt;/p&gt;

&lt;p&gt;然后我们开始进一步配置gtk-fortran&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;下载
&lt;a href=&#34;https://github.com/jueqingsizhe66/gtk-fortran&#34; target=&#34;_blank&#34;&gt;https://github.com/jueqingsizhe66/gtk-fortran&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;编译&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;mkdir build
cd build

在gtk-fortran目录下：/home/happycamp-of-fortran/gtk-fortran/build
cmake ..
make 
make install

&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;会得到如下结果:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;Install the project...
-- Install configuration: &amp;quot;release&amp;quot;
-- Installing: /usr/local/lib/libgtk-2-fortran.a
-- Installing: /usr/local/lib/libgtk-2-fortran.so.0.1
-- Installing: /usr/local/lib/libgtk-2-fortran.so
-- Installing: /usr/local/include/gtk-2-fortran/atk.mod
-- Installing: /usr/local/include/gtk-2-fortran/cairo.mod
-- Installing: /usr/local/include/gtk-2-fortran/gdk.mod
-- Installing: /usr/local/include/gtk-2-fortran/gdk_pixbuf.mod
-- Installing: /usr/local/include/gtk-2-fortran/g.mod
-- Installing: /usr/local/include/gtk-2-fortran/gtk.mod
-- Installing: /usr/local/include/gtk-2-fortran/gtk_hl.mod
-- Installing: /usr/local/include/gtk-2-fortran/gtk_hl_container.mod
-- Installing: /usr/local/include/gtk-2-fortran/gtk_hl_button.mod
-- Installing: /usr/local/include/gtk-2-fortran/gtk_hl_entry.mod
-- Installing: /usr/local/include/gtk-2-fortran/gtk_hl_tree.mod
-- Installing: /usr/local/include/gtk-2-fortran/gtk_hl_menu.mod
-- Installing: /usr/local/include/gtk-2-fortran/gtk_hl_combobox.mod
-- Installing: /usr/local/include/gtk-2-fortran/gtk_hl_spin_slider.mod
-- Installing: /usr/local/include/gtk-2-fortran/gtk_hl_chooser.mod
-- Installing: /usr/local/include/gtk-2-fortran/gtk_hl_dialog.mod
-- Installing: /usr/local/include/gtk-2-fortran/gtk_hl_progress.mod
-- Installing: /usr/local/include/gtk-2-fortran/gtk_hl_accelerator.mod
-- Installing: /usr/local/include/gtk-2-fortran/gtk_hl_infobar.mod
-- Installing: /usr/local/include/gtk-2-fortran/gtk_hl_assistant.mod
-- Installing: /usr/local/include/gtk-2-fortran/gtk_hl_misc.mod
-- Installing: /usr/local/include/gtk-2-fortran/gtk_draw_hl.mod
-- Installing: /usr/local/include/gtk-2-fortran/gdk_pixbuf_hl.mod
-- Installing: /usr/local/include/gtk-2-fortran/gtk_sup.mod
-- Installing: /usr/local/include/gtk-2-fortran/pango.mod
-- Installing: /usr/local/include/gtk-2-fortran/gdk_events.mod
-- Installing: /usr/local/include/gtk-2-fortran/gtk_os_dependent.mod
-- Installing: /usr/local/bin/gtk-2-fortran-modscan
-- Installing: /usr/local/share/gtk-fortran/gtk-2-fortran-index.csv
-- Installing: /usr/local/share/gtk-fortran/gtk-2-enumerators.lis
-- Installing: /usr/local/lib/pkgconfig/gtk-2-fortran.pc
-- Installing: /usr/local/share/man/man1/gtk-2-fortran-modscan.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3: 测试软件
然后你就会发现
cd 到 /home/happycamp-of-fortran/gtk-fortran/examples
然后&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;root at javazhao-N53SM [19:27:20ä��午] in /home/happycamp-of-fortran/gtk-fortran/examples on git:master?
$ gfortran gtkhello2.f90 -o gtkhello2 `pkg-config --cflags --libs gtk-2-fortran` 

就可以了. 一定记住加入的是gtk-2-fortran 这个库。而不是gtk+-2.0或者gtk+-3.0,这两个库是针对c语言的。
$ ./gtkhello2 


&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
  </channel>
</rss>
